<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="定时调度系列之单机定时调度Quartz使用总结及原理解析"><meta name="keywords" content="定时调度,Quartz"><meta name="author" content="何鹏 [smile.hepeng@qq.com]"><meta name="copyright" content="何鹏 [smile.hepeng@qq.com]"><title>定时调度系列之单机定时调度Quartz使用总结及原理解析 | 沉默者</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://unpkg.zhimg.com/font-awesome@4.7.0/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><link rel="alternate" href="/atom.xml" title="沉默者" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Quartz%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">Quartz可以用来做什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Quartz%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-number">2.</span> <span class="toc-text">Quartz使用总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%E7%9C%8BQuartz%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.1.</span> <span class="toc-text">从简单示例看Quartz核心设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Demo%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">一个简单的Demo程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Quartz%E6%A0%B8%E5%BF%83%E5%85%83%E7%B4%A0%EF%BC%9A"><span class="toc-number">2.1.2.</span> <span class="toc-text">Quartz核心元素：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.3.</span> <span class="toc-text">核心元素之间的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quartz-API"><span class="toc-number">2.2.</span> <span class="toc-text">Quartz API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ename%E5%92%8Cgroup"><span class="toc-number">2.3.</span> <span class="toc-text">关于name和group</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trigger"><span class="toc-number">2.4.</span> <span class="toc-text">Trigger</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StartTime-amp-EndTime"><span class="toc-number">2.4.1.</span> <span class="toc-text">StartTime &amp; EndTime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88Priority%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">优先级（Priority）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Misfire-%E9%94%99%E5%A4%B1%E8%A7%A6%E5%8F%91%EF%BC%89%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.3.</span> <span class="toc-text">Misfire(错失触发）策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Calendar"><span class="toc-number">2.4.4.</span> <span class="toc-text">Calendar</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B1%9E%E6%80%A7"><span class="toc-number">2.4.5.</span> <span class="toc-text">其他属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Trigger%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">2.4.6.</span> <span class="toc-text">Trigger实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SimpleTrigger"><span class="toc-number">2.4.6.1.</span> <span class="toc-text">SimpleTrigger</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CalendarIntervalTrigger"><span class="toc-number">2.4.6.2.</span> <span class="toc-text">CalendarIntervalTrigger</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DailyTimeIntervalTrigger"><span class="toc-number">2.4.6.3.</span> <span class="toc-text">DailyTimeIntervalTrigger</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CronTrigger"><span class="toc-number">2.4.6.4.</span> <span class="toc-text">CronTrigger</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JobDetail-amp-Job"><span class="toc-number">2.5.</span> <span class="toc-text">JobDetail &amp; Job</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JobDataMap"><span class="toc-number">2.5.1.</span> <span class="toc-text">JobDataMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Job%E5%B9%B6%E5%8F%91"><span class="toc-number">2.5.2.</span> <span class="toc-text">Job并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JobExecutionException"><span class="toc-number">2.5.3.</span> <span class="toc-text">JobExecutionException</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scheduler"><span class="toc-number">2.6.</span> <span class="toc-text">Scheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SchedulerFactory"><span class="toc-number">2.6.1.</span> <span class="toc-text">SchedulerFactory</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">2.7.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Quartz%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">3.</span> <span class="toc-text">Quartz源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Quartz%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">Quartz启动流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quartz-%E7%BA%BF%E7%A8%8B%E8%A7%86%E5%9B%BE"><span class="toc-number">3.2.</span> <span class="toc-text">Quartz 线程视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QuartzSchedulerThread%E9%80%BB%E8%BE%91%E5%85%B7%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.3.</span> <span class="toc-text">QuartzSchedulerThread逻辑具体介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#misfireHandler%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">misfireHandler线程</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img2.baidu.com/it/u=928705063,3876627980&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg"></div><div class="author-info__name text-center">何鹏 [smile.hepeng@qq.com]</div><div class="author-info__description text-center">路漫漫其修远兮，吾将上下而求索</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">68</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">53</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默者</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">定时调度系列之单机定时调度Quartz使用总结及原理解析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-03-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA%E5%BC%80%E5%8F%91/">JAVA开发</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">6.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 24 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Quartz可以用来做什么？"><a href="#Quartz可以用来做什么？" class="headerlink" title="Quartz可以用来做什么？"></a>Quartz可以用来做什么？</h2><p>在某一个有规律的时间点干某件事。<br>并且时间的触发的条件可以非常复杂（比如每月最后一个工作日的17:50），复杂到需要一个专门的框架来干这个事。<br>Quartz就是来干这样的事，你给它一个触发条件的定义，它负责到了时间点，触发相应的Job起来干活。</p>
<h2 id="Quartz使用总结"><a href="#Quartz使用总结" class="headerlink" title="Quartz使用总结"></a>Quartz使用总结</h2><h3 id="从简单示例看Quartz核心设计"><a href="#从简单示例看Quartz核心设计" class="headerlink" title="从简单示例看Quartz核心设计"></a>从简单示例看Quartz核心设计</h3><h4 id="一个简单的Demo程序"><a href="#一个简单的Demo程序" class="headerlink" title="一个简单的Demo程序"></a>一个简单的Demo程序</h4><p>这里面的所有例子都是基于Quartz 2.2.1</p>
<details>
<summary>点击展开/收起</summary>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.quartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.DateBuilder.newDate;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.JobBuilder.newJob;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.SimpleScheduleBuilder.simpleSchedule;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.TriggerBuilder.newTrigger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.GregorianCalendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.JobDetail;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Trigger;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.calendar.AnnualCalendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建scheduler</span></span><br><span class="line">            Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义一个Trigger</span></span><br><span class="line">            Trigger trigger = newTrigger().withIdentity(<span class="string">&quot;trigger1&quot;</span>, <span class="string">&quot;group1&quot;</span>) <span class="comment">//定义name/group</span></span><br><span class="line">                .startNow()<span class="comment">//一旦加入scheduler，立即生效</span></span><br><span class="line">                .withSchedule(simpleSchedule() <span class="comment">//使用SimpleTrigger</span></span><br><span class="line">                    .withIntervalInSeconds(<span class="number">1</span>) <span class="comment">//每隔一秒执行一次</span></span><br><span class="line">                    .repeatForever()) <span class="comment">//一直执行，奔腾到老不停歇</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义一个JobDetail</span></span><br><span class="line">            JobDetail job = newJob(HelloQuartz.class) <span class="comment">//定义Job类为HelloQuartz类，这是真正的执行逻辑所在</span></span><br><span class="line">                .withIdentity(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;group1&quot;</span>) <span class="comment">//定义name/group</span></span><br><span class="line">                .usingJobData(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;quartz&quot;</span>) <span class="comment">//定义属性</span></span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入这个调度</span></span><br><span class="line">            scheduler.scheduleJob(job, trigger);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动之</span></span><br><span class="line">            scheduler.start();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//运行一段时间后关闭</span></span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            scheduler.shutdown(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.quartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.DisallowConcurrentExecution;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobDetail;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloQuartz</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        JobDetail detail = context.getJobDetail();</span><br><span class="line">        String name = detail.getJobDataMap().getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;say hello to &quot;</span> + name + <span class="string">&quot; at &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h4 id="Quartz核心元素："><a href="#Quartz核心元素：" class="headerlink" title="Quartz核心元素："></a>Quartz核心元素：</h4><ul>
<li><p>Scheduler：调度器。<br>负责整个定时系统的调度，内部通过线程池进行调度。</p>
</li>
<li><p>Trigger： 定义触发的条件。<br>主要有四种类型：SimpleTrigger、CronTrigger、DataIntervalTrigger、NthIncludedTrigger，在项目中常用的为：SimpleTrigger和CronTrigger。。</p>
</li>
<li><p>JobDetail：定义任务数据。<br>记录Job的名字、组及任务执行的具体类和任务执行所需要的参数</p>
</li>
<li><p>Job： 真正的执行逻辑。  </p>
</li>
</ul>
<p>为什么设计成JobDetail + Job，不直接使用Job？<br>这是因为任务是有可能并发执行，如果Scheduler直接使用Job，就会存在对同一个Job实例并发访问的问题。<br>而JobDetail &amp; Job 方式，sheduler每次执行，都会根据JobDetail创建一个新的Job实例，这样就可以规避并发访问的问题。</p>
<h4 id="核心元素之间的关系"><a href="#核心元素之间的关系" class="headerlink" title="核心元素之间的关系"></a>核心元素之间的关系</h4><ul>
<li>先由SchedulerFactory创建Scheduler调度器</li>
<li>由调度器去调取即将执行的Trigger</li>
<li>执行时获取到对于的JobDetail信息</li>
<li>找到对应的Job类执行业务逻辑</li>
</ul>
<h3 id="Quartz-API"><a href="#Quartz-API" class="headerlink" title="Quartz API"></a>Quartz API</h3><p>Quartz的API的风格在2.x以后，采用的是DSL风格（通常意味着fluent interface风格），就是示例中newTrigger()那一段东西。它是通过Builder实现的，就是以下几个。（** 下面大部分代码都要引用这些Builder ** )</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//job相关的builder</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.JobBuilder.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//trigger相关的builder</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.TriggerBuilder.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.SimpleScheduleBuilder.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.CronScheduleBuilder.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.DailyTimeIntervalScheduleBuilder.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.CalendarIntervalScheduleBuilder.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//日期相关的builder</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.DateBuilder.*;</span><br></pre></td></tr></table></figure>
<p>DSL风格写起来会更加连贯，畅快，而且由于不是使用setter的风格，语义上会更容易理解一些。对比一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JobDetail jobDetail=new JobDetailImpl(&quot;jobDetail1&quot;,&quot;group1&quot;,HelloQuartz.class);</span><br><span class="line">jobDetail.getJobDataMap().put(&quot;name&quot;, &quot;quartz&quot;);</span><br><span class="line"></span><br><span class="line">SimpleTriggerImpl trigger=new SimpleTriggerImpl(&quot;trigger1&quot;,&quot;group1&quot;);</span><br><span class="line">trigger.setStartTime(new Date());</span><br><span class="line">trigger.setRepeatInterval(1);</span><br><span class="line">trigger.setRepeatCount(-1);</span><br></pre></td></tr></table></figure>

<h3 id="关于name和group"><a href="#关于name和group" class="headerlink" title="关于name和group"></a>关于name和group</h3><p>JobDetail和Trigger都有name和group。</p>
<p>name是它们在这个sheduler里面的唯一标识。如果我们要更新一个JobDetail定义，只需要设置一个name相同的JobDetail实例即可。</p>
<p>group是一个组织单元，sheduler会提供一些对整组操作的API，比如 scheduler.resumeJobs()。</p>
<h3 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h3><h4 id="StartTime-amp-EndTime"><a href="#StartTime-amp-EndTime" class="headerlink" title="StartTime &amp; EndTime"></a>StartTime &amp; EndTime</h4><p>startTime和endTime指定的Trigger会被触发的时间区间。在这个区间之外，Trigger是不会被触发的。</p>
<p>** 所有Trigger都会包含这两个属性 **</p>
<h4 id="优先级（Priority）"><a href="#优先级（Priority）" class="headerlink" title="优先级（Priority）"></a>优先级（Priority）</h4><p>当scheduler比较繁忙的时候，可能在同一个时刻，有多个Trigger被触发了，但资源不足（比如线程池不足）。那么这个时候比剪刀石头布更好的方式，就是设置优先级。优先级高的先执行。</p>
<p>需要注意的是，优先级只有在同一时刻执行的Trigger之间才会起作用，如果一个Trigger是9:00，另一个Trigger是9:30。那么无论后一个优先级多高，前一个都是先执行。</p>
<p>优先级的值默认是5，当为负数时使用默认值。最大值似乎没有指定，但建议遵循Java的标准，使用1-10，不然鬼才知道看到【优先级为10】是时，上头还有没有更大的值。</p>
<h4 id="Misfire-错失触发）策略"><a href="#Misfire-错失触发）策略" class="headerlink" title="Misfire(错失触发）策略"></a>Misfire(错失触发）策略</h4><p>类似的Scheduler资源不足的时候，或者机器崩溃重启等，有可能某一些Trigger在应该触发的时间点没有被触发，也就是Miss Fire了。这个时候Trigger需要一个策略来处理这种情况。每种Trigger可选的策略各不相同。</p>
<p>这里有两个点需要重点注意：</p>
<ul>
<li>MisFire的触发是有一个阀值，这个阀值是配置在JobStore的。比RAMJobStore是org.quartz.jobStore.misfireThreshold。只有超过这个阀值，才会算MisFire。小于这个阀值，Quartz是会全部重新触发。</li>
</ul>
<p>所有MisFire的策略实际上都是解答两个问题：</p>
<ul>
<li>已经MisFire的任务还要重新触发吗？</li>
<li>如果发生MisFire，要调整现有的调度时间吗？</li>
</ul>
<details>
<summary>比如SimpleTrigger的MisFire策略有</summary>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> MISFIRE<span class="emphasis">_INSTRUCTION_</span>IGNORE<span class="emphasis">_MISFIRE_</span>POLICY</span><br><span class="line"></span><br><span class="line"><span class="code">    这个不是忽略已经错失的触发的意思，而是说忽略MisFire策略。它会在资源合适的时候，重新触发所有的MisFire任务，并且不会影响现有的调度时间。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    比如，SimpleTrigger每15秒执行一次，而中间有5分钟时间它都MisFire了，一共错失了20个，5分钟后，假设资源充足了，并且任务允许并发，它会被一次性触发。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    这个属性是所有Trigger都适用。</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="bullet">*</span> MISFIRE<span class="emphasis">_INSTRUCTION_</span>FIRE<span class="emphasis">_NOW</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">  忽略已经MisFire的任务，并且立即执行调度。这通常只适用于只执行一次的任务。</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">* MISFIRE_</span>INSTRUCTION<span class="emphasis">_RESCHEDULE_</span>NOW<span class="emphasis">_WITH_</span>EXISTING<span class="emphasis">_REPEAT_</span>COUNT</span><br><span class="line"></span><br><span class="line">  将startTime设置当前时间，立即重新调度任务，包括的MisFire的</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> MISFIRE<span class="emphasis">_INSTRUCTION_</span>RESCHEDULE<span class="emphasis">_NOW_</span>WITH<span class="emphasis">_REMAINING_</span>REPEAT<span class="emphasis">_COUNT</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">  类似MISFIRE_</span>INSTRUCTION<span class="emphasis">_RESCHEDULE_</span>NOW<span class="emphasis">_WITH_</span>EXISTING<span class="emphasis">_REPEAT_</span>COUNT，区别在于会忽略已经MisFire的任务</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> MISFIRE<span class="emphasis">_INSTRUCTION_</span>RESCHEDULE<span class="emphasis">_NEXT_</span>WITH<span class="emphasis">_EXISTING_</span>COUNT</span><br><span class="line"></span><br><span class="line">  在下一次调度时间点，重新开始调度任务，包括的MisFire的</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> MISFIRE<span class="emphasis">_INSTRUCTION_</span>RESCHEDULE<span class="emphasis">_NEXT_</span>WITH<span class="emphasis">_REMAINING_</span>COUNT</span><br><span class="line"></span><br><span class="line">  类似于MISFIRE<span class="emphasis">_INSTRUCTION_</span>RESCHEDULE<span class="emphasis">_NEXT_</span>WITH<span class="emphasis">_EXISTING_</span>COUNT，区别在于会忽略已经MisFire的任务。</span><br><span class="line"></span><br><span class="line"><span class="bullet">*</span> MISFIRE<span class="emphasis">_INSTRUCTION_</span>SMART<span class="emphasis">_POLICY</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">  所有的Trigger的MisFire默认值都是这个，大致意思是“把处理逻辑交给聪明的Quartz去决定”。基本策略是，</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">  * 如果是只执行一次的调度，使用MISFIRE_</span>INSTRUCTION<span class="emphasis">_FIRE_</span>NOW</span><br><span class="line"><span class="bullet">  *</span> 如果是无限次的调度(repeatCount是无限的)，使用MISFIRE<span class="emphasis">_INSTRUCTION_</span>RESCHEDULE<span class="emphasis">_NEXT_</span>WITH<span class="emphasis">_REMAINING_</span>COUNT</span><br><span class="line"><span class="bullet">  *</span> 否则，使用MISFIRE<span class="emphasis">_INSTRUCTION_</span>RESCHEDULE<span class="emphasis">_NOW_</span>WITH<span class="emphasis">_EXISTING_</span>REPEAT<span class="emphasis">_COUNT</span></span><br></pre></td></tr></table></figure>
</details>

<h4 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h4><p>这里的Calendar不是jdk的java.util.Calendar，不是为了计算日期的。它的作用是在于补充Trigger的时间。可以排除或加入某一些特定的时间点。</p>
<p>以”每月25日零点自动还卡债“为例，我们想排除掉每年的2月25号零点这个时间点（因为有2.14，所以2月一定会破产）。这个时间，就可以用Calendar来实现。</p>
<details>
<summary>例子</summary>
<pre><code>AnnualCalendar cal = new AnnualCalendar(); //定义一个每年执行Calendar，精度为天，即不能定义到2.25号下午2:00
java.util.Calendar excludeDay = new GregorianCalendar();
excludeDay.setTime(newDate().inMonthOnDay(2, 25).build());
cal.setDayExcluded(excludeDay, true);  //设置排除2.25这个日期
scheduler.addCalendar("FebCal", cal, false, false); //scheduler加入这个Calendar
//定义一个Trigger
Trigger trigger = newTrigger().withIdentity("trigger1", "group1")
.startNow()//一旦加入scheduler，立即生效
.modifiedByCalendar("FebCal") //使用Calendar !!
.withSchedule(simpleSchedule()
.withIntervalInSeconds(1)
.repeatForever())
.build();</code></pre>
</details>

<p>Quartz体贴地为我们提供以下几种Calendar，注意，所有的Calendar既可以是排除，也可以是包含，取决于：</p>
<ul>
<li>HolidayCalendar。指定特定的日期，比如20140613。精度到天。</li>
<li>DailyCalendar。指定每天的时间段（rangeStartingTime, rangeEndingTime)，格式是HH:MM[:SS[:mmm]]。也就是最大精度可以到毫秒。</li>
<li>WeeklyCalendar。指定每星期的星期几，可选值比如为java.util.Calendar.SUNDAY。精度是天。</li>
<li>MonthlyCalendar。指定每月的几号。可选值为1-31。精度是天</li>
<li>AnnualCalendar。 指定每年的哪一天。使用方式如上例。精度是天。</li>
<li>CronCalendar。指定Cron表达式。精度取决于Cron表达式，也就是最大精度可以到秒。</li>
</ul>
<h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><ul>
<li><p>Durability(耐久性？)</p>
<p>如果一个任务不是durable，那么当没有Trigger关联它的时候，它就会被自动删除。</p>
</li>
<li><p>RequestsRecovery</p>
<p>如果一个任务是”requests recovery”，那么当任务运行过程非正常退出时（比如进程崩溃，机器断电，但不包括抛出异常这种情况），Quartz再次启动时，会重新运行一次这个任务实例。</p>
<p>可以通过JobExecutionContext.isRecovering()查询任务是否是被恢复的。</p>
</li>
</ul>
<h4 id="Trigger实现类"><a href="#Trigger实现类" class="headerlink" title="Trigger实现类"></a>Trigger实现类</h4><h5 id="SimpleTrigger"><a href="#SimpleTrigger" class="headerlink" title="SimpleTrigger"></a>SimpleTrigger</h5><p>指定从某一个时间开始，以一定的时间间隔（单位是毫秒）执行的任务。</p>
<p>它适合的任务类似于：9:00 开始，每隔1小时，执行一次。</p>
<p>它的属性有：</p>
<ul>
<li>repeatInterval 重复间隔</li>
<li>repeatCount 重复次数。实际执行次数是 repeatCount+1。因为在startTime的时候一定会执行一次。<strong>下面有关repeatCount 属性的都是同理</strong></li>
</ul>
<details>
<summary>例子</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">simpleSchedule()</span><br><span class="line">        .withIntervalInHours(1) //每小时执行一次</span><br><span class="line">        .repeatForever() //次数不限</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">simpleSchedule()</span><br><span class="line">    .withIntervalInMinutes(1) //每分钟执行一次</span><br><span class="line">    .withRepeatCount(10) //次数为10次</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
</details>

<h5 id="CalendarIntervalTrigger"><a href="#CalendarIntervalTrigger" class="headerlink" title="CalendarIntervalTrigger"></a>CalendarIntervalTrigger</h5><p>类似于SimpleTrigger，指定从某一个时间开始，以一定的时间间隔执行的任务。<br>但是不同的是SimpleTrigger指定的时间间隔为毫秒，没办法指定每隔一个月执行一次（每月的时间间隔不是固定值），而CalendarIntervalTrigger支持的间隔单位有秒，分钟，小时，天，月，年，星期。</p>
<p>相较于SimpleTrigger有两个优势：1、更方便，比如每隔1小时执行，你不用自己去计算1小时等于多少毫秒。 2、支持不是固定长度的间隔，比如间隔为月和年。但劣势是精度只能到秒。</p>
<p>它适合的任务类似于：9:00 开始执行，并且以后每周 9:00 执行一次</p>
<p>它的属性有:</p>
<ul>
<li>interval 执行间隔</li>
<li>intervalUnit 执行间隔的单位（秒，分钟，小时，天，月，年，星期）</li>
</ul>
<details>
<summary>例子</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">calendarIntervalSchedule()</span><br><span class="line">    .withIntervalInDays(1) //每天执行一次</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">calendarIntervalSchedule()</span><br><span class="line">    .withIntervalInWeeks(1) //每周执行一次</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
</details>

<h5 id="DailyTimeIntervalTrigger"><a href="#DailyTimeIntervalTrigger" class="headerlink" title="DailyTimeIntervalTrigger"></a>DailyTimeIntervalTrigger</h5><p>指定每天的某个时间段内，以一定的时间间隔执行任务。并且它可以支持指定星期。</p>
<p>它适合的任务类似于：指定每天9:00 至 18:00 ，每隔70秒执行一次，并且只要周一至周五执行。</p>
<p>它的属性有:</p>
<ul>
<li>startTimeOfDay 每天开始时间</li>
<li>endTimeOfDay 每天结束时间</li>
<li>daysOfWeek 需要执行的星期</li>
<li>interval 执行间隔</li>
<li>intervalUnit 执行间隔的单位（秒，分钟，小时，天，月，年，星期）</li>
<li>repeatCount 重复次数</li>
</ul>
<details>
<summary>例子</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dailyTimeIntervalSchedule()</span><br><span class="line">    .startingDailyAt(TimeOfDay.hourAndMinuteOfDay(9, 0)) //第天9：00开始</span><br><span class="line">    .endingDailyAt(TimeOfDay.hourAndMinuteOfDay(16, 0)) //16：00 结束 </span><br><span class="line">    .onDaysOfTheWeek(MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY) //周一至周五执行</span><br><span class="line">    .withIntervalInHours(1) //每间隔1小时执行一次</span><br><span class="line">    .withRepeatCount(100) //最多重复100次（实际执行100+1次）</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">dailyTimeIntervalSchedule()</span><br><span class="line">    .startingDailyAt(TimeOfDay.hourAndMinuteOfDay(9, 0)) //第天9：00开始</span><br><span class="line">    .endingDailyAfterCount(10) //每天执行10次，这个方法实际上根据 startTimeOfDay+interval*count 算出 endTimeOfDay</span><br><span class="line">    .onDaysOfTheWeek(MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY) //周一至周五执行</span><br><span class="line">    .withIntervalInHours(1) //每间隔1小时执行一次</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
</details>

<h5 id="CronTrigger"><a href="#CronTrigger" class="headerlink" title="CronTrigger"></a>CronTrigger</h5><p>适合于更复杂的任务，它支持类型于Linux Cron的语法（并且更强大）。基本上它覆盖了以上三个Trigger的绝大部分能力（但不是全部）—— 当然，也更难理解。</p>
<p>它适合的任务类似于：每天0:00,9:00,18:00各执行一次。</p>
<p>它的属性只有:</p>
<p>Cron表达式。但这个表示式本身就够复杂了。</p>
<h3 id="JobDetail-amp-Job"><a href="#JobDetail-amp-Job" class="headerlink" title="JobDetail &amp; Job"></a>JobDetail &amp; Job</h3><p>JobDetail是任务的定义，而Job是任务的执行逻辑。在JobDetail里会引用一个Job Class定义。</p>
<details>
<summary>一个最简单的例子</summary>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException, IOException </span>&#123;</span><br><span class="line">           JobDetail job=newJob()</span><br><span class="line">               .ofType(DoNothingJob.class) <span class="comment">//引用Job Class</span></span><br><span class="line">               .withIdentity(<span class="string">&quot;job1&quot;</span>, <span class="string">&quot;group1&quot;</span>) <span class="comment">//设置name/group</span></span><br><span class="line">               .withDescription(<span class="string">&quot;this is a test job&quot;</span>) <span class="comment">//设置描述</span></span><br><span class="line">               .usingJobData(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>) <span class="comment">//加入属性到ageJobDataMap</span></span><br><span class="line">               .build();</span><br><span class="line"></span><br><span class="line">           job.getJobDataMap().put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;quertz&quot;</span>); <span class="comment">//加入属性name到JobDataMap</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">//定义一个每秒执行一次的SimpleTrigger</span></span><br><span class="line">           Trigger trigger=newTrigger()</span><br><span class="line">                   .startNow()</span><br><span class="line">                   .withIdentity(<span class="string">&quot;trigger1&quot;</span>)</span><br><span class="line">                   .withSchedule(simpleSchedule()</span><br><span class="line">                       .withIntervalInSeconds(<span class="number">1</span>)</span><br><span class="line">                       .repeatForever())</span><br><span class="line">                   .build();</span><br><span class="line"></span><br><span class="line">           Scheduler sche=StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">           sche.scheduleJob(job, trigger);</span><br><span class="line"></span><br><span class="line">           sche.start();</span><br><span class="line"></span><br><span class="line">           System.in.read();</span><br><span class="line"></span><br><span class="line">           sche.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoNothingJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do nothing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>从上例我们可以看出，要定义一个任务，需要干几件事：</p>
<ul>
<li>创建一个org.quartz.Job的实现类，并实现实现自己的业务逻辑。比如上面的DoNothingJob。</li>
<li>定义一个JobDetail，引用这个实现类</li>
<li>加入scheduleJob</li>
</ul>
<p>Quartz调度一次任务，会干如下的事：</p>
<ul>
<li>JobClass jobClass=JobDetail.getJobClass()</li>
<li>Job jobInstance=jobClass.newInstance()。所以Job实现类，必须有一个public的无参构建方法。</li>
<li>jobInstance.execute(JobExecutionContext context)。JobExecutionContext是Job运行的上下文，可以获得Trigger、Scheduler、JobDetail的信息。</li>
</ul>
<p>也就是说，每次调度都会创建一个新的Job实例，这样的好处是有些任务并发执行的时候，不存在对临界资源的访问问题——当然，如果需要共享JobDataMap的时候，还是存在临界资源的并发访问的问题。</p>
<h4 id="JobDataMap"><a href="#JobDataMap" class="headerlink" title="JobDataMap"></a>JobDataMap</h4><p>每一个JobDetail都会有一个JobDataMap。JobDataMap本质就是一个Map的扩展类，只是提供了一些更便捷的方法，比如getString()之类的。</p>
<p>我们可以在定义JobDetail，加入属性值，方式有二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newJob().usingJobData(&quot;age&quot;, 18) //加入属性到ageJobDataMap</span><br><span class="line"></span><br><span class="line"> or</span><br><span class="line"></span><br><span class="line">job.getJobDataMap().put(&quot;name&quot;, &quot;quertz&quot;); //加入属性name到JobDataMap</span><br></pre></td></tr></table></figure>

<p>然后在Job中可以获取这个JobDataMap的值，方式同样有二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloQuartz</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        JobDetail detail = context.getJobDetail();</span><br><span class="line">        JobDataMap map = detail.getJobDataMap(); <span class="comment">//方法一：获得JobDataMap</span></span><br><span class="line">        System.out.println(<span class="string">&quot;say hello to &quot;</span> + name + <span class="string">&quot;[&quot;</span> + map.getInt(<span class="string">&quot;age&quot;</span>) + <span class="string">&quot;]&quot;</span> + <span class="string">&quot; at &quot;</span></span><br><span class="line">                           + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：属性的setter方法，会将JobDataMap的属性自动注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于同一个JobDetail实例，执行的多个Job实例，是共享同样的JobDataMap，也就是说，如果你在任务里修改了里面的值，会对其他Job实例（并发的或者后续的）造成影响。</p>
<p>除了JobDetail，Trigger同样有一个JobDataMap，共享范围是所有使用这个Trigger的Job实例。</p>
<h4 id="Job并发"><a href="#Job并发" class="headerlink" title="Job并发"></a>Job并发</h4><p>Job是有可能并发执行的，比如一个任务要执行10秒中，而调度算法是每秒中触发1次，那么就有可能多个任务被并发执行。</p>
<p>有时候我们并不想任务并发执行，比如这个任务要去”获得数据库中所有未发送邮件的名单“，如果是并发执行，就需要一个数据库锁去避免一个数据被多次处理。这个时候一个@DisallowConcurrentExecution解决这个问题。</p>
<p>就是这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoNothingJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DisallowConcurrentExecution</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;do nothing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，@DisallowConcurrentExecution是对JobDetail实例生效，也就是如果你定义两个JobDetail，引用同一个Job类，是可以并发执行的。</p>
<h4 id="JobExecutionException"><a href="#JobExecutionException" class="headerlink" title="JobExecutionException"></a>JobExecutionException</h4><p>Job.execute()方法是不允许抛出除JobExecutionException之外的所有异常的（包括RuntimeException)，所以编码的时候，最好是try-catch住所有的Throwable，小心处理。</p>
<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>Scheduler就是Quartz的大脑，所有任务都是由它来设施。</p>
<p>Schduelr包含一个两个重要组件: JobStore和ThreadPool。</p>
<p>JobStore是会来存储运行时信息的，包括Trigger,Schduler,JobDetail，业务锁等。它有多种实现RAMJob(内存实现)，JobStoreTX(JDBC，事务由Quartz管理），JobStoreCMT(JDBC，使用容器事务)，ClusteredJobStore(集群实现)、TerracottaJobStore(什么是Terractta)。</p>
<p>ThreadPool就是线程池，Quartz有自己的线程池实现。所有任务的都会由线程池执行。</p>
<h4 id="SchedulerFactory"><a href="#SchedulerFactory" class="headerlink" title="SchedulerFactory"></a>SchedulerFactory</h4><p>SchdulerFactory，顾名思义就是来用创建Schduler了，有两个实现：DirectSchedulerFactory和 StdSchdulerFactory。前者可以用来在代码里定制你自己的Schduler参数。后者是直接读取classpath下的quartz.properties（不存在就都使用默认值）配置来实例化Schduler。通常来讲，我们使用StdSchdulerFactory也就足够了。</p>
<p>SchdulerFactory本身是支持创建RMI stub的，可以用来管理远程的Scheduler，功能与本地一样，可以远程提交个Job什么的。</p>
<p>DirectSchedulerFactory的创建接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Same as</span><br><span class="line">     * &#123;@link DirectSchedulerFactory#createScheduler(ThreadPool threadPool, JobStore jobStore)&#125;,</span><br><span class="line">     * with the addition of specifying the scheduler name and instance ID. This</span><br><span class="line">     * scheduler can only be retrieved via</span><br><span class="line">     * &#123;@link DirectSchedulerFactory#getScheduler(String)&#125;</span><br><span class="line">     *</span><br><span class="line">     * @param schedulerName</span><br><span class="line">     *          The name for the scheduler.</span><br><span class="line">     * @param schedulerInstanceId</span><br><span class="line">     *          The instance ID for the scheduler.</span><br><span class="line">     * @param threadPool</span><br><span class="line">     *          The thread pool for executing jobs</span><br><span class="line">     * @param jobStore</span><br><span class="line">     *          The type of job store</span><br><span class="line">     * @throws SchedulerException</span><br><span class="line">     *           if initialization failed</span><br><span class="line">     */</span><br><span class="line">    public void createScheduler(String schedulerName,</span><br><span class="line">            String schedulerInstanceId, ThreadPool threadPool, JobStore jobStore)</span><br><span class="line">        throws SchedulerException;</span><br></pre></td></tr></table></figure>
<p>StdSchdulerFactory的配置例子，更多配置，参考<a target="_blank" rel="noopener" href="http://quartz-scheduler.org/documentation/quartz-2.2.x/configuration/">Quartz配置指南</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.scheduler.instanceName = DefaultQuartzScheduler</span><br><span class="line">org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool</span><br><span class="line">org.quartz.threadPool.threadCount = 10 </span><br><span class="line">org.quartz.threadPool.threadPriority = 5</span><br><span class="line">org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread = true</span><br><span class="line">org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore</span><br></pre></td></tr></table></figure>



<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>JobStore <ul>
<li><a target="_blank" rel="noopener" href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-09">介绍</a></li>
<li><a target="_blank" rel="noopener" href="http://quartz-scheduler.org/documentation/quartz-2.2.x/configuration/">配置</a></li>
</ul>
</li>
<li>集群: <ul>
<li><a target="_blank" rel="noopener" href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-11">介绍</a></li>
<li><a target="_blank" rel="noopener" href="http://quartz-scheduler.org/documentation/quartz-2.2.x/configuration/ConfigJDBCJobStoreClustering">配置</a></li>
</ul>
</li>
<li>RMI</li>
<li>监听器 <ul>
<li><a target="_blank" rel="noopener" href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-07">TriggerListeners and JobListeners</a></li>
<li><a target="_blank" rel="noopener" href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/tutorial-lesson-08">SchedulerListeners</a></li>
</ul>
</li>
<li>插件</li>
</ul>
<p>主要的资料来自<a target="_blank" rel="noopener" href="http://quartz-scheduler.org/documentation/quartz-2.2.x/tutorials/">官方文档</a>，这里有教程，例子，配置等，非常详细</p>
<h2 id="Quartz源码解析"><a href="#Quartz源码解析" class="headerlink" title="Quartz源码解析"></a>Quartz源码解析</h2><h3 id="Quartz启动流程"><a href="#Quartz启动流程" class="headerlink" title="Quartz启动流程"></a>Quartz启动流程</h3><p>当服务器启动时，Spring就加载相关的bean。<br>SchedulerFactoryBean实现了InitializingBean接口，因此在初始化bean的时候，会执行afterPropertiesSet方法，该方法将会调用SchedulerFactory(DirectSchedulerFactory 或者 StdSchedulerFactory，通常用StdSchedulerFactory)创建Scheduler。==<br>我们在SchedulerFactoryBean配置类中配了相关的配置及配置文件参数，所以会读取配置文件参数，初始化各个组件。  </p>
<p>关键组件如下：</p>
<ul>
<li><strong>ThreadPool</strong>：一般是使用SimpleThreadPool(线程数量固定的线程池),SimpleThreadPool创建了一定数量的WorkerThread实例来使得Job能够在线程中进行处理。WorkerThread是定义在SimpleThreadPool类中的内部类，它实质上就是一个线程。<br>在SimpleThreadPool中有三个list：workers-存放池中所有的线程引用，availWorkers-存放所有空闲的线程，busyWorkers-存放所有工作中的线程；配置如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.quartz.threadPool.class=org.quartz.simpl.SimpleThreadPool</span><br><span class="line">org.quartz.threadPool.threadCount=3</span><br><span class="line">org.quartz.threadPool.threadPriority=5</span><br></pre></td></tr></table></figure></li>
<li><strong>JobStore</strong>： 初始化定时任务的数据存储方式，分为两种：<ul>
<li>存储在内存的RAMJobStore<br>存取速度非常快，但是由于其在系统被停止后所有的数据都会丢失，所以在集群应用中，必须使用JobStoreSupport</li>
<li>存储在数据库的JobStoreSupport(包括JobStoreTX和JobStoreCMT两种实现，JobStoreCMT是依赖于容器来进行事务的管理，而JobStoreTX是自己管理事务） </li>
</ul>
</li>
<li><strong>QuartzSchedulerThread</strong>： 初始化调度线程，在初始化的时候paused=true,halted=false,虽然线程开始运行了，但是paused=true，线程会一直等待，直到start方法将paused置为false；SchedulerFactoryBean还实现了SmartLifeCycle接口，因此初始化完成后，会执行start()方法，该方法将主要会执行以下的几个动作：<ul>
<li>创建ClusterManager线程并启动线程:该线程用来进行集群故障检测和处理</li>
<li>创建MisfireHandler线程并启动线程:该线程用来进行misfire任务的处理</li>
<li>置QuartzSchedulerThread的paused=false，调度线程才真正开始调度</li>
</ul>
整个启动流程图如下：<br><img src="/2020/03/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F/%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%95%E6%9C%BA%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6Quartz%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/img.png"><br>流程图简要说明：<ol>
<li>先读取配置文件</li>
<li>初始化SchedulerFactoryBean</li>
<li>初始化SchedulerFactory</li>
<li>实例化执行线程池（TheadPool）</li>
<li>实例化数据存储</li>
<li>初始化QuartzScheduler(为Scheduler的简单实现，包括调度作业、注册JobListener实例等方法。)</li>
<li>new一个QuartzSchedulerThread调度线程（负责执行在QuartzScheduler中注册的触发触发器的线程。），并开始运行</li>
<li>调度开始，注册监听器，注册Job和Trigger</li>
<li>SchedulerFactoryBean初始化完成后执行start()方法</li>
<li>创建ClusterManager线程并启动线程</li>
<li>创建MisfireHandler线程并启动线程</li>
<li>置QuartzSchedulerThread的paused=false，调度线程真正开始调度，开始执行run方法</li>
</ol>
</li>
</ul>
<h3 id="Quartz-线程视图"><a href="#Quartz-线程视图" class="headerlink" title="Quartz 线程视图"></a>Quartz 线程视图</h3><p>在Quartz中，有两类线程，Scheduler调度线程和任务执行线程，其中任务执行线程通常使用一个线程池维护一组线程。<br><img src="/2020/03/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F/%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%95%E6%9C%BA%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6Quartz%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/img_3.png"></p>
<p>Scheduler调度线程主要有两个：执行常规调度的线程，和执行misfiredtrigger的线程。  </p>
<ul>
<li>常规调度线程轮询存储的所有trigger，如果有需要触发的trigger，即到达了下一次触发的时间，则从任务执行线程池获取一个空闲线程，执行与该trigger关联的任务。<br>— Misfire线程是扫描所有的trigger，查看是否有misfiredtrigger，如果有的话根据misfire的策略分别处理(fire now OR wait for the next fire)。</li>
</ul>
<h3 id="QuartzSchedulerThread逻辑具体介绍"><a href="#QuartzSchedulerThread逻辑具体介绍" class="headerlink" title="QuartzSchedulerThread逻辑具体介绍"></a>QuartzSchedulerThread逻辑具体介绍</h3><p>类中主要的方法就是run方法，下面主要对run方法进行介绍：</p>
<details>
<summary>源码解析</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//只有当Quartzscheduler执行start方法时被调用</span><br><span class="line">void togglePause(boolean pause) &#123;</span><br><span class="line">    synchronized(this.sigLock) &#123;</span><br><span class="line">        this.paused = pause;</span><br><span class="line">        if (this.paused) &#123;</span><br><span class="line">          this.signalSchedulingChange(0L);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.sigLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    boolean lastAcquireFailed = false;</span><br><span class="line">    label214:</span><br><span class="line">    //此处判断调度器是否终止</span><br><span class="line">    while(!this.halted.get()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            synchronized(this.sigLock) &#123;</span><br><span class="line">                //此处判断调度器是否终止或是否暂停，由于我们在初始化的时候</span><br><span class="line">                //将paused=true，那么调度线程此时不会真正开始执行只会在不断循环阻塞</span><br><span class="line">                //只有当Quartzscheduler执行start方法时调用togglePause开始将</span><br><span class="line">                //paused置为false,run方法开始真正运行</span><br><span class="line">                while(this.paused &amp;&amp; !this.halted.get()) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        this.sigLock.wait(1000L);</span><br><span class="line">                    &#125; catch (InterruptedException var23) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (this.halted.get()) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //取出执行线程池中空闲的线程数量</span><br><span class="line">            int availThreadCount = this.qsRsrcs.getThreadPool().blockForAvailableThreads();</span><br><span class="line">            if (availThreadCount &gt; 0) &#123;</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">            //如果可用线程数量足够那么查看30秒内需要触发的触发器。如果没有的</span><br><span class="line">            //话那么就是30后再次扫描，其中方法中三个参数idleWaitTime为如果</span><br><span class="line">            //没有的再次扫描的时间，第二个为最多取几个，最后一个参数</span><br><span class="line">            //batchTimeWindow，这个参数默认是0，同样是一个时间范围，如果</span><br><span class="line">            //有两个任务只差一两秒，而执行线程数量满足及batchTimeWindow时间</span><br><span class="line">            //也满足的情况下就会两个都取出来</span><br><span class="line"></span><br><span class="line">            triggers = this.qsRsrcs.getJobStore().acquireNextTriggers(now + this.idleWaitTime, Math.min(availThreadCount, this.qsRsrcs.getMaxBatchSize()), this.qsRsrcs.getBatchTimeWindow());</span><br><span class="line">            ...</span><br><span class="line">            ...</span><br><span class="line">            //trigger列表是以下次执行时间排序查出来的</span><br><span class="line">            //在列表不为空的时候进行后续操作</span><br><span class="line">            if (triggers != null &amp;&amp; !triggers.isEmpty()) &#123;</span><br><span class="line">            now = System.currentTimeMillis();</span><br><span class="line">            //取出集合中最早执行的触发器</span><br><span class="line">            long triggerTime = ((OperableTrigger)triggers.get(0)).getNextFireTime().getTime();</span><br><span class="line">            //判断距离执行时间是否大于两毫秒</span><br><span class="line">            for(long timeUntilTrigger = triggerTime - now; timeUntilTrigger &gt; 2L; timeUntilTrigger = triggerTime - now) &#123;</span><br><span class="line">                synchronized(this.sigLock) &#123;</span><br><span class="line">                    if (this.halted.get()) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //判断是否还有更早的trigger</span><br><span class="line">                    if (!this.isCandidateNewTimeEarlierWithinReason(triggerTime, false)) &#123;</span><br><span class="line">                    //没有的话进行简单的阻塞，到时候再执行</span><br><span class="line">                        try &#123;</span><br><span class="line">                            now = System.currentTimeMillis();</span><br><span class="line">                            timeUntilTrigger = triggerTime - now;</span><br><span class="line">                            if (timeUntilTrigger &gt;= 1L) &#123;</span><br><span class="line">                                this.sigLock.wait(timeUntilTrigger);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; catch (InterruptedException var22) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //开始根据需要执行的trigger从数据库中获取相应的JobDetail</span><br><span class="line">                 if (goAhead) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        List&lt;TriggerFiredResult&gt; res = this.qsRsrcs.getJobStore().triggersFired(triggers);</span><br><span class="line">                        if (res != null) &#123;</span><br><span class="line">                            bndles = res;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (SchedulerException var24) &#123;</span><br><span class="line">                        this.qs.notifySchedulerListenersError(&quot;An error occurred while firing triggers &#x27;&quot; + triggers + &quot;&#x27;&quot;, var24);</span><br><span class="line">                        int i = 0;</span><br><span class="line"></span><br><span class="line">                        while(true) &#123;</span><br><span class="line">                            if (i &gt;= triggers.size()) &#123;</span><br><span class="line">                                continue label214;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            this.qsRsrcs.getJobStore().releaseAcquiredTrigger((OperableTrigger)triggers.get(i));</span><br><span class="line">                            ++i;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //将查询到的结果封装成为 TriggerFiredResult</span><br><span class="line">                 for(int i = 0; i &lt; ((List)bndles).size(); ++i) &#123;</span><br><span class="line">                    TriggerFiredResult result = (TriggerFiredResult)((List)bndles).get(i);</span><br><span class="line">                    TriggerFiredBundle bndle = result.getTriggerFiredBundle();</span><br><span class="line">                    Exception exception = result.getException();</span><br><span class="line">                    if (exception instanceof RuntimeException) &#123;</span><br><span class="line">                        this.getLog().error(&quot;RuntimeException while firing trigger &quot; + triggers.get(i), exception);</span><br><span class="line">                        this.qsRsrcs.getJobStore().releaseAcquiredTrigger((OperableTrigger)triggers.get(i));</span><br><span class="line">                    &#125; else if (bndle == null) &#123;</span><br><span class="line">                        this.qsRsrcs.getJobStore().releaseAcquiredTrigger((OperableTrigger)triggers.get(i));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        JobRunShell shell = null;</span><br><span class="line"></span><br><span class="line">                        try &#123;</span><br><span class="line">                        //把任务封装成JobRunShell线程任务，然后放到线程池中跑动。</span><br><span class="line">                            shell = this.qsRsrcs.getJobRunShellFactory().createJobRunShell(bndle);</span><br><span class="line">                            shell.initialize(this.qs);</span><br><span class="line">                        &#125; catch (SchedulerException var27) &#123;</span><br><span class="line">                            this.qsRsrcs.getJobStore().triggeredJobComplete((OperableTrigger)triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        //runInThread方法加Job放入对应的工作线程进行执行Job</span><br><span class="line">                        if (!this.qsRsrcs.getThreadPool().runInThread(shell)) &#123;</span><br><span class="line">                            this.getLog().error(&quot;ThreadPool.runInThread() return false!&quot;);</span><br><span class="line">                            this.qsRsrcs.getJobStore().triggeredJobComplete((OperableTrigger)triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>
</details>

<p><img src="/2020/03/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F/%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%95%E6%9C%BA%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6Quartz%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/img_1.png"></p>
<p>总结下来:</p>
<ol>
<li>先获取线程池中的可用线程数量（若没有可用的会阻塞，直到有可用的）；</li>
<li>获取30m内要执行的trigger(即acquireNextTriggers)获取trigger的锁，通过select …for update方式实现；获取30m内（可配置）要执行的triggers（需要保证集群节点的时间一致），若@ConcurrentExectionDisallowed且列表存在该条trigger则跳过，否则更新trigger状态为ACQUIRED(刚开始为WAITING)；插入firedTrigger表，状态为ACQUIRED;（注意：在RAMJobStore中，有个timeTriggers，排序方式是按触发时间nextFireTime排的；JobStoreSupport从数据库取出triggers时是按照nextFireTime排序）;</li>
<li>待直到获取的trigger中最先执行的trigger在2ms内；</li>
<li>triggersFired：<ol>
<li>更新firedTrigger的status=EXECUTING;</li>
<li>更新trigger下一次触发的时间; </li>
<li>更新trigger的状态：无状态的trigger-&gt;WAITING，有状态的trigger-&gt;BLOCKED，若nextFireTime==null -&gt;COMPLETE；</li>
<li>commit connection,释放锁；</li>
</ol>
</li>
<li>针对每个要执行的trigger，创建JobRunShell，并放入线程池执行：<ol>
<li>execute:执行job</li>
<li>获取TRIGGER_ACCESS锁</li>
<li>若是有状态的job：更新trigger状态：BLOCKED-&gt;WAITING,PAUSED_BLOCKED-&gt;BLOCKED</li>
<li>若@PersistJobDataAfterExecution，则updateJobData</li>
<li>删除firedTrigger</li>
<li>commit connection，释放锁</li>
</ol>
</li>
</ol>
<h3 id="misfireHandler线程"><a href="#misfireHandler线程" class="headerlink" title="misfireHandler线程"></a>misfireHandler线程</h3><p>下面这些原因可能造成 misfired job:</p>
<ol>
<li>系统因为某些原因被重启。在系统关闭到重新启动之间的一段时间里，可能有些任务会被 misfire；</li>
<li>Trigger 被暂停（suspend）的一段时间里，有些任务可能会被 misfire；</li>
<li>线程池中所有线程都被占用，导致任务无法被触发执行，造成 misfire；</li>
<li>有状态任务在下次触发时间到达时，上次执行还没有结束；为了处理 misfired job，Quartz 中为 trigger定义了处理策略，主要有下面两种：MISFIRE_INSTRUCTION_FIRE_ONCE_NOW：针对 misfired job马上执行一次；MISFIRE_INSTRUCTION_DO_NOTHING：忽略 misfired job，等待下次触发；默认是MISFIRE_INSTRUCTION_SMART_POLICY，该策略在CronTrigger中=MISFIRE_INSTRUCTION_FIRE_ONCE_NOW线程默认1分钟执行一次；在一个事务中，默认一次最多recovery 20个；</li>
</ol>
<p>执行流程：<br><img src="/2020/03/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F/%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%95%E6%9C%BA%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6Quartz%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%E5%8F%8A%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/img_2.png"></p>
<ol>
<li>若配置(默认为true，可配置)成获取锁前先检查是否有需要recovery的trigger，先获取misfireCount；</li>
<li>获取TRIGGER_ACCESS锁；</li>
<li>hasMisfiredTriggersInState：获取misfired的trigger，默认一个事务里只能最大20个misfired trigger（可配置），misfired判断依据：status=waiting,next_fire_time &lt; current_time-misfirethreshold(可配置，默认1min)</li>
<li>notifyTriggerListenersMisfired</li>
<li>updateAfterMisfire:获取misfire策略(默认是MISFIRE_INSTRUCTION_SMART_POLICY，该策略在CronTrigger中=MISFIRE_INSTRUCTION_FIRE_ONCE_NOW)，根据策略更新nextFireTime；</li>
<li>将nextFireTime等更新到trigger表；</li>
<li>commit connection，释放锁8.如果还有更多的misfired，sleep短暂时间(为了集群负载均衡)，否则sleep misfirethreshold时间，后继续轮询；</li>
</ol>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6/">定时调度</a><a class="post-meta__tags" href="/tags/Quartz/">Quartz</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F/%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E4%BC%98%E7%A7%80%E5%9B%BD%E4%BA%A7%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F/"><i class="fa fa-chevron-left">  </i><span>定时调度系列之分布式定时调度优秀国产调度系统</span></a></div><div class="next-post pull-right"><a href="/2020/03/14/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F/%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%95%E6%9C%BA%E5%AE%9A%E6%97%B6%E8%B0%83%E5%BA%A6Linux%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1cron/"><span>定时调度系列之单机定时调度Linux定时任务cron</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By 何鹏 [smile.hepeng@qq.com]</div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://unpkg.zhimg.com/animejs@3.2.1/lib/anime.min.js"></script><script src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script src="https://unpkg.zhimg.com/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://unpkg.com/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://unpkg.com/velocity-ui-pack@1.2.2/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>