<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="RocketMQ初探之整体设计简介"><meta name="keywords" content="消息中间件,MQ,RocketMQ"><meta name="author" content="何鹏 [smile.hepeng@qq.com]"><meta name="copyright" content="何鹏 [smile.hepeng@qq.com]"><title>RocketMQ初探之整体设计简介 | 沉默者</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.0'
} </script><link rel="alternate" href="/atom.xml" title="沉默者" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRocketMQ"><span class="toc-number">1.</span> <span class="toc-text">什么是RocketMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RocketMQ%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">RocketMQ特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E6%A6%82%E5%BF%B5%E8%A7%A3%E8%AF%BB"><span class="toc-number">2.</span> <span class="toc-text">RocketMQ概念解读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RocketMQ%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">RocketMQ核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Name-Server-%E5%90%8D%E7%A7%B0%E6%9C%8D%E5%8A%A1%E5%85%85%E5%BD%93%E8%B7%AF%E7%94%B1%E6%B6%88%E6%81%AF%E7%9A%84%E6%8F%90%E4%BE%9B%E8%80%85%E3%80%82"><span class="toc-number">2.1.1.</span> <span class="toc-text">Name Server: 名称服务充当路由消息的提供者。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Broker%EF%BC%9A%E6%B6%88%E6%81%AF%E4%B8%AD%E8%BD%AC%E8%A7%92%E8%89%B2%EF%BC%8C%E8%B4%9F%E8%B4%A3%E5%AD%98%E5%82%A8%E6%B6%88%E6%81%AF%EF%BC%8C%E8%BD%AC%E5%8F%91%E6%B6%88%E6%81%AF%E3%80%82"><span class="toc-number">2.1.2.</span> <span class="toc-text">Broker：消息中转角色，负责存储消息，转发消息。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">2.1.3.</span> <span class="toc-text">生产者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">2.1.4.</span> <span class="toc-text">消费者</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Topic%E3%80%81Queue%E3%80%81tags"><span class="toc-number">2.2.</span> <span class="toc-text">Topic、Queue、tags</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Topic"><span class="toc-number">2.2.1.</span> <span class="toc-text">Topic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue"><span class="toc-number">2.2.2.</span> <span class="toc-text">Queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tags"><span class="toc-number">2.2.3.</span> <span class="toc-text">Tags</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Group"><span class="toc-number">2.3.</span> <span class="toc-text">Group</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Producer-amp-amp-Producer-Group"><span class="toc-number">2.3.1.</span> <span class="toc-text">Producer &amp;&amp; Producer Group</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Consumer-amp-amp-Consumer-Group"><span class="toc-number">2.3.2.</span> <span class="toc-text">Consumer &amp;&amp; Consumer Group</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E7%BB%84%E4%BB%B6%E5%85%B3%E7%B3%BB"><span class="toc-number">3.</span> <span class="toc-text">RocketMQ组件关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Broker-amp-amp-Producer-amp-amp-Consumer"><span class="toc-number">3.1.</span> <span class="toc-text">Broker &amp;&amp; Producer &amp;&amp; Consumer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Topic-amp-amp-Topic%E5%88%86%E7%89%87-amp-amp-Queue"><span class="toc-number">3.2.</span> <span class="toc-text">Topic &amp;&amp; Topic分片 &amp;&amp; Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue%E6%95%B0%E9%87%8F%E6%8C%87%E5%AE%9A%E6%96%B9%E5%BC%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">Queue数量指定方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E5%A4%A7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">RocketMQ发布订阅大体流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%88%86%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">消息分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">发送类型分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%B6%88%E6%81%AF"><span class="toc-number">5.1.1.</span> <span class="toc-text">同步消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF"><span class="toc-number">5.1.2.</span> <span class="toc-text">异步消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%B6%88%E6%81%AF"><span class="toc-number">5.1.3.</span> <span class="toc-text">单向消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E5%88%92%E5%88%86"><span class="toc-number">5.2.</span> <span class="toc-text">按照功能使用划分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF-amp-amp-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">5.2.1.</span> <span class="toc-text">普通消息 &amp;&amp; 顺序消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF"><span class="toc-number">5.2.2.</span> <span class="toc-text">广播消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">5.2.3.</span> <span class="toc-text">延时消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">定时消息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-1"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">延时消息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">5.2.4.</span> <span class="toc-text">事务消息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">发布订阅模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#producer%E7%AB%AF%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">producer端消息发布原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consumer%E7%AB%AF%E6%B6%88%E6%81%AF%E8%8E%B7%E5%8F%96%E6%A8%A1%E5%BC%8F%EF%BC%88push-pull%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">consumer端消息获取模式（push&#x2F;pull）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#consumer%E7%AB%AF%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F-%E9%9B%86%E7%BE%A4-%E5%B9%BF%E6%92%AD"><span class="toc-number">6.3.</span> <span class="toc-text">consumer端消息消费模式(集群&#x2F;广播)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.4.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9"><span class="toc-number">6.4.1.</span> <span class="toc-text">集群消费</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-amp-amp-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">使用场景 &amp;&amp; 注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9"><span class="toc-number">6.4.2.</span> <span class="toc-text">广播消费</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-amp-amp-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">6.4.2.1.</span> <span class="toc-text">使用场景 &amp;&amp; 注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E6%A8%A1%E6%8B%9F%E5%B9%BF%E6%92%AD"><span class="toc-number">6.4.3.</span> <span class="toc-text">使用集群模式模拟广播</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-amp-amp-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.4.3.1.</span> <span class="toc-text">适用场景 &amp;&amp; 注意事项</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">7.</span> <span class="toc-text">负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">7.1.</span> <span class="toc-text">生产端负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">7.2.</span> <span class="toc-text">消费端负载均衡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84"><span class="toc-number">8.</span> <span class="toc-text">部署架构</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img2.baidu.com/it/u=928705063,3876627980&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg"></div><div class="author-info__name text-center">何鹏 [smile.hepeng@qq.com]</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">51</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">41</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默者</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">RocketMQ初探之整体设计简介</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-12-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"> 中间件</a><span class="post-meta__separator">|</span><span class="post-meta-wordcount"><span>Word count: </span><span class="word-count">6.7k</span><span class="post-meta__separator">|</span><span>Reading time: 21 min</span></span></div><div class="article-container" id="post-content"><p>说明： 文章转账自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/weifeng1463/p/12889300.html">RocketMQ之一：RocketMQ整体介绍</a></p>
<h2 id="什么是RocketMQ"><a href="#什么是RocketMQ" class="headerlink" title="什么是RocketMQ"></a>什么是RocketMQ</h2><p>RocketMQ 是阿里巴巴开源的分布式消息中间件。</p>
<p>支持:</p>
<ul>
<li>事务消息<ul>
<li>对于分布式事务来说提供了又一种解决思路。</li>
</ul>
</li>
<li>顺序消息：<ul>
<li>保证消息消费者按照消息发送的顺序对消息进行消费。</li>
<li>分为全局有序和局部有序</li>
<li>一般推荐使用局部有序，即生产者通过将某一类消息按顺序发送至同一个队列来实现</li>
</ul>
</li>
<li>批量消息</li>
<li>定时消息</li>
<li>消息回溯<ul>
<li>指消费者已经消费成功的消息，由于业务上需求需要重新消费</li>
<li>RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯。</li>
</ul>
</li>
</ul>
<p>它里面有几个区别于标准消息中件间的概念，如</p>
<ul>
<li>Group</li>
<li>Topic</li>
<li>Queue</li>
</ul>
<p>系统组成由</p>
<ul>
<li>Producer</li>
<li>Consumer</li>
<li>Broker</li>
<li>NameServer</li>
</ul>
<h3 id="RocketMQ特点"><a href="#RocketMQ特点" class="headerlink" title="RocketMQ特点"></a>RocketMQ特点</h3><ul>
<li>一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式等特点</li>
<li>Producer、Consumer、队列都可以分布式</li>
<li>Producer 向一些队列轮流发送消息，队列集合称为 Topic<ul>
<li>Consumer 如果做广播消费，则一个 Consumer 实例消费这个 Topic 对应的所有队列</li>
<li><font color="#FF0000">如果做集群消费，则多个 Consumer 实例平均消费这个 Topic 对应的队列集合</font><ul>
<li>如何实现平均消费？</li>
</ul>
</li>
</ul>
</li>
<li>能够保证严格的消息顺序</li>
<li>支持 <font color="#FF0000">拉（pull）和推（push）两种消息模式</font></li>
<li>高效的订阅者水平扩展能力</li>
<li>实时的消息订阅机制</li>
<li>亿级消息堆积能力，堆积了这么多消息后依然保持写入低延迟</li>
<li>支持多种消息协议，如 JMS、OpenMessaging 等</li>
<li>较少的依赖</li>
</ul>
<h2 id="RocketMQ概念解读"><a href="#RocketMQ概念解读" class="headerlink" title="RocketMQ概念解读"></a>RocketMQ概念解读</h2><h3 id="RocketMQ核心概念"><a href="#RocketMQ核心概念" class="headerlink" title="RocketMQ核心概念"></a>RocketMQ核心概念</h3><p>消息队列 RocketMQ 在任何一个环境都是可扩展的，生产者必须是一个集群，消息服务器必须是一个集群，消费者也同样。</p>
<p>集群级别的高可用，是消息队列 RocketMQ 跟其他的消息服务器的主要区别，消息生产者发送一条消息到消息服务器，消息服务器会<font color="#FF0000">随机的选择一个消费者</font><br>，只要这个消费者消费成功就认为是成功了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：文中所提及的消息队列 RocketMQ 的服务端或者服务器包含 Name Server、Broker 等。服务端不等同于 Broker。</span><br></pre></td></tr></table></figure>

<p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112011406.png"></p>
<p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成。</p>
<p>其中：</p>
<ul>
<li>Producer 负责生产消息，<ul>
<li>同步<ul>
<li>指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包</li>
<li>一般用于重要通知消息，例如重要通知邮件、营销短信。</li>
</ul>
</li>
<li>异步<ul>
<li>发送方发出数据后，不等接收方发回响应，接着发送下个数据包</li>
<li>一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。</li>
</ul>
</li>
<li>单向</li>
</ul>
</li>
<li>Consumer 负责消费消息，<ul>
<li>ConsumerGroup 由多个 Consumer 实例构成。</li>
</ul>
</li>
<li>Broker 负责存储消息。<ul>
<li>Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。</li>
<li>Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。</li>
</ul>
</li>
</ul>
<p>图中所涉及到的概念如下所述：</p>
<h4 id="Name-Server-名称服务充当路由消息的提供者。"><a href="#Name-Server-名称服务充当路由消息的提供者。" class="headerlink" title="Name Server: 名称服务充当路由消息的提供者。"></a>Name Server: 名称服务充当路由消息的提供者。</h4><p>一个几乎无状态节点，可集群部署，节点之间无任何信息同步。在消息队列 RocketMQ 中提供命名服务，更新和发现 Broker 服务。</p>
<p><strong>两个功能</strong></p>
<ul>
<li>接收broker的请求，注册broker的路由信息</li>
<li>接收client（producer/consumer）的请求，根据某个topic获取其到broker的路由信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NameServer没有状态，可以横向扩展。</span><br><span class="line"></span><br><span class="line">每个broker在启动的时候会到NameServer注册； Producer在发送消息前会根据topic到NameServer获取路由(到broker)信息； </span><br><span class="line">Consumer也会定时获取topic路由信息。</span><br><span class="line"></span><br><span class="line">无信息同步如何实现数据持久化</span><br></pre></td></tr></table></figure>

<h4 id="Broker：消息中转角色，负责存储消息，转发消息。"><a href="#Broker：消息中转角色，负责存储消息，转发消息。" class="headerlink" title="Broker：消息中转角色，负责存储消息，转发消息。"></a>Broker：消息中转角色，负责存储消息，转发消息。</h4><p>Broker可以理解为消息队列服务器，提供了消息的接收、存储、拉取和转发服务。 它是RocketMQ的核心，<font color="#FF0000">需要保证broker的高可用</font>。</p>
<ul>
<li>broker分为 Master Broker 和 Slave Broker，一个 Master Broker 可以对应多个 Slave Broker，但是一个 Slave Broker<br>只能对应一个 Master Broker。</li>
<li>Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。</li>
<li>每个Broker与Name Server集群中的所有节点建立长连接，定时注册Topic信息到所有Name Server。Broker 启动后需要完成一次将自己注册至 Name Server<br>的操作；随后每隔 30s 定期向 Name Server 上报 Topic 路由信息。<ul>
<li>如果Master挂了，需要30s才能被Name Server感知</li>
</ul>
</li>
</ul>
<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>与 Name Server 集群中的其中一个节点（随机）建立长链接（Keep-alive），定期从 Name Server 读取 Topic 路由信息，并向提供 Topic 服务的 Master<br>Broker 建立长链接，且定时向 Master Broker 发送心跳。</p>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>与 Name Server 集群中的其中一个节点（随机）建立长连接，定期从 Name Server 拉取 Topic 路由信息，并向提供 Topic 服务的 Master Broker、Slave<br>Broker 建立长连接，且定时向 Master Broker、Slave Broker 发送心跳。</p>
<p>Consumer 既可以从 Master Broker 订阅消息，也可以从 Slave Broker 订阅消息，订阅规则由 Broker 配置决定。</p>
<h3 id="Topic、Queue、tags"><a href="#Topic、Queue、tags" class="headerlink" title="Topic、Queue、tags"></a>Topic、Queue、tags</h3><p>RocketMQ的Topic/Queue和JMS中的Topic/Queue概念有一定的差异:</p>
<ul>
<li>JMS中所有消费者都会消费一个Topic消息的副本，而Queue中消息只会被一个消费者消费；</li>
<li><strong>RocketMQ中Topic只代表普通的消息队列，而Queue是组成Topic的更小单元</strong>。</li>
</ul>
<h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p>表示消息的第一级类型，比如一个电商系统的消息可以分为：交易消息、物流消息…… 一条消息必须有一个Topic。</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>主题被划分为一个或多个子主题，称为“message queues”。一个topic下，我们可以设置多个queue(消息队列)。</p>
<p>当我们发送消息时，需要要指定该消息的topic。RocketMQ会轮询该topic下的所有队列，将消息发送出去。</p>
<p><strong>定义： Queue是Topic在一个Broker上的分片，在分片基础上再等分为若干份（可指定份数）后的其中一份，是负载均衡过程中资源分配的基本单元。</strong></p>
<p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112011721.png"></p>
<p>集群消费模式下一个消费者只消费该Topic中部分Queue中的消息，当一个消费者开启广播模式时则会消费该Topic下所有Queue中的消息。</p>
<h4 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h4><p>Tags是Topic下的次级消息类型/二级类型（注：Tags也支持TagA || TagB这样的表达式），可以在同一个Topic下基于Tags进行消息过滤。</p>
<p>Tags的过滤需要经过两次比对，首先会在Broker端通过Tag hashcode进行一次比对过滤，匹配成功传到consumer端后再对具体Tags进行比对，以防止Tag hashcode重复的情况。</p>
<p>比如交易消息又可以分为：交易创建消息，交易完成消息….. 一条消息可以没有Tag。</p>
<p>RocketMQ提供2级消息分类，方便大家灵活控制。标签，换句话说，为用户提供了额外的灵活性。有了标签，来自同一个业务模块的不同目的的消息可能具有相同的主题和不同的标签。标签将有助于保持您的代码干净和连贯，并且标签还可以为RocketMQ提供的查询系统提供帮助。</p>
<p>Queue中具体的存储单元结构如下图，最后面的8个Byte存储Tag信息。</p>
<p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112011726.png"></p>
<p>具体参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/duanxz/p/5020398.html">RocketMQ消息存储</a></p>
<h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><h4 id="Producer-amp-amp-Producer-Group"><a href="#Producer-amp-amp-Producer-Group" class="headerlink" title="Producer &amp;&amp; Producer Group"></a>Producer &amp;&amp; Producer Group</h4><p>Producer表示消息队列的生产者。消息队列的本质就是实现了pub/sub模式，生产者生产消息，消费者消费消息。</p>
<ul>
<li>所以这里的Producer就是用来生产和发送消息的，一般指业务系统。</li>
<li>RocketMQ提供了发送：普通消息（同步、异步和单向（one-way）消息）、定时消息、延时消息、事务消息。</li>
</ul>
<p>Producer Group是一类Producer的集合名称，这类Producer通常发送一类消息，且发送逻辑一致。相同角色的生产者被分组在一起。</p>
<ul>
<li>同一生产者组的另一个生产者实例可能被broker联系，以提交或回滚事务，以防原始生产者在交易后崩溃。</li>
</ul>
<p><font color="#FF0000">警告： 考虑提供的生产者在发送消息时足够强大，每个生产者组只允许一个实例，以避免对生产者实例进行不必要的初始化。</font></p>
<h4 id="Consumer-amp-amp-Consumer-Group"><a href="#Consumer-amp-amp-Consumer-Group" class="headerlink" title="Consumer &amp;&amp; Consumer Group"></a>Consumer &amp;&amp; Consumer Group</h4><p>Consumer: 消息消费者，一般由业务后台系统异步的消费消息。</p>
<ul>
<li>Push Consumer： Consumer 的一种，应用通常向 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调 Listener<br>接口方法。</li>
<li>Pull Consumer： Consumer 的一种，应用通常主动调用 Consumer 的拉消息方法从 Broker 拉消息，主动权由应用控制。</li>
</ul>
<p>Consumer Group： Consumer Group是一类Consumer的集合名称，这类Consumer通常消费一类消息，且消费逻辑一致(使用相同 Group ID<br>的订阅者属于同一个集群。同一个集群下的订阅者消费逻辑必须完全一致（包括 Tag 的使用），这些订阅者在逻辑上可以认为是一个消费节点)。</p>
<ul>
<li>消费者群体是一个伟大的概念，它实现了负载平衡和容错的目标，在信息消费方面，是非常容易的。</li>
</ul>
<p><font color="#FF0000">警告： 消费者群体的消费者实例<strong>必须</strong>订阅完全相同的主题。</font></p>
<h2 id="RocketMQ组件关系"><a href="#RocketMQ组件关系" class="headerlink" title="RocketMQ组件关系"></a>RocketMQ组件关系</h2><h3 id="Broker-amp-amp-Producer-amp-amp-Consumer"><a href="#Broker-amp-amp-Producer-amp-amp-Consumer" class="headerlink" title="Broker &amp;&amp; Producer &amp;&amp; Consumer"></a>Broker &amp;&amp; Producer &amp;&amp; Consumer</h3><p>如果不考虑负载均衡和高可用，最简单的Broker，Producer和Consumer之间的关系如下图所示：</p>
<p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112011748.png"></p>
<h3 id="Topic-amp-amp-Topic分片-amp-amp-Queue"><a href="#Topic-amp-amp-Topic分片-amp-amp-Queue" class="headerlink" title="Topic &amp;&amp; Topic分片 &amp;&amp; Queue"></a>Topic &amp;&amp; Topic分片 &amp;&amp; Queue</h3><p>从本质上来说，RocketMQ中的Queue是数据分片的产物。 为了更好地理解Queue的定义，我们还需要引入一个新的概念：Topic分片。</p>
<p>在分布式数据库和分布式缓存领域，分片概念已经有了清晰的定义。</p>
<p>同理，对于RocketMQ，一个Topic可以分布在各个Broker上，我们可以把一个Topic分布在一个Broker上的子集定义为一个Topic分片。</p>
<p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112011757.png"></p>
<p>对应上图，TopicA有3个Topic分片，分布在Broker1,Broker2和Broker3上，TopicB有2个Topic分片，分布在Broker1和Broker2上，TopicC有2个Topic分片，分布在Broker2和Broker3上。</p>
<p><strong>将Topic分片再切分为若干等分，其中的一份就是一个Queue</strong></p>
<p>每个Topic分片等分的Queue的数量可以不同，由用户在创建Topic时指定。</p>
<p>数据分片的主要目的是突破单点的资源（网络带宽，CPU，内存或文件存储）限制从而实现水平扩展。 RocketMQ<br>在进行Topic分片以后，已经达到水平扩展的目的了，为什么还需要进一步切分为Queue呢？</p>
<p>解答这个问题还需要从<strong>负载均衡</strong>说起。以消息消费为例，借用Rocket MQ官方文档中的Consumer负载均衡示意图来说明：</p>
<p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112021307.png"></p>
<p>如图所示，TOPIC_A在一个Broker上的Topic分片有5个Queue，一个Consumer<br>Group内有2个Consumer按照集群消费的方式消费消息，按照平均分配策略进行负载均衡得到的结果是：第一个 Consumer 消费3个Queue，第二个Consumer<br>消费2个Queue。如果增加Consumer，每个Consumer分配到的Queue会相应减少。</p>
<p>Rocket MQ的负载均衡策略规定：Consumer数量应该小于等于Queue数量，如果Consumer超过Queue数量，那么多余的Consumer 将不能消费消息。</p>
<p>在一个Consumer<br>Group内，Queue和Consumer之间的对应关系是一对多的关系：一个Queue最多只能分配给一个Consumer，一个Cosumer可以分配得到多个Queue。这样的分配规则，每个Queue只有一个消费者，可以避免消费过程中的多线程处理和资源锁定，有效提高各Consumer消费的并行度和处理效率。</p>
<p>由此，我们可以给出Queue的定义：</p>
<p>Queue是Topic在一个Broker上的分片等分为指定份数后的其中一份，是负载均衡过程中资源分配的基本单元。</p>
<h4 id="Queue数量指定方式"><a href="#Queue数量指定方式" class="headerlink" title="Queue数量指定方式"></a>Queue数量指定方式</h4><ul>
<li><p>代码指定</p>
<ul>
<li>producer.setDefaultTopicQueueNums(8);</li>
</ul>
</li>
<li><p>配置文件指定</p>
<ul>
<li>同时设置broker服务器的配置文件broker.properties：defaultTopicQueueNums=16</li>
</ul>
</li>
<li><p>rocket-console控制台指定</p>
<p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112011801.png"></p>
</li>
</ul>
<h2 id="RocketMQ发布订阅大体流程"><a href="#RocketMQ发布订阅大体流程" class="headerlink" title="RocketMQ发布订阅大体流程"></a>RocketMQ发布订阅大体流程</h2><ol>
<li><p>producer生产者连接nameserver，产生数据放入不同的topic；</p>
</li>
<li><p>对于RocketMQ，一个Topic可以分布在各个Broker上，我们可以把一个Topic分布在一个Broker上的子集定义为一个Topic分片；</p>
</li>
<li><p>将Topic分片再切分为若干等分，其中的一份就是一个Queue。每个Topic分片等分的Queue的数量可以不同，由用户在创建Topic时指定。</p>
</li>
<li><p>consumer消费者连接nameserver，根据broker分配的Queue来消费数据。</p>
</li>
</ol>
<p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112021312.png"></p>
<h2 id="消息分类"><a href="#消息分类" class="headerlink" title="消息分类"></a>消息分类</h2><h3 id="发送类型分类"><a href="#发送类型分类" class="headerlink" title="发送类型分类"></a>发送类型分类</h3><h4 id="同步消息"><a href="#同步消息" class="headerlink" title="同步消息"></a>同步消息</h4><p>指消息发送方发出数据后，<strong>会阻塞直到MQ服务方发回响应消息</strong>。</p>
<p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112021324.png"></p>
<p>应用场景：此种方式应用场景非常广泛，例如重要通知邮件、报名短信通知、营销短信系统等。</p>
<p>关键代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SendResult sendResult = producer.send(msg);</span><br></pre></td></tr></table></figure>

<h4 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h4><p>发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</p>
<p><strong>MQ<br>的异步发送，需要用户实现异步发送回调接口（SendCallback），在执行消息的异步发送时，应用不需要等待服务器响应即可直接返回，通过回调接口接收服务器响应，并对服务器的响应结果进行处理。</strong></p>
<img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112021327.png" class>

<p>应用场景：异步发送一般用于链路耗时较长，对 RT 响应时间较为敏感的业务场景，例如用户视频上传后通知启动转码服务，转码完成后通知推送转码结果等。</p>
<p>关键代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.sendAsync(msg, new SendCallback() &#123;//...&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="单向消息"><a href="#单向消息" class="headerlink" title="单向消息"></a>单向消息</h4><p>只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求不等待应答。</p>
<p><strong>此方式发送消息的过程耗时非常短，一般在微秒级别。但是可能存在数据丢失</strong></p>
<p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112021330.png"></p>
<p>应用场景：适用于某些耗时非常短，但对可靠性要求并不高的场景，例如日志收集。</p>
<p>关键代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.sendOneway(msg);</span><br></pre></td></tr></table></figure>

<h3 id="按照功能使用划分"><a href="#按照功能使用划分" class="headerlink" title="按照功能使用划分"></a>按照功能使用划分</h3><h4 id="普通消息-amp-amp-顺序消息"><a href="#普通消息-amp-amp-顺序消息" class="headerlink" title="普通消息 &amp;&amp; 顺序消息"></a>普通消息 &amp;&amp; 顺序消息</h4><h4 id="广播消息"><a href="#广播消息" class="headerlink" title="广播消息"></a>广播消息</h4><h4 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h4><h5 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h5><p>定时消息，单位毫秒（ms），在指定时间戳（当前时间之后）进行投递</p>
<p>核心代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 例如 2016-03-07 16:21:00 投递。</span><br><span class="line">// 如果被设置成当前时间戳之前的某个时刻，消息将立刻投递给消费者。    </span><br><span class="line">long timeStamp = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).parse(&quot;2016-03-07 16:21:00&quot;).getTime();    </span><br><span class="line">msg.setStartDeliverTime(timeStamp);​    </span><br><span class="line">// 发送消息，只要不抛异常就是成功    </span><br><span class="line">SendResult sendResult = producer.send(msg);   </span><br></pre></td></tr></table></figure>

<h5 id="延时消息-1"><a href="#延时消息-1" class="headerlink" title="延时消息"></a>延时消息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Message sendMsg = new Message(topic, tags, message.getBytes());</span><br><span class="line">sendMsg.setDelayTimeLevel(delayLevel);</span><br><span class="line">// 默认3秒超时</span><br><span class="line">SendResult sendResult = rocketMQProducer.send(sendMsg);</span><br></pre></td></tr></table></figure>

<h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>RocketMQ提供类似X/Open XA的分布式事务功能来确保业务发送方和MQ消息的最终一致性。</p>
<p><strong>其本质是通过半消息(prepare消息和commit消息)的方式把分布式事务放在MQ端来处理</strong>。</p>
<p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112031329.png"></p>
<p>其中：</p>
<ol>
<li>发送方向消息队列 RocketMQ 服务端发送消息。</li>
<li>服务端将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向服务端提交二次确认（Commit 或是 Rollback），服务端收到 Commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；服务端收到 Rollback<br>状态则删除半消息，订阅方将不会接受该消息。</li>
</ol>
<p>补偿流程：</p>
<ol start="5">
<li>在断网或者是应用重启的特殊情况下，上述步骤 4 提交的二次确认最终未到达服务端，经过固定时间后服务端将对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤 4 对半消息进行操作。</li>
</ol>
<p><strong><font color="#FF0000">RocketMQ的半消息机制的注意事项是</font></strong></p>
<ol>
<li>根据第六步可以看出他要求发送方提供业务回查接口。</li>
<li>不能保证发送方的消息幂等，在ack没有返回的情况下，可能存在重复消息</li>
<li>消费方要做幂等处理。</li>
</ol>
<h2 id="发布订阅模型"><a href="#发布订阅模型" class="headerlink" title="发布订阅模型"></a>发布订阅模型</h2><p>在RocketMQ中，producer发布消息，consumer订阅消息。消息的收发模型如下图：</p>
<p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112031342.png"></p>
<h3 id="producer端消息发布原理"><a href="#producer端消息发布原理" class="headerlink" title="producer端消息发布原理"></a>producer端消息发布原理</h3><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112031345.png"></p>
<p>producer完全无状态，可以集群部署。</p>
<h3 id="consumer端消息获取模式（push-pull）"><a href="#consumer端消息获取模式（push-pull）" class="headerlink" title="consumer端消息获取模式（push/pull）"></a>consumer端消息获取模式（push/pull）</h3><p>consumer有两种消息的获取模式</p>
<ul>
<li>Push模式，即MQServer主动向消费端推送；</li>
<li>Pull模式，即消费端在需要时，主动到MQServer拉取。</li>
</ul>
<p>实际实现中： <strong>Push和Pull模式都是采用消费端主动拉取的方式</strong>。</p>
<p>消费端的Push模式是通过长轮询的模式来实现的：</p>
<ul>
<li>Consumer端每隔一段时间主动向broker发送拉消息请求，broker在收到Pull请求后<ul>
<li>如果有消息就立即返回数据，Consumer端收到返回的消息后，再回调消费者设置的Listener方法。</li>
<li>消息队列里没有数据，broker端会阻塞请求直到有数据传递或超时才返回。</li>
</ul>
</li>
<li>当然，Consumer端是通过一个线程将阻塞队列LinkedBlockingQueue<PullRequest>中的PullRequest发送到broker拉取消息，以防止Consumer一致被阻塞。</PullRequest></li>
<li>而Broker端，在接收到Consumer的PullRequest时，如果发现没有消息，就会把PullRequest扔到ConcurrentHashMap中缓存起来。</li>
<li>broker在启动时，会启动一个线程不停的从ConcurrentHashMap取出PullRequest检查，直到有数据返回。</li>
</ul>
<h3 id="consumer端消息消费模式-集群-广播"><a href="#consumer端消息消费模式-集群-广播" class="headerlink" title="consumer端消息消费模式(集群/广播)"></a>consumer端消息消费模式(集群/广播)</h3><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>消息队列 RocketMQ 是基于发布/订阅模型的消息系统。消息的订阅方订阅关注的 Topic，以获取并消费消息。</p>
<p>由于订阅方应用一般是分布式系统，以集群方式部署有多台机器。</p>
<h4 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h4><p>使用相同 Group ID 的订阅者属于同一个集群。同一个集群下的订阅者消费逻辑必须完全一致（包括 Tag 的使用），这些订阅者在逻辑上可以认为是一个消费节点。</p>
<p>当使用集群消费模式时，消息队列 RocketMQ 认为任意一条消息只需要被集群内的任意一个消费者处理即可。</p>
<p>一个Consumer Group中的Consumer实例平均分摊消费消息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如某个Topic有 9 条消息，其中一个Consumer Group有 3 个实例(可能是 3 个进程,或者 3 台机器)，那么每个实例只消费其中的 3 条消息。</span><br></pre></td></tr></table></figure>

<h5 id="使用场景-amp-amp-注意事项"><a href="#使用场景-amp-amp-注意事项" class="headerlink" title="使用场景 &amp;&amp; 注意事项"></a>使用场景 &amp;&amp; 注意事项</h5><ul>
<li>消费端集群化部署，每条消息只需要被处理一次。</li>
<li>由于消费进度在服务端维护，可靠性更高。</li>
<li>集群消费模式下，<strong>每一条消息都只会被分发到一台机器上处理</strong>。如果需要被集群下的每一台机器都处理，请使用广播模式。</li>
<li>集群消费模式下，<strong>不保证每一次失败重投的消息路由到同一台机器上</strong>，因此处理消息时不应该做任何确定性假设。</li>
</ul>
<h4 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h4><p>当使用广播消费模式时，消息队列 RocketMQ 会将每条消息推送给集群内所有注册过的客户端，保证消息至少被每台机器消费一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一条消息被多个Consumer消费，即使这些Consumer属于同一个Consumer Group，消息也会被Consumer Group中的每个Consumer都消费一次。</span><br></pre></td></tr></table></figure>

<p><strong>在广播消费中的Consumer Group概念可以认为在消息划分方面无意义</strong>。</p>
<h5 id="使用场景-amp-amp-注意事项-1"><a href="#使用场景-amp-amp-注意事项-1" class="headerlink" title="使用场景 &amp;&amp; 注意事项"></a>使用场景 &amp;&amp; 注意事项</h5><ul>
<li>广播消费模式下<strong>不支持顺序消息</strong>。</li>
<li>广播消费模式下<strong>不支持重置消费位点</strong>。</li>
<li>每条消息都需要被相同逻辑的多台机器处理。</li>
<li>消费进度在客户端维护，出现重复的概率稍大于集群模式。</li>
<li>广播模式下，消息队列 RocketMQ 保证每条消息至少被每台客户端消费一次，但是并<strong>不会对消费失败的消息进行失败重投</strong>，因此业务方需要关注消费失败的情况。</li>
<li>广播模式下，客户端每一次重启都会从最新消息消费。<strong>客户端在被停止期间发送至服务端的消息将会被自动跳过</strong>，请谨慎选择。</li>
<li>广播模式下，每条消息都会被大量的客户端重复处理，因此推荐尽可能使用集群模式。</li>
<li>目前仅 Java 客户端支持广播模式。</li>
<li>广播模式下服务端不维护消费进度，所以消息队列 RocketMQ 控制台<strong>不支持消息堆积查询、消息堆积报警和订阅关系查询功能</strong>。</li>
</ul>
<h4 id="使用集群模式模拟广播"><a href="#使用集群模式模拟广播" class="headerlink" title="使用集群模式模拟广播"></a>使用集群模式模拟广播</h4><p>如果业务需要使用广播模式，也可以创建多个 Group ID，用于订阅同一个 Topic。</p>
<h5 id="适用场景-amp-amp-注意事项"><a href="#适用场景-amp-amp-注意事项" class="headerlink" title="适用场景 &amp;&amp; 注意事项"></a>适用场景 &amp;&amp; 注意事项</h5><ul>
<li>每条消息都需要被多台机器处理，每台机器的逻辑可以相同也可以不一样。</li>
<li>消费进度在服务端维护，可靠性高于广播模式。</li>
<li>对于一个 Group ID 来说，可以部署一个消费端实例，也可以部署多个消费端实例。 <ul>
<li>当部署多个消费端实例时，实例之间又组成了集群模式（共同分担消费消息）。</li>
<li>假设 Group ID 1 部署了三个消费者实例 C1、C2、C3，那么这三个实例将共同分担服务器发送给 Group ID 1 的消息。 </li>
<li>实例之间订阅关系必须保持一致。</li>
</ul>
</li>
</ul>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="生产端负载均衡"><a href="#生产端负载均衡" class="headerlink" title="生产端负载均衡"></a>生产端负载均衡</h3><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112031427.png"></p>
<p>首先分析一下RocketMQ的客户端发送消息的源码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer defaultMQProducer = new DefaultMQProducer(&quot;ProducerGroupName&quot;);</span><br><span class="line">// 初始化Producer， 整个生命周期只需要一次</span><br><span class="line">producer.start();</span><br><span class="line">// 构造Message</span><br><span class="line">Message msg = new Message(&quot;Topic&quot;, &quot;TagA&quot;, &quot;key&quot;, &quot;aaaaaaaa&quot;.getBytes());</span><br><span class="line">// 发送消息并返回结果</span><br><span class="line">SendResult sendResult = producer.send(msg);</span><br><span class="line">// 清理资源、关闭网络、注销自己</span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure>

<p>在整个应用生命周期内，生产者需要调用一次start方法来初始化，初始化主要完成的任务有：</p>
<ul>
<li>如果没有指定namesrv地址，将会自动寻址</li>
<li>启动定时任务<ul>
<li>更新namesrv地址</li>
<li>从namsrv更新topic路由信息</li>
<li>清理已经挂掉的broker</li>
<li>向所有broker发送心跳…</li>
</ul>
</li>
<li>启动负载均衡的服务</li>
</ul>
<p>初始化完成后，开始发送消息，发送消息的主要代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">privete SendResult sendDefaultImpl(Message msg, .....) &#123;</span><br><span class="line">  // 检查Producer状态是否Running</span><br><span class="line">  this.makesureStateOK();</span><br><span class="line">  // 检查msg是否合法，是否为null, topic、body是否为空，body是否超长</span><br><span class="line">  Validators.checkMessage(msg, this.defaultMQProducer);</span><br><span class="line">  // 获取路由信息</span><br><span class="line">  TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">  // 从路由中悬着一个消息队列</span><br><span class="line">  MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, info);</span><br><span class="line">  // </span><br><span class="line">  sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中需要关注的两个方法tryToFindTopicPublishInfo和selectOneMessageQueue。</p>
<ul>
<li>前面说过在producer初始化时，会启动定时任务获取路由信息并更新到本地缓存，所以tryToFindTopicPublishInfo会首先从缓存中获取topic路由信息，如果没有获取到，则会自己去namesrv获取路由信息。</li>
<li>selectOneMessageQueue方法通过轮询的方式，返回一个队列，以达到负载均衡的目的。</li>
</ul>
<p>如果Producer发送消息失败，会自动重试，重试的策略：</p>
<ul>
<li>重试次数 &lt; retryTimesWhenSendFailed（可配置）</li>
<li>总的耗时（包含重试n次的耗时） &lt; sendMsgTimeout（发送消息时传入的参数）</li>
<li>同时满足上面两个条件后，Producer会选择另外一个队列发送消息</li>
</ul>
<h3 id="消费端负载均衡"><a href="#消费端负载均衡" class="headerlink" title="消费端负载均衡"></a>消费端负载均衡</h3><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112031500.png"></p>
<p>producer向一些队列轮流发送消息，队列集合称为Topic：</p>
<ul>
<li>Consumer如果做广播消费，则一个consumer实例消费这个Topic对应的所有队列；</li>
<li>如果做集群消费，则多个Consumer实例平均消费这个Topic对应的队列集合</li>
</ul>
<p>集群模式里，每个consumer消费部分消息，这里的负载均衡是怎样的呢:</p>
<p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112031503.png"></p>
<p>消费端会通过RebalanceService线程，20秒钟做一次基于topic下的所有队列负载：</p>
<ul>
<li>遍历Consumer下的所有topic，然后根据topic订阅所有的消息</li>
<li>获取同一topic和Consumer Group下的所有Consumer</li>
<li>然后根据具体的分配策略来分配消费队列，分配的策略包含：平均分配、消费端配置等</li>
</ul>
<p>如同上图所示：如果有 3 个队列，2 个 consumer，那么第一个 Consumer 消费 2 个队列，第二 consumer 消费 1 个队列。这里采用的就是平均分配策略，它类似于我们的分页，TOPIC下面的所有queue就是记录，Consumer的个数就相当于总的页数，那么每页有多少条记录，就类似于某个Consumer会消费哪些队列。</p>
<p>通过这样的策略来达到大体上的平均消费，这样的设计也可以很方面的水平扩展Consumer来提高消费能力。</p>
<h2 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h2><ul>
<li>单Master模式：无需多言，一旦单个broker重启或宕机，一切都结束了！。</li>
<li>多Master模式：全是Master，没有Slave。<ul>
<li>当然，一个broker宕机了，应用是无影响的</li>
<li>缺点在于宕机的Master上未被消费的消息在Master没有恢复之前不可以订阅。</li>
</ul>
</li>
<li>多Master多Slave模式（异步复制）：多对Master-Slave，高可用！<ul>
<li>采用异步复制的方式，主备之间短暂延迟，MS级别。</li>
<li>Master宕机，消费者可以从Slave上进行消费，不受影响。</li>
<li>但是Master的宕机，会导致丢失掉极少量的消息。</li>
</ul>
</li>
<li>多Master多Slave模式（同步双写）：在Master/Slave都写成功的前提下，向应用返回成功<ul>
<li>不论是数据，还是服务都没有单点，都非常可靠！</li>
<li>缺点在于同步的性能比异步稍低。</li>
</ul>
</li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">消息中间件</a><a class="post-meta__tags" href="/tags/MQ/">MQ</a><a class="post-meta__tags" href="/tags/RocketMQ/">RocketMQ</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/12/08/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF/%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B9%8BDebezium%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"><i class="fa fa-chevron-left">  </i><span>增量数据同步之Debezium技术研究</span></a></div><div class="next-post pull-right"><a href="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/MQ%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%9B%9B%E5%A4%A7%E5%B8%B8%E7%94%A8MQ%E5%AF%B9%E6%AF%94/"><span>MQ详解及四大常用MQ对比</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '83850031ee87c27765eb',
  clientSecret: '6c5e13a8b6670d5bfa85ba548ba3570cae29e671',
  repo: 'blob-comment',
  owner: 'hepeng0',
  admin: 'hepeng0',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By 何鹏 [smile.hepeng@qq.com]</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>