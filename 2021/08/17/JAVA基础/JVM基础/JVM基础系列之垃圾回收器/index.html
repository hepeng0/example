<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JVM基础系列之垃圾回收器"><meta name="keywords" content="JVM"><meta name="author" content="何鹏 [smile.hepeng@qq.com]"><meta name="copyright" content="何鹏 [smile.hepeng@qq.com]"><title>JVM基础系列之垃圾回收器 | 沉默者</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://unpkg.zhimg.com/font-awesome@4.7.0/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><link rel="alternate" href="/atom.xml" title="沉默者" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.</span> <span class="toc-text">JVM内存的分配与垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">标记清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">标记整理算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">常见垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%B4%A8%E6%A3%80%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">3.1.</span> <span class="toc-text">各种垃圾收集器质检的关系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">Serial收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">3.2.1.</span> <span class="toc-text">Serial收集器运行示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.2.2.</span> <span class="toc-text">Serial收集器介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.3.</span> <span class="toc-text">Serial收集器适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">ParNew收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">3.3.1.</span> <span class="toc-text">ParNew收集器运行示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.3.2.</span> <span class="toc-text">ParNew收集器介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.3.</span> <span class="toc-text">ParNew收集器适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">Parallel Scavenge收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">3.4.1.</span> <span class="toc-text">Parallel Scavenge收集器运行示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.4.2.</span> <span class="toc-text">Parallel Scavenge收集器介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.4.3.</span> <span class="toc-text">Parallel Scavenge收集器适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.5.</span> <span class="toc-text">Serial Old收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE%EF%BC%88%E5%90%8CSerial%E7%A4%BA%E6%84%8F%E5%9B%BE%EF%BC%89"><span class="toc-number">3.5.1.</span> <span class="toc-text">Serial Old收集器运行示意图（同Serial示意图）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.5.2.</span> <span class="toc-text">Serial Old收集器介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.5.3.</span> <span class="toc-text">Serial Old收集器适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.6.</span> <span class="toc-text">Parallel Old收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE%EF%BC%88%E5%90%8CParallel-Scavenge%EF%BC%89"><span class="toc-number">3.6.1.</span> <span class="toc-text">Parallel Old收集器运行示意图（同Parallel Scavenge）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.6.2.</span> <span class="toc-text">Parallel Old收集器介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.6.3.</span> <span class="toc-text">Parallel Old收集器适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.7.</span> <span class="toc-text">CMS收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">3.7.1.</span> <span class="toc-text">CMS收集器运行示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.7.2.</span> <span class="toc-text">CMS收集器介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">3.7.3.</span> <span class="toc-text">CMS收集器的缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Garbage-First%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.8.</span> <span class="toc-text">Garbage First收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E5%8C%BA%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">3.8.1.</span> <span class="toc-text">G1收集器分区示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">3.8.2.</span> <span class="toc-text">G1运行示意图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.8.3.</span> <span class="toc-text">G1收集器介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E7%BC%BA%E7%82%B9"><span class="toc-number">3.8.4.</span> <span class="toc-text">G1收集器缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.8.5.</span> <span class="toc-text">G1收集器适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-gc"><span class="toc-number">4.</span> <span class="toc-text">System.gc()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81System-gc"><span class="toc-number">4.1.</span> <span class="toc-text">为什么需要System.gc()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B9%B6%E7%AE%A1%E7%90%86%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E7%9A%84%E6%A1%86%E6%9E%B6%EF%BC%8C%E9%9C%80%E8%A6%81FullGC%E7%9A%84%E6%9C%BA%E5%88%B6%E8%A7%A6%E5%8F%91%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-number">4.1.1.</span> <span class="toc-text">使用并管理堆外内存的框架，需要FullGC的机制触发堆外内存回收</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%86-WeakReference%EF%BC%8C-SoftReference-%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E9%9C%80%E8%A6%81%E7%9B%B8%E5%BA%94%E7%9A%84-GC-%E5%9B%9E%E6%94%B6%E3%80%82"><span class="toc-number">4.1.2.</span> <span class="toc-text">使用了 WeakReference， SoftReference 的程序，需要相应的 GC 回收。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E3%80%81%E5%AD%A6%E4%B9%A0-JVM-%E6%9C%BA%E5%88%B6%E7%9A%84%E6%97%B6%E5%80%99"><span class="toc-number">4.1.3.</span> <span class="toc-text">测试、学习 JVM 机制的时候</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System-gc-%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">4.2.</span> <span class="toc-text">System.gc()做了什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">5.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-number">5.1.</span> <span class="toc-text">堆外内存回收</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img2.baidu.com/it/u=928705063,3876627980&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg"></div><div class="author-info__name text-center">何鹏 [smile.hepeng@qq.com]</div><div class="author-info__description text-center">路漫漫其修远兮，吾将上下而求索</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">67</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">52</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默者</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">JVM基础系列之垃圾回收器</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-08-17</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 18 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="JVM内存的分配与垃圾回收"><a href="#JVM内存的分配与垃圾回收" class="headerlink" title="JVM内存的分配与垃圾回收"></a>JVM内存的分配与垃圾回收</h2><p>在研究垃圾回收器钱，首先我们还是简单看下JVM的内存规则：</p>
<ul>
<li>新生代：一般来说新创建的对象都分配在这里。</li>
<li>年老代：经过几次垃圾回收，新生代的对象就会放在年老代里面。年老代中的对象保存的时间更久。</li>
<li>永久代：这里面存放的是class相关的信息，一般是不会进行垃圾回收的。</li>
</ul>
<p>JVM垃圾回收</p>
<p>由于JVM会替我们执行垃圾回收，因此开发者根本不需要关心对象的释放。但是如果不了解其中的原委，很容易内存泄漏，只能两眼望天了！</p>
<p>垃圾回收，大致可以分为下面几种：</p>
<ul>
<li>Minor GC:当新创建对象，内存空间不够的时候，就会执行这个垃圾回收。由于执行最频繁，因此一般采用复制回收机制。</li>
<li>Major GC:清理年老代的内存，这里一般采用的是标记清除+标记整理机制。</li>
<li>Full GC:有的说与Major GC差不多，有的说相当于执行minor+major回收，那么我们暂且可以认为Full GC就是全面的垃圾回收吧。</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将存活对象复制到一块区域中</p>
<p>优缺点：存活对象少场景下，复制效率高；但是会浪费一块内存空间用于存放存活对象</p>
<h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>将存活对象标记，然后删除未存活对象</p>
<p>优缺点：存在内存碎片</p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>将回收对象标记，存活对象整理到一边，最后清除另一边区域</p>
<p>优缺点：内存空间连续，gc时间长</p>
<h2 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器"></a>常见垃圾收集器</h2><h3 id="各种垃圾收集器质检的关系图"><a href="#各种垃圾收集器质检的关系图" class="headerlink" title="各种垃圾收集器质检的关系图"></a>各种垃圾收集器质检的关系图</h3><p><img src="/2021/08/17/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/img.png"></p>
<p>1、图片展示了各种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用（这个关系不是一成不变的，由于维护和兼容性测试的成本，在JDK 8时将 Serial + CMS、ParNew + Serial Old这两个组合声明为废弃，并在JDK 9中完全取消了这些组合的支持），图中收集器所处的区域，则表示它是属于新生代收集器或是老年代收集器。</p>
<p>2、在介绍这些收集器各自的特性之前，需要明确一个观点：虽然会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来，虽然垃圾收集器的技术在不断进步，但直到现在还没有最好的收集器出现，更加<strong>不存在“万能”的收集器</strong>，所以我们选择的只是对具体应用最合适的收集器。</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><h4 id="Serial收集器运行示意图"><a href="#Serial收集器运行示意图" class="headerlink" title="Serial收集器运行示意图"></a>Serial收集器运行示意图</h4><p><img src="/2021/08/17/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/img_1.png"></p>
<h4 id="Serial收集器介绍"><a href="#Serial收集器介绍" class="headerlink" title="Serial收集器介绍"></a>Serial收集器介绍</h4><ul>
<li>Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择。</li>
<li>大家只看名字就能够猜到，这个收集器是一个单线程工作的收集器，它在进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</li>
<li>“Stop The World”这个词语也许听起来很酷，但这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可知、不可控的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是不能接受的</li>
</ul>
<h4 id="Serial收集器适用场景"><a href="#Serial收集器适用场景" class="headerlink" title="Serial收集器适用场景"></a>Serial收集器适用场景</h4><ul>
<li>简单而高效（与其他收集器的单线程相比）<ul>
<li>对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的；</li>
<li>对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有线程交互的开销，收集效率高。</li>
</ul>
</li>
<li>在用户桌面的应用场景中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的内存），垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。</li>
<li>所以，Serial收集器对于<strong>运行在客户端模式下的虚拟机</strong>来说是一个很好的选择</li>
</ul>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><h4 id="ParNew收集器运行示意图"><a href="#ParNew收集器运行示意图" class="headerlink" title="ParNew收集器运行示意图"></a>ParNew收集器运行示意图</h4><p><img src="/2021/08/17/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/img_2.png"></p>
<h4 id="ParNew收集器介绍"><a href="#ParNew收集器介绍" class="headerlink" title="ParNew收集器介绍"></a>ParNew收集器介绍</h4><p>ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX：PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、STW、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</p>
<h4 id="ParNew收集器适用场景"><a href="#ParNew收集器适用场景" class="headerlink" title="ParNew收集器适用场景"></a>ParNew收集器适用场景</h4><p>ParNew收集器除了支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是不少运行在服务端模式下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集器。</p>
<p><strong>其中有一个与功能、性能无关但其实很重要的原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作。</strong></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><h4 id="Parallel-Scavenge收集器运行示意图"><a href="#Parallel-Scavenge收集器运行示意图" class="headerlink" title="Parallel Scavenge收集器运行示意图"></a>Parallel Scavenge收集器运行示意图</h4><p><img src="/2021/08/17/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/img_3.png"></p>
<h4 id="Parallel-Scavenge收集器介绍"><a href="#Parallel-Scavenge收集器介绍" class="headerlink" title="Parallel Scavenge收集器介绍"></a>Parallel Scavenge收集器介绍</h4><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器……Parallel Scavenge的诸多特性从表面上看和ParNew非常相似，那它有什么特别之处呢？</p>
<p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同：</p>
<ul>
<li>CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间</li>
<li>而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（<strong>处理器用于运行用户代码的时间与处理器总消耗时间的比值</strong>）。</li>
</ul>
<h4 id="Parallel-Scavenge收集器适用场景"><a href="#Parallel-Scavenge收集器适用场景" class="headerlink" title="Parallel Scavenge收集器适用场景"></a>Parallel Scavenge收集器适用场景</h4><p>如果对于收集器运作不太了解，手工优化存在困难的话，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成也许是一个很不错的选择。</p>
<p>只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用-XX：MaxGCPauseMillis参数（更关注最大停顿时间）或-XX：GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。</p>
<p><strong>自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。</strong></p>
<p>其实ParNew的Par就是Parallel的简写，ParNew就是Parallel Scavenge的增强版，为了配合CMS ParNew做了一些增强。</p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><h4 id="Serial-Old收集器运行示意图（同Serial示意图）"><a href="#Serial-Old收集器运行示意图（同Serial示意图）" class="headerlink" title="Serial Old收集器运行示意图（同Serial示意图）"></a>Serial Old收集器运行示意图（同Serial示意图）</h4><p><img src="/2021/08/17/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/img_4.png"></p>
<h4 id="Serial-Old收集器介绍"><a href="#Serial-Old收集器介绍" class="headerlink" title="Serial Old收集器介绍"></a>Serial Old收集器介绍</h4><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p>
<h4 id="Serial-Old收集器适用场景"><a href="#Serial-Old收集器适用场景" class="headerlink" title="Serial Old收集器适用场景"></a>Serial Old收集器适用场景</h4><p>Serial Old收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。</p>
<p>如果在服务端模式下，它也可能有两种用途：</p>
<ul>
<li>在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用，</li>
<li>作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用。</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><h4 id="Parallel-Old收集器运行示意图（同Parallel-Scavenge）"><a href="#Parallel-Old收集器运行示意图（同Parallel-Scavenge）" class="headerlink" title="Parallel Old收集器运行示意图（同Parallel Scavenge）"></a>Parallel Old收集器运行示意图（同Parallel Scavenge）</h4><p><img src="/2021/08/17/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/img_5.png"></p>
<h4 id="Parallel-Old收集器介绍"><a href="#Parallel-Old收集器介绍" class="headerlink" title="Parallel Old收集器介绍"></a>Parallel Old收集器介绍</h4><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p>
<p>这个收集器是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于相当尴尬的状态，原因是如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old收集器以外别无选择，其他表现良好的老年代收集器，如CMS无法与它配合工作。</p>
<p>由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用Parallel Scavenge收集器也未必能在整体上获得吞吐量最大化的效果。同样，由于单线程的老年代收集中无法充分利用服务器多处理器的并行处理能力，在老年代内存空间很大而且硬件规格比较高级的运行环境中，这种组合的总吞吐量甚至不一定比ParNew加CMS的组合来得优秀。</p>
<h4 id="Parallel-Old收集器适用场景"><a href="#Parallel-Old收集器适用场景" class="headerlink" title="Parallel Old收集器适用场景"></a>Parallel Old收集器适用场景</h4><p>在Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在<strong>注重吞吐量或者处理器资源较为稀缺的场合</strong>，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><h4 id="CMS收集器运行示意图"><a href="#CMS收集器运行示意图" class="headerlink" title="CMS收集器运行示意图"></a>CMS收集器运行示意图</h4><p><img src="/2021/08/17/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/img_6.png"></p>
<h4 id="CMS收集器介绍"><a href="#CMS收集器介绍" class="headerlink" title="CMS收集器介绍"></a>CMS收集器介绍</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间为目标</strong>的收集器。</p>
<p>目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统STW尽可能短，以给用户带来良好的交互体验。CMS收集器就非常符合这类应用的需求。</p>
<p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于<strong>标记-清除算法</strong>实现的，它的运作过程相对于前面几种收集器来说要更复杂一些。</p>
<p>整个过程分为四个步骤，包括：</p>
<ol>
<li>初始标记（CMS initial mark）</li>
</ol>
<p>有STW；初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快。</p>
<ol start="2">
<li>并发标记（CMS concurrent mark）</li>
</ol>
<p>并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与GC线程一起并发运行。</p>
<ol start="3">
<li>重新标记（CMS remark）</li>
</ol>
<p>有STW；重新标记阶段是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录；采用三色标记算法和增量更新避免漏标。</p>
<ol start="4">
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<p>清理删除掉标记阶段判断的已经死亡的 对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发执行的。</p>
<h4 id="CMS收集器的缺点"><a href="#CMS收集器的缺点" class="headerlink" title="CMS收集器的缺点"></a>CMS收集器的缺点</h4><ol>
<li>CMS收集器对处理器资源非常敏感。</li>
<li>由于CMS收集器无法处理“浮动垃圾”（Floating Garbage），有可能出现“Con-current Mode Failure”失败进而导致另一次完全STW的Full GC的产生，即让Serial Old来进行收集。浮动垃圾就是并发标记、并发清理时产生的垃圾。</li>
<li>大量空间碎片的产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。</li>
</ol>
<h3 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h3><h4 id="G1收集器分区示意图"><a href="#G1收集器分区示意图" class="headerlink" title="G1收集器分区示意图"></a>G1收集器分区示意图</h4><p><img src="/2021/08/17/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/img_7.png"></p>
<ul>
<li>E：Eden区</li>
<li>S：Survivor区</li>
<li>H：Humongous区（存放大对象）</li>
</ul>
<h4 id="G1运行示意图"><a href="#G1运行示意图" class="headerlink" title="G1运行示意图"></a>G1运行示意图</h4><p><img src="/2021/08/17/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/img_8.png"></p>
<h4 id="G1收集器介绍"><a href="#G1收集器介绍" class="headerlink" title="G1收集器介绍"></a>G1收集器介绍</h4><p>在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。而G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p>
<p>G1开创的<strong>基于Region的堆内存布局</strong>是它能够实现垃圾优先回收目标的关键。虽然G1也仍是<strong>遵循分代收集理论设计</strong>的，但其堆内存的布局与G1之前的收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p>
<p>虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。</p>
<p>更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。</p>
<h4 id="G1收集器缺点"><a href="#G1收集器缺点" class="headerlink" title="G1收集器缺点"></a>G1收集器缺点</h4><p>G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS高</p>
<h4 id="G1收集器适用场景"><a href="#G1收集器适用场景" class="headerlink" title="G1收集器适用场景"></a>G1收集器适用场景</h4><p>目前在小内存应用上CMS的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间，当然，这也不是绝对的，不同应用需要量体裁衣地实际测试才能得出最合适的结论，随着HotSpot的开发者对G1的不断优化，也会让对比结果继续向G1倾斜。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说，HotSpot的垃圾收集器是伴随着内存发展而不断前进的：</p>
<ul>
<li>早期几十M的内存，Serial+Serial Old单线程进行回收就足以；</li>
<li>但是内存达到几百M时，就得使用PS+PO多线程的GC线程来回收；</li>
<li>当内存达到几个G时， 多线程也忙不过来，就得使用并发的CMS+ParNew收集器；</li>
<li>当到了动辄几十个G内存的时候，以前那种每次GC都进行新生代或老年代或整个堆的回收的STW也无法忍受时，就得使用G1了。</li>
</ul>
<p>目前绝大数的生产环境都是使用的JDK8，若没有进行过调优，默认使用的是PS+PO的收集器； 但是要进行调优时，会在CMS和G1中来进行选择，如果内存比较大（10G以上），最好使用G1，内存较小（几个G）可以考虑CMS。</p>
<p>如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，HotSpot虚拟机完全没必要实现那么多种不同的收集器了。也就是只有最合适的收集器，没有最好的收集器。</p>
<h2 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h2><h3 id="为什么需要System-gc"><a href="#为什么需要System-gc" class="headerlink" title="为什么需要System.gc()"></a>为什么需要System.gc()</h3><h4 id="使用并管理堆外内存的框架，需要FullGC的机制触发堆外内存回收"><a href="#使用并管理堆外内存的框架，需要FullGC的机制触发堆外内存回收" class="headerlink" title="使用并管理堆外内存的框架，需要FullGC的机制触发堆外内存回收"></a>使用并管理堆外内存的框架，需要FullGC的机制触发堆外内存回收</h4><details><summary>JVM 的内存，不止堆内存，还有其他很多块，通过 Native Memory Tracking 可以看到</summary>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">Native Memory Tracking:</span><br><span class="line"> </span><br><span class="line">Total: reserved=6308603KB, committed=4822083KB</span><br><span class="line">-                 Java Heap (reserved=4194304KB, committed=4194304KB)</span><br><span class="line">                            (mmap: reserved=4194304KB, committed=4194304KB) </span><br><span class="line"> </span><br><span class="line">-                     Class (reserved=1161041KB, committed=126673KB)</span><br><span class="line">                            (classes #21662)</span><br><span class="line">                            (  instance classes #20542, array classes #1120)</span><br><span class="line">                            (malloc=3921KB #64030) </span><br><span class="line">                            (mmap: reserved=1157120KB, committed=122752KB) </span><br><span class="line">                            (  Metadata:   )</span><br><span class="line">                            (    reserved=108544KB, committed=107520KB)</span><br><span class="line">                            (    used=105411KB)</span><br><span class="line">                            (    free=2109KB)</span><br><span class="line">                            (    waste=0KB =0.00%)</span><br><span class="line">                            (  Class space:)</span><br><span class="line">                            (    reserved=1048576KB, committed=15232KB)</span><br><span class="line">                            (    used=13918KB)</span><br><span class="line">                            (    free=1314KB)</span><br><span class="line">                            (    waste=0KB =0.00%)</span><br><span class="line"> </span><br><span class="line">-                    Thread (reserved=355251KB, committed=86023KB)</span><br><span class="line">                            (thread #673)</span><br><span class="line">                            (stack: reserved=353372KB, committed=84144KB)</span><br><span class="line">                            (malloc=1090KB #4039) </span><br><span class="line">                            (arena=789KB #1344)</span><br><span class="line"> </span><br><span class="line">-                      Code (reserved=252395KB, committed=69471KB)</span><br><span class="line">                            (malloc=4707KB #17917) </span><br><span class="line">                            (mmap: reserved=247688KB, committed=64764KB) </span><br><span class="line"> </span><br><span class="line">-                        GC (reserved=199635KB, committed=199635KB)</span><br><span class="line">                            (malloc=11079KB #29639) </span><br><span class="line">                            (mmap: reserved=188556KB, committed=188556KB) </span><br><span class="line"> </span><br><span class="line">-                  Compiler (reserved=2605KB, committed=2605KB)</span><br><span class="line">                            (malloc=2474KB #2357) </span><br><span class="line">                            (arena=131KB #5)</span><br><span class="line"> </span><br><span class="line">-                  Internal (reserved=3643KB, committed=3643KB)</span><br><span class="line">                            (malloc=3611KB #8683) </span><br><span class="line">                            (mmap: reserved=32KB, committed=32KB) </span><br><span class="line"> </span><br><span class="line">-                     Other (reserved=67891KB, committed=67891KB)</span><br><span class="line">                            (malloc=67891KB #2859) </span><br><span class="line"> </span><br><span class="line">-                    Symbol (reserved=26220KB, committed=26220KB)</span><br><span class="line">                            (malloc=22664KB #292684) </span><br><span class="line">                            (arena=3556KB #1)</span><br><span class="line"> </span><br><span class="line">-    Native Memory Tracking (reserved=7616KB, committed=7616KB)</span><br><span class="line">                            (malloc=585KB #8238) </span><br><span class="line">                            (tracking overhead=7031KB)</span><br><span class="line"> </span><br><span class="line">-               Arena Chunk (reserved=10911KB, committed=10911KB)</span><br><span class="line">                            (malloc=10911KB) </span><br><span class="line"> </span><br><span class="line">-                   Tracing (reserved=25937KB, committed=25937KB)</span><br><span class="line">                            (malloc=25937KB #8666) </span><br><span class="line"> </span><br><span class="line">-                   Logging (reserved=5KB, committed=5KB)</span><br><span class="line">                            (malloc=5KB #196) </span><br><span class="line"> </span><br><span class="line">-                 Arguments (reserved=18KB, committed=18KB)</span><br><span class="line">                            (malloc=18KB #486) </span><br><span class="line"> </span><br><span class="line">-                    Module (reserved=532KB, committed=532KB)</span><br><span class="line">                            (malloc=532KB #3579) </span><br><span class="line"> </span><br><span class="line">-              Synchronizer (reserved=591KB, committed=591KB)</span><br><span class="line">                            (malloc=591KB #4777) </span><br><span class="line"> </span><br><span class="line">-                 Safepoint (reserved=8KB, committed=8KB)</span><br><span class="line">                            (mmap: reserved=8KB, committed=8KB)</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「java  分享官」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/aa119101/article/details/124406444</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li>Java Heap: 堆内存，即 -Xmx 限制的最大堆大小的内存。</li>
<li>Class：加载的类似方法信息，其实就是 metaspace，包含两部分： 一是 metadata，被 -XX:MaxMetaspaceSize 限制最大大小，另外是 class space，被 -XX:CompressedClassSpaceSize 限制最大大小</li>
<li>Thread：线程与线程栈占用内存，每个线程栈占用大小受 -Xss 限制，但是总大小没有限制。</li>
<li>Code：JIT 即时编译后（C1 C2 编译器优化）的代码占用内存，受 -XX:ReservedCodeCacheSize 限制</li>
<li>GC：垃圾回收占用内存，例如垃圾回收需要的 CardTable，标记数，区域划分记录，还有标记 GC Root 等等，都需要内存。这个不受限制，一般不会很大的。</li>
<li>Compiler：C1 C2 编译器本身的代码和标记占用的内存，这个不受限制，一般不会很大的</li>
<li>Internal：命令行解析，JVMTI 使用的内存，这个不受限制，一般不会很大的</li>
<li>Symbol: 常量池占用的大小，字符串常量池受 -XX:StringTableSize 个数限制，总内存大小不受限制</li>
<li>Native Memory Tracking：内存采集本身占用的内存大小，如果没有打开采集（那就看不到这个了，哈哈），就不会占用，这个不受限制，一般不会很大的</li>
<li>Arena Chunk：所有通过 arena 方式分配的内存，这个不受限制，一般不会很大的</li>
<li>Tracing：所有采集占用的内存，如果开启了 JFR 则主要是 JFR 占用的内存。这个不受限制，一般不会很大的</li>
<li>Logging，Arguments，Module，Synchronizer，Safepoint，Other，这些一般我们不会关心。</li>
</ul>
<p>除了 Native Memory Tracking 记录的内存使用，还有两种内存 <strong>Native Memory Tracking 没有记录</strong> ，那就是：</p>
<ul>
<li>Direct Buffer：直接内存</li>
<li>MMap Buffer：文件映射内存</li>
</ul>
<p>针对除了堆内存以外，其他的内存，有些也是需要 GC 的。</p>
<pre><code>例如：MetaSpace，CodeCache，Direct Buffer，MMap Buffer 等等。
</code></pre>
<p>早期在 Java 8 之前的 JVM，对于这些内存回收的机制并不完善，很多情况下都需要 FullGC 扫描整个堆才能确定这些区域中哪些内存可以回收。</p>
<p>有一些框架，大量使用并管理了这些堆外空间。例如:</p>
<ul>
<li>netty 使用了 Direct Buffer，</li>
<li>Kafka 和 RocketMQ 使用了 Direct Buffer 和 MMap Buffer。</li>
</ul>
<p>他们都是提前从系统申请好一块内存，之后管理起来并使用。</p>
<p>在空间不足时，继续向系统申请，并且也会有缩容。</p>
<p>例如 netty: </p>
<ul>
<li>在使用的 Direct Buffer 达到 -XX:MaxDirectMemorySize 的限制之后，则会先尝试将不可达的Reference对象加入Reference链表中，依赖Reference的内部守护线程触发可以被回收DirectByteBuffer关联的Cleaner的run()方法。</li>
<li>如果内存还是不足， 则执行 System.gc() ，期望触发full gc ，来回收堆内存中的 DirectByteBuffer 对象来触发堆外内存回收，</li>
<li>如果还是超过限制，则抛出 java.lang.OutOfMemoryError .</li>
</ul>
<h4 id="使用了-WeakReference，-SoftReference-的程序，需要相应的-GC-回收。"><a href="#使用了-WeakReference，-SoftReference-的程序，需要相应的-GC-回收。" class="headerlink" title="使用了 WeakReference， SoftReference 的程序，需要相应的 GC 回收。"></a>使用了 WeakReference， SoftReference 的程序，需要相应的 GC 回收。</h4><ul>
<li>WeakReference，只要发生 GC，无论是 Young GC 还是 FullGC 就会被回收。</li>
<li>SoftReference 只有在 FullGC 的时候才会被回收。</li>
</ul>
<p>当我们程序想主动对于这些引用进行回收的时候，需要能触发 GC 的方法，这就用到了 System.gc() 。</p>
<h4 id="测试、学习-JVM-机制的时候"><a href="#测试、学习-JVM-机制的时候" class="headerlink" title="测试、学习 JVM 机制的时候"></a>测试、学习 JVM 机制的时候</h4><p>有些时候，我们为了测试，学习 JVM 的某些机制，需要让 JVM 做一次 GC 之后开始，这也会用到 System.gc() 。</p>
<h3 id="System-gc-做了什么"><a href="#System-gc-做了什么" class="headerlink" title="System.gc()做了什么"></a>System.gc()做了什么</h3><p>System.gc()我们都知道是手动垃圾回收，这点无需多说，今天我们来了解一下System.gc()是怎么进行垃圾回收的。</p>
<p>System.gc()内部调用了 Runtime.getRuntiom</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Runtime.getRuntime().gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在往深一层则是本地方法了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Runs the garbage collector.</span></span><br><span class="line"><span class="comment"> * Calling this method suggests that the Java virtual machine expend</span></span><br><span class="line"><span class="comment"> * effort toward recycling unused objects in order to make the memory</span></span><br><span class="line"><span class="comment"> * they currently occupy available for quick reuse. When control</span></span><br><span class="line"><span class="comment"> * returns from the method call, the virtual machine has made</span></span><br><span class="line"><span class="comment"> * its best effort to recycle all discarded objects.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The name &lt;code&gt;gc&lt;/code&gt; stands for &quot;garbage</span></span><br><span class="line"><span class="comment"> * collector&quot;. The virtual machine performs this recycling</span></span><br><span class="line"><span class="comment"> * process automatically as needed, in a separate thread, even if the</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;gc&lt;/code&gt; method is not invoked explicitly.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The method &#123;<span class="doctag">@link</span> System#gc()&#125; is the conventional and convenient</span></span><br><span class="line"><span class="comment"> * means of invoking this method.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>对应JVM源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JVM_ENTRY_NO_ENV</span>(<span class="keyword">void</span>, <span class="built_in">JVM_GC</span>(<span class="keyword">void</span>))</span><br><span class="line">  <span class="built_in">JVMWrapper</span>(<span class="string">&quot;JVM_GC&quot;</span>);</span><br><span class="line">  <span class="comment">//如果没有将JVM启动参数 DisableExplicitGC 设置为 false，则执行 GC，GC 原因是 System.gc 触发，对应 GCCause::_java_lang_system_gc</span></span><br><span class="line">  <span class="keyword">if</span> (!DisableExplicitGC) &#123;</span><br><span class="line">    Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">collect</span>(GCCause::_java_lang_system_gc);</span><br><span class="line">  &#125;</span><br><span class="line">JVM_END</span><br></pre></td></tr></table></figure>

<p>System.gc()会执行FullGC,对新生代和老年代进行回收</p>
<p>注意: <strong>此时垃圾回收线程可能并不会立即执行</strong></p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="堆外内存回收"><a href="#堆外内存回收" class="headerlink" title="堆外内存回收"></a>堆外内存回收</h3><p>参考文档: <a target="_blank" rel="noopener" href="http://t.zoukankan.com/duanxz-p-6089485.html">堆外内存回收方法</a></p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/08/18/JAVA%E5%9F%BA%E7%A1%80/JAVA%E9%9B%86%E5%90%88/JAVA%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E4%B9%8B%E5%90%84%E9%9B%86%E5%90%88%E5%9F%BA%E6%9C%AC%E5%AF%B9%E6%AF%94/"><i class="fa fa-chevron-left">  </i><span>JAVA集合概述之各集合基本对比</span></a></div><div class="next-post pull-right"><a href="/2021/08/13/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE/"><span>JVM基础系列之对象的创建与访问</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By 何鹏 [smile.hepeng@qq.com]</div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://unpkg.zhimg.com/animejs@3.2.1/lib/anime.min.js"></script><script src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script src="https://unpkg.zhimg.com/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://unpkg.com/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://unpkg.com/velocity-ui-pack@1.2.2/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>