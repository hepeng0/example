<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="操作系统第三步之一个新进程的诞生"><meta name="keywords" content="操作系统"><meta name="author" content="何鹏 [smile.hepeng@qq.com]"><meta name="copyright" content="何鹏 [smile.hepeng@qq.com]"><title>操作系统第三步之一个新进程的诞生 | 沉默者</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><link rel="alternate" href="/atom.xml" title="沉默者" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%A6%82%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text">整体概览</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#move-to-user-mode"><span class="toc-number">1.1.</span> <span class="toc-text">move_to_user_mode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fork"><span class="toc-number">1.2.</span> <span class="toc-text">fork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#init"><span class="toc-number">1.3.</span> <span class="toc-text">init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pause"><span class="toc-number">1.4.</span> <span class="toc-text">pause</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%86%85%E6%A0%B8%E6%80%81%E5%88%B0%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-number">2.</span> <span class="toc-text">从内核态到用户态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A9%E8%BF%9B%E7%A8%8B%E6%97%A0%E6%B3%95%E9%80%83%E5%87%BA%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-number">2.1.</span> <span class="toc-text">让进程无法逃出用户态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E6%9C%AC%E8%B4%A8-%E7%89%B9%E6%9D%83%E7%BA%A7"><span class="toc-number">2.2.</span> <span class="toc-text">内核态与用户态的本质-特权级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%9D%83%E7%BA%A7%E8%BD%AC%E6%8D%A2%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">特权级转换的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E4%BA%86%E6%94%B9%E5%8F%98%E7%89%B9%E6%9D%83%E7%BA%A7%E4%B9%8B%E5%A4%96"><span class="toc-number">2.4.</span> <span class="toc-text">除了改变特权级之外</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E6%9D%A5%E8%AE%BE%E8%AE%A1%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">3.</span> <span class="toc-text">如果让你来设计进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.</span> <span class="toc-text">整体流程设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83"><span class="toc-number">3.2.</span> <span class="toc-text">上下文环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%E4%BF%A1%E6%81%AF"><span class="toc-number">3.3.</span> <span class="toc-text">运行时间信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.4.</span> <span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">3.5.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%B8%80%E6%AC%A1%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BB%B4%E7%AD%94%E6%9D%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">从一次定时器滴答来看进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="toc-number">4.1.</span> <span class="toc-text">时钟中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">时钟中断处理函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%89%E6%8B%A9"><span class="toc-number">4.3.</span> <span class="toc-text">进程选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">4.4.</span> <span class="toc-text">进程切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%88%B0%E4%B8%BB%E6%B5%81%E7%A8%8B%EF%BC%8C%E9%80%9A%E8%BF%87fork%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">回到主流程，通过fork看系统调用流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fork%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">fork函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork%E4%B8%AD%E8%BF%9B%E7%A8%8B%E6%A7%BD%E4%BD%8D%E7%94%B3%E8%AF%B7%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">6.</span> <span class="toc-text">fork中进程槽位申请和基本信息的复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#find-empty-process"><span class="toc-number">6.1.</span> <span class="toc-text">find_empty_process</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy-process"><span class="toc-number">6.2.</span> <span class="toc-text">copy_process</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E8%A7%84%E5%88%92%E7%9A%84%E9%97%AE%E9%A2%98-%E9%A1%B5%E8%A1%A8%E5%92%8C%E6%AE%B5%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">7.</span> <span class="toc-text">fork中进程内存规划的问题-页表和段表的复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LDT-%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">7.1.</span> <span class="toc-text">LDT 的赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">7.2.</span> <span class="toc-text">页表的复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%96%B0%E8%80%81%E8%BF%9B%E7%A8%8B%E9%A1%B5%E8%A1%A8%E4%BF%AE%E6%94%B9%E4%B8%BA%E5%8F%AA%E8%AF%BB"><span class="toc-number">7.3.</span> <span class="toc-text">将新老进程页表修改为只读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#copy-process%E6%80%BB%E7%BB%93"><span class="toc-number">7.4.</span> <span class="toc-text">copy_process总结</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img2.baidu.com/it/u=928705063,3876627980&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg"></div><div class="author-info__name text-center">何鹏 [smile.hepeng@qq.com]</div><div class="author-info__description text-center">路漫漫其修远兮，吾将上下而求索</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">69</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">53</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默者</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">操作系统第三步之一个新进程的诞生</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-06-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">12.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 45 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>第一步和第二步，为我们这个第三步做了充足的铺垫工作。</p>
<ul>
<li>第一步 进入内核前的苦力活</li>
<li>第二步 大战前期的初始化工作</li>
</ul>
<p>到了第三步，简单说就是从内核态切换到用户态，然后通过 fork 创建出一个新的进程，再之后老进程进入死循环。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    // 第二部分的内容，各种初始化工作</span><br><span class="line">    ...</span><br><span class="line">    // 第三部分的内容，一个新进程的诞生</span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    if (!fork()) &#123;</span><br><span class="line">        // 新进程里干了啥，是第四部分的内容</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    // 死循环，操作系统怠速状态</span><br><span class="line">    for(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于 fork 出来的新进程做了什么事，就是 init 函数里的故事里，这个不在第三部分的讨论范畴。</p>
<p>所以你看，一共就两行代码，顶多再算上最后一行的死循环，三行，就把创建新进程这个事搞定了。</p>
<p>再加上新进程里要做的 init 函数，一共四行代码，就走到了 main 函数的结尾，也就标志着操作系统启动完毕！</p>
<p>但就是这没有多少个字母的四行代码，是整个操作系统的精髓所在，也是最难的四行代码。</p>
<h3 id="整体概览"><a href="#整体概览" class="headerlink" title="整体概览"></a>整体概览</h3><h4 id="move-to-user-mode"><a href="#move-to-user-mode" class="headerlink" title="move_to_user_mode"></a>move_to_user_mode</h4><p>直译过来即可，就是转变为用户态模式。因为 Linux 将操作系统特权级分为用户态与内核态两种，之前都处于内核态，现在要先转变为用户态，仅此而已。</p>
<p>一旦转变为了用户态，那么之后的代码将一直处于用户态的模式，除非发生了中断，比如用户发出了系统调用的中断指令，那么此时将会从用户态陷入内核态，不过当中断处理程序执行完之后，又会通过中断返回指令从内核态回到用户态。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img.png"></p>
<p>整个过程被操作系统的机制拿捏的死死的，始终让用户进程处于用户态运行，必要的时候陷入一下内核态，但很快就会被返回而再次回到用户态，是不是非常无奈？</p>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>这是创建一个新进程的意思，而且所有用户进程想要创建新的进程，都需要调用这个函数。</p>
<p>原来操作系统只有一个执行流，就是我们一直看过来的所有代码，就是进程 0，只不过我们并没有意识到它也是一个进程。调用完 fork 之后，现在又多了一个进程，叫做进程 1。</p>
<p>当然，更准确的说法是，我们一路看过来的代码能够被我们自信地称作进程 0 的确切时刻，是我们在 <code>进程调度初始化 sched_init</code> 里为当前执行流添加了一个进程管理结构到 task 数组里，同时开启了定时器以及时钟中断的那一个时刻。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_1.png"></p>
<p>因为此时时钟中断到来之后，就可以执行到我们的进程调度程序，进程调度程序才会去这个 task 数组里挑选合适的进程进行切换。所以此时，我们当前执行的代码，才真正有了一个进程的身份，才勉强得到了一个可以被称为进程 0 的资格，毕竟还没有其他进程参与竞争。</p>
<h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><p>只有进程 1 会走到这个分支来执行。</p>
<p>这里的代码可太多了，它本身需要完成如加载根文件系统的任务，同时这个方法将又会创建出一个新的进程 2，在进程 2 里又会加载与用户交互的 shell 程序，此时操作系统就正式成为了用户可用的一个状态了。</p>
<h4 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h4><p>当没有任何可运行的进程时，操作系统会悬停在这里，达到怠速状态。没啥好说的，操作系统就是由中断驱动的一个死循环。</p>
<p>一共四句话，切换到用户态，创建新进程，初始化，然后悬停怠速。</p>
<h3 id="从内核态到用户态"><a href="#从内核态到用户态" class="headerlink" title="从内核态到用户态"></a>从内核态到用户态</h3><h4 id="让进程无法逃出用户态"><a href="#让进程无法逃出用户态" class="headerlink" title="让进程无法逃出用户态"></a>让进程无法逃出用户态</h4><p>我相信你肯定听说过操作系统的内核态与用户态，用户进程都在用户态这个特权级下运行，而有时程序想要做一些内核态才允许做的事情，比如读取硬盘的数据，就需要通过系统调用，来请求操作系统在内核态特权级下执行一些指令。</p>
<p>我们现在的代码，还是在内核态下运行，之后操作系统达到怠速状态时，是以用户态的 shell 进程运行，随时等待着来自用户输入的命令。</p>
<p>所以，就在这一步，也就是 <code>move_to_user_mode</code> 这行代码，作用就是将当前代码的特权级，从内核态变为用户态。</p>
<p>一旦转变为了用户态，那么之后的代码将一直处于用户态的模式，除非发生了中断，比如用户发出了系统调用的中断指令，那么此时将会从用户态陷入内核态，不过当中断处理程序执行完之后，又会通过中断返回指令从内核态回到用户态。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_2.png"></p>
<p>整个过程被操作系统的机制拿捏的死死的，始终让用户进程处于用户态运行，必要的时候陷入一下内核态，但很快就会被返回而再次回到用户态，是不是非常无奈？这样操作系统就掌控了控制权，而用户进程再怎么折腾也无法逃出这个模式。</p>
<h4 id="内核态与用户态的本质-特权级"><a href="#内核态与用户态的本质-特权级" class="headerlink" title="内核态与用户态的本质-特权级"></a>内核态与用户态的本质-特权级</h4><p>首先从一个最大的视角来看，这一切都源于 CPU 的保护机制。</p>
<p>CPU 为了配合操作系统完成保护机制这一特性，分别设计了<strong>分段保护机制</strong>与<strong>分页保护机制</strong>。</p>
<p>参考<a href="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/" title="操作系统第一步之进入内核前的苦力活">操作系统第一步之进入内核前的苦力活</a>， 将 cr0 寄存器的 PE 位开启时，就开启了保护模式，也即开启了分段保护机制。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_3.png"></p>
<p>将 cr0 寄存器的 PG 位开启时，就开启了分页模式，也即开启了分页保护机制。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_4.png"></p>
<p>有关特权级的保护，实际上属于分段保护机制的一种。具体怎么保护的呢？由于这里的细节比较繁琐，所以我举个例子简单理解下即可，实际上的特权级检查规则要比我说的多好多内容。</p>
<p>我们目前正在执行的代码地址，是通过 CPU 中的两个寄存器 cs : eip 指向的对吧？cs 寄存器是代码段寄存器，里面存着的是段选择子，还记得它的结构么？</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_5.png"></p>
<p>这里面的低端两位，此时表示 CPL，也就是当前所处的特权级，假如我们现在这个时刻，CS 寄存器的后两位为 3，二进制就是 11，就表示是当前处理器处于用户态这个特权级。</p>
<p>假如我们此时要跳转到另一处内存地址执行，在最终的汇编指令层面无非就是 jmp、call 和中断。我们拿 jmp 跳转来举例。</p>
<ul>
<li>如果是短跳转，也就是直接 jmp xxx，那不涉及到段的变换，也就没有特权级检查这回事。</li>
<li>如果是长跳转，也就是 jmp yyy : xxx，这里的 yyy 就是另一个要跳转到的段的段选择子结构。</li>
</ul>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_6.png"></p>
<p>这个结构仍然是一样的段选择子结构，只不过这里的低端两位，表示 RPL，也就是请求特权级，表示我想请求的特权级是什么。</p>
<p>同时，CPU 会拿这个段选择子去全局描述符表中寻找段描述符，从中找到段基址。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_7.png"></p>
<p>那还记得段描述符的样子么？</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_8.png"></p>
<p>你看，这里面又有个 DPL，这表示目标代码段特权级，也就是即将要跳转过去的那个段的特权级。</p>
<p>好了，我们总结一下简图，就是这三个玩意的比较。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_9.png"></p>
<p>这里的检查规则比较多，简单说，绝大多数情况下，要求 CPL 必须等于 DPL，才会跳转成功，否则就会报错。</p>
<p>也就是说，当前代码所处段的特权级，必须要等于要跳转过去的代码所处的段的特权级，那就只能<strong>用户态往用户态跳，内核态往内核态跳</strong>，这样就防止了处于用户态的程序，跳转到内核态的代码段中做坏事。</p>
<p>这只是代码段跳转时所做的特权级检查，还有访问内存数据时也会有数据段的特权级检查，这里就不展开了。</p>
<p>最终的效果是，<strong>处于内核态的代码可以访问任何特权级的数据段，处于用户态的代码则只可以访问用户态的数据段</strong>，这也就实现了内存数据读写的保护。</p>
<p>说了这么多，其实就是，<strong>代码跳转只能同特权级，数据访问只能高特权级访问低特权级</strong>。</p>
<h4 id="特权级转换的方式"><a href="#特权级转换的方式" class="headerlink" title="特权级转换的方式"></a>特权级转换的方式</h4><p>从内核态转变为用户态，那如果代码跳转只能同特权级跳，我们现在处于内核态，要怎么样才能跳转到用户态呢？</p>
<p>Intel 设计了好多种特权级转换的方式，中断和中断返回就是其中的一种。</p>
<p><strong>处于用户态的程序，通过触发中断，可以进入内核态，之后再通过中断返回，又可以恢复为用户态</strong>。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_2.png"></p>
<p>而<strong>系统调用</strong>就是这么玩的，用户通过 int 0x80 中断指令触发了中断，CPU 切换至内核态，执行中断处理程序，之后中断程序返回，又从内核态切换回用户态。</p>
<p>但有个问题是，我们当前的代码，此时就是处于内核态，并不是由一个用户态程序通过中断而切换到的内核态，那怎么回到原来的用户态呢？答案还是，通过中断返回。</p>
<p>没有中断也能中断返回？可以的，Intel 设计的 CPU 就是这样不符合人们的直觉，中断和中断返回的确是应该配套使用的，但也可以单独使用，我们看代码。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...    </span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">define move_to_user_mode() \</span></span><br><span class="line"><span class="bash">_asm &#123; \</span></span><br><span class="line"><span class="bash">    _asm mov eax,esp \</span></span><br><span class="line"><span class="bash">    _asm push 00000017h \</span></span><br><span class="line"><span class="bash">    _asm push eax \</span></span><br><span class="line"><span class="bash">    _asm pushfd \</span></span><br><span class="line"><span class="bash">    _asm push 0000000fh \</span></span><br><span class="line"><span class="bash">    _asm push offset l1 \</span></span><br><span class="line"><span class="bash">    _asm iretd /* 执行中断返回指令*/ \</span></span><br><span class="line"><span class="bash">_asm l1: mov eax,17h \</span></span><br><span class="line"><span class="bash">    _asm mov ds,ax \</span></span><br><span class="line"><span class="bash">    _asm mov es,ax \</span></span><br><span class="line"><span class="bash">    _asm mov fs,ax \</span></span><br><span class="line"><span class="bash">    _asm mov gs,ax \</span></span><br><span class="line"><span class="bash">&#125;</span></span><br></pre></td></tr></table></figure>

<p>你看，这个方法里直接就执行了中断返回指令 iretd。 那么为什么之前进行了一共五次的压栈操作呢？ </p>
<p>因为中断返回理论上就是应该和中断配合使用的，而此时并不是真的发生了中断到这里，所以我们得假装发生了中断才行，怎么假装呢？</p>
<p>其实就把栈做做工作就好了:</p>
<ul>
<li>中断发生时，CPU 会自动帮我们做如下的压栈操作。</li>
<li>中断返回时，CPU 又会帮我们把压栈的这些值返序赋值给响应的寄存器。</li>
</ul>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%8E%8B%E6%A0%88%E6%93%8D%E4%BD%9C.png"></p>
<p>去掉错误码，刚好是五个参数，所以我们在代码中模仿 CPU 进行了五次压栈操作，这样在执行 iretd 指令时，硬件会按顺序将刚刚压入栈中的数据，分别赋值给 SS、ESP、EFLAGS、CS、EIP 这几个寄存器，这就感觉像是正确返回了一样，让其误以为这是通过中断进来的。</p>
<ul>
<li>压入栈的 CS 和 EIP 就表示中断发生前代码所处的位置，这样中断返回后好继续去那里执行。</li>
<li>压入栈的 SS 和 ESP 表示中断发生前的栈的位置，这样中断返回后才好恢复原来的栈。</li>
</ul>
<p>其中，特权级的转换，就体现在 CS 和 SS 寄存器的值里，都是细节！</p>
<p>拿 CS 举例，给它赋的值是，0000000fh，用二进制表示为： <code>0000000000001111</code></p>
<p>最后两位 11 表示特权级为 3，即用户态。而我们刚刚说了，CS 寄存器里的特权级，表示 CPL，即当前处理器特权级。</p>
<p><strong>所以经过 iretd 返回之后，CS 的值就变成了它，而当前处理器特权级，也就变成了用户态特权级。</strong></p>
<h4 id="除了改变特权级之外"><a href="#除了改变特权级之外" class="headerlink" title="除了改变特权级之外"></a>除了改变特权级之外</h4><p>刚刚我们关注段寄存器，只关注了特权级的部分，除了改变了特权级之外，还做了什么事情呢，我们再详细看看。</p>
<p>刚刚说了 CS 寄存器为 <code>0000000000001111</code>，最后两位表示用户态的含义。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_5.png"></p>
<p>那继续解读，倒数第三位 TI 表示，前面的描述符索引，是从 GDT 还是 LDT 中取，1 表示 LDT，也就是从局部描述符表中取，表示从局部描述符表中取到代码段描述符。</p>
<p>在进程调度初始化中， 0 号 LDT 作为当前的 LDT 索引，记录在了 CPU 的 lldt 寄存器中。</p>
<p>而整个 GDT 与 LDT 表的设计，目前是这个样子</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_11.png"></p>
<p>所以，一目了然。</p>
<p>再看这行代码，把 EIP 寄存器赋值为了那行标号的地址。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">define move_to_user_mode() \</span></span><br><span class="line"><span class="bash">_asm &#123; \</span></span><br><span class="line"><span class="bash">   ...</span></span><br><span class="line">    _asm push offset l1 \</span><br><span class="line">    _asm iretd /* 执行中断返回指令*/ \</span><br><span class="line">_asm l1: mov eax,17h \</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里刚好设置的是下面标号 l1 的位置，所以 iretd 之后 CPU 就乖乖去那里执行了。</p>
<p>所以其实从效果上看，就是顺序往下执行，只不过利用了 iretd 做了些特权级转换等工作。</p>
<p>同理，这里的栈段 ss 和数据段 ds，都被赋值为了 17h，大家可以展开二进制算一下，他们又是什么特权级，对应的描述符又是谁。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>所以其实，最终效果上看就是按顺序执行了我们所写的指令，通过模拟中断返回实现了特权级的翻转，也就是从内核态变为了用户态，顺便设置了栈段、代码段和数据段的基地址。</p>
<p>好了，我们兜兜转转终于把这个 mov_to_user_mode 讲完了，特权级这块的检查细节非常繁琐，为了理解操作系统，我们只需要暂且记住如下一句话就好了：</p>
<p><strong>数据访问只能高特权级访问低特权级，代码跳转只能同特权级跳转，要想实现特权级转换，可以通过中断和中断返回来实现。</strong></p>
<details><summary>由此，表明需要内核态来完成的工作已经全部安排妥当</summary>

<ul>
<li>对全局描述符表、中断描述符表、页表等关键内存结构进行设置</li>
<li>以及对 CPU 特殊寄存器如 cr0 和 cr3 的设置</li>
<li>对外设如硬盘、键盘、定时器的设置等</li></ul></details>

<p>接下来只需要在用户态进行工作即可了</p>
<h3 id="如果让你来设计进程调度"><a href="#如果让你来设计进程调度" class="headerlink" title="如果让你来设计进程调度"></a>如果让你来设计进程调度</h3><p>创建新进程的过程，是一个很能体现操作系统设计的地方。在研究fork实现代码前，我们先头脑风暴一下，如果自己设计进程调度，我们会怎么弄。</p>
<p>进程调度本质是什么？很简单，假如有三段代码被加载到内存中。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_12.png"></p>
<p>进程调度就是让 CPU 一会去程序 1 的位置处运行一段时间，一会去程序 2 的位置处运行一段时间。</p>
<h4 id="整体流程设计"><a href="#整体流程设计" class="headerlink" title="整体流程设计"></a>整体流程设计</h4><ul>
<li>方案1 <ul>
<li>程序 1 的代码里，每隔几行就写一段代码，主动放弃自己的执行权，跳转到程序 2 的地方运行。</li>
<li>然后程序 2 也是如此。</li>
<li>这种依靠程序自己的办法肯定不靠谱。</li>
</ul>
</li>
<li>方案2<ul>
<li>由一个不受任何程序控制的，第三方的不可抗力，每隔一段时间就中断一下 CPU 的运行，</li>
<li>然后跳转到一个特殊的程序那里，这个程序通过某种方式获取到 CPU 下一个要运行的程序的地址，然后跳转过去。</li>
</ul>
</li>
</ul>
<p>每隔一段时间就中断 CPU 的不可抗力，就是由定时器触发的<strong>时钟中断</strong>，这个定时器和时钟中断，在进程调度初始化的<code>sched_init</code>中已经搞定了。</p>
<p>而那个特殊的程序，就是具体的<strong>进程调度函数</strong>了。</p>
<p>好了，整个流程就这样处理完了，那么应该设计什么样的数据结构，来支持这个流程呢？不妨假设这个结构叫 tast_struct。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">    ?</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>换句话说，你总得有一个结构来记录各个进程的信息，比如它上一次执行到哪里了，要不 CPU 就算决定好了要跳转到你这个进程上运行，具体跳到哪一行运行，总得有个地方存吧？</p>
<h4 id="上下文环境"><a href="#上下文环境" class="headerlink" title="上下文环境"></a>上下文环境</h4><p>每个程序最终的本质就是执行指令。这个过程会涉及<strong>寄存器，内存和外设端口</strong>。</p>
<p>内存还有可能设计成相互错开的，互不干扰，比如进程 1 你就用 0<del>1K 的内存空间，进程 2 就用 1K</del>2K 的内存空间，咱谁也别影响谁。</p>
<p>虽然有点浪费空间，而且对程序员十分不友好，但起码还是能实现的。</p>
<p>不过寄存器一共就那么点，肯定做不到互不干扰，可能一个进程就把寄存器全用上了，那其他进程咋整。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_13.png"></p>
<p>比如程序 1 刚刚往 eax 写入一个值，准备用，这时切换到进程 2 了，又往 eax 里写入了一个值。那么之后再切回进程 1 的时候，就出错了。</p>
<p>所以最稳妥的做法就是</p>
<details><summary>每次切换进程时，都把当前这些寄存器的值存到一个地方，以便之后切换回来的时候恢复</summary>

<p>每个进程的结构 task_struct 里面，有一个叫 tss 的结构，存储的就是 CPU 这些寄存器的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">    ...</span><br><span class="line">    struct tss_struct tss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct tss_struct &#123;</span><br><span class="line">    long    back_link;  /* 16 high bits zero */</span><br><span class="line">    long    esp0;</span><br><span class="line">    long    ss0;        /* 16 high bits zero */</span><br><span class="line">    long    esp1;</span><br><span class="line">    long    ss1;        /* 16 high bits zero */</span><br><span class="line">    long    esp2;</span><br><span class="line">    long    ss2;        /* 16 high bits zero */</span><br><span class="line">    long    cr3;</span><br><span class="line">    long    eip;</span><br><span class="line">    long    eflags;</span><br><span class="line">    long    eax,ecx,edx,ebx;</span><br><span class="line">    long    esp;</span><br><span class="line">    long    ebp;</span><br><span class="line">    long    esi;</span><br><span class="line">    long    edi;</span><br><span class="line">    long    es;     /* 16 high bits zero */</span><br><span class="line">    long    cs;     /* 16 high bits zero */</span><br><span class="line">    long    ss;     /* 16 high bits zero */</span><br><span class="line">    long    ds;     /* 16 high bits zero */</span><br><span class="line">    long    fs;     /* 16 high bits zero */</span><br><span class="line">    long    gs;     /* 16 high bits zero */</span><br><span class="line">    long    ldt;        /* 16 high bits zero */</span><br><span class="line">    long    trace_bitmap;   /* bits: trace 0, bitmap 16-31 */</span><br><span class="line">    struct i387_struct i387;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>

<p>这里提个细节，你发现 tss 结构里还有个 cr3 不？它表示 cr3 寄存器里存的值，而 cr3 寄存器是指向页目录表首地址的。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_14.png"></p>
<p>那么指向不同的页目录表，整个页表结构就是完全不同的一套，那么线性地址到物理地址的映射关系就有能力做到不同。</p>
<p>也就是说，在我们刚刚假设的理想情况下，不同程序用不同的内存地址可以做到内存互不干扰。</p>
<p>但是有了这个 cr3 字段，就完全可以无需由各个进程自己保证不和其他进程使用的内存冲突，因为只要建立不同的映射关系即可，由操作系统来建立不同的页目录表并替换 cr3 寄存器即可。</p>
<p>这也可以理解为，保存了<strong>内存映射的上下文信息</strong>。</p>
<p>当然 Linux 0.11 并不是通过替换 cr3 寄存器来实现内存互不干扰的，它的实现更为简单，这是后话了。</p>
<h4 id="运行时间信息"><a href="#运行时间信息" class="headerlink" title="运行时间信息"></a>运行时间信息</h4><p>如何判断一个进程该让出 CPU 了，切换到下一个进程呢？ 总不能是每次时钟中断时都切换一次吧？一来这样不灵活，二来这完全依赖时钟中断的频率，有点危险。</p>
<p>所以一个好的办法就是，给进程一个属性，叫<strong>剩余时间片</strong>，每次时钟中断来了之后都 -1，如果减到 0 了，就触发切换进程的操作。</p>
<p>在 Linux 0.11 里，这个属性就是 counter。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">    ...</span><br><span class="line">    long counter;</span><br><span class="line">    ...</span><br><span class="line">    struct tss_struct tss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而他的用法也非常简单，就是每次中断都判断一下是否到 0 了。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void do_timer(long cpl) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 当前线程还有剩余时间片，直接返回</span><br><span class="line">    if ((--current-&gt;counter)&gt;0) return;</span><br><span class="line">    // 若没有剩余时间片，调度</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果还没到 0，就直接返回，相当于这次时钟中断什么也没做，仅仅是给当前进程的时间片属性做了 -1 操作。</p>
<p>如果已经到 0 了，就触发<strong>进程调度</strong>，选择下一个进程并使 CPU 跳转到那里运行。 进程调度的逻辑就是在 schedule 函数里，怎么调，我们先不管。</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>上面那个 counter 一开始的时候该是多少呢？而且随着 counter 不断递减，减到 0 时，下一轮回中这个 counter 应该赋予什么值呢？</p>
<p>其实这俩问题都是一个问题，就是 <strong>counter 的初始化</strong>问题，也需要有一个属性来记录这个值。</p>
<p>往宏观想一下，这个值越大，那么 counter 就越大，那么每次轮到这个进程时，它在 CPU 中运行的时间就越长，也就是这个进程比其他进程得到了更多 CPU 运行的时间。</p>
<p>那我们可以把这个值称为<strong>优先级</strong>，是不是很形象。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">...</span><br><span class="line">long counter;</span><br><span class="line">long priority;</span><br><span class="line">...</span><br><span class="line">struct tss_struct tss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次一个进程初始化时，都把 counter 赋值为这个 priority，而且当 counter 减为 0 时，下一次分配时间片，也赋值为这个。</p>
<p>其实叫啥都行，反正就是这么用的，就叫优先级吧。</p>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>其实我们有了上面那三个信息，就已经可以完成进程的调度了。</p>
<p>甚至如果你的操作系统让所有进程都得到同样的运行时间，连 counter 和 priority 都不用记录，就操作系统自己定一个固定值一直递减，减到 0 了就随机切一个新进程。 这样就仅仅维护好寄存器的上下文信息 tss 就好了。</p>
<p>但我们总要不断优化以适应不同场景的用户需求的，很简单的一个场景，一个进程中有一个读取硬盘的操作，发起读请求后，要等好久才能得到硬盘的中断信号。 </p>
<ul>
<li>那这个时间其实该进程再占用着 CPU 也没用，此时就可以选择主动放弃 CPU 执行权，然后再把自己的状态标记为等待中。 </li>
<li>意思是告诉进程调度的代码，先别调度我，因为我还在等硬盘的中断，现在轮到我了也没用，把机会给别人吧。</li>
</ul>
<p>那这个状态可以记录一个属性了，叫 state，记录了此时进程的状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">    long state;</span><br><span class="line">    long counter;</span><br><span class="line">    long priority;</span><br><span class="line">    ...</span><br><span class="line">    struct tss_struct tss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个进程的状态在 Linux 0.11 里有这么五种。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define TASK_RUNNING          0</span><br><span class="line">#define TASK_INTERRUPTIBLE    1</span><br><span class="line">#define TASK_UNINTERRUPTIBLE  2</span><br><span class="line">#define TASK_ZOMBIE           3</span><br><span class="line">#define TASK_STOPPED          4</span><br></pre></td></tr></table></figure>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>好了，目前我们这几个字段，就已经可以完成简单的进程调度任务了：</p>
<ul>
<li>有表示状态的 state</li>
<li>表示剩余时间片的 counter</li>
<li>表示优先级的 priority</li>
<li>和表示上下文信息的 tss</li>
</ul>
<p>其他字段我们需要用到的时候再说记住这四个字段就可以了</p>
<details><summary>看一下 Linux 0.11 中进程结构的全部，心里先有个数，具体干嘛的先不管</summary>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">/* these are hardcoded - don&#x27;t touch */</span><br><span class="line">    long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><span class="line">    long counter;</span><br><span class="line">    long priority;</span><br><span class="line">    long signal;</span><br><span class="line">    struct sigaction sigaction[32];</span><br><span class="line">    long blocked;   /* bitmap of masked signals */</span><br><span class="line">/* various fields */</span><br><span class="line">    int exit_code;</span><br><span class="line">    unsigned long start_code,end_code,end_data,brk,start_stack;</span><br><span class="line">    long pid,father,pgrp,session,leader;</span><br><span class="line">    unsigned short uid,euid,suid;</span><br><span class="line">    unsigned short gid,egid,sgid;</span><br><span class="line">    long alarm;</span><br><span class="line">    long utime,stime,cutime,cstime,start_time;</span><br><span class="line">    unsigned short used_math;</span><br><span class="line">/* file system info */</span><br><span class="line">    int tty;        /* -1 if no tty, so it must be signed */</span><br><span class="line">    unsigned short umask;</span><br><span class="line">    struct m_inode * pwd;</span><br><span class="line">    struct m_inode * root;</span><br><span class="line">    struct m_inode * executable;</span><br><span class="line">    unsigned long close_on_exec;</span><br><span class="line">    struct file * filp[NR_OPEN];</span><br><span class="line">/* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span><br><span class="line">    struct desc_struct ldt[3];</span><br><span class="line">/* tss for this task */</span><br><span class="line">    struct tss_struct tss;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>

<p>由此，我们知道了进程调度：</p>
<ul>
<li>开始，要从一次定时器滴答来触发，通过时钟中断处理函数走到进程调度函数，</li>
<li>然后去进程的结构 task_struct 中取出所需的数据，</li>
<li>进行策略计算，并挑选出下一个可以得到 CPU 运行的进程，跳转过去。</li>
</ul>
<h3 id="从一次定时器滴答来看进程调度"><a href="#从一次定时器滴答来看进程调度" class="headerlink" title="从一次定时器滴答来看进程调度"></a>从一次定时器滴答来看进程调度</h3><h4 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h4><p>我们在进程调度初始化时，开启了定时器，这个定时器每隔一段时间就会向CPU发起一个中断信号。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_15.png"></p>
<p>这个间隔时间被设置为 10 ms，也就是 100 Hz。发起的中断叫时钟中断，其中断向量号被设置为了 0x20。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define HZ 100</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">set_intr_gate(0x20, &amp;timer_interrupt);</span><br></pre></td></tr></table></figure>

<p>这样，当时钟中断，也就是 0x20 号中断来临时，CPU 会查找中断向量表中 0x20 处的函数地址，即中断处理函数，并跳转过去执行。</p>
<h4 id="时钟中断处理函数"><a href="#时钟中断处理函数" class="headerlink" title="时钟中断处理函数"></a>时钟中断处理函数</h4><details><summary>这个中断处理函数就是 timer_interrupt，是用汇编语言写的</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_timer_interrupt:</span><br><span class="line">    ...</span><br><span class="line">    // 增加系统滴答数</span><br><span class="line">    incl _jiffies</span><br><span class="line">    ...</span><br><span class="line">    // 调用函数 do_timer</span><br><span class="line">    call _do_timer</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
</details>


<p>这个函数做了两件事:</p>
<ul>
<li>一个是将系统滴答数这个变量 jiffies 加一</li>
<li>一个是调用了另一个函数 do_timer</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void do_timer(long cpl) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 当前线程还有剩余时间片，直接返回</span><br><span class="line">    if ((--current-&gt;counter)&gt;0) return;</span><br><span class="line">    // 若没有剩余时间片，调度</span><br><span class="line">    schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>do_timer 最重要的部分就是上面这段代码，非常简单:</p>
<ul>
<li>首先将当先进程的时间片 -1，然后判断：</li>
<li>如果时间片仍然大于零，则什么都不做直接返回。</li>
<li>如果时间片已经为零，则调用 schedule()，很明显，这就是进行进程调度的主干。</li>
</ul>
<h4 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a>进程选择</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void schedule(void) &#123;</span><br><span class="line">    int i, next, c;</span><br><span class="line">    struct task_struct ** p;</span><br><span class="line">    ...</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        c = -1;</span><br><span class="line">        next = 0;</span><br><span class="line">        i = NR_TASKS;</span><br><span class="line">        p = &amp;task[NR_TASKS];</span><br><span class="line">        while (--i) &#123;</span><br><span class="line">            if (!*--p)</span><br><span class="line">                continue;</span><br><span class="line">            if ((*p)-&gt;state == TASK_RUNNING &amp;&amp; (*p)-&gt;counter &gt; c)</span><br><span class="line">                c = (*p)-&gt;counter, next = i;</span><br><span class="line">        &#125;</span><br><span class="line">        if (c) break;</span><br><span class="line">        for(p = &amp;LAST_TASK ; p &gt; &amp;FIRST_TASK ; --p)</span><br><span class="line">            if (*p)</span><br><span class="line">                (*p)-&gt;counter = ((*p)-&gt;counter &gt;&gt; 1) +</span><br><span class="line">                        (*p)-&gt;priority;</span><br><span class="line">    &#125;</span><br><span class="line">    switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做个不严谨的简化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void schedule(void) &#123;</span><br><span class="line">    int next = get_max_counter_and_runnable_thread();</span><br><span class="line">    refresh_all_thread_counter();</span><br><span class="line">    switch_to(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简答，这个函数就做了三件事：</p>
<ol>
<li>拿到剩余时间片（counter的值）最大且在 runnable 状态（state = 0）的进程号 next。<br><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_16.png"></li>
<li>如果所有 runnable 进程时间片都为 0，则将所有进程（注意不仅仅是 runnable 的进程）的 counter 重新赋值（counter = counter/2 + priority），然后再次执行步骤 1。</li>
<li>最后拿到了一个进程号 next，调用了 switch_to(next) 这个方法，就切换到了这个进程去执行了。</li>
</ol>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><details><summary>看 switch_to 方法，是用内联汇编语句写的</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define switch_to(n) &#123;\</span><br><span class="line">struct &#123;long a,b;&#125; __tmp; \</span><br><span class="line">__asm__(&quot;cmpl %%ecx,_current\n\t&quot; \</span><br><span class="line">    &quot;je 1f\n\t&quot; \</span><br><span class="line">    &quot;movw %%dx,%1\n\t&quot; \</span><br><span class="line">    &quot;xchgl %%ecx,_current\n\t&quot; \</span><br><span class="line">    &quot;ljmp %0\n\t&quot; \</span><br><span class="line">    &quot;cmpl %%ecx,_last_task_used_math\n\t&quot; \</span><br><span class="line">    &quot;jne 1f\n\t&quot; \</span><br><span class="line">    &quot;clts\n&quot; \</span><br><span class="line">    &quot;1:&quot; \</span><br><span class="line">    ::&quot;m&quot; (*&amp;__tmp.a),&quot;m&quot; (*&amp;__tmp.b), \</span><br><span class="line">    &quot;d&quot; (_TSS(n)),&quot;c&quot; ((long) task[n])); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>看不懂没关系，其实主要就干了一件事，就是 ljmp 到新进程的 tss 段处。 啥意思？</p>
<p>CPU 规定，如果 ljmp 指令后面跟的是一个 tss 段，那么，会由硬件将当前各个寄存器的值保存在当前进程的 tss 中，并将新进程的 tss 信息加载到各个寄存器。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/_posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/Linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8AV5.0-Ljmp.png" alt="图片来源Linux内核完全注释V5.0"></p>
<p>简单说就是，<strong>保存当前进程上下文，恢复下一个进程的上下文，跳过去！</strong></p>
<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>罪魁祸首的，就是那个每 10ms 触发一次的定时器滴答。</p>
<p>而这个滴答将会给 CPU 产生一个时钟中断信号。</p>
<p>而这个中断信号会使 CPU 查找中断向量表，找到操作系统写好的一个时钟中断处理函数 do_timer。</p>
<p>do_timer 会首先将当前进程的 counter 变量 -1，如果 counter 此时仍然大于 0，则就此结束。</p>
<p>但如果 counter = 0 了，就开始进行进程的调度。</p>
<p>进程调度就是找到所有处于 RUNNABLE 状态的进程，并找到一个 counter 值最大的进程，把它丢进 switch_to 函数的入参里。</p>
<p>switch_to 这个终极函数，会保存当前进程上下文，恢复要跳转到的这个进程的上下文，同时使得 CPU 跳转到这个进程的偏移地址处。</p>
<p>接着，这个进程就舒舒服服地运行了起来，等待着下一次时钟中断的来临。</p>
<h3 id="回到主流程，通过fork看系统调用流程"><a href="#回到主流程，通过fork看系统调用流程" class="headerlink" title="回到主流程，通过fork看系统调用流程"></a>回到主流程，通过fork看系统调用流程</h3><h4 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h4><p>自此，我们通过自己设计了一遍进程调度，又看了一次 Linux 0.11 的进程调度的全过程。了解了进程调度具体实现，接下来，回到我们的主流程中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...    </span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    if (!fork()) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    for(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details><summary>这个 fork 函数干了啥?</summary>

<p>这个 fork 函数稍稍绕了点，我们看如下代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static _inline _syscall0(int,fork)</span><br><span class="line"></span><br><span class="line">#define _syscall0(type,name) \</span><br><span class="line">type name(void) \</span><br><span class="line">&#123; \</span><br><span class="line">long __res; \</span><br><span class="line">__asm__ volatile (&quot;int $0x80&quot; \</span><br><span class="line">    : &quot;=a&quot; (__res) \</span><br><span class="line">    : &quot;0&quot; (__NR_##name)); \</span><br><span class="line">if (__res &gt;= 0) \</span><br><span class="line">    return (type) __res; \</span><br><span class="line">errno = -__res; \</span><br><span class="line">return -1; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别急，我把它变成稍稍能看得懂的样子，就是这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define _syscall0(type,name) \</span><br><span class="line">type name(void) \</span><br><span class="line">&#123; \</span><br><span class="line">    volatile long __res; \</span><br><span class="line">    _asm &#123; \</span><br><span class="line">        _asm mov eax,__NR_##name \</span><br><span class="line">        _asm int 80h \</span><br><span class="line">        _asm mov __res,eax \</span><br><span class="line">    &#125; \</span><br><span class="line">    if (__res &gt;= 0) \</span><br><span class="line">        return (type) __res; \</span><br><span class="line">    errno = -__res; \</span><br><span class="line">    return -1; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，把宏定义都展开，其实就相当于<strong>定义了一个函数</strong>，仅此而已。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int fork(void) &#123;</span><br><span class="line">     volatile long __res;</span><br><span class="line">    _asm &#123;</span><br><span class="line">        _asm mov eax,__NR_fork</span><br><span class="line">        _asm int 80h</span><br><span class="line">        _asm mov __res,eax</span><br><span class="line">    &#125;</span><br><span class="line">    if (__res &gt;= 0)</span><br><span class="line">        return (void) __res;</span><br><span class="line">    errno = -__res;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>关键指令就是一个 0x80 号软中断的触发，<code>int 80h</code>,还记得 0x80 号中断的处理函数么, 进程调度初始化 <code>sched_init</code>中设置的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_system_gate(0x80, &amp;system_call);</span><br></pre></td></tr></table></figure>

<p>其中还有一个 eax 寄存器里的参数是 <code>__NR_fork</code>，这也是个宏定义，值是 2。</p>
<p>看这个 system_call 的汇编代码，我们发现这么一行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_system_call:</span><br><span class="line">    ...</span><br><span class="line">    call [_sys_call_table + eax*4]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这个值就用上了，eax 寄存器里的值是 2，所以这个就是在这个 sys_call_table 表里找下标 2 位置处的函数，然后跳转过去。</p>
<p>那我们接着看 sys_call_table 是个啥，其实就是各种函数指针组成的一个数组，说白了就是个系统调用函数表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fn_ptr sys_call_table[] = &#123; sys_setup, sys_exit, sys_fork, sys_read,</span><br><span class="line">  sys_write, sys_open, sys_close, sys_waitpid, sys_creat, sys_link,</span><br><span class="line">  sys_unlink, sys_execve, sys_chdir, sys_time, sys_mknod, sys_chmod,</span><br><span class="line">  sys_chown, sys_break, sys_stat, sys_lseek, sys_getpid, sys_mount,</span><br><span class="line">  sys_umount, sys_setuid, sys_getuid, sys_stime, sys_ptrace, sys_alarm,</span><br><span class="line">  sys_fstat, sys_pause, sys_utime, sys_stty, sys_gtty, sys_access,</span><br><span class="line">  sys_nice, sys_ftime, sys_sync, sys_kill, sys_rename, sys_mkdir,</span><br><span class="line">  sys_rmdir, sys_dup, sys_pipe, sys_times, sys_prof, sys_brk, sys_setgid,</span><br><span class="line">  sys_getgid, sys_signal, sys_geteuid, sys_getegid, sys_acct, sys_phys,</span><br><span class="line">  sys_lock, sys_ioctl, sys_fcntl, sys_mpx, sys_setpgid, sys_ulimit,</span><br><span class="line">  sys_uname, sys_umask, sys_chroot, sys_ustat, sys_dup2, sys_getppid,</span><br><span class="line">  sys_getpgrp, sys_setsid, sys_sigaction, sys_sgetmask, sys_ssetmask,</span><br><span class="line">  sys_setreuid, sys_setregid</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那下标 2 位置处是啥？从第零项开始数，第二项就是 sys_fork 函数！</p>
<p>至此，我们终于找到了 fork 函数，通过系统调用这个中断，最终走到内核层面的函数是什么，就是 sys_fork。</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>由此，我们也可以看出，操作系统 <strong>通过系统调用，提供给用户态可用的功能，都暴露在 sys_call_table</strong> 里了：</p>
<ul>
<li>系统调用统一通过 int 0x80 中断来进入，具体调用这个表里的哪个功能函数，就由 eax 寄存器传过来，这里的值是个数组索引的下标，通过这个下标就可以找到在 sys_call_table 这个数组里的具体函数。</li>
<li>同时也可以看出，用户进程调用内核的功能，可以直接通过写一句 int 0x80 汇编指令，并且给 eax 赋值，当然这样就比较麻烦。</li>
<li>所以也可以直接调用 fork 这样的包装好的方法，而这个方法里本质也是 int 0x80 以及 eax 赋值而已。</li>
</ul>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_17.png"></p>
<details><summary>一些扩展内容，系统调用的参数传递</summary>

<p>刚刚定义 fork 的系统调用模板函数时，用的是 syscall0，其实这个表示参数个数为 0，也就是 sys_fork 函数并不需要任何参数。</p>
<p>所以其实，在 unistd.h 头文件里，还定义了 syscall0 ~ syscall3 一共四个宏。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define _syscall0(type,name)</span><br><span class="line">#define _syscall1(type,name,atype,a)</span><br><span class="line">#define _syscall2(type,name,atype,a,btype,b)</span><br><span class="line">#define _syscall3(type,name,atype,a,btype,b,ctype,c)</span><br></pre></td></tr></table></figure>
<p>看都能看出来，其实 syscall1 就表示有一个参数，syscall2 就表示有两个参数。</p>
<p>那这些参数放在哪里了呢？总得有个约定的地方吧？</p>
<p>我们看一个今后要讲的重点函数，<code>execve</code>，是一个通常和 fork 在一起配合的变身函数，在之后的进程 1 创建进程 2 的过程中，就是这样玩的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (!(pid=fork())) &#123;</span><br><span class="line">        ...</span><br><span class="line">        execve(&quot;/bin/sh&quot;,argv_rc,envp_rc);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然我们的重点不是研究这个函数的作用，仅仅把它当做研究 syscall3 的一个例子，因为它的宏定义就是 syscall3。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">execve(&quot;/bin/sh&quot;,argv_rc,envp_rc);</span><br><span class="line"></span><br><span class="line">_syscall3(int,execve,const char *,file,char **,argv,char **,envp)</span><br><span class="line"></span><br><span class="line">#define _syscall3(type,name,atype,a,btype,b,ctype,c) \</span><br><span class="line">type name(atype a,btype b,ctype c) &#123; \</span><br><span class="line">    volatile long __res; \</span><br><span class="line">    _asm &#123; \</span><br><span class="line">        _asm mov eax,__NR_##name \</span><br><span class="line">        _asm mov ebx,a \</span><br><span class="line">        _asm mov ecx,b \</span><br><span class="line">        _asm mov edx,c \</span><br><span class="line">        _asm int 80h \</span><br><span class="line">        _asm mov __res,eax\</span><br><span class="line">    &#125; \</span><br><span class="line">    if (__res &gt;= 0) \</span><br><span class="line">        return (type) __res; \</span><br><span class="line">    errno = -__res; \</span><br><span class="line">    return -1; \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<strong>参数 a 被放在了 ebx 寄存器，参数 b 被放在了 ecx 寄存器，参数 c 被放在了 edx 寄存器</strong>。</p>
<p>我们再打开 system_call 的代码，刚刚我们只看了它的关键一行，就是去系统调用表里找函数，我们再看看全貌。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">_system_call:</span><br><span class="line">    cmpl $nr_system_calls-1,%eax</span><br><span class="line">    ja bad_sys_call</span><br><span class="line">    push %ds</span><br><span class="line">    push %es</span><br><span class="line">    push %fs</span><br><span class="line">    pushl %edx</span><br><span class="line">    pushl %ecx      # push %ebx,%ecx,%edx as parameters</span><br><span class="line">    pushl %ebx      # to the system call</span><br><span class="line">    movl $0x10,%edx     # set up ds,es to kernel space</span><br><span class="line">    mov %dx,%ds</span><br><span class="line">    mov %dx,%es</span><br><span class="line">    movl $0x17,%edx     # fs points to local data space</span><br><span class="line">    mov %dx,%fs</span><br><span class="line">    call _sys_call_table(,%eax,4)</span><br><span class="line">    pushl %eax</span><br><span class="line">    movl _current,%eax</span><br><span class="line">    cmpl $0,state(%eax)     # state</span><br><span class="line">    jne reschedule</span><br><span class="line">    cmpl $0,counter(%eax)       # counter</span><br><span class="line">    je reschedule</span><br><span class="line">ret_from_sys_call:</span><br><span class="line">    movl _current,%eax      # task[0] cannot have signals</span><br><span class="line">    cmpl _task,%eax</span><br><span class="line">    je 3f</span><br><span class="line">    cmpw $0x0f,CS(%esp)     # was old code segment supervisor ?</span><br><span class="line">    jne 3f</span><br><span class="line">    cmpw $0x17,OLDSS(%esp)      # was stack segment = 0x17 ?</span><br><span class="line">    jne 3f</span><br><span class="line">    movl signal(%eax),%ebx</span><br><span class="line">    movl blocked(%eax),%ecx</span><br><span class="line">    notl %ecx</span><br><span class="line">    andl %ebx,%ecx</span><br><span class="line">    bsfl %ecx,%ecx</span><br><span class="line">    je 3f</span><br><span class="line">    btrl %ecx,%ebx</span><br><span class="line">    movl %ebx,signal(%eax)</span><br><span class="line">    incl %ecx</span><br><span class="line">    pushl %ecx</span><br><span class="line">    call _do_signal</span><br><span class="line">    popl %eax</span><br><span class="line">3:  popl %eax</span><br><span class="line">    popl %ebx</span><br><span class="line">    popl %ecx</span><br><span class="line">    popl %edx</span><br><span class="line">    pop %fs</span><br><span class="line">    pop %es</span><br><span class="line">    pop %ds</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure>

<p>我们先只关注压栈的情况，触发了中断后，CPU 会自动帮我们做如下压栈操作</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%8E%8B%E6%A0%88%E6%93%8D%E4%BD%9C.png"></p>
<p>因为 system_call 是通过 int 80h 这个软中断进来的，所以也属于中断的一种，具体说是属于特权级发生变化的，且没有错误码情况的中断，所以在这之前栈已经被压了 SS、ESP、EFLAGS、CS、EIP 这些值。</p>
<p>接下来 system_call 又压入了一些值，具体说来有 ds、es、fs、edx、ecx、ebx、eax。</p>
<p>如果你看源码费劲，得不出我上述结论，那你可以看 system_call.s 上面的注释，Linus 作者已经很贴心地给你写出了此时的堆栈状态。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Stack layout in &#x27;ret_from_system_call&#x27;:</span><br><span class="line"> *</span><br><span class="line"> *   0(%esp) - %eax</span><br><span class="line"> *   4(%esp) - %ebx</span><br><span class="line"> *   8(%esp) - %ecx</span><br><span class="line"> *   C(%esp) - %edx</span><br><span class="line"> *  10(%esp) - %fs</span><br><span class="line"> *  14(%esp) - %es</span><br><span class="line"> *  18(%esp) - %ds</span><br><span class="line"> *  1C(%esp) - %eip</span><br><span class="line"> *  20(%esp) - %cs</span><br><span class="line"> *  24(%esp) - %eflags</span><br><span class="line"> *  28(%esp) - %oldesp</span><br><span class="line"> *  2C(%esp) - %oldss</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>看，就是 CPU 中断压入的 5 个值，加上 system_call 手动压入的 7 个值。</p>
<p>所以之后，中断处理程序如果有需要的话，就可以从这里取出它想要的值，包括 CPU 压入的那五个值，或者 system_call 手动压入的 7 个值。</p>
<p>比如 sys_execve 这个中断处理函数，一开始就取走了位于栈顶 0x1C 位置处的 EIP 的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EIP = 0x1C</span><br><span class="line">_sys_execve:</span><br><span class="line">    lea EIP(%esp),%eax</span><br><span class="line">    pushl %eax</span><br><span class="line">    call _do_execve</span><br><span class="line">    addl $4,%esp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>随后在 <code>do_execve</code> 函数中，又通过 C 语言函数调用的约定，取走了 <code>filename，argv，envp</code> 等参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int do_execve(</span><br><span class="line">        unsigned long * eip,</span><br><span class="line">        long tmp,</span><br><span class="line">        char * filename,</span><br><span class="line">        char ** argv,</span><br><span class="line">        char ** envp) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体这个函数的详细流程和作用，将在后续文章中讲到。</p>
</details>

<h3 id="fork中进程槽位申请和基本信息的复制"><a href="#fork中进程槽位申请和基本信息的复制" class="headerlink" title="fork中进程槽位申请和基本信息的复制"></a>fork中进程槽位申请和基本信息的复制</h3><p>fork 触发系统调用中断，最终调用到了 sys_fork 函数，这个函数具体做了什么？</p>
<p>还是个汇编代码，但我们要关注的地方不多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_sys_fork:</span><br><span class="line">    call _find_empty_process</span><br><span class="line">    testl %eax,%eax</span><br><span class="line">    js 1f</span><br><span class="line">    push %gs</span><br><span class="line">    pushl %esi</span><br><span class="line">    pushl %edi</span><br><span class="line">    pushl %ebp</span><br><span class="line">    pushl %eax</span><br><span class="line">    call _copy_process</span><br><span class="line">    addl $20,%esp</span><br><span class="line">1:  ret</span><br></pre></td></tr></table></figure>

<p>其实就是调用了两个函数。我们先从方法名直接翻译一下，猜猜意思。</p>
<ul>
<li>先是 find_empty_process，就是找到空闲的进程槽位。</li>
<li>然后 copy_process，就是复制进程。</li>
</ul>
<p>在进程调度初始化<code>sched_init</code>函数中，我们设置了一个存储进程的数据结构 task[64] 数组。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_10.png"></p>
<p>就是先在这个数组中找一个空闲的位置，准备存一个新的进程的结构 task_struct</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">    long state;</span><br><span class="line">    long counter;</span><br><span class="line">    long priority;</span><br><span class="line">    ...</span><br><span class="line">    struct tss_struct tss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个结构各个字段具体赋什么值呢？</p>
<p>通过 copy_process 这个名字我们知道，就是复制原来的进程，也就是当前进程。</p>
<p>当前只有一个进程，就是数组中位置 0 处的 init_task.init，也就是零号进程，那自然就复制它咯。</p>
<h4 id="find-empty-process"><a href="#find-empty-process" class="headerlink" title="find_empty_process"></a>find_empty_process</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">long last_pid = 0;</span><br><span class="line"></span><br><span class="line">int find_empty_process(void) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    repeat:</span><br><span class="line">        if ((++last_pid)&lt;0) last_pid=1;</span><br><span class="line">        for(i=0 ; i&lt;64 ; i++)</span><br><span class="line">            if (task[i] &amp;&amp; task[i]-&gt;pid == last_pid) goto repeat;</span><br><span class="line">    for(i=1 ; i&lt;64; i++)</span><br><span class="line">        if (!task[i])</span><br><span class="line">            return i;</span><br><span class="line">    return -EAGAIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一共三步，很简单:</p>
<ol>
<li>判断 ++last_pid 是不是小于零了，小于零说明已经超过 long 的最大值了，重新赋值为 1，起到一个保护作用，这没什么好说的。</li>
<li>一个 for 循环，看看刚刚的 last_pid 在所有 task[] 数组中，是否已经被某进程占用了。如果被占用了，那就重复执行，再次加一，然后再次判断，直到找到一个 pid 号没有被任何进程用为止。</li>
<li>又是个 for 循环，刚刚已经找到一个可用的 pid 号了，那这一步就是再次遍历这个 task[] 试图找到一个空闲项，找到了就返回素组索引下标。</li>
</ol>
<p>最终，<strong>这个方法就返回 task[] 数组的索引，表示找到了一个空闲项</strong>，之后就开始往这里塞一个新的进程吧。</p>
<p>由于我们现在只有 0 号进程，且 task[] 除了 0 号索引位置，其他地方都是空的，所以这个方法运行完，<strong>last_pid 就是 1，也就是新进程被分配的 pid 就是 1</strong>，然后即将要加入的 task[] 数组的索引位置，也是 1。</p>
<p>好的，那我们接下来就看，怎么构造这个进程结构，塞到这个 1 索引位置的 task[] 中？</p>
<h4 id="copy-process"><a href="#copy-process" class="headerlink" title="copy_process"></a>copy_process</h4><details><summary>先看看源码</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,</span><br><span class="line">        long ebx,long ecx,long edx,</span><br><span class="line">        long fs,long es,long ds,</span><br><span class="line">        long eip,long cs,long eflags,long esp,long ss)</span><br><span class="line">&#123;</span><br><span class="line">    struct task_struct *p;</span><br><span class="line">    int i;</span><br><span class="line">    struct file *f;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p = (struct task_struct *) get_free_page();</span><br><span class="line">    if (!p)</span><br><span class="line">        return -EAGAIN;</span><br><span class="line">    task[nr] = p;</span><br><span class="line">    *p = *current;  /* NOTE! this doesn&#x27;t copy the supervisor stack */</span><br><span class="line">    p-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">    p-&gt;pid = last_pid;</span><br><span class="line">    p-&gt;father = current-&gt;pid;</span><br><span class="line">    p-&gt;counter = p-&gt;priority;</span><br><span class="line">    p-&gt;signal = 0;</span><br><span class="line">    p-&gt;alarm = 0;</span><br><span class="line">    p-&gt;leader = 0;      /* process leadership doesn&#x27;t inherit */</span><br><span class="line">    p-&gt;utime = p-&gt;stime = 0;</span><br><span class="line">    p-&gt;cutime = p-&gt;cstime = 0;</span><br><span class="line">    p-&gt;start_time = jiffies;</span><br><span class="line">    p-&gt;tss.back_link = 0;</span><br><span class="line">    p-&gt;tss.esp0 = PAGE_SIZE + (long) p;</span><br><span class="line">    p-&gt;tss.ss0 = 0x10;</span><br><span class="line">    p-&gt;tss.eip = eip;</span><br><span class="line">    p-&gt;tss.eflags = eflags;</span><br><span class="line">    p-&gt;tss.eax = 0;</span><br><span class="line">    p-&gt;tss.ecx = ecx;</span><br><span class="line">    p-&gt;tss.edx = edx;</span><br><span class="line">    p-&gt;tss.ebx = ebx;</span><br><span class="line">    p-&gt;tss.esp = esp;</span><br><span class="line">    p-&gt;tss.ebp = ebp;</span><br><span class="line">    p-&gt;tss.esi = esi;</span><br><span class="line">    p-&gt;tss.edi = edi;</span><br><span class="line">    p-&gt;tss.es = es &amp; 0xffff;</span><br><span class="line">    p-&gt;tss.cs = cs &amp; 0xffff;</span><br><span class="line">    p-&gt;tss.ss = ss &amp; 0xffff;</span><br><span class="line">    p-&gt;tss.ds = ds &amp; 0xffff;</span><br><span class="line">    p-&gt;tss.fs = fs &amp; 0xffff;</span><br><span class="line">    p-&gt;tss.gs = gs &amp; 0xffff;</span><br><span class="line">    p-&gt;tss.ldt = _LDT(nr);</span><br><span class="line">    p-&gt;tss.trace_bitmap = 0x80000000;</span><br><span class="line">    if (last_task_used_math == current)</span><br><span class="line">        __asm__(&quot;clts ; fnsave %0&quot;::&quot;m&quot; (p-&gt;tss.i387));</span><br><span class="line">    if (copy_mem(nr,p)) &#123;</span><br><span class="line">        task[nr] = NULL;</span><br><span class="line">        free_page((long) p);</span><br><span class="line">        return -EAGAIN;</span><br><span class="line">    &#125;</span><br><span class="line">    for (i=0; i&lt;NR_OPEN;i++)</span><br><span class="line">        if (f=p-&gt;filp[i])</span><br><span class="line">            f-&gt;f_count++;</span><br><span class="line">    if (current-&gt;pwd)</span><br><span class="line">        current-&gt;pwd-&gt;i_count++;</span><br><span class="line">    if (current-&gt;root)</span><br><span class="line">        current-&gt;root-&gt;i_count++;</span><br><span class="line">    if (current-&gt;executable)</span><br><span class="line">        current-&gt;executable-&gt;i_count++;</span><br><span class="line">    set_tss_desc(gdt+(nr&lt;&lt;1)+FIRST_TSS_ENTRY,&amp;(p-&gt;tss));</span><br><span class="line">    set_ldt_desc(gdt+(nr&lt;&lt;1)+FIRST_LDT_ENTRY,&amp;(p-&gt;ldt));</span><br><span class="line">    p-&gt;state = TASK_RUNNING;    /* do this last, just in case */</span><br><span class="line">    return last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>大部分都是 tss 结构的复制，以及一些无关紧要的分支，进行部分简化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int copy_process(int nr, ...) &#123;</span><br><span class="line">    struct task_struct p = </span><br><span class="line">        (struct task_struct *) get_free_page();</span><br><span class="line">    task[nr] = p;</span><br><span class="line">    *p = *current;</span><br><span class="line"></span><br><span class="line">    p-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line">    p-&gt;pid = last_pid;</span><br><span class="line">    p-&gt;counter = p-&gt;priority;</span><br><span class="line">    ..</span><br><span class="line">    p-&gt;tss.edx = edx;</span><br><span class="line">    p-&gt;tss.ebx = ebx;</span><br><span class="line">    p-&gt;tss.esp = esp;</span><br><span class="line">    ...</span><br><span class="line">    copy_mem(nr,p);</span><br><span class="line">    ...</span><br><span class="line">    set_tss_desc(gdt+(nr&lt;&lt;1)+FIRST_TSS_ENTRY,&amp;(p-&gt;tss));</span><br><span class="line">    set_ldt_desc(gdt+(nr&lt;&lt;1)+FIRST_LDT_ENTRY,&amp;(p-&gt;ldt));</span><br><span class="line">    p-&gt;state = TASK_RUNNING;</span><br><span class="line">    return last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数本来就是 fork 的难点了，所以我们慢慢来。</p>
<ol>
<li>首先 get_free_page 会在主内存末端申请一个空闲页面<br> <img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_18.png"><ul>
<li>就是遍历 mem_map[] 这个数组，找出值为零的项，就表示找到了空闲的一页内存。 </li>
<li>然后把该项置为 1，表示该页已经被使用。</li>
<li>最后，算出这个页的内存起始地址，返回。</li>
</ul>
</li>
<li>拿到的这个内存起始地址，给 task_struct 结构的 p。<ul>
<li>自此，一个进程结构 task_struct 就在内存中有了一块空间，但此时还没有赋值具体的字段。</li>
</ul>
</li>
<li>将这个 p 记录在进程管理结构 task[] 中</li>
<li>然后下一句 *p = *current 很简单，<strong>就是把当前进程，也就是 0 号进程的 task_struct 的全部值都复制给即将创建的进程 p</strong>，目前它们两者就完全一样了。<ul>
<li>嗯，这就附上值了，就完全复制之前的进程的 task_struct 而已，很粗暴，最后的内存布局效果就是这样。<br><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_19.png"></li>
</ul>
</li>
<li>进程 1 和进程 0 目前是完全复制的关系，但有一些值是需要个性化处理的，下面的代码就是把这些不一样的值覆盖掉<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int copy_process(int nr, ...) &#123;</span><br><span class="line"> ...</span><br><span class="line"> p-&gt;state = TASK_UNINTERRUPTIBLE;</span><br><span class="line"> p-&gt;pid = last_pid;</span><br><span class="line"> p-&gt;counter = p-&gt;priority;</span><br><span class="line"> ..</span><br><span class="line"> p-&gt;tss.edx = edx;</span><br><span class="line"> p-&gt;tss.ebx = ebx;</span><br><span class="line"> p-&gt;tss.esp = esp;</span><br><span class="line"> ...</span><br><span class="line"> p-&gt;tss.esp0 = PAGE_SIZE + (long) p;</span><br><span class="line"> p-&gt;tss.ss0 = 0x10;</span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>不一样的值，一部分是 state，pid，counter 这种<strong>进程的元信息</strong>，另一部分是 tss 里面保存的各种寄存器的信息，即<strong>上下文</strong>。</li>
<li>这里有两个寄存器的值的赋值有些特殊，就是 ss0 和 esp0，这个表示 0 特权级也就是内核态时的 ss:esp 的指向。 根据代码我们得知，其含义是将代码在内核态时使用的堆栈栈顶指针指向进程 task_struct 所在的 4K 内存页的最顶端，而且之后的每个进程都是这样被设置的。<br><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_20.png"></li>
</ul>
<p>好了，进程槽位的申请，以及基本信息的复制，就讲完了。</p>
<p><strong>就是内存中找个地方存一个 task_struct 结构的东东，并添加到 task[] 数组里的空闲位置处，这个东东的具体字段赋值的大部分都是复制原来进程的</strong>。</p>
<p>接下来将是进程页表和段表的复制，这将会决定进程之间的内存规划问题，很是精彩，也是 fork 真正的难点所在。</p>
<h3 id="fork中进程内存规划的问题-页表和段表的复制"><a href="#fork中进程内存规划的问题-页表和段表的复制" class="headerlink" title="fork中进程内存规划的问题-页表和段表的复制"></a>fork中进程内存规划的问题-页表和段表的复制</h3><p>完成进程槽位申请和基本信息复制后，我们基本已经完成了fork函数的一般，接下来我们展开看看另一半，即copy_mem函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int copy_process(int nr, ...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    copy_mem(nr,p);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将会决定进程之间的内存规划问题，十分精彩。</p>
<p>整个函数不长，我们还是试着先直译一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int copy_mem(int nr,struct task_struct * p) &#123;</span><br><span class="line">    // 局部描述符表 LDT 赋值</span><br><span class="line">    unsigned long old_data_base,new_data_base,data_limit;</span><br><span class="line">    unsigned long old_code_base,new_code_base,code_limit;</span><br><span class="line">    code_limit = get_limit(0x0f);</span><br><span class="line">    data_limit = get_limit(0x17);</span><br><span class="line">    new_code_base = nr * 0x4000000;</span><br><span class="line">    new_data_base = nr * 0x4000000;</span><br><span class="line">    set_base(p-&gt;ldt[1],new_code_base);</span><br><span class="line">    set_base(p-&gt;ldt[2],new_data_base);</span><br><span class="line">    // 拷贝页表</span><br><span class="line">    old_code_base = get_base(current-&gt;ldt[1]);</span><br><span class="line">    old_data_base = get_base(current-&gt;ldt[2]);</span><br><span class="line">    copy_page_tables(old_data_base,new_data_base,data_limit);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是<strong>新进程 LDT 表项的赋值，以及页表的拷贝</strong>。</p>
<h4 id="LDT-的赋值"><a href="#LDT-的赋值" class="headerlink" title="LDT 的赋值"></a>LDT 的赋值</h4><details><summary>我们先回顾一下LDT表项的含义</summary>

<p>程序员给出的逻辑地址最终转化为物理地址要经过这几步骤</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_21.png"></p>
<p>而我们已经开启了分页，那么分页机制的具体转化是这样的。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_22.png"></p>
<p>因为有了页表的存在，所以多了<strong>线性地址空间</strong>的概念，即经过分段机制转化后，分页机制转化前的地址。</p>
<p>不考虑段限长的话，32 位的 CPU 线性地址空间应为 4G。现在只有四个页目录表，也就是将前 16M 的线性地址空间，与 16M 的物理地址空间一一对应起来了。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_23.png"></p>
<p>把这个图和全局描述符表 GDT 联系起来，这个线性地址空间，就是经过分段机制（段可能是 GDT 也可能是 LDT）后的地址，是这样对应的。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_24.png"></p>
</details>

<p>我们给进程 0 准备的 LDT 的代码段和数据段，段基址都是 0，段限长是 640K。<br>给进程 1，也就是我们现在正在 fork 的这个进程，其代码段和数据段还没有设置。</p>
<p>所以第一步，局部描述符表 LDT 的赋值，就是给上图中那两个还未设置的代码段和数据段赋值。</p>
<ul>
<li>其中段限长，就是取自进程 0 设置好的段限长，也就是 640K。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int copy_mem(int nr,struct task_struct * p) &#123;</span><br><span class="line">  ...</span><br><span class="line">  code_limit = get_limit(0x0f);</span><br><span class="line">  data_limit = get_limit(0x17);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>而段基址有点意思，是取决于当前是几号进程，也就是 nr 的值。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int copy_mem(int nr,struct task_struct * p) &#123;</span><br><span class="line">  ...</span><br><span class="line">  new_code_base = nr * 0x4000000;</span><br><span class="line">  new_data_base = nr * 0x4000000;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这里的 0x4000000 等于 64M。</p>
<p>也就是说，今后每个进程通过段基址的手段，分别在线性地址空间中占用 64M 的空间（暂不考虑段限长），且紧挨着。</p>
<p>接着就把 LDT 设置进了 LDT 表里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int copy_mem(int nr,struct task_struct * p) &#123;</span><br><span class="line">    ...</span><br><span class="line">    set_base(p-&gt;ldt[1],new_code_base);</span><br><span class="line">    set_base(p-&gt;ldt[2],new_data_base);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终效果如图</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_25.png"></p>
<p>经过以上的步骤，就通过分段的方式，将进程映射到了相互隔离的线性地址空间里，这就是<strong>段式管理</strong>。</p>
<p>当然，Linux 0.11 不但是分段管理，也开启了分页管理，最终形成段页式的管理方式。这就涉及到下面要说的，页表的复制。</p>
<h4 id="页表的复制"><a href="#页表的复制" class="headerlink" title="页表的复制"></a>页表的复制</h4><p>讲完段表的赋值，接下来就是页表的复制了，这也是 copy_mem 函数里的最后一行代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int copy_mem(int nr,struct task_struct * p) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // old=0, new=64M, limit=640K</span><br><span class="line">    copy_page_tables(old_data_base,new_data_base,data_limit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来进程 0 有<strong>一个页目录表和四个页表</strong>，将线性地址空间的 0-16M 原封不动映射到了物理地址空间的 0-16M。</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_23.png"></p>
<p>那么新诞生的这个进程 2，也需要一套映射关系的页表，那我们看看这些页表是怎么建立的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  Well, here is one of the most complicated functions in mm. It</span><br><span class="line"> * copies a range of linerar addresses by copying only the pages.</span><br><span class="line"> * Let&#x27;s hope this is bug-free, &#x27;cause this one I don&#x27;t want to debug :-)</span><br><span class="line"> */</span><br><span class="line">int copy_page_tables(unsigned long from,unsigned long to,long size)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned long * from_page_table;</span><br><span class="line">    unsigned long * to_page_table;</span><br><span class="line">    unsigned long this_page;</span><br><span class="line">    unsigned long * from_dir, * to_dir;</span><br><span class="line">    unsigned long nr;</span><br><span class="line"></span><br><span class="line">    from_dir = (unsigned long *) ((from&gt;&gt;20) &amp; 0xffc);</span><br><span class="line">    to_dir = (unsigned long *) ((to&gt;&gt;20) &amp; 0xffc);</span><br><span class="line">    size = ((unsigned) (size+0x3fffff)) &gt;&gt; 22;</span><br><span class="line">    for( ; size--&gt;0 ; from_dir++,to_dir++) &#123;</span><br><span class="line">        if (!(1 &amp; *from_dir))</span><br><span class="line">            continue;</span><br><span class="line">        from_page_table = (unsigned long *) (0xfffff000 &amp; *from_dir);</span><br><span class="line">        to_page_table = (unsigned long *) get_free_page()</span><br><span class="line">        *to_dir = ((unsigned long) to_page_table) | 7;</span><br><span class="line">        nr = (from==0)?0xA0:1024;</span><br><span class="line">        for ( ; nr-- &gt; 0 ; from_page_table++,to_page_table++) &#123;</span><br><span class="line">            this_page = *from_page_table;</span><br><span class="line">            if (!(1 &amp; this_page))</span><br><span class="line">                continue;</span><br><span class="line">            this_page &amp;= ~2;</span><br><span class="line">            *to_page_table = this_page;</span><br><span class="line">            if (this_page &gt; LOW_MEM) &#123;</span><br><span class="line">                *from_page_table = this_page;</span><br><span class="line">                this_page -= LOW_MEM;</span><br><span class="line">                this_page &gt;&gt;= 12;</span><br><span class="line">                mem_map[this_page]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    invalidate();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先不讲这个函数，我们先看看注释，注释是 Linus 自己写的，他说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;这部分是内存管理中最复杂的代码，希望这段代码没有错误（bug-free），因为我实在不想调试它！&quot;</span><br></pre></td></tr></table></figure>

<p>回归正题，这个函数要完成什么事情呢？</p>
<p>你想，现在进程 0 的线性地址空间是 0 - 64M，进程 1 的线性地址空间是 64M - 128M。</p>
<p><strong>我们现在要造一个进程 1 的页表，使得进程 1 和进程 0 最终被映射到的物理空间都是 0 - 64M，这样进程 1 才能顺利运行起来。</strong></p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_26.png"></p>
<p>总之，最终的效果就是：</p>
<ul>
<li>假设现在正在运行进程 0，代码中给出一个虚拟地址 0x03，由于进程 0 的 LDT 中代码段基址是 0，所以线性地址也是 0x03，最终由进程 0 页表映射到物理地址 0x03 处。</li>
<li>假设现在正在运行进程 1，代码中给出一个虚拟地址 0x03，由于进程 1 的 LDT 中代码段基址是 64M，所以线性地址是 64M + 3，最终由进程 1 页表映射到物理地址也同样是 0x03 处。</li>
</ul>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_27.png"></p>
<p><strong>即，进程 0 和进程 1 目前共同映射物理内存的前 640K 的空间。</strong></p>
<p>至于如何将不同地址通过不同页表映射到相同物理地址空间，很简单，举个刚刚的例子。</p>
<ul>
<li>刚刚的进程 1 的线性地址 64M + 0x03 用二进制表示是： 0000010000_0000000000_000000000011</li>
<li>刚刚的进程 0 的线性地址 0x03 用二进制表示是： 0000000000_0000000000_000000000011</li>
</ul>
<p>根据分页机制的转化规则，前 10 位表示页目录项，中间 10 位表示页表项，后 12 位表页内偏移。</p>
<ul>
<li>进程 1 要找的是页目录项 16 中的第 0 号页表</li>
<li>进程 0 要找的是页目录项 0 中的第 0 号页表</li>
</ul>
<p>那只要让这俩最终找到的两个页表里的数据一模一样即可。</p>
<p>由于理解起来非常简单，但代码中的计算就非常绕，所以我们就不细致分析代码了，只要理解其最终的作用就好。</p>
<h4 id="将新老进程页表修改为只读"><a href="#将新老进程页表修改为只读" class="headerlink" title="将新老进程页表修改为只读"></a>将新老进程页表修改为只读</h4><p>还记得页表的结构吧？</p>
<p><img src="/2022/06/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AD%A5%E4%B9%8B%E4%B8%80%E4%B8%AA%E6%96%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AF%9E%E7%94%9F/img_28.png"></p>
<p>其中 RW 位表示读写状态</p>
<ul>
<li>0 表示只读（或可执行）</li>
<li>1表示可读写（或可执行）。 </li>
<li>当然，在内核态也就是 0 特权级时，这个标志位是没用的。</li>
</ul>
<p>那我们看下面的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int copy_page_tables(unsigned long from,unsigned long to,long size) &#123;</span><br><span class="line">    ...</span><br><span class="line">    for( ; size--&gt;0 ; from_dir++,to_dir++) &#123;</span><br><span class="line">        ...</span><br><span class="line">        for ( ; nr-- &gt; 0 ; from_page_table++,to_page_table++) &#123;</span><br><span class="line">            ...</span><br><span class="line">            this_page &amp;= ~2;</span><br><span class="line">            ...</span><br><span class="line">            if (this_page &gt; LOW_MEM) &#123;</span><br><span class="line">                *from_page_table = this_page;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>~2 表示取反，2 用二进制表示是 10，取反就是 01，其目的是把 this_page 也就是当前的页表的 RW 位置零，也就是是<strong>把该页变成只读</strong>。</p>
<p>而 *from_page_table = this_page 表示又把<strong>源页表也变成只读</strong>。</p>
<p>也就是说，<strong>经过 fork 创建出的新进程，其页表项都是只读的，而且导致源进程的页表项也变成了只读</strong>。</p>
<p>这个就是写时复制的基础：</p>
<ul>
<li>新老进程一开始共享同一个物理内存空间，如果只有读，那就相安无事</li>
<li>但如果任何一方有写操作，由于页面是只读的，将触发缺页中断，然后就会分配一块新的物理内存给产生写操作的那个进程，此时这一块内存就不再共享了。</li>
</ul>
<h4 id="copy-process总结"><a href="#copy-process总结" class="headerlink" title="copy_process总结"></a>copy_process总结</h4><ol>
<li>封不动复制了一下 task_struct</li>
<li>LDT 的复制和改造，使得进程 0 和进程 1 分别映射到了不同的线性地址空间</li>
<li>页表的复制，使得进程 0 和进程 1 又从不同的线性地址空间，被映射到了相同的物理地址空间</li>
<li>将新老进程的页表都变成只读状态，为后面写时复制的缺页中断做准备</li>
</ol>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/07/19/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%E4%B9%8B%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%90%9E%E5%90%90%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"><i class="fa fa-chevron-left">  </i><span>高并发系统总结之如何设计一个高吞吐的系统概述</span></a></div><div class="next-post pull-right"><a href="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/"><span>操作系统第二步之大战前期的初始化工作</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By 何鹏 [smile.hepeng@qq.com]</div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>