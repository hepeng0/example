<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="操作系统第二步之大战前期的初始化工作"><meta name="keywords" content="操作系统"><meta name="author" content="何鹏 [smile.hepeng@qq.com]"><meta name="copyright" content="何鹏 [smile.hepeng@qq.com]"><title>操作系统第二步之大战前期的初始化工作 | 沉默者</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://unpkg.zhimg.com/font-awesome@4.7.0/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><link rel="alternate" href="/atom.xml" title="沉默者" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E9%81%93%E8%87%B3%E7%AE%80-%E4%BA%8C%E5%8D%81%E5%87%A0%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%8C%E6%88%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.</span> <span class="toc-text">大道至简 二十几行代码完成操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E4%B8%80%E4%BA%9B%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%96%E5%80%BC%E5%92%8C%E8%AE%A1%E7%AE%97%E3%80%82"><span class="toc-number">1.1.</span> <span class="toc-text">第一部分 一些参数的取值和计算。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E5%90%84%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96-init-%E6%93%8D%E4%BD%9C%E3%80%82"><span class="toc-number">1.2.</span> <span class="toc-text">第二部分 各种初始化 init 操作。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E5%88%87%E6%8D%A2%E5%88%B0%E7%94%A8%E6%88%B7%E6%80%81%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%B9%B6%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%AD%E5%81%9A%E4%B8%80%E4%B8%AA%E6%9C%80%E7%BB%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-init%E3%80%82"><span class="toc-number">1.3.</span> <span class="toc-text">第三部分 切换到用户态模式，并在一个新的进程中做一个最终的初始化 init。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.4.</span> <span class="toc-text">第四部分 死循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE-%E5%B7%B2%E5%AE%8C%E6%88%90%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.5.</span> <span class="toc-text">回顾 已完成工作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E5%89%8D%E5%85%88%E5%88%92%E5%88%86%E5%87%BA%E4%B8%89%E4%B8%AA%E8%BE%B9%E7%95%8C%E5%80%BC"><span class="toc-number">2.</span> <span class="toc-text">管理内存前先划分出三个边界值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%86%85%E5%AD%98%E5%8C%BA%E5%88%9D%E5%A7%8B%E5%8C%96-%E7%94%A8%E4%B8%80%E5%BC%A0%E5%A4%A7%E8%A1%A8%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98-mem-init"><span class="toc-number">3.</span> <span class="toc-text">主内存区初始化 - 用一张大表管理内存 - mem_init</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-get-free-page-%E7%94%B3%E8%AF%B7%E7%A9%BA%E9%97%B2%E5%86%85%E5%AD%98%E9%A1%B5"><span class="toc-number">3.1.</span> <span class="toc-text">通过 get_free_page() 申请空闲内存页</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%88%9D%E5%A7%8B%E5%8C%96-%E9%94%AE%E7%9B%98%E6%98%AF%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BC%80%E5%A7%8B%E7%94%9F%E6%95%88%E7%9A%84-trap-init"><span class="toc-number">4.</span> <span class="toc-text">中断初始化 - 键盘是什么时候开始生效的 - trap_init</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#trap-init"><span class="toc-number">4.1.</span> <span class="toc-text">trap_init()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-trap-gate-amp-set-system-gate"><span class="toc-number">4.2.</span> <span class="toc-text">set_trap_gate &amp; set_system_gate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E4%B8%AD%E6%96%AD%E8%AE%BE%E7%BD%AE"><span class="toc-number">4.3.</span> <span class="toc-text">键盘中断设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E7%94%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">4.4.</span> <span class="toc-text">启用中断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E8%AE%BE%E5%A4%87%E8%AF%B7%E6%B1%82%E9%A1%B9%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-%E8%AF%BB%E5%8F%96%E5%9D%97%E8%AE%BE%E5%A4%87%E4%B8%8E%E5%86%85%E5%AD%98%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E6%A1%A5%E6%A2%81-blk-dev-init"><span class="toc-number">5.</span> <span class="toc-text">块设备请求项的初始化 - 读取块设备与内存缓冲区之间的桥梁 - blk_dev_init</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-request-32"><span class="toc-number">5.1.</span> <span class="toc-text">初始化 request[32]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#request-32-%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">request[32] 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-request-32-%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E8%AF%BB%E7%9B%98"><span class="toc-number">5.3.</span> <span class="toc-text">如何使用 request[32] 结构 - 数据读盘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%88%9D%E5%A7%8B%E5%8C%96-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B1%8F%E5%B9%95%E4%B8%8A%E5%B0%B1%E4%BC%9A%E6%9C%89%E8%BE%93%E5%87%BA-tty-init"><span class="toc-number">6.</span> <span class="toc-text">控制台初始化 - 为什么屏幕上就会有输出 - tty_init</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E4%B8%8E%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">串口中断与显示模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E6%98%AF%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%9A%84%E5%91%A2"><span class="toc-number">6.2.</span> <span class="toc-text">一个字符是如何显示在屏幕上的呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E6%95%B2%E5%87%BB%E5%A6%82%E4%BD%95%E6%98%BE%E7%A4%BA%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%8A"><span class="toc-number">6.3.</span> <span class="toc-text">键盘敲击如何显示在屏幕上</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8D%A2%E8%A1%8C%E6%95%88%E6%9E%9C"><span class="toc-number">6.3.1.</span> <span class="toc-text">换行效果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%9A%E5%B1%8F"><span class="toc-number">6.3.2.</span> <span class="toc-text">滚屏</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">6.4.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4"><span class="toc-number">7.</span> <span class="toc-text">时间初始化 操作系统如何获取当前时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CMOS-READ"><span class="toc-number">7.1.</span> <span class="toc-text">CMOS_READ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BCD-TO-BIN"><span class="toc-number">7.2.</span> <span class="toc-text">BCD_TO_BIN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kernel-mktime"><span class="toc-number">7.3.</span> <span class="toc-text">kernel_mktime</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">进程调度初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%86%E4%B8%8B-TSS-%E5%92%8C-LDT-%E7%BA%BF%E7%A8%8B0"><span class="toc-number">8.1.</span> <span class="toc-text">初始化了下 TSS 和 LDT (线程0)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ltr-amp-lldt"><span class="toc-number">8.2.</span> <span class="toc-text">ltr &amp; lldt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E7%BC%96%E7%A8%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="toc-number">8.3.</span> <span class="toc-text">可编程定时器与中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">8.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%9D%E5%A7%8B%E5%8C%96-%E4%B8%BB%E5%86%85%E5%AD%98%E5%A4%96%E7%9A%84%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">缓冲区初始化 主内存外的另一个内存管理神器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E9%93%BE%E6%8E%A5%E5%99%A8-ld-%E8%8E%B7%E5%8F%96%E7%BC%93%E5%86%B2%E5%8C%BA%E5%BC%80%E5%A7%8B%E4%BD%8D%E7%BD%AE"><span class="toc-number">9.1.</span> <span class="toc-text">通过链接器 ld 获取缓冲区开始位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">9.2.</span> <span class="toc-text">两个内存管理结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96%E6%9F%A5%E8%AF%A2"><span class="toc-number">9.3.</span> <span class="toc-text">通过 哈希表 + 双向链表 进一步优化查询</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img2.baidu.com/it/u=928705063,3876627980&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg"></div><div class="author-info__name text-center">何鹏 [smile.hepeng@qq.com]</div><div class="author-info__description text-center">路漫漫其修远兮，吾将上下而求索</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">65</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">52</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默者</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">操作系统第二步之大战前期的初始化工作</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-05-18</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">15.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 56 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h3 id="大道至简-二十几行代码完成操作系统"><a href="#大道至简-二十几行代码完成操作系统" class="headerlink" title="大道至简 二十几行代码完成操作系统"></a>大道至简 二十几行代码完成操作系统</h3><p>在第一部分，我们完成了进入 main 方法前的苦力工作，我们的程序终于跳到第一个由 c 语言写的，也是操作系统的全部代码骨架的地方，就是 main.c 文件里的 main 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line">    drive_info = DRIVE_INFO;</span><br><span class="line">    memory_end = (1&lt;&lt;20) + (EXT_MEM_K&lt;&lt;10);</span><br><span class="line">    memory_end &amp;= 0xfffff000;</span><br><span class="line">    if (memory_end &gt; 16*1024*1024)</span><br><span class="line">    memory_end = 16*1024*1024;</span><br><span class="line">    if (memory_end &gt; 12*1024*1024)</span><br><span class="line">    buffer_memory_end = 4*1024*1024;</span><br><span class="line">    else if (memory_end &gt; 6*1024*1024)</span><br><span class="line">    buffer_memory_end = 2*1024*1024;</span><br><span class="line">    else</span><br><span class="line">    buffer_memory_end = 1*1024*1024;</span><br><span class="line">    main_memory_start = buffer_memory_end;</span><br><span class="line"></span><br><span class="line">    mem_init(main_memory_start,memory_end);</span><br><span class="line">    trap_init();</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    sched_init();</span><br><span class="line">    buffer_init(buffer_memory_end);</span><br><span class="line">    hd_init();</span><br><span class="line">    floppy_init();</span><br><span class="line"></span><br><span class="line">    sti();</span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    if (!fork()) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数一数看，总共也就 20 几行代码。</p>
<p>但这的确是操作系统启动流程的全部秘密了，我用空格将这个代码分成了几个部分。</p>
<h4 id="第一部分-一些参数的取值和计算。"><a href="#第一部分-一些参数的取值和计算。" class="headerlink" title="第一部分 一些参数的取值和计算。"></a>第一部分 一些参数的取值和计算。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line">    drive_info = DRIVE_INFO;</span><br><span class="line">    memory_end = (1&lt;&lt;20) + (EXT_MEM_K&lt;&lt;10);</span><br><span class="line">    memory_end &amp;= 0xfffff000;</span><br><span class="line">    if (memory_end &gt; 16*1024*1024)</span><br><span class="line">        memory_end = 16*1024*1024;</span><br><span class="line">    if (memory_end &gt; 12*1024*1024)</span><br><span class="line">        buffer_memory_end = 4*1024*1024;</span><br><span class="line">    else if (memory_end &gt; 6*1024*1024)</span><br><span class="line">        buffer_memory_end = 2*1024*1024;</span><br><span class="line">    else</span><br><span class="line">        buffer_memory_end = 1*1024*1024;</span><br><span class="line">    main_memory_start = buffer_memory_end;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包括<strong>根设备 ROOT_DEV</strong>，之前在汇编语言中获取的各个设备的<strong>参数信息 drive_info</strong>，以及通过计算得到的<strong>内存边界</strong></p>
<ul>
<li>main_memory_start</li>
<li>main_memory_end</li>
<li>buffer_memory_start</li>
<li>buffer_memory_end</li>
</ul>
<p>从哪获得之前的设备参数信息呢？</p>
<p>如果你前面看了，那一定还记得这个表，都是由 setup.s 这个汇编程序调用 BIOS 中断获取的各个设备的信息，并保存在约定好的内存地址 0x90000 处，现在这不就来取了么。</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>长度(字节)</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>0x90000</td>
<td>2</td>
<td>光标位置</td>
</tr>
<tr>
<td>0x90002</td>
<td>2</td>
<td>扩展内存数</td>
</tr>
<tr>
<td>0x90004</td>
<td>2</td>
<td>显示页面</td>
</tr>
<tr>
<td>0x90006</td>
<td>1</td>
<td>显示模式</td>
</tr>
<tr>
<td>0x90007</td>
<td>1</td>
<td>字符列数</td>
</tr>
<tr>
<td>0x90008</td>
<td>2</td>
<td>未知</td>
</tr>
<tr>
<td>0x9000A</td>
<td>1</td>
<td>显示内存</td>
</tr>
<tr>
<td>0x9000B</td>
<td>1</td>
<td>显示状态</td>
</tr>
<tr>
<td>0x9000C</td>
<td>2</td>
<td>显卡特性参数</td>
</tr>
<tr>
<td>0x9000E</td>
<td>1</td>
<td>屏幕行数</td>
</tr>
<tr>
<td>0x9000F</td>
<td>1</td>
<td>屏幕列数</td>
</tr>
<tr>
<td>0x90080</td>
<td>16</td>
<td>硬盘1参数表</td>
</tr>
<tr>
<td>0x90090</td>
<td>16</td>
<td>硬盘2参数表</td>
</tr>
<tr>
<td>0x901FC</td>
<td>2</td>
<td>根设备号</td>
</tr>
</tbody></table>
<h4 id="第二部分-各种初始化-init-操作。"><a href="#第二部分-各种初始化-init-操作。" class="headerlink" title="第二部分 各种初始化 init 操作。"></a>第二部分 各种初始化 init 操作。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mem_init(main_memory_start,memory_end);</span><br><span class="line">    trap_init();</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    sched_init();</span><br><span class="line">    buffer_init(buffer_memory_end);</span><br><span class="line">    hd_init();</span><br><span class="line">    floppy_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包括<strong>内存初始化 mem_init</strong>，<strong>中断初始化 trap_init</strong>、<strong>进程调度初始化 sched_init</strong> 等等。</p>
<p>我们知道学操作系统知识的时候，其实就分成这么几块来学的，看来在操作系统源码上看，也确实是这么划分的，那我们之后照着源码慢慢品，就好了。</p>
<h4 id="第三部分-切换到用户态模式，并在一个新的进程中做一个最终的初始化-init。"><a href="#第三部分-切换到用户态模式，并在一个新的进程中做一个最终的初始化-init。" class="headerlink" title="第三部分 切换到用户态模式，并在一个新的进程中做一个最终的初始化 init。"></a>第三部分 切换到用户态模式，并在一个新的进程中做一个最终的初始化 init。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    sti();</span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    if (!fork()) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 init 函数里会创建出一个进程，设置终端的标准 IO，并且再创建出一个执行 shell 程序的进程用来接受用户的命令，到这里其实就出现了我们熟悉的画面（下面是 bochs 启动 Linux 0.11 后的画面）。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img.png"></p>
<h4 id="第四部分-死循环"><a href="#第四部分-死循环" class="headerlink" title="第四部分 死循环"></a>第四部分 死循环</h4><p>如果没有任何任务可以运行，操作系统会一直陷入这个死循环无法自拔。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    for(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，不要细品每一句话，我们本回就是要你有个整体印象，之后会细细讲这里的每一个部分。</p>
<h4 id="回顾-已完成工作"><a href="#回顾-已完成工作" class="headerlink" title="回顾 已完成工作"></a>回顾 已完成工作</h4><p>这里再放上目前的内存布局图。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_1.png"></p>
<p>这个图大家一定要牢记在心，操作系统说白了就是在内存中放置各种的数据结构，来实现“管理”的功能。</p>
<p>所以之后我们的学习过程，主心骨其实就是看看，操作系统在经过一番折腾后，又在内存中建立了什么数据结构，而这些数据结构后面又是如何用到的。</p>
<p>比如进程管理，就是在内存中建立好多复杂的数据结构用来记录进程的信息，再配合上进程调度的小算法，完成了进程这个强大的功能。</p>
<p>为了让大家目前心里有个底，我们把前面的工作再再再再在这里做一个回顾，用一张图表示就是：</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_2.png"></p>
<p>看到了吧，我们已经把 boot 文件夹下的三个汇编文件的全部代码都一行一行品读过了，其主要功能就是三张表的设置：</p>
<ul>
<li>全局描述符表</li>
<li>中断描述符表</li>
<li>页表</li>
</ul>
<p>同时还设置了各种段寄存器，栈顶指针。</p>
<p>并且，还为后续的程序提供了设备信息，保存在 0x90000 处往后的几个位置上。</p>
<p>最后，一个华丽的跳转，将程序跳转到了 main.c 文件里的 main 函数中。</p>
<h3 id="管理内存前先划分出三个边界值"><a href="#管理内存前先划分出三个边界值" class="headerlink" title="管理内存前先划分出三个边界值"></a>管理内存前先划分出三个边界值</h3><p>还是把 main 的全部代码都先写出来，很少</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line"></span><br><span class="line">    ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line">    drive_info = DRIVE_INFO;</span><br><span class="line">    memory_end = (1&lt;&lt;20) + (EXT_MEM_K&lt;&lt;10);</span><br><span class="line">    memory_end &amp;= 0xfffff000;</span><br><span class="line">    if (memory_end &gt; 16*1024*1024)</span><br><span class="line">        memory_end = 16*1024*1024;</span><br><span class="line">    if (memory_end &gt; 12*1024*1024) </span><br><span class="line">        buffer_memory_end = 4*1024*1024;</span><br><span class="line">    else if (memory_end &gt; 6*1024*1024)</span><br><span class="line">        buffer_memory_end = 2*1024*1024;</span><br><span class="line">    else</span><br><span class="line">        buffer_memory_end = 1*1024*1024;</span><br><span class="line">    main_memory_start = buffer_memory_end;</span><br><span class="line"></span><br><span class="line">    mem_init(main_memory_start,memory_end);</span><br><span class="line">    trap_init();</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    sched_init();</span><br><span class="line">    buffer_init(buffer_memory_end);</span><br><span class="line">    hd_init();</span><br><span class="line">    floppy_init();</span><br><span class="line"></span><br><span class="line">    sti();</span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    if (!fork()) &#123;      /* we count on this going ok */</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们今天就看这第一小段。</p>
<p>首先，ROOT_DEV 为系统的根文件设备号，drive_info 为之前 setup.s 程序获取并存储在内存 0x90000 处的设备信息，我们先不管这俩，等之后用到了再说。</p>
<p>我们看后面这一坨很影响整体画风的一段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    memory_end = (1&lt;&lt;20) + (EXT_MEM_K&lt;&lt;10);</span><br><span class="line">    memory_end &amp;= 0xfffff000;</span><br><span class="line">    if (memory_end &gt; 16*1024*1024)</span><br><span class="line">        memory_end = 16*1024*1024;</span><br><span class="line">    if (memory_end &gt; 12*1024*1024) </span><br><span class="line">        buffer_memory_end = 4*1024*1024;</span><br><span class="line">    else if (memory_end &gt; 6*1024*1024)</span><br><span class="line">        buffer_memory_end = 2*1024*1024;</span><br><span class="line">    else</span><br><span class="line">        buffer_memory_end = 1*1024*1024;</span><br><span class="line">    main_memory_start = buffer_memory_end;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一坨代码和后面规规整整的 xxx_init 平级的位置，要是我们这么写代码，肯定被老板批评，被同事鄙视了。但 Linus 写的，就是经典，学就完事了。</p>
<p>这一坨代码虽然很乱，但仔细看就知道它只是为了计算出三个变量罢了。</p>
<ul>
<li>main_memory_start</li>
<li>memory_end</li>
<li>buffer_memory_end</li>
</ul>
<p>而观察最后一行代码发现，其实两个变量是相等的，所以其实仅仅计算出了两个变量。</p>
<ul>
<li>main_memory_start</li>
<li>memory_end</li>
</ul>
<p>然后再具体分析这个逻辑，其实就是一堆 if else 判断而已，判断的标准都是 memory_end 也就是内存最大值的大小，而这个内存最大值由第一行代码可以看出，是等于 1M + 扩展内存大小。</p>
<p>那 ok 了，其实就只是<strong>针对不同的内存大小，设置不同的边界值</strong>罢了，为了理解它，我们完全没必要考虑这么周全，就假设总内存一共就 8M 大小吧。</p>
<p>那么如果内存为 8M 大小，memory_end 就是 8 * 1024 * 1024，也就只会走倒数第二个分支，那么 buffer_memory_end 就为 2 * 1024 * 1024， 那么 main_memory_start<br>也为 2 * 1024 * 1024</p>
<p>那这些值有什么用呢？一张图就给你说明白了。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_3.png"></p>
<p>你看，其实就是定了三个箭头所指向的地址的三个边界变量。</p>
<h3 id="主内存区初始化-用一张大表管理内存-mem-init"><a href="#主内存区初始化-用一张大表管理内存-mem-init" class="headerlink" title="主内存区初始化 - 用一张大表管理内存 - mem_init"></a>主内存区初始化 - 用一张大表管理内存 - mem_init</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mem_init(main_memory_start, memory_end);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入 mem_init 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define LOW_MEM 0x100000</span><br><span class="line">#define PAGING_MEMORY (15*1024*1024)</span><br><span class="line">#define PAGING_PAGES (PAGING_MEMORY&gt;&gt;12)</span><br><span class="line">#define MAP_NR(addr) (((addr)-LOW_MEM)&gt;&gt;12)</span><br><span class="line">#define USED 100</span><br><span class="line"></span><br><span class="line">static long HIGH_MEMORY = 0;</span><br><span class="line">static unsigned char mem_map[PAGING_PAGES] = &#123; 0, &#125;;</span><br><span class="line"></span><br><span class="line">// start_mem = 2 * 1024 * 1024</span><br><span class="line">// end_mem = 8 * 1024 * 1024</span><br><span class="line">void mem_init(long start_mem, long end_mem)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    HIGH_MEMORY = end_mem;</span><br><span class="line">    for (i=0 ; i&lt;PAGING_PAGES ; i++)</span><br><span class="line">        mem_map[i] = USED;</span><br><span class="line">    i = MAP_NR(start_mem);</span><br><span class="line">    end_mem -= start_mem;</span><br><span class="line">    end_mem &gt;&gt;= 12;</span><br><span class="line">    while (end_mem--&gt;0)</span><br><span class="line">        mem_map[i++]=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现也没几行，而且并没有更深的方法调用，看来是个好欺负的方法。</p>
<p>仔细一看这个方法，其实折腾来折腾去，就是给一个 <strong>mem_map</strong> 数组的各个位置上赋了值，而且显示全部赋值为 USED 也就是 100，然后对其中一部分又赋值为了 0。</p>
<p>是不是很简单？就是<strong>准备了一个表，记录了哪些内存被占用了，哪些内存没被占用</strong>。这就是所谓的“管理”，并没有那么神乎其神。</p>
<p>那接下来自然有两个问题，每个元素表示占用和未占用，这个表示的范围是多大？初始化时哪些地方是占用的，哪些地方又是未占用的？</p>
<p>还是一张图就看明白了，我们仍然假设内存总共只有 8M。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_4.png"></p>
<p>可以看出，初始化完成后，其实就是 mem_map 这个数组的每个元素都代表一个 4K 内存是否空闲（准确说是使用次数）。</p>
<p>4K 内存通常叫做 1 页内存，而这种管理方式叫<strong>分页管理</strong>，就是把内存分成一页一页（4K）的单位去管理。</p>
<p>1M 以下的内存这个数组干脆没有记录，这里的内存是无需管理的，或者换个说法是无权管理的，也就是没有权利申请和释放，因为这个区域是内核代码所在的地方，不能被“污染”。</p>
<p>1M 到 2M 这个区间是<strong>缓冲区</strong>，2M 是缓冲区的末端，缓冲区的开始在哪里之后再说，这些地方不是主内存区域，因此直接标记为 USED，产生的效果就是无法再被分配了。</p>
<p>2M 以上的空间是<strong>主内存区域</strong>，而主内存目前没有任何程序申请，所以初始化时统统都是零，未来等着应用程序去申请和释放这里的内存资源。</p>
<h4 id="通过-get-free-page-申请空闲内存页"><a href="#通过-get-free-page-申请空闲内存页" class="headerlink" title="通过 get_free_page() 申请空闲内存页"></a>通过 get_free_page() 申请空闲内存页</h4><p>在 memory.c 文件中有个函数 get_free_page()，用于在主内存区中申请一页空闲内存页，并返回物理内存页的起始地址</p>
<p>比如我们在 fork 子进程的时候，会调用 <strong>copy_process</strong> 函数来复制进程的结构信息，其中有一个步骤就是要<strong>申请一页内存</strong>，用于存放进程结构信息 task_struct。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int copy_process(...) &#123;</span><br><span class="line">    struct task_struct *p;</span><br><span class="line">    ...</span><br><span class="line">    p = (struct task_struct *) get_free_page();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看 get_free_page 的具体实现，是内联汇编代码，看不懂不要紧，注意它里面就有 mem_map 结构的使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">unsigned long get_free_page(void) &#123;</span><br><span class="line">    register unsigned long __res asm(&quot;ax&quot;);</span><br><span class="line">    __asm__(</span><br><span class="line">        &quot;std ; repne ; scasb\n\t&quot;</span><br><span class="line">        &quot;jne 1f\n\t&quot;</span><br><span class="line">        &quot;movb $1,1(%%edi)\n\t&quot;</span><br><span class="line">        &quot;sall $12,%%ecx\n\t&quot;</span><br><span class="line">        &quot;addl %2,%%ecx\n\t&quot;</span><br><span class="line">        &quot;movl %%ecx,%%edx\n\t&quot;</span><br><span class="line">        &quot;movl $1024,%%ecx\n\t&quot;</span><br><span class="line">        &quot;leal 4092(%%edx),%%edi\n\t&quot;</span><br><span class="line">        &quot;rep ; stosl\n\t&quot;</span><br><span class="line">        &quot;movl %%edx,%%eax\n&quot;</span><br><span class="line">        &quot;1:&quot;</span><br><span class="line">        :&quot;=a&quot; (__res)</span><br><span class="line">        :&quot;0&quot; (0),&quot;i&quot; (LOW_MEM),&quot;c&quot; (PAGING_PAGES),</span><br><span class="line">        &quot;D&quot; (mem_map + PAGING_PAGES-1)</span><br><span class="line">        :&quot;di&quot;,&quot;cx&quot;,&quot;dx&quot;);</span><br><span class="line">    return __res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是选择 mem_map 中首个空闲页面，并标记为已使用。</p>
<p>之后的内存申请与释放等骚操作，统统是跟着张大表 mem_map 打交道而已。</p>
<h3 id="中断初始化-键盘是什么时候开始生效的-trap-init"><a href="#中断初始化-键盘是什么时候开始生效的-trap-init" class="headerlink" title="中断初始化 - 键盘是什么时候开始生效的 - trap_init"></a>中断初始化 - 键盘是什么时候开始生效的 - trap_init</h3><p>当你的计算机刚刚启动时，你按下键盘是不生效的，但是过了一段时间后，再按下键盘就有效果了。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/_posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_5.png" alt="img_5.png"></p>
<p>那我们今天就来刨根问底一下，<strong>到底过了多久之后，按下键盘才有效果呢</strong>？</p>
<p>当然首先你得知道，按下键盘后会触发中断，CPU 收到你的键盘中断后，根据中断号，寻找由操作系统写好的键盘中断处理程序。</p>
<p>这个中断处理程序会把你的键盘码放入一个队列中，由相应的用户程序或内核程序读取，并显示在控制台，或者其他用途，这就代表你的键盘生效了。</p>
<p>不过放宽心，我们不展开讲这个中断处理程序以及用户程序读取键盘码后的处理细节，我们把关注点放在，究竟是“<strong>什么时候</strong>”，按下键盘才会有这个效果。</p>
<h4 id="trap-init"><a href="#trap-init" class="headerlink" title="trap_init()"></a>trap_init()</h4><p>进入内核的 main 函数后不久，有这样一行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    trap_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这个方法的全部代码后，你可能会会心一笑，也可能一脸懵逼。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void trap_init(void) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    set_trap_gate(0,&amp;divide_error);</span><br><span class="line">    set_trap_gate(1,&amp;debug);</span><br><span class="line">    set_trap_gate(2,&amp;nmi);</span><br><span class="line">    set_system_gate(3,&amp;int3);   /* int3-5 can be called from all */</span><br><span class="line">    set_system_gate(4,&amp;overflow);</span><br><span class="line">    set_system_gate(5,&amp;bounds);</span><br><span class="line">    set_trap_gate(6,&amp;invalid_op);</span><br><span class="line">    set_trap_gate(7,&amp;device_not_available);</span><br><span class="line">    set_trap_gate(8,&amp;double_fault);</span><br><span class="line">    set_trap_gate(9,&amp;coprocessor_segment_overrun);</span><br><span class="line">    set_trap_gate(10,&amp;invalid_TSS);</span><br><span class="line">    set_trap_gate(11,&amp;segment_not_present);</span><br><span class="line">    set_trap_gate(12,&amp;stack_segment);</span><br><span class="line">    set_trap_gate(13,&amp;general_protection);</span><br><span class="line">    set_trap_gate(14,&amp;page_fault);</span><br><span class="line">    set_trap_gate(15,&amp;reserved);</span><br><span class="line">    set_trap_gate(16,&amp;coprocessor_error);</span><br><span class="line">    for (i=17;i&lt;48;i++)</span><br><span class="line">        set_trap_gate(i,&amp;reserved);</span><br><span class="line">    set_trap_gate(45,&amp;irq13);</span><br><span class="line">    set_trap_gate(39,&amp;parallel_interrupt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给他简化一下, 把相同功能的去掉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void trap_init(void) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    // set 了一堆 trap_gate</span><br><span class="line">    set_trap_gate(0, &amp;divide_error);</span><br><span class="line">    ... </span><br><span class="line">    // 又 set 了一堆 system_gate</span><br><span class="line">    set_system_gate(45, &amp;bounds);</span><br><span class="line">    ...</span><br><span class="line">    // 又又批量 set 了一堆 trap_gate</span><br><span class="line">    for (i=17;i&lt;48;i++)</span><br><span class="line">        set_trap_gate(i, &amp;reserved);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="set-trap-gate-amp-set-system-gate"><a href="#set-trap-gate-amp-set-system-gate" class="headerlink" title="set_trap_gate &amp; set_system_gate"></a>set_trap_gate &amp; set_system_gate</h4><p>首先我们看 set_trap_gate 和 set_system_gate 这俩货，发现了这么几个宏定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define _set_gate(gate_addr,type,dpl,addr) \</span><br><span class="line">__asm__ (&quot;movw %%dx,%%ax\n\t&quot; \</span><br><span class="line">    &quot;movw %0,%%dx\n\t&quot; \</span><br><span class="line">    &quot;movl %%eax,%1\n\t&quot; \</span><br><span class="line">    &quot;movl %%edx,%2&quot; \</span><br><span class="line">    : \</span><br><span class="line">    : &quot;i&quot; ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \</span><br><span class="line">    &quot;o&quot; (*((char *) (gate_addr))), \</span><br><span class="line">    &quot;o&quot; (*(4+(char *) (gate_addr))), \</span><br><span class="line">    &quot;d&quot; ((char *) (addr)),&quot;a&quot; (0x00080000))</span><br><span class="line"></span><br><span class="line">#define set_trap_gate(n,addr) \</span><br><span class="line">    _set_gate(&amp;idt[n],15,0,addr)</span><br><span class="line"></span><br><span class="line">#define set_system_gate(n,addr) \</span><br><span class="line">    _set_gate(&amp;idt[n],15,3,addr)</span><br></pre></td></tr></table></figure>

<p>不过这俩都是最终指向了相同的另一个宏定义 _set_gate，说明是有共性的。</p>
<p>啥共性呢？我直接说吧，那段你完全看不懂的代码，是将汇编语言嵌入到 c 语言了，最终的效果就是</p>
<p><strong>在中断描述符表中插入了一个中断描述符</strong>。</p>
<p>中断描述符表还记得吧，英文叫 idt。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_6.png"></p>
<p>这段代码就是往这个 idt 表里一项一项地写东西，其对应的中断号就是第一个参数，中断处理程序就是第二个参数。</p>
<p>产生的效果就是，之后如果来一个中断后，CPU 根据其中断号，就可以到这个中断描述符表 idt 中找到对应的中断处理程序了。</p>
<p>比如这个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_trap_gate(0,&amp;divide_error);</span><br></pre></td></tr></table></figure>

<p>就是设置 0 号中断，对应的中断处理程序是 divide_error。</p>
<p>等 CPU 执行了一条除零指令的时候，会从硬件层面发起一个 0 号异常中断，然后执行由我们操作系统定义的 divide_error 也就是除法异常处理程序，执行完之后再返回。</p>
<p>再比如这个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_system_gate(5,&amp;overflow);</span><br></pre></td></tr></table></figure>

<p>就是设置 5 号中断，对应的中断处理程序是 overflow，是边界出错中断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIPS：这个 system 与 trap 的区别仅仅在于，设置的中断描述符的特权级不同，前者是 0（内核态），后者是 3（用户态），这块展开将会是非常严谨的、绕口的、复杂的特权级相关的知识，不明白的话先不用管，就理解为都是设置一个中断号和中断处理程序的对应关系就好了。</span><br></pre></td></tr></table></figure>

<p>再往后看，批量操作这里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void trap_init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    for (i=17;i&lt;48;i++)</span><br><span class="line">        set_trap_gate(i,&amp;reserved);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>17 到 48 号中断都批量设置为了 reserved 函数，这是暂时的，后面各个硬件初始化时要重新设置好这些中断，把暂时的这个给覆盖掉，此时你留个印象。</p>
<p>所以整段代码执行下来，内存中那个 idt 的位置会变成如下的样子。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_7.png"></p>
<p>好了，我们看到了设置中断号与中断处理程序对应的地方，那这行代码过去后，键盘好使了么？</p>
<p><strong>NO</strong></p>
<p>键盘产生的中断的中断号是 0x21，此时这个中断号还仅仅对应着一个临时的中断处理程序 &amp;reserved，我们接着往后看。</p>
<h4 id="键盘中断设置"><a href="#键盘中断设置" class="headerlink" title="键盘中断设置"></a>键盘中断设置</h4><p>在这行代码往后几行，还有这么一行代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    trap_init();</span><br><span class="line">    ...</span><br><span class="line">    tty_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tty_init(void) &#123;</span><br><span class="line">    rs_init();</span><br><span class="line">    con_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void con_init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    set_trap_gate(0x21,&amp;keyboard_interrupt);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到 trap_init 后有个 tty_init，最后根据调用链，会调用到一行添加 0x21 号中断处理程序的代码，就是刚刚熟悉的 set_trap_gate。</p>
<p>而后面的 keyboard_interrupt 根据名字也可以猜出，就是键盘的中断处理程序嘛！</p>
<p>就是从这一行代码开始，我们的键盘生效了！</p>
<h4 id="启用中断"><a href="#启用中断" class="headerlink" title="启用中断"></a>启用中断</h4><p>不过还有点小问题，不过不重要，就是我们现在的中断处于<strong>禁用状态</strong>，不论是键盘中断还是其他中断，通通都不好使。</p>
<p>而 main 方法继续往下读，还有一行这个东西。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    trap_init();</span><br><span class="line">    ...</span><br><span class="line">    tty_init();</span><br><span class="line">    ...</span><br><span class="line">    sti();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sti 最终会对应一个同名的汇编指令 sti，表示允许中断。所以这行代码之后，键盘才真正开始生效！</p>
<h3 id="块设备请求项的初始化-读取块设备与内存缓冲区之间的桥梁-blk-dev-init"><a href="#块设备请求项的初始化-读取块设备与内存缓冲区之间的桥梁-blk-dev-init" class="headerlink" title="块设备请求项的初始化 - 读取块设备与内存缓冲区之间的桥梁 - blk_dev_init"></a>块设备请求项的初始化 - 读取块设备与内存缓冲区之间的桥梁 - blk_dev_init</h3><p>读取硬盘数据到内存中，是操作系统的一个基础功能。</p>
<p>读取硬盘需要有块设备驱动程序，而以文件的方式来读取则还有要再上面包一层文件系统。</p>
<p>把读出来的数据放到内存，就涉及到内存中缓冲区的管理。</p>
<p>上面说的每一件事，都是一个十分庞大的体系，先不展开叙述，先梳理读取块设备与内存缓冲区之间的桥梁，<strong>块设备请求项</strong>的初始化工作。</p>
<h4 id="初始化-request-32"><a href="#初始化-request-32" class="headerlink" title="初始化 request[32]"></a>初始化 request[32]</h4><p>进入内核的 main 函数后不久，有这样一行代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这个方法的全部代码后，你可能会会心一笑，也可能一脸懵逼。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void blk_dev_init(void) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;</span><br><span class="line">        request[i].dev = -1;</span><br><span class="line">        request[i].next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是给 request 这个数组的前 32 个元素的两个变量 dev 和 next 附上值，看这俩值 -1 和 NULL 也可以大概猜出，这是没有任何作用时的初始化值。</p>
<h4 id="request-32-结构"><a href="#request-32-结构" class="headerlink" title="request[32] 结构"></a>request[32] 结构</h4><p>我们看下 request 结构体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Ok, this is an expanded form so that we can use the same</span><br><span class="line"> * request for paging requests when that is implemented. In</span><br><span class="line"> * paging, &#x27;bh&#x27; is NULL, and &#x27;waiting&#x27; is used to wait for</span><br><span class="line"> * read/write completion.</span><br><span class="line"> */</span><br><span class="line">struct request &#123;</span><br><span class="line">    int dev;        /* -1 if no request */</span><br><span class="line">    int cmd;        /* READ or WRITE */</span><br><span class="line">    int errors;</span><br><span class="line">    unsigned long sector;</span><br><span class="line">    unsigned long nr_sectors;</span><br><span class="line">    char * buffer;</span><br><span class="line">    struct task_struct * waiting;</span><br><span class="line">    struct buffer_head * bh;</span><br><span class="line">    struct request * next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>哎哟，这就有点头大了，刚刚的函数虽然很短，但看到这个结构体我们知道了，重点在这呢。</p>
<p>这也侧面说明了，学习操作系统，其实把遇到的重要数据结构牢记心中，就已经成功一半了。比如主内存管理结构 mem_map，知道它的数据结构是什么样子，其功能也基本就懂了。</p>
<p>收，继续说这个 request 结构，这个结构就代表了一次读盘请求，其中：</p>
<ul>
<li>dev 表示设备号，-1 就表示空闲。</li>
<li>cmd 表示命令，其实就是 READ 还是 WRITE，也就表示本次操作是读还是写。</li>
<li>errors 表示操作时产生的错误次数。</li>
<li>sector 表示起始扇区。</li>
<li>nr_sectors 表示扇区数。</li>
<li>buffer 表示数据缓冲区，也就是读盘之后的数据放在内存中的什么位置。</li>
<li>waiting 是个 task_struct 结构，这可以表示一个进程，也就表示是哪个进程发起了这个请求。</li>
<li>bh 是缓冲区头指针，这个后面讲完缓冲区就懂了，因为这个 request 是需要与缓冲区挂钩的。</li>
<li>next 指向了下一个请求项。</li>
</ul>
<p>这里有的变量看不懂没关系，不过我们倒是可以基于现有的重点参数猜测一下，比如读请求时，cmd 就是 READ，sector 和 nr_sectors 这俩就定位了所要读取的块设备（可以简单先理解为硬盘）的哪几个扇区，buffer<br>就定位了这些数据读完之后放在内存的什么位置。</p>
<p>这就够啦，想想看，这四个参数是不是就能完整描述了一个读取硬盘的需求了？而且完全没有歧义，就像下面这样。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_8.png"></p>
<p>而其他的参数，肯定是为了更好地配合操作系统进行读写块设备操作嘛，为了把多个读写块设备请求很好地组织起来。</p>
<p>这个组织不但要有这个数据结构中 hb 和 next 等变量的配合，还要有后面的电梯调度算法的配合，仅此而已，先点到为止。</p>
<p>总之，我们这里就先明白，这个 request 结构可以完整描述一个读盘操作。然后那个 request 数组就是把它们都放在一起，并且它们又通过 next 指针串成链表。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_9.png"></p>
<h4 id="如何使用-request-32-结构-数据读盘"><a href="#如何使用-request-32-结构-数据读盘" class="headerlink" title="如何使用 request[32] 结构 - 数据读盘"></a>如何使用 request[32] 结构 - 数据读盘</h4><p>简单展望一下，后面读盘的全流程中，是怎么用到刚刚初始化的这个 request[32] 结构的。</p>
<p>读操作的系统调用函数是 sys_read，源代码很长，简化一下，仅仅保留读取普通文件的分支，就是如下的样子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int sys_read(unsigned int fd,char * buf,int count) &#123;</span><br><span class="line">    struct file * file = current-&gt;filp[fd];</span><br><span class="line">    struct m_inode * inode = file-&gt;f_inode;</span><br><span class="line">    // 校验 buf 区域的内存限制</span><br><span class="line">    verify_area(buf,count);</span><br><span class="line">    // 仅关注目录文件或普通文件</span><br><span class="line">    return file_read(inode,file,buf,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看，入参 fd 是文件描述符，通过它可以找到一个文件的 inode，进而找到这个文件在硬盘中的位置。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_10.png"></p>
<p>另两个入参 buf 就是要复制到的内存中的位置，count 就是要复制多少个字节，很好理解。</p>
<p>钻到 file_read 函数里继续看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int file_read(struct m_inode * inode, struct file * filp, char * buf, int count) &#123;</span><br><span class="line">    int left,chars,nr;</span><br><span class="line">    struct buffer_head * bh;</span><br><span class="line">    left = count;</span><br><span class="line">    while (left) &#123;</span><br><span class="line">        if (nr = bmap(inode,(filp-&gt;f_pos)/BLOCK_SIZE)) &#123;</span><br><span class="line">            if (!(bh=bread(inode-&gt;i_dev,nr)))</span><br><span class="line">                break;</span><br><span class="line">        &#125; else</span><br><span class="line">            bh = NULL;</span><br><span class="line">        nr = filp-&gt;f_pos % BLOCK_SIZE;</span><br><span class="line">        chars = MIN( BLOCK_SIZE-nr , left );</span><br><span class="line">        filp-&gt;f_pos += chars;</span><br><span class="line">        left -= chars;</span><br><span class="line">        if (bh) &#123;</span><br><span class="line">            char * p = nr + bh-&gt;b_data;</span><br><span class="line">            while (chars--&gt;0)</span><br><span class="line">                put_fs_byte(*(p++),buf++);</span><br><span class="line">            brelse(bh);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (chars--&gt;0)</span><br><span class="line">                put_fs_byte(0,buf++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inode-&gt;i_atime = CURRENT_TIME;</span><br><span class="line">    return (count-left)?(count-left):-ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体看，就是一个 while 循环，每次读入一个块的数据，直到入参所要求的大小全部读完为止。</p>
<p>直接看 bread 那一行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int file_read(struct m_inode * inode, struct file * filp, char * buf, int count) &#123;</span><br><span class="line">    ...</span><br><span class="line">    while (left) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (!(bh=bread(inode-&gt;i_dev,nr)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数就是去读某一个设备的某一个数据块号的内容，展开进去看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct buffer_head * bread(int dev,int block) &#123;</span><br><span class="line">    struct buffer_head * bh = getblk(dev,block);</span><br><span class="line">    if (bh-&gt;b_uptodate)</span><br><span class="line">        return bh;</span><br><span class="line">    ll_rw_block(READ,bh);</span><br><span class="line">    wait_on_buffer(bh);</span><br><span class="line">    if (bh-&gt;b_uptodate)</span><br><span class="line">        return bh;</span><br><span class="line">    brelse(bh);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 getblk 先申请了一个内存中的缓冲块，然后 ll_rw_block 负责把数据读入这个缓冲块，进去继续看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void ll_rw_block(int rw, struct buffer_head * bh) &#123;</span><br><span class="line">    ...</span><br><span class="line">    make_request(major,rw,bh);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void make_request(int major,int rw, struct buffer_head * bh) &#123;</span><br><span class="line">    ...</span><br><span class="line">if (rw == READ)</span><br><span class="line">        req = request+NR_REQUEST;</span><br><span class="line">    else</span><br><span class="line">        req = request+((NR_REQUEST*2)/3);</span><br><span class="line">/* find an empty request */</span><br><span class="line">    while (--req &gt;= request)</span><br><span class="line">        if (req-&gt;dev&lt;0)</span><br><span class="line">            break;</span><br><span class="line">    ...</span><br><span class="line">/* fill up the request-info, and add it to the queue */</span><br><span class="line">    req-&gt;dev = bh-&gt;b_dev;</span><br><span class="line">    req-&gt;cmd = rw;</span><br><span class="line">    req-&gt;errors=0;</span><br><span class="line">    req-&gt;sector = bh-&gt;b_blocknr&lt;&lt;1;</span><br><span class="line">    req-&gt;nr_sectors = 2;</span><br><span class="line">    req-&gt;buffer = bh-&gt;b_data;</span><br><span class="line">    req-&gt;waiting = NULL;</span><br><span class="line">    req-&gt;bh = bh;</span><br><span class="line">    req-&gt;next = NULL;</span><br><span class="line">    add_request(major+blk_dev,req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看，这里就用到了刚刚说的结构咯。</p>
<p>具体说来，就是该函数会往刚刚的设备的请求项链表 request[32] 中添加一个请求项，只要 request[32] 中有未处理的请求项存在，都会陆续地被处理，直到设备的请求项链表是空为止。</p>
<p>具体怎么读盘，就是与硬盘 IO 端口进行交互的过程了，可以继续往里跟，直到看到一个 hd_out 函数为止，本讲不展开了。</p>
<p>具体读盘操作，后面会有详细的章节展开讲解，目前你只需要知道，我们在 main 函数的 init 系列函数中，通过 blk_dev_init 为后面的块设备访问，提前建立了一个数据结构，作为访问块设备和内存缓冲区之间的桥梁，就可以了。</p>
<h3 id="控制台初始化-为什么屏幕上就会有输出-tty-init"><a href="#控制台初始化-为什么屏幕上就会有输出-tty-init" class="headerlink" title="控制台初始化 - 为什么屏幕上就会有输出 - tty_init"></a>控制台初始化 - 为什么屏幕上就会有输出 - tty_init</h3><p>继内存管理结构 mem_map 和中断描述符表 idt 建立好之后，我们又在内存中倒腾出一个新的数据结构 request。</p>
<p>这是块<strong>设备驱动程序</strong>与<strong>内存缓冲区</strong>的桥梁，通过它可以完整地表示一个块设备读写操作要做的事。</p>
<h4 id="串口中断与显示模式"><a href="#串口中断与显示模式" class="headerlink" title="串口中断与显示模式"></a>串口中断与显示模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法执行完成之后，我们将会具备键盘输入到显示器输出字符这个最常用的功能。</p>
<p>打开这个函数后我有点慌。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void tty_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    rs_init();</span><br><span class="line">    con_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看来这个方法已经多到需要拆成两个子方法了。</p>
<p>打开第一个方法，还好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void rs_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    set_intr_gate(0x24,rs1_interrupt);</span><br><span class="line">    set_intr_gate(0x23,rs2_interrupt);</span><br><span class="line">    init(tty_table[1].read_q.data);</span><br><span class="line">    init(tty_table[2].read_q.data);</span><br><span class="line">    outb(inb_p(0x21)&amp;0xE7,0x21);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是串口中断的开启，以及设置对应的中断处理程序，串口在我们现在的 PC 机上已经很少用到了，所以这个直接忽略。</p>
<p>看第二个方法，这是重点。代码非常长，有点吓人，我先把大体框架写出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void con_init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (ORIG_VIDEO_MODE == 7) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if ((ORIG_VIDEO_EGA_BX &amp; 0xff) != 0x10) &#123;...&#125;</span><br><span class="line">        else &#123;...&#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">        if ((ORIG_VIDEO_EGA_BX &amp; 0xff) != 0x10) &#123;...&#125;</span><br><span class="line">        else &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，非常多的 if else。</p>
<p>这是为了应对不同的显示模式，来分配不同的变量值，那如果我们仅仅找出一个显示模式，这些分支就可以只看一个了。</p>
<h4 id="一个字符是如何显示在屏幕上的呢"><a href="#一个字符是如何显示在屏幕上的呢" class="headerlink" title="一个字符是如何显示在屏幕上的呢"></a>一个字符是如何显示在屏幕上的呢</h4><p>如果你可以随意操作内存和 CPU 等设备，你如何操作才能使得你的显示器上，显示一个字符‘a’呢？</p>
<p>我们先看一张图。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_11.png"></p>
<p>内存中有这样一部分区域，是和显存映射的。啥意思，就是你往上图的这些内存区域中写数据，相当于写在了显存中。而往显存中写数据，就相当于在屏幕上输出文本了。</p>
<p>没错，就是这么简单。</p>
<p>如果我们写这一行汇编语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [0xB8000],&#x27;h&#x27;</span><br></pre></td></tr></table></figure>

<p>后面那个 h 相当于汇编编辑器帮我们转换成 ASCII 码的二进制数值，当然我们也可以直接写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov [0xB8000],0x68</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实就是往内存中 0xB8000 这个位置写了一个值，只要一写，屏幕上就会是这样。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_12.png"></p>
<p>简单吧，具体说来，这片内存是<strong>每两个字节表示一个显示在屏幕上的字符，第一个是字符的编码，第二个是字符的颜色</strong>，那我们先不管颜色，如果多写几个字符就像这样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov [0xB8000],&#x27;h&#x27;</span><br><span class="line">mov [0xB8002],&#x27;e&#x27;</span><br><span class="line">mov [0xB8004],&#x27;l&#x27;</span><br><span class="line">mov [0xB8006],&#x27;l&#x27;</span><br><span class="line">mov [0xB8008],&#x27;o&#x27;</span><br></pre></td></tr></table></figure>

<p>此时屏幕上就会是这样。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_13.png"></p>
<p>是不是贼简单？那我们回过头看刚刚的代码，我们就假设显示模式是我们现在的这种文本模式，那条件分支就可以去掉好多。</p>
<p>代码可以简化成这个样子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#define ORIG_X          (*(unsigned char *)0x90000)</span><br><span class="line">#define ORIG_Y          (*(unsigned char *)0x90001)</span><br><span class="line">void con_init(void) &#123;</span><br><span class="line">    register unsigned char a;</span><br><span class="line">    // 第一部分 获取显示模式相关信息</span><br><span class="line">    video_num_columns = (((*(unsigned short *)0x90006) &amp; 0xff00) &gt;&gt; 8);</span><br><span class="line">    video_size_row = video_num_columns * 2;</span><br><span class="line">    video_num_lines = 25;</span><br><span class="line">    video_page = (*(unsigned short *)0x90004);</span><br><span class="line">    video_erase_char = 0x0720;</span><br><span class="line">    // 第二部分 显存映射的内存区域 </span><br><span class="line">    video_mem_start = 0xb8000;</span><br><span class="line">    video_port_reg  = 0x3d4;</span><br><span class="line">    video_port_val  = 0x3d5;</span><br><span class="line">    video_mem_end = 0xba000;</span><br><span class="line">    // 第三部分 滚动屏幕操作时的信息</span><br><span class="line">    origin  = video_mem_start;</span><br><span class="line">    scr_end = video_mem_start + video_num_lines * video_size_row;</span><br><span class="line">    top = 0;</span><br><span class="line">    bottom  = video_num_lines;</span><br><span class="line">    // 第四部分 定位光标并开启键盘中断</span><br><span class="line">    gotoxy(ORIG_X, ORIG_Y);</span><br><span class="line">    set_trap_gate(0x21,&amp;keyboard_interrupt);</span><br><span class="line">    outb_p(inb_p(0x21)&amp;0xfd,0x21);</span><br><span class="line">    a=inb_p(0x61);</span><br><span class="line">    outb_p(a|0x80,0x61);</span><br><span class="line">    outb(a,0x61);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先还记不记得之前汇编语言的时候做的工作，存了好多以后要用的数据在内存中。</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>长度(字节)</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>0x90000</td>
<td>2</td>
<td>光标位置</td>
</tr>
<tr>
<td>0x90002</td>
<td>2</td>
<td>扩展内存数</td>
</tr>
<tr>
<td>0x90004</td>
<td>2</td>
<td>显示页面</td>
</tr>
<tr>
<td>0x90006</td>
<td>1</td>
<td>显示模式</td>
</tr>
<tr>
<td>0x90007</td>
<td>1</td>
<td>字符列数</td>
</tr>
<tr>
<td>0x90008</td>
<td>2</td>
<td>未知</td>
</tr>
<tr>
<td>0x9000A</td>
<td>1</td>
<td>显示内存</td>
</tr>
<tr>
<td>0x9000B</td>
<td>1</td>
<td>显示状态</td>
</tr>
<tr>
<td>0x9000C</td>
<td>2</td>
<td>显卡特性参数</td>
</tr>
<tr>
<td>0x9000E</td>
<td>1</td>
<td>屏幕行数</td>
</tr>
<tr>
<td>0x9000F</td>
<td>1</td>
<td>屏幕列数</td>
</tr>
<tr>
<td>0x90080</td>
<td>16</td>
<td>硬盘1参数表</td>
</tr>
<tr>
<td>0x90090</td>
<td>16</td>
<td>硬盘2参数表</td>
</tr>
<tr>
<td>0x901FC</td>
<td>2</td>
<td>根设备号</td>
</tr>
</tbody></table>
<p>所以：</p>
<ol>
<li>第一部分获取 0x90006 地址处的数据，就是获取显示模式等相关信息。</li>
<li>第二部分就是显存映射的内存地址范围，我们现在假设是 CGA 类型的文本模式，所以映射的内存是从 0xB8000 到 0xBA000。</li>
<li>第三部分是设置一些滚动屏幕时需要的参数，定义顶行和底行是哪里，这里顶行就是第一行，底行就是最后一行，很合理。</li>
<li>第四部分是把光标定位到之前保存的光标位置处（取内存地址 0x90000 处的数据），然后设置并开启键盘中断。</li>
</ol>
<h4 id="键盘敲击如何显示在屏幕上"><a href="#键盘敲击如何显示在屏幕上" class="headerlink" title="键盘敲击如何显示在屏幕上"></a>键盘敲击如何显示在屏幕上</h4><p>开启键盘中断后，键盘上敲击一个按键后就会触发中断，中断程序就会读键盘码转换成 ASCII 码，然后写到光标处的内存地址，也就相当于往显存写，于是这个键盘敲击的字符就显示在了屏幕上。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_14.png"></p>
<p>这一切具体是怎么做到的呢？我们先看看我们干了什么。</p>
<ol>
<li>我们现在根据已有信息已经可以实现往屏幕上的任意位置写字符了，而且还能指定颜色。</li>
<li>并且，我们也能接受键盘中断，根据键盘码中断处理程序就可以得知哪个键按下了。</li>
</ol>
<p>有了这俩功能，那我们想干嘛还不是为所欲为？</p>
<p>好，接下来我们看看代码是怎么处理的，很简单。一切的起点，就是第四步的 gotoxy 函数，定位当前光标。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define ORIG_X          (*(unsigned char *)0x90000)</span><br><span class="line">#define ORIG_Y          (*(unsigned char *)0x90001)</span><br><span class="line">void con_init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 第四部分 定位光标并开启键盘中断</span><br><span class="line">    gotoxy(ORIG_X, ORIG_Y);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面干嘛了呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static inline void gotoxy(unsigned int new_x,unsigned int new_y) &#123;</span><br><span class="line">   ...</span><br><span class="line">   x = new_x;</span><br><span class="line">   y = new_y;</span><br><span class="line">   pos = origin + y*video_size_row + (x&lt;&lt;1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是给 x y pos 这三个参数附上了值。</p>
<p>其中 x 表示光标在哪一列，y 表示光标在哪一行，pos 表示根据列号和行号计算出来的内存指针，也就是往这个 pos 指向的地址处写数据，就相当于往控制台的 x 列 y 行处写入字符了，简单吧？</p>
<p>然后，当你按下键盘后，触发键盘中断，之后的程序调用链是这样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_keyboard_interrupt:</span><br><span class="line">    ...</span><br><span class="line">    call _do_tty_interrupt</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">void do_tty_interrupt(int tty) &#123;</span><br><span class="line">   copy_to_cooked(tty_table+tty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void copy_to_cooked(struct tty_struct * tty) &#123;</span><br><span class="line">    ...</span><br><span class="line">    tty-&gt;write(tty);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 控制台时 tty 的 write 为 con_write 函数</span><br><span class="line">void con_write(struct tty_struct * tty) &#123;</span><br><span class="line">    ...</span><br><span class="line">    __asm__(&quot;movb _attr,%%ah\n\t&quot;</span><br><span class="line">      &quot;movw %%ax,%1\n\t&quot;</span><br><span class="line">      ::&quot;a&quot; (c),&quot;m&quot; (*(short *)pos)</span><br><span class="line">      :&quot;ax&quot;);</span><br><span class="line">     pos += 2;</span><br><span class="line">     x++;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的过程不用管，我们看最后一个函数 con_write 中的关键代码。</p>
<p><strong>asm</strong> 内联汇编，就是把键盘输入的字符 c 写入 pos 指针指向的内存，相当于往屏幕输出了。</p>
<p>之后两行 pos+=2 和 x++，就是调整所谓的光标。</p>
<p>你看，写入一个字符，最底层，其实就是往内存的某处写个数据，然后顺便调整一下光标。</p>
<p>由此我们也可以看出，<strong>光标的本质，其实就是这里的 x y pos 这仨变量</strong>而已。</p>
<h5 id="换行效果"><a href="#换行效果" class="headerlink" title="换行效果"></a>换行效果</h5><p>当发现光标位置处于某一行的结尾时（这个应该很好算吧，我们都知道屏幕上一共有几行几列了），就把光标计算出一个新值，让其处于下一行的开头。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_15.png"></p>
<p>就一个小计算公式即可搞定，仍然在 con_write 源码处有体现，就是判断列号 x 是否大于了总列数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void con_write(struct tty_struct * tty) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (x&gt;=video_num_columns) &#123;</span><br><span class="line">        x -= video_num_columns;</span><br><span class="line">        pos -= video_size_row;</span><br><span class="line">        lf();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void lf(void) &#123;</span><br><span class="line">   if (y+1&lt;bottom) &#123;</span><br><span class="line">      y++;</span><br><span class="line">      pos += video_size_row;</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="滚屏"><a href="#滚屏" class="headerlink" title="滚屏"></a>滚屏</h5><p>无非就是当检测到光标已经出现在最后一行最后一列了，那就把每一行的字符，都复制到它上一行，其实就是算好哪些内存地址上的值，拷贝到哪些内存地址，就好了。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>所以，有了这个初始化工作，我们就可以利用这些信息，弄几个小算法，实现各种我们常见控制台的操作。</p>
<p>或者换句话说，我们见惯不怪的控制台，回车、换行、删除、滚屏、清屏等操作，其实底层都要实现相应的代码的。</p>
<p>所以 console.c 中的其他方法就是做这个事的，我们就不展开每一个功能的方法体了，简单看看有哪些方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定位光标的</span><br><span class="line">static inline void gotoxy(unsigned int new_x, unsigned int new_y)&#123;&#125;</span><br><span class="line">// 滚屏，即内容向上滚动一行</span><br><span class="line">static void scrup(void)&#123;&#125;</span><br><span class="line">// 光标同列位置下移一行</span><br><span class="line">static void lf(int currcons)&#123;&#125;</span><br><span class="line">// 光标回到第一列</span><br><span class="line">static void cr(void)&#123;&#125;</span><br><span class="line">...</span><br><span class="line">// 删除一行</span><br><span class="line">static void delete_line(void)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>整个 console.c 就讲完了，要知道这个文件可是整个内核中代码量最大的文件，可是功能特别单一，也都很简单，主要是处理键盘各种不同的按键，需要写好多 switch case 等语句，十分麻烦，我们这里就完全没必要去展开了，就是个苦力活。</p>
<p>到这里，我们就正式讲完了 tty_init 的作用。</p>
<p>在此之后，内核代码就可以用它来方便地在控制台输出字符啦！这在之后内核想要在启动过程中告诉用户一些信息，以及后面内核完全建立起来之后，由用户用 shell 进行操作时手动输入命令，都是可以用到这里的代码的！</p>
<h3 id="时间初始化-操作系统如何获取当前时间"><a href="#时间初始化-操作系统如何获取当前时间" class="headerlink" title="时间初始化 操作系统如何获取当前时间"></a>时间初始化 操作系统如何获取当前时间</h3><p>过初始化控制台的 tty_init 操作，内核代码可以很方便地在控制台输出字符啦，同时支持用户键盘操作和换行和滚屏等友好设计。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续往下看下一个初始化的倒霉鬼，time_init。</p>
<p>为什么操作系统在启动之后，可以显示出当前时间呢？难道操作系统在电脑关机后，依然不停地在某处运行着，勤勤恳恳数着秒表么？</p>
<p>当然不是，那我们今天就打开这个 time_init 函数一探究竟。</p>
<p>打开这个函数后我又是很开心，因为很短，且没有更深入的方法调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#define CMOS_READ(addr) (&#123; \</span><br><span class="line">    outb_p(0x80|addr,0x70); \</span><br><span class="line">    inb_p(0x71); \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#define BCD_TO_BIN(val) ((val)=((val)&amp;15) + ((val)&gt;&gt;4)*10)</span><br><span class="line"></span><br><span class="line">static void time_init(void) &#123;</span><br><span class="line">    struct tm time;</span><br><span class="line">    do &#123;</span><br><span class="line">        time.tm_sec = CMOS_READ(0);</span><br><span class="line">        time.tm_min = CMOS_READ(2);</span><br><span class="line">        time.tm_hour = CMOS_READ(4);</span><br><span class="line">        time.tm_mday = CMOS_READ(7);</span><br><span class="line">        time.tm_mon = CMOS_READ(8);</span><br><span class="line">        time.tm_year = CMOS_READ(9);</span><br><span class="line">    &#125; while (time.tm_sec != CMOS_READ(0));</span><br><span class="line">    BCD_TO_BIN(time.tm_sec);</span><br><span class="line">    BCD_TO_BIN(time.tm_min);</span><br><span class="line">    BCD_TO_BIN(time.tm_hour);</span><br><span class="line">    BCD_TO_BIN(time.tm_mday);</span><br><span class="line">    BCD_TO_BIN(time.tm_mon);</span><br><span class="line">    BCD_TO_BIN(time.tm_year);</span><br><span class="line">    time.tm_mon--;</span><br><span class="line">    startup_time = kernel_mktime(&amp;time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>梦想的代码呀！ 那主要就是对 CMOS_READ 和 BCD_TO_BIN 都是啥意思展开讲一下就明白了了。</p>
<h4 id="CMOS-READ"><a href="#CMOS-READ" class="headerlink" title="CMOS_READ"></a>CMOS_READ</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define CMOS_READ(addr) (&#123; \</span><br><span class="line">    outb_p(0x80|addr,0x70); \</span><br><span class="line">    inb_p(0x71); \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>就是对一个端口先 out 写一下，再 in 读一下。</p>
<p>这是 CPU 与外设交互的一个基本玩法，CPU 与外设打交道基本是通过端口，往某些端口写值来表示要这个外设干嘛，然后从另一些端口读值来接受外设的反馈。</p>
<p>至于这个外设内部是怎么实现的，对使用它的操作系统而言，是个黑盒，无需关心。那对于我们程序员来说，就更不用关心了。</p>
<p>对 CMOS 这个外设的交互讲起来可能没感觉，我们看看与硬盘的交互。</p>
<p>最常见的就是读硬盘了，我们看硬盘的端口表。</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>读</th>
<th>写</th>
</tr>
</thead>
<tbody><tr>
<td>0x1F0</td>
<td>数据寄存器</td>
<td>数据寄存器</td>
</tr>
<tr>
<td>0x1F1</td>
<td>错误寄存器</td>
<td>特征寄存器</td>
</tr>
<tr>
<td>0x1F2</td>
<td>扇区计数寄存器</td>
<td>扇区计数寄存器</td>
</tr>
<tr>
<td>0x1F3</td>
<td>扇区号寄存器或 LBA 块地址 0~7</td>
<td>扇区号或 LBA 块地址 0~7</td>
</tr>
<tr>
<td>0x1F4</td>
<td>磁道数低 8 位或 LBA 块地址 8~15</td>
<td>磁道数低 8 位或 LBA 块地址 8~15</td>
</tr>
<tr>
<td>0x1F5</td>
<td>磁道数高 8 位或 LBA 块地址 16~23</td>
<td>磁道数高 8 位或 LBA 块地址 16~23</td>
</tr>
<tr>
<td>0x1F6</td>
<td>驱动器/磁头或 LBA 块地址 24~27</td>
<td>驱动器/磁头或 LBA 块地址 24~27</td>
</tr>
<tr>
<td>0x1F7</td>
<td>命令寄存器或状态寄存器</td>
<td>命令寄存器</td>
</tr>
</tbody></table>
<p>那读硬盘就是，往除了第一个以外的后面几个端口写数据，告诉要读硬盘的哪个扇区，读多少。然后再从 0x1F0 端口一个字节一个字节的读数据。这就完成了一次硬盘读操作。</p>
<p>如果觉得不够具体，那来个具体的版本。</p>
<ol>
<li>在 0x1F2 写入要读取的扇区数</li>
<li>在 0x1F3 ~ 0x1F6 这四个端口写入计算好的起始 LBA 地址</li>
<li>在 0x1F7 处写入读命令的指令号</li>
<li>不断检测 0x1F7 （此时已成为状态寄存器的含义）的忙位</li>
<li>如果第四步骤为不忙，则开始不断从 0x1F0 处读取数据到内存指定位置，直到读完</li>
</ol>
<p>看，是不是对 CPU 最底层是如何与外设打交道有点感觉了？是不是也不难？就是按照人家的操作手册，然后无脑按照要求读写端口就行了。</p>
<p>当然，读取硬盘的这个无脑循环，可以 <strong>CPU</strong> 直接读取并做写入内存的操作，这样就会占用 CPU 的计算资源。</p>
<p>也可以交给 <strong>DMA</strong> 设备去读，解放 CPU，但和硬盘的交互，通通都是按照硬件手册上的端口说明，来操作的，实际上也是做了一层封装。</p>
<p>好了，我们已经学会了和一个外设打交道的基本玩法了。</p>
<p>那我们代码中要打交道的是哪个外设呢？就是 <strong>CMOS</strong>。</p>
<p>它是主板上的一个可读写的 RAM 芯片，你在开机时长按某个键就可以进入设置它的页面。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_16.png"></p>
<p>那我们的代码，其实就是与它打交道，获取它的一些数据而已。</p>
<p>我们回过头看代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void time_init(void) &#123;</span><br><span class="line">    struct tm time;</span><br><span class="line">    do &#123;</span><br><span class="line">        time.tm_sec = CMOS_READ(0);</span><br><span class="line">        time.tm_min = CMOS_READ(2);</span><br><span class="line">        time.tm_hour = CMOS_READ(4);</span><br><span class="line">        time.tm_mday = CMOS_READ(7);</span><br><span class="line">        time.tm_mon = CMOS_READ(8);</span><br><span class="line">        time.tm_year = CMOS_READ(9);</span><br><span class="line">    &#125; while (time.tm_sec != CMOS_READ(0));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面几个赋值语句 CMOS_READ 就是<strong>通过读写 CMOS 上的指定端口，依次获取年月日时分秒</strong>等信息。具体咋操作代码上也写了，也是按照 CMOS 手册要求的读写指定端口就行了，我们就不展开了。</p>
<p>所以你看，其实操作系统程序，也是要依靠与一个外部设备打交道，来获取这些信息的，并不是它自己有什么魔力。操作系统最大的魅力，就在于它借力完成了一项伟大的事，借 CPU 的力，借硬盘的力，借内存的力，以及现在借 CMOS 的力。</p>
<p>至于 CMOS 又是如何知道时间的，这个就不在我们讨论范围了。</p>
<h4 id="BCD-TO-BIN"><a href="#BCD-TO-BIN" class="headerlink" title="BCD_TO_BIN"></a>BCD_TO_BIN</h4><p>就是 BCD 转换成 BIN，因为从 CMOS 上获取的这些年月日都是 BCD 码值，需要转换成存储在我们变量上的二进制数值，所以需要一个小算法来转换一下，没什么意思。</p>
<h4 id="kernel-mktime"><a href="#kernel-mktime" class="headerlink" title="kernel_mktime"></a>kernel_mktime</h4><p>就是根据刚刚的那些时分秒数据，计算从 <strong>1970 年 1 月 1 日 0 时</strong>起到开机当时经过的秒数，作为开机时间，存储在 <strong>startup_time</strong> 这个变量里。</p>
<p>想研究可以仔细看看这段代码，不过我觉得这种细节不必看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">startup_time = kernel_mktime(&amp;time);</span><br><span class="line"></span><br><span class="line">// kernel/mktime.c</span><br><span class="line">long kernel_mktime(struct tm * tm)</span><br><span class="line">&#123;</span><br><span class="line">    long res;</span><br><span class="line">    int year;</span><br><span class="line">    year = tm-&gt;tm_year - 70;</span><br><span class="line">    res = YEAR*year + DAY*((year+1)/4);</span><br><span class="line">    res += month[tm-&gt;tm_mon];</span><br><span class="line">    if (tm-&gt;tm_mon&gt;1 &amp;&amp; ((year+2)%4))</span><br><span class="line">        res -= DAY;</span><br><span class="line">    res += DAY*(tm-&gt;tm_mday-1);</span><br><span class="line">    res += HOUR*tm-&gt;tm_hour;</span><br><span class="line">    res += MINUTE*tm-&gt;tm_min;</span><br><span class="line">    res += tm-&gt;tm_sec;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>所以今天其实就是，计算出了一个 startup_time 变量而已，至于这个变量今后会被谁用，怎么用，那就是后话了。</p>
<p>相信你逐渐也体会到了，此时操作系统好多地方都是用外设要求的方式去询问，比如硬盘信息、显示模式，以及今天的开机时间的获取等。</p>
<p>所以至少到目前来说，你还不应该感觉操作系统有多么的“高端”，很多时候都是繁琐地，读人家的硬件手册，获取到想要的的信息，拿来给自己用，或者对其进行各种设置。</p>
<p>但你一定要耐得住寂寞，真正体现操作系统的强大设计之处，还得接着往下读。</p>
<h3 id="进程调度初始化"><a href="#进程调度初始化" class="headerlink" title="进程调度初始化"></a>进程调度初始化</h3><p>我们继续往下看，大名鼎鼎的进程调度初始化，shed_init，这方法可了不起，因为它就是多进程的基石！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    sched_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于来到了兴奋的时刻，是不是很激动？不过先别激动，这里只是进程调度的初始化，也就是为进程调度所需要用到的数据结构做个准备，真正的进程调度还需要调度算法、时钟中断等机制的配合。</p>
<p>当然，对于理解操作系统，流程和数据结构最为重要了，而这一段作为整个流程的起点，以及建立数据结构的地方，就显得格外重要了。</p>
<p>我们进入这个方法，一点点往后看。</p>
<h4 id="初始化了下-TSS-和-LDT-线程0"><a href="#初始化了下-TSS-和-LDT-线程0" class="headerlink" title="初始化了下 TSS 和 LDT (线程0)"></a>初始化了下 TSS 和 LDT (线程0)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void sched_init(void) &#123;</span><br><span class="line">    set_tss_desc(gdt+4, &amp;(init_task.task.tss));</span><br><span class="line">    set_ldt_desc(gdt+5, &amp;(init_task.task.ldt));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两行代码初始化了下 TSS 和 LDT。</p>
<p>先别急问这俩结构是啥。还记得之前讲的全局描述符表 gdt 么？它在内存的这个位置，并且被设置成了这个样子。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_17.png"></p>
<p>说回这两行代码，其实就是往后又加了两项，分别是 TSS 和 LDT。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_18.png"></p>
<p>好，那再说说这俩结构是干嘛的，不过本篇先简单理解，后面会详细讲到。</p>
<p><strong>TSS 叫任务状态段，就是保存和恢复进程的上下文的</strong>，所谓上下文，其实就是各个寄存器的信息而已，这样进程切换的时候，才能做到保存和恢复上下文，继续执行。</p>
<p>由它的数据结构你应该可以看出点意思。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct tss_struct&#123;</span><br><span class="line">    long back_link;</span><br><span class="line">    long esp0;</span><br><span class="line">    long ss0;</span><br><span class="line">    long esp1;</span><br><span class="line">    long ss1;</span><br><span class="line">    long esp2;</span><br><span class="line">    long ss2;</span><br><span class="line">    long cr3;</span><br><span class="line">    long eip;</span><br><span class="line">    long eflags;</span><br><span class="line">    long eax, ecx, edx, ebx;</span><br><span class="line">    long esp;</span><br><span class="line">    long ebp;</span><br><span class="line">    long esi;</span><br><span class="line">    long edi;</span><br><span class="line">    long es;</span><br><span class="line">    long cs;</span><br><span class="line">    long ss;</span><br><span class="line">    long ds;</span><br><span class="line">    long fs;</span><br><span class="line">    long gs;</span><br><span class="line">    long ldt;</span><br><span class="line">    long trace_bitmap;</span><br><span class="line">    struct i387_struct i387;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而 <strong>LDT 叫局部描述符表，是与 GDT 全局描述符表相对应的</strong>，内核态的代码用 GDT 里的数据段和代码段，而用户进程的代码用每个用户进程自己的 LDT 里得数据段和代码段。</p>
<p>先不管它，我这里放一张超纲的图，你先找找感觉。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_19.png"></p>
<p>我们接着往下看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct desc_struct &#123;</span><br><span class="line">    unsigned long a,b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct task_struct * task[64] = &#123;&amp;(init_task.task), &#125;;</span><br><span class="line"></span><br><span class="line">void sched_init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    int i;</span><br><span class="line">    struct desc_struct * p;</span><br><span class="line">        p = gdt+6;</span><br><span class="line">    for(i=1;i&lt;64;i++) &#123;</span><br><span class="line">        task[i] = NULL;</span><br><span class="line">        p-&gt;a=p-&gt;b=0;</span><br><span class="line">        p++;</span><br><span class="line">        p-&gt;a=p-&gt;b=0;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码有个循环，干了两件事。</p>
<p>一个是给一个长度为 64，结构为 task_struct 的数组 task 附上初始值。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_20.png"></p>
<p>这个 task_struct 结构就是代表<strong>每一个进程的信息</strong>，这可是个<strong>相当相当重要</strong>的结构了，把它放在心里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">/* these are hardcoded - don&#x27;t touch */</span><br><span class="line">    long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><span class="line">    long counter;</span><br><span class="line">    long priority;</span><br><span class="line">    long signal;</span><br><span class="line">    struct sigaction sigaction[32];</span><br><span class="line">    long blocked; /* bitmap of masked signals */</span><br><span class="line">  /* various fields */</span><br><span class="line">    int exit_code;</span><br><span class="line">    unsigned long start_code,end_code,end_data,brk,start_stack;</span><br><span class="line">    long pid,father,pgrp,session,leader;</span><br><span class="line">    unsigned short uid,euid,suid;</span><br><span class="line">    unsigned short gid,egid,sgid;</span><br><span class="line">    long alarm;</span><br><span class="line">    long utime,stime,cutime,cstime,start_time;</span><br><span class="line">    unsigned short used_math;</span><br><span class="line">  /* file system info */</span><br><span class="line">    int tty;  /* -1 if no tty, so it must be signed */</span><br><span class="line">    unsigned short umask;</span><br><span class="line">    struct m_inode * pwd;</span><br><span class="line">    struct m_inode * root;</span><br><span class="line">    struct m_inode * executable;</span><br><span class="line">    unsigned long close_on_exec;</span><br><span class="line">    struct file * filp[NR_OPEN];</span><br><span class="line">  /* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span><br><span class="line">    struct desc_struct ldt[3];</span><br><span class="line">  /* tss for this task */</span><br><span class="line">    struct tss_struct tss;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个循环做的另一件事，是给 gdt 剩下的位置填充上 0，也就是把剩下留给 TSS 和 LDT 的描述符都先附上空值。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_21.png"></p>
<p>往后展望一下的话，就是以后每创建一个新进程，就会在后面添加一组 TSS 和 LDT 表示这个进程的任务状态段以及局部描述符表信息。</p>
<p>还记得刚刚的超纲图吧，未来整个内存的规划就是这样的，不过你先不用理解得很细。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_22.png"></p>
<p>那为什么一开始就先有了一组 TSS 和 LDT 呢？现在也没创建进程呀。错了，现在虽然我们还没有建立起进程调度的机制，但我们正在运行的代码就是会作为<strong>未来的一个进程的指令流</strong>。</p>
<p>也就是当未来进程调度机制一建立起来，正在执行的代码就会化身成为<strong>进程 0</strong> 的代码。所以我们需要提前把这些未来会作为进程 0 的信息写好。</p>
<p>如果你觉得很疑惑，别急，等后面整个进程调度机制建立起来，并且让你亲眼看到进程 0 以及进程 1 的创建，以及它们后面因为进程调度机制而切换，你就明白这一切的意义了。</p>
<h4 id="ltr-amp-lldt"><a href="#ltr-amp-lldt" class="headerlink" title="ltr &amp; lldt"></a>ltr &amp; lldt</h4><p>好，收回来，初始化了一组 TSS 和 LDT 后，再往下看两行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define ltr(n) __asm__(&quot;ltr %%ax&quot;::&quot;a&quot; (_TSS(n)))</span><br><span class="line">#define lldt(n) __asm__(&quot;lldt %%ax&quot;::&quot;a&quot; (_LDT(n)))</span><br><span class="line"></span><br><span class="line">void sched_init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ltr(0);</span><br><span class="line">    lldt(0);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这又涉及到之前的知识咯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还记得 lidt 和 lgdt 指令么？一个是给 idtr 寄存器赋值，以告诉 CPU 中断描述符表 idt 在内存的位置；一个是给 gdtr 寄存器赋值，以告诉 CPU 全局描述符表 gdt 在内存的位置。</span><br></pre></td></tr></table></figure>

<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_23.png"></p>
<p>那这两行和刚刚的类似:</p>
<ul>
<li>ltr 是给 tr 寄存器赋值，以告诉 CPU 任务状态段 TSS 在内存的位置；</li>
<li>lldt 一个是给 ldt 寄存器赋值，以告诉 CPU 局部描述符 LDT 在内存的位置。</li>
</ul>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_24.png"></p>
<p>这样，CPU 之后就能通过 tr 寄存器找到当前进程的任务状态段信息，也就是上下文信息，以及通过 ldt 寄存器找到当前进程在用的局部描述符表信息。</p>
<h4 id="可编程定时器与中断"><a href="#可编程定时器与中断" class="headerlink" title="可编程定时器与中断"></a>可编程定时器与中断</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void sched_init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    outb_p(0x36,0x43);      /* binary, mode 3, LSB/MSB, ch 0 */</span><br><span class="line">    outb_p(LATCH &amp; 0xff , 0x40);    /* LSB */</span><br><span class="line">    outb(LATCH &gt;&gt; 8 , 0x40);    /* MSB */</span><br><span class="line">    set_intr_gate(0x20,&amp;timer_interrupt);</span><br><span class="line">    outb(inb_p(0x21)&amp;~0x01,0x21);</span><br><span class="line">    set_system_gate(0x80,&amp;system_call);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四行端口读写代码，两行设置中断代码。</p>
<p>端口读写我们已经很熟悉了，就是 CPU 与外设交互的一种方式，之前讲硬盘读写以及 CMOS 读写时，已经接触过了。</p>
<p>而这次交互的外设是一个<strong>可编程定时器的芯片</strong>，这四行代码就开启了这个定时器，之后这个定时器变会<strong>持续的、以一定频率的向 CPU 发出中断信号</strong>。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_25.png"></p>
<p>而这段代码中设置的两个中断:</p>
<ul>
<li>第一个就是<strong>时钟中断，中断号为 0x20，中断处理程序为 timer_interrupt</strong>。那么每次定时器向 CPU 发出中断后，便会执行这个函数。<ul>
<li>这个定时器的触发，以及时钟中断函数的设置，是操作系统主导进程调度的一个关键！没有他们这样的外部信号不断触发中断，操作系统就没有办法作为进程管理的主人，通过强制的手段收回进程的 CPU 执行权限。</li>
</ul>
</li>
<li>第二个设置的中断叫<strong>系统调用 system_call，中断号是 0x80</strong>，这个中断又是个<strong>非常非常非常非常非常非常非常重要</strong>的中断，所有用户态程序想要调用内核提供的方法，都需要基于这个系统调用来进行。<ul>
<li>比如 Java 程序员写一个 read，底层会执行汇编指令 int 0x80，这就会触发系统调用这个中断，最终调用到 Linux 里的 sys_read 方法。</li>
</ul>
</li>
</ul>
<p>所以你看这一章的内容，偷偷设置了影响进程和影响用户程序调用系统方法的两个重量级中断处理函数，不简单呀~</p>
<p>到目前为止，中断已经设置了不少了，我们现在看看所设置好的中断有哪些。</p>
<table>
<thead>
<tr>
<th>中断号</th>
<th>中断处理函数</th>
</tr>
</thead>
<tbody><tr>
<td>0 ~ 0x10</td>
<td>trap_init 里设置的一堆</td>
</tr>
<tr>
<td>0x20</td>
<td>timer_interrupt</td>
</tr>
<tr>
<td>0x21</td>
<td>keyboard_interrupt</td>
</tr>
<tr>
<td>0x80</td>
<td>system_call</td>
</tr>
</tbody></table>
<ul>
<li>其中 0-0x10 这 17 个中断是 trap_init 里初始化设置的，是一些基本的中断，比如除零异常等。</li>
<li>在控制台初始化 con_init 里设置了 0x21 键盘中断， 这样按下键盘就有反应了。</li>
<li>0x20 时钟中断，并且开启定时器。</li>
<li>最后又偷偷设置了一个极为重要的 0x80 系统调用中断。</li>
</ul>
<p>找到些感觉没，有没有越来越发现，操作系统有点靠中断驱动的意思，各个模块不断初始化各种中断处理函数，并且开启指定的外设开关，让操作系统自己慢慢“活”了起来，逐渐通过中断忙碌于各种事情中，无法自拔。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>回顾一下我们今天，就三件事。</p>
<ul>
<li>第一，我们往全局描述符表写了两个结构，TSS 和 LDT，作为未来进程 0 的任务状态段和局部描述符表信息。</li>
</ul>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_26.png"></p>
<ul>
<li>第二，我们初始化了一个结构为 task_struct  的数组，未来这里会存放所有进程的信息，并且我们给数组的第一个位置附上了 init_task.init 这个具体值，也是作为未来进程 0 的信息。</li>
</ul>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_27.png"></p>
<ul>
<li>第三，设置了时钟中断 0x20 和系统调用 0x80，一个作为进程调度的起点，一个作为用户程序调用操作系统功能的桥梁，非常之重要。</li>
</ul>
<p>后面，我们将会逐渐看到，这些重要的事情，是如何紧密且精妙地结合在一起，发挥出奇妙的作用。</p>
<h3 id="缓冲区初始化-主内存外的另一个内存管理神器"><a href="#缓冲区初始化-主内存外的另一个内存管理神器" class="headerlink" title="缓冲区初始化 主内存外的另一个内存管理神器"></a>缓冲区初始化 主内存外的另一个内存管理神器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mem_init(main_memory_start, memory_end);</span><br><span class="line">    ...</span><br><span class="line">    buffer_init(buffer_memory_end);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在管理内存之初，我们划分出了三个边界值，对主内存和缓冲区进行了区分</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_28.png"></p>
<p>并通过 mem_init 完成了主内存区初始化， 设置好了内存管理结构 mam_map</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_29.png"></p>
<p>至此，我们完成了主内存区的管理，而缓冲区是如何管理和分配的，就要看 buffer_init 了。</p>
<p>我们还是采用之前的方式，就假设内存只有 8M，把一些不相干的分支去掉，方便理解。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">extern int end;</span><br><span class="line">struct buffer_head * start_buffer = (struct buffer_head *) &amp;end;</span><br><span class="line"></span><br><span class="line">void buffer_init(long buffer_end) &#123;</span><br><span class="line">    struct buffer_head * h = start_buffer;</span><br><span class="line">    void * b = (void *) buffer_end;</span><br><span class="line">    while ( (b -= 1024) &gt;= ((void *) (h+1)) ) &#123;</span><br><span class="line">        h-&gt;b_dev = 0;</span><br><span class="line">        h-&gt;b_dirt = 0;</span><br><span class="line">        h-&gt;b_count = 0;</span><br><span class="line">        h-&gt;b_lock = 0;</span><br><span class="line">        h-&gt;b_uptodate = 0;</span><br><span class="line">        h-&gt;b_wait = NULL;</span><br><span class="line">        h-&gt;b_next = NULL;</span><br><span class="line">        h-&gt;b_prev = NULL;</span><br><span class="line">        h-&gt;b_data = (char *) b;</span><br><span class="line">        h-&gt;b_prev_free = h-1;</span><br><span class="line">        h-&gt;b_next_free = h+1;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    h--;</span><br><span class="line">    free_list = start_buffer;</span><br><span class="line">    free_list-&gt;b_prev_free = h;</span><br><span class="line">    h-&gt;b_next_free = free_list;</span><br><span class="line">    for (int i=0;i&lt;307;i++)</span><br><span class="line">        hash_table[i]=NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然很长，但其实就造了<strong>两个数据结构</strong>而已。</p>
<h4 id="通过链接器-ld-获取缓冲区开始位置"><a href="#通过链接器-ld-获取缓冲区开始位置" class="headerlink" title="通过链接器 ld 获取缓冲区开始位置"></a>通过链接器 ld 获取缓冲区开始位置</h4><p>不过别急，我们先看这一行代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern int end;</span><br><span class="line">void buffer_init(long buffer_end) &#123;</span><br><span class="line">    struct buffer_head * start_buffer = (struct buffer_head *) &amp;end;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个外部变量 <strong>end</strong>，而我们的缓冲区开始位置 <strong>start_buffer</strong> 就等于这个变量的内存地址。</p>
<p>这个外部变量 end 并不是操作系统代码写就的，而是由<strong>链接器 ld</strong> 在链接整个程序时设置的一个外部变量，帮我们计算好了整个内核代码的末尾地址。</p>
<p>那在这之前的是内核代码区域肯定不能用，在这之后的，就给 buffer 用了。所以我们的内存分布图可以更精确一点了。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_30.png"></p>
<p>你看，之前的疑惑解决了吧？很好理解嘛，内核程序和缓冲区的划分，肯定有个分界线，这个分界线就是 end 变量的值。</p>
<p>这个值定多少合适呢？</p>
<p>像主内存和缓冲区的分界线，就直接代码里写死了，就是上图中的 2M。</p>
<p>可是内核程序占多大内存在写的时候完全不知道，就算知道了如果改动一点代码也会变化，所以就由程序编译链接时由链接器程序帮我们把这个内核代码末端的地址计算出来，作为一个外部变量 end 我们拿来即用，就方便多了。</p>
<h4 id="两个内存管理结构"><a href="#两个内存管理结构" class="headerlink" title="两个内存管理结构"></a>两个内存管理结构</h4><p>好，回过头我们再看看，<strong>整段代码创造了哪两个管理结构</strong>？</p>
<p>我们先看这段结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void buffer_init(long buffer_end) &#123;</span><br><span class="line">    struct buffer_head * h = start_buffer;</span><br><span class="line">    void * b = (void *) buffer_end;</span><br><span class="line">    while ( (b -= 1024) &gt;= ((void *) (h+1)) ) &#123;</span><br><span class="line">        ...</span><br><span class="line">        h-&gt;b_data = (char *) b;</span><br><span class="line">        h-&gt;b_prev_free = h-1;</span><br><span class="line">        h-&gt;b_next_free = h+1;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就俩变量。</p>
<ul>
<li>一个是 buffer_head 结构的 h，代表缓冲头，其指针值是 start_buffer，刚刚我们计算过了，就是图中的内核代码末端地址 end，也就是缓冲区开头。</li>
<li>一个是 b，代表缓冲块，指针值是 buffer_end，也就是图中的 2M，就是缓冲区结尾。</li>
</ul>
<p>缓冲区结尾的 b 每次循环 -1024，也就是一页的值，缓冲区结尾的 h 每次循环 +1（一个 buffer_head 大小的内存），直到碰一块为止。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_31.png"></p>
<p>可以看到，其实这个 b 就代表缓冲块，h 代表缓冲头，一个从上往下，一个从下往上。</p>
<p>而且这个过程中，h 被附上了属性值，其中比较关键的是这个 buffer 所表示的数据部分 b_data，也就是指向了上面的缓冲块 b。</p>
<p>还有这个 buffer 的前后空闲 buffer 的指针 b_prev_free 和 b_next_free。</p>
<p>那画成图就是如下这样。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_32.png"></p>
<p>当缓冲头 h 的所有 next 和 prev 指针都指向彼此时，就构成了一个双向链表。继续看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void buffer_init(long buffer_end) &#123;</span><br><span class="line">...</span><br><span class="line">free_list = start_buffer;</span><br><span class="line">free_list-&gt;b_prev_free = h;</span><br><span class="line">h-&gt;b_next_free = free_list;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三行代码，结合刚刚的双向链表 h，我画出图，你就懂了。</p>
<p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_33.png"></p>
<p>看，free_list 指向了缓冲头双向链表的第一个结构，然后就可以顺着这个结构，从双向链表中遍历到任何一个缓冲头结构了，而通过缓冲头又可以找到这个缓冲头对应的缓冲块。</p>
<p>简单说，<strong>缓冲头就是具体缓冲块的管理结构，而 free_list 开头的双向链表又是缓冲头的管理结构</strong>，整个管理体系就这样建立起来了。</p>
<p>现在，从 free_list 开始遍历，就可以找到这里的所有内容了。</p>
<h4 id="通过-哈希表-双向链表-进一步优化查询"><a href="#通过-哈希表-双向链表-进一步优化查询" class="headerlink" title="通过 哈希表 + 双向链表 进一步优化查询"></a>通过 哈希表 + 双向链表 进一步优化查询</h4><p>不过，还有最后一个事，能帮助更好管理，往下看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void buffer_init(long buffer_end) &#123;</span><br><span class="line">    ...</span><br><span class="line">    for (i=0;i&lt;307;i++)</span><br><span class="line">        hash_table[i]=NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 307 大小的 <strong>hash_table</strong> 数组，这是干嘛的呢？</p>
<p>其实这段代码在 <strong>buffer.c</strong> 中，而 buffer.c 是在 <strong>fs</strong> 包下的，也就是<strong>文件系统</strong>包下的。所以它今后是为文件系统而服务，具体是内核程序如果需要访问块设备中的数据，就都需要经过缓冲区来间接地操作。</p>
<p>也就是说，读取块设备的数据（硬盘中的数据），需要先读到缓冲区中，如果缓冲区已有了，就不用从块设备读取了，直接取走。</p>
<p>那怎么知道缓冲区已经有了要读取的块设备中的数据呢？从双向链表从头遍历当然可以，但是这效率可太低了。所以需要一个 hashmap 的结构方便快速查找，这就是 hash_table 这个数组的作用。</p>
<p>现在只是初始化这个 hash_table，还并没有哪个地方用到了它，所以我就先简单剧透下。</p>
<p>之后当要读取某个块设备上的数据时，首先要搜索相应的缓冲块，是下面这个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#define _hashfn(dev,block) (((unsigned)(dev^block))%307)</span><br><span class="line">#define hash(dev,block) hash_table[_hashfn(dev,block)]</span><br><span class="line"></span><br><span class="line">// 搜索合适的缓冲块 </span><br><span class="line">struct buffer_head * getblk(int dev,int block) &#123;</span><br><span class="line">    ...</span><br><span class="line">    struct buffer_head bh = get_hash_table(dev,block)；</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct buffer_head * get_hash_table(int dev, int block) &#123;</span><br><span class="line">    ...    </span><br><span class="line">    find_buffer(dev,block);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct buffer_head * find_buffer(int dev, int block) &#123; </span><br><span class="line">    ...     </span><br><span class="line">    hash(dev,block);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一路跟下来发现，就是通过</p>
<figure class="highlight plaintext"><figcaption><span>% 307``` 即 ```(设备号^逻辑块号) Mod 307``` 找到在 hash_table 里的索引下标，接下来就和 Java 里的 HashMap 类似，如果哈希冲突就形成链表，画成图就是这样。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](./操作系统第二步之大战前期的初始化工作/img_34.png)</span><br><span class="line"></span><br><span class="line">**哈希表 + 双向链表**，如果刷算法题多了，很容易想到这可以实现 **LRU 算法**，没错，之后的缓冲区使用和弃用，正是这个算法发挥了作用。</span><br><span class="line"></span><br><span class="line">也就是之后在讲通过文件系统来读取硬盘文件时，都需要使用和弃用这个缓冲区里的内容，缓冲区即是用户进程的内存和硬盘之间的桥梁。</span><br><span class="line"></span><br><span class="line">### 硬盘初始化 - hd_init</span><br><span class="line"></span><br><span class="line">至此，我们只剩下了最后两个初始化函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>void main(void) {<br>    …<br>    mem_init(main_memory_start,memory_end);<br>    trap_init();<br>    blk_dev_init();<br>    chr_dev_init();<br>    tty_init();<br>    time_init();<br>    sched_init();<br>    buffer_init(buffer_memory_end);<br>    hd_init(); //本节重点<br>    floppy_init();</p>
<pre><code>sti();
move_to_user_mode();
if (!fork()) &#123;init();&#125;
for(;;) pause();
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">floppy_init 是软盘初始化，现在软盘几乎都被淘汰了，计算机中也没有软盘驱动器了，所以这个我们完全可以不看。</span><br><span class="line"></span><br><span class="line">我们直接看 hd_init 硬盘初始化干了什么？</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>void hd_init(void) {<br>    blk_dev[3].request_fn = do_hd_request;<br>    set_intr_gate(0x2E,&amp;hd_interrupt);<br>    outb_p(inb_p(0x21)&amp;0xfb,0x21);<br>    outb(inb_p(0xA1)&amp;0xbf,0xA1);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">就这？一共就四行代码。</span><br><span class="line"></span><br><span class="line">没错，初始化嘛，往往都比较简单，尤其是对硬件设备的初始化，大体都是：</span><br><span class="line">1. 往某些 IO 端口上读写一些数据，表示开启它；</span><br><span class="line">2. 然后再向中断向量表中添加一个中断，使得 CPU 能够响应这个硬件设备的动作；</span><br><span class="line">3. 最后再初始化一些数据结构来管理。不过像是内存管理可能结构复杂些，外设的管理，相对就简单很多了。</span><br><span class="line"></span><br><span class="line">#### blk_dev[3]</span><br><span class="line"></span><br><span class="line">看第一行代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>void hd_init(void) {<br>    blk_dev[3].request_fn = do_hd_request;<br>    …<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们把 blk_dev 数组索引 3 位置处的块设备管理结构 blk_dev_struct 的 request_fn 赋值为了 do_hd_request，这是啥意思呢？</span><br><span class="line"></span><br><span class="line">因为有很多块设备，所以 Linux 0.11 内核用了一个 blk_dev[] 来进行管理，每一个索引表示一个块设备。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>struct blk_dev_struct blk_dev[NR_BLK_DEV] = {<br>    { NULL, NULL },     /* no_dev <em>/<br>    { NULL, NULL },     /</em> dev mem <em>/<br>    { NULL, NULL },     /</em> dev fd <em>/<br>    { NULL, NULL },     /</em> dev hd <em>/<br>    { NULL, NULL },     /</em> dev ttyx <em>/<br>    { NULL, NULL },     /</em> dev tty <em>/<br>    { NULL, NULL }      /</em> dev lp */<br>};</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">你看，索引为 3 这个位置，就表示给硬盘 hd 这个块设备留的位置。</span><br><span class="line"></span><br><span class="line">那么每个块设备执行读写请求都有自己的函数实现，在上层看来都是一个统一函数 request_fn 即可，具体实现各有不同，对于硬盘来说，这个实现就是 do_hd_request 函数。</span><br><span class="line"></span><br><span class="line">是不是有点像接口？这其实就是**多态**思想在 C 语言的体现嘛~ 用 Java 程序员熟悉的话就是，父类引用 request_fn 指向子类对象 do_hd_request 的感觉咯。</span><br><span class="line"></span><br><span class="line">#### 设置中断 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>void hd_init(void) {<br>    …<br>    set_intr_gate(0x2E,&amp;hd_interrupt);<br>    …<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对于中断我们已经很熟悉了，这里就是又设置了一个新的中断，中断号是 0x2E，中断处理函数是 hd_interrupt，也就是说硬盘发生读写时，硬盘会发出中断信号给 CPU，之后 CPU 便会陷入中断处理程序，也就是执行 hd_interrupt 函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>_hd_interrupt:<br>    …<br>    xchgl _do_hd,%edx<br>    …</p>
<p>// 如果是读盘操作，这个 do_hd 是 read_intr<br>static void read_intr(void) {<br>    …<br>    do_hd_request();<br>    …<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">好了，又多了一个中断，那我们再次梳理下目前开启的中断都有哪些。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 中断号 | 中断处理函数           |</span><br><span class="line">| ---- |------------------|</span><br><span class="line">| 0 ~ 0x10 | trap_init 里设置的一堆 |</span><br><span class="line">| 0x20 | timer_interrupt  |</span><br><span class="line">| 0x21 | keyboard_interrupt |</span><br><span class="line">| 0x2E | hd_interrupt |</span><br><span class="line">| 0x80 | system_call | </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看到最后，你会发现操作系统就是一个靠中断驱动的死循环而已，如果不发生任何中断，操作系统会一直在一个死循环里等待。换句话说，让操作系统工作的唯一方式，就是触发中断。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 允许硬盘控制器发送中断请求信号</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>void hd_init(void) {<br>    …<br>    outb_p(inb_p(0x21)&amp;0xfb,0x21);<br>    outb(inb_p(0xA1)&amp;0xbf,0xA1);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">就是往几个 IO 端口上读写，其作用是**允许硬盘控制器发送中断请求信号**，仅此而已。我们向来是不深入硬件细节，知道往这个端口里写上这些数据，导致硬盘开启了中断，即可。</span><br><span class="line"></span><br><span class="line">#### 拓展</span><br><span class="line"></span><br><span class="line">hd.c 里还有很多读写硬盘的方法，这个在之后文件系统用到他们时，自然会讲起，这里就抛个引子，看看读硬盘最最底层的操作流程，是怎样的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 端口     | 读                        | 写      |</span><br><span class="line">|--------|--------------------------|--------|</span><br><span class="line">| 0x1F0  | 数据寄存器	                   | 数据寄存器  |</span><br><span class="line">| 0x1F1  | 错误寄存器	                   | 特征寄存器 |</span><br><span class="line">| 0x1F2  | 扇区计数寄存器	                 | 扇区计数寄存器 | </span><br><span class="line">| 0x1F3  | 扇区号寄存器或 LBA 块地址 0~7      | 扇区号或 LBA 块地址 0~7 |</span><br><span class="line">| 0x1F4  | 磁道数低 8 位或 LBA 块地址 8~15   | 磁道数低 8 位或 LBA 块地址 8~15 |</span><br><span class="line">| 0x1F5  | 磁道数高 8 位或 LBA 块地址 16~23	 | 磁道数高 8 位或 LBA 块地址 16~23 |</span><br><span class="line">| 0x1F6  | 驱动器/磁头或 LBA 块地址 24~27    | 驱动器/磁头或 LBA 块地址 24~27 |</span><br><span class="line">| 0x1F7  | 命令寄存器或状态寄存器              | 命令寄存器 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那读硬盘就是，往除了第一个以外的后面几个端口写数据，告诉要读硬盘的哪个扇区，读多少。然后再从 0x1F0 端口一个字节一个字节的读数据。这就完成了一次硬盘读操作。</span><br><span class="line"></span><br><span class="line">如果觉得不够具体，那来个具体的版本。</span><br><span class="line"></span><br><span class="line">1. 在 0x1F2 写入要读取的扇区数</span><br><span class="line">2. 在 0x1F3 ~ 0x1F6 这四个端口写入计算好的起始 LBA 地址</span><br><span class="line">3. 在 0x1F7 处写入读命令的指令号</span><br><span class="line">4. 不断检测 0x1F7 （此时已成为状态寄存器的含义）的忙位</span><br><span class="line">5. 如果第四步骤为不忙，则开始不断从 0x1F0 处读取数据到内存指定位置，直到读完</span><br><span class="line"></span><br><span class="line">而操作系统的代码，也是这样写的，我们一睹为快一下，不用理解细节。</span><br></pre></td></tr></table></figure>
<p>static void hd_out(unsigned int drive,unsigned int nsect,unsigned int sect,<br>        unsigned int head,unsigned int cyl,unsigned int cmd,<br>        void (*intr_addr)(void)) {<br>    …<br>    do_hd = intr_addr;<br>    outb_p(hd_info[drive].ctl,HD_CMD);<br>    port = 0x1f0;<br>    outb_p(hd_info[drive].wpcom&gt;&gt;2,++port);<br>    outb_p(nsect,++port);<br>    outb_p(sect,++port);<br>    outb_p(cyl,++port);<br>    outb_p(cyl&gt;&gt;8,++port);<br>    outb_p(0xA0|(drive&lt;&lt;4)|head,++port);<br>    outb(cmd,++port);<br>}</p>
<pre><code>
看，那些 outb_p 方法，转换成汇编语言，就是 out 指令，往指定的硬盘 IO 端口上写数据，达到我们想要的读或者写的目的。

是不是很 low？

但我们由用户层写的各种 read\write 函数，即便是经过系统调用、文件系统、缓冲区管理等等过程，但只要是读写硬盘，最终都要调用到这个最底层的函数，殊途同归，逃不掉的！

### 总结

[大战前期的初始化工作](https://mp.weixin.qq.com/s/Hf9B1ww1wFxiUDkWb0obeQ)
</code></pre>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/"><span>操作系统第一步之进入内核前的苦力活</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '83850031ee87c27765eb',
  clientSecret: '6c5e13a8b6670d5bfa85ba548ba3570cae29e671',
  repo: 'blob-comment',
  owner: 'hepeng0',
  admin: 'hepeng0',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By 何鹏 [smile.hepeng@qq.com]</div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://unpkg.zhimg.com/animejs@3.2.1/lib/anime.min.js"></script><script src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script src="https://unpkg.zhimg.com/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://unpkg.com/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://unpkg.com/velocity-ui-pack@1.2.2/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>