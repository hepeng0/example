<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Redis底层存储结构之用户数据结构存储模式详解"><meta name="keywords" content="Redis,跳跃表,索引"><meta name="author" content="何鹏 [smile.hepeng@qq.com]"><meta name="copyright" content="何鹏 [smile.hepeng@qq.com]"><title>Redis底层存储结构之用户数据结构存储模式详解 | 沉默者</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><link rel="alternate" href="/atom.xml" title="沉默者" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-Dict%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">Redis Dict结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Dict"><span class="toc-number">2.1.</span> <span class="toc-text">为什么要使用Dict</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dict%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.</span> <span class="toc-text">Dict的数据结构定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91dictType%E7%BB%93%E6%9E%84%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%88type%EF%BC%89%E3%80%82"><span class="toc-number">2.2.1.</span> <span class="toc-text">一个指向dictType结构的指针（type）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#privdata%E3%80%82"><span class="toc-number">2.2.2.</span> <span class="toc-text">privdata。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88ht-2-%EF%BC%89%E3%80%82"><span class="toc-number">2.2.3.</span> <span class="toc-text">两个哈希表（ht[2]）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#used"><span class="toc-number">2.2.4.</span> <span class="toc-text">used</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dict%E7%9A%84CURD"><span class="toc-number">2.3.</span> <span class="toc-text">Dict的CURD</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dictCreate"><span class="toc-number">2.3.1.</span> <span class="toc-text">dictCreate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dictFind"><span class="toc-number">2.3.2.</span> <span class="toc-text">dictFind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dictAdd-amp-dictReplace"><span class="toc-number">2.3.3.</span> <span class="toc-text">dictAdd &amp; dictReplace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dictDelete"><span class="toc-number">2.3.4.</span> <span class="toc-text">dictDelete</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-SDS"><span class="toc-number">3.</span> <span class="toc-text">Redis SDS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">SDS的数据结构定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sds%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">sds的一些基础函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sds%E7%9A%84CURD"><span class="toc-number">3.3.</span> <span class="toc-text">sds的CURD</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sdsnewlen-%E5%88%9B%E5%BB%BAsds%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.3.1.</span> <span class="toc-text">sdsnewlen 创建sds字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sdsfree-%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"><span class="toc-number">3.3.2.</span> <span class="toc-text">sdsfree 释放内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sdscatlen-%E8%BF%BD%E5%8A%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.3.</span> <span class="toc-text">sdscatlen 追加操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E8%B0%88sds%E4%B8%8Estring%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.4.</span> <span class="toc-text">浅谈sds与string的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-robj"><span class="toc-number">4.</span> <span class="toc-text">Redis robj</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#robj%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.</span> <span class="toc-text">robj的数据结构定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-robj%E7%9A%84%E7%BC%96%E7%A0%81%E8%BF%87%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">string robj的编码过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-robj%E7%9A%84%E8%A7%A3%E7%A0%81%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">string robj的解码过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88sds%E4%B8%8Estring%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.4.</span> <span class="toc-text">再谈sds与string的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#robj%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="toc-number">4.5.</span> <span class="toc-text">robj的引用计数操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-ziplist"><span class="toc-number">5.</span> <span class="toc-text">Redis ziplist</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFziplist"><span class="toc-number">5.1.</span> <span class="toc-text">什么是ziplist</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ziplist%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.2.</span> <span class="toc-text">ziplist的数据结构定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ziplist%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.3.</span> <span class="toc-text">ziplist的接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ziplist%E7%9A%84%E6%8F%92%E5%85%A5%E9%80%BB%E8%BE%91%E8%A7%A3%E6%9E%90"><span class="toc-number">5.3.1.</span> <span class="toc-text">ziplist的插入逻辑解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%E4%B8%8Eziplist"><span class="toc-number">5.4.</span> <span class="toc-text">hash与ziplist</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-quicklist"><span class="toc-number">6.</span> <span class="toc-text">Redis quicklist</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#quickList%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">quickList概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#quicklist%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.2.</span> <span class="toc-text">quicklist的数据结构定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#quicklist%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81"><span class="toc-number">6.3.</span> <span class="toc-text">quicklist执行过程源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#quicklist%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">6.3.1.</span> <span class="toc-text">quicklist的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#quicklist%E7%9A%84push%E6%93%8D%E4%BD%9C"><span class="toc-number">6.3.2.</span> <span class="toc-text">quicklist的push操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#quicklist%E7%9A%84%E5%85%B6%E5%AE%83%E6%93%8D%E4%BD%9C"><span class="toc-number">6.3.3.</span> <span class="toc-text">quicklist的其它操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-SkipList"><span class="toc-number">7.</span> <span class="toc-text">Redis SkipList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%B3%E8%B7%83%E8%A1%A8"><span class="toc-number">7.1.</span> <span class="toc-text">什么是跳跃表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#skiplist%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B"><span class="toc-number">7.1.1.</span> <span class="toc-text">skiplist数据结构简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#skiplist%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD"><span class="toc-number">7.1.2.</span> <span class="toc-text">skiplist算法性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#skiplist%E4%B8%8E%E5%B9%B3%E8%A1%A1%E6%A0%91%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">7.1.3.</span> <span class="toc-text">skiplist与平衡树、哈希表的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%ADSkipList%E4%BD%BF%E7%94%A8"><span class="toc-number">7.2.</span> <span class="toc-text">Redis中SkipList使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%ADSkipList%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.3.</span> <span class="toc-text">Redis中SkipList的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%B8%ADSkipList%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="toc-number">7.3.1.</span> <span class="toc-text">Redis中SkipList实现的特殊性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SkipList%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">7.3.2.</span> <span class="toc-text">SkipList的数据结构定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E4%B8%AD%E7%9A%84SortedSet"><span class="toc-number">7.3.3.</span> <span class="toc-text">Redis中的SortedSet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%ADSkipList%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">7.4.</span> <span class="toc-text">Redis中SkipList常用操作时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-IntSet"><span class="toc-number">8.</span> <span class="toc-text">Redis IntSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#intset%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B"><span class="toc-number">8.1.</span> <span class="toc-text">intset数据结构简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#intset%E7%9A%84%E6%9F%A5%E6%89%BE%E5%92%8C%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">8.2.</span> <span class="toc-text">intset的查找和添加操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#intsetFind"><span class="toc-number">8.2.1.</span> <span class="toc-text">intsetFind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#intsetAdd"><span class="toc-number">8.2.2.</span> <span class="toc-text">intsetAdd</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-Set%E7%BB%93%E6%9E%84"><span class="toc-number">8.3.</span> <span class="toc-text">Redis Set结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RedisSet%E7%9A%84%E5%B9%B6%E3%80%81%E4%BA%A4%E3%80%81%E5%8F%89%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.</span> <span class="toc-text">RedisSet的并、交、叉算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E9%9B%86"><span class="toc-number">8.4.1.</span> <span class="toc-text">交集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E9%9B%86"><span class="toc-number">8.4.2.</span> <span class="toc-text">并集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%AE%E9%9B%86"><span class="toc-number">8.4.3.</span> <span class="toc-text">差集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%98%85%E8%AF%BB"><span class="toc-number">9.</span> <span class="toc-text">参考阅读</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img2.baidu.com/it/u=928705063,3876627980&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg"></div><div class="author-info__name text-center">何鹏 [smile.hepeng@qq.com]</div><div class="author-info__description text-center">路漫漫其修远兮，吾将上下而求索</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">69</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">53</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默者</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Redis底层存储结构之用户数据结构存储模式详解</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">29.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 96 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis作为目前已知速度最快的Key-Value数据库，本质上是一个数据结构服务器（data structures server），以高效的方式实现了多种现成的数据结构，研究它的数据结构和基于其上的算法，对于我们自己提升局部算法的编程水平有很重要的参考意义。</p>
<p>当我们提到Redis的“数据结构”，可能是在两个不同的层面来讨论它。</p>
<p>第一个层面，是从使用者的角度。比如：</p>
<ul>
<li>string</li>
<li>list</li>
<li>hash</li>
<li>set</li>
<li>sorted set</li>
</ul>
<p>这一层面也是Redis暴露给外部的调用接口。</p>
<p>第二个层面，是从内部实现的角度，属于更底层的实现。 比如：</p>
<ul>
<li>dict</li>
<li>sds</li>
<li>ziplist</li>
<li>quicklist</li>
<li>skiplist</li>
</ul>
<p>对于第一个层面的”数据结构“，<a target="_blank" rel="noopener" href="http://redis.io/topics/data-types-intro">Redis官方文档</a>有详细介绍，我们在 <a href="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" title="Redis初探之常见问题汇总">Redis初探之常见问题汇总</a> 也有简单的总结。</p>
<p>本文的重点在于讨论第二个层面：</p>
<ul>
<li>Redis数据结构的内部实现</li>
<li>以及这两个层面的数据结构之间的关系： Redis如何通过组合第二个层面的各种基础数据结构来实现第一个层面的更高层的数据结构。</li>
</ul>
<p>在讨论任何一个系统的内部实现的时候，我们都要先明确它的设计原则，这样我们才能更深刻地理解它为什么会进行如此设计的真正意图。</p>
<p>在本文接下来的讨论中，我们主要关注以下几点：</p>
<ul>
<li>存储效率（memory efficiency）。<ul>
<li>Redis是专用于存储数据的，它对于计算机资源的主要消耗就在于内存，因此节省内存是它非常非常重要的一个方面。</li>
<li>这意味着Redis一定是非常精细地考虑了<strong>压缩数据、减少内存碎片</strong>等问题。</li>
</ul>
</li>
<li>快速响应时间（fast response time）。<ul>
<li>与快速响应时间相对的，是高吞吐量（high throughput）。</li>
<li>Redis是用于提供在线访问的，对于单个请求的响应时间要求很高，因此，<strong>快速响应时间是比高吞吐量更重要的目标</strong>。</li>
<li>有时候，这两个目标是矛盾的。</li>
</ul>
</li>
<li>单线程（single-threaded）。<ul>
<li>Redis的性能瓶颈不在于CPU资源，而在于内存访问和网络IO。</li>
<li>而采用单线程的设计带来的好处是，极大简化了数据结构和算法的实现。</li>
<li>相反，Redis通过异步IO和pipelining等机制来实现高速的并发访问。</li>
<li>显然，单线程的设计，对于单个请求的快速响应时间也提出了更高的要求。</li>
</ul>
</li>
</ul>
<h2 id="Redis-Dict结构"><a href="#Redis-Dict结构" class="headerlink" title="Redis Dict结构"></a>Redis Dict结构</h2><p>dict是一个用于维护key和value映射关系的数据结构，与很多语言中的Map或dictionary类似。</p>
<ul>
<li>Redis的一个database中所有key到value的映射，就是使用一个dict来维护的。</li>
</ul>
<p>不过，这只是它在Redis中的一个用途而已，它在Redis中被使用的地方还有很多。</p>
<ul>
<li>比如，一个Redis hash结构，当它的field较多时，便会采用dict来存储。</li>
<li>再比如，Redis配合使用dict和skiplist来共同维护一个sorted set。</li>
</ul>
<p>这些细节我们后面再讨论，我们先集中精力讨论dict本身的实现。</p>
<h3 id="为什么要使用Dict"><a href="#为什么要使用Dict" class="headerlink" title="为什么要使用Dict"></a>为什么要使用Dict</h3><p>dict本质上是为了解决算法中的查找问题（Searching）。</p>
<p>一般查找问题的解法分为两个大类：</p>
<ul>
<li>一个是基于各种平衡树，</li>
<li>一个是基于哈希表。</li>
</ul>
<p>我们平常使用的各种Map或dictionary，大都是基于哈希表实现的。</p>
<p>在不要求数据有序存储，且能保持较低的哈希值冲突概率的前提下，基于哈希表的查找性能能做到非常高效，接近O(1)，而且实现简单。</p>
<p>在Redis中，dict也是一个<strong>基于哈希表</strong>的算法。</p>
<p>和传统的哈希算法类似，它采用某个<strong>哈希函数</strong>从key计算得到在哈希表中的位置，采用<strong>拉链法</strong>解决冲突，并在装载因子（load factor）超过预定值时自动扩展内存，引发<strong>重哈希</strong>（rehashing）。</p>
<p>Redis的dict实现最显著的一个特点，就在于它的重哈希。</p>
<p>它采用了一种称为<strong>增量式重哈希</strong>（incremental rehashing）的方法，在需要扩展内存时避免一次性对所有key进行重哈希，而是将重哈希操作分散到对于dict的各个增删改查的操作中去。</p>
<p>这种方法能做到<strong>每次只对一小部分key进行重哈希</strong>，而每次重哈希之间不影响dict的操作。</p>
<p>dict之所以这样设计，是为了<strong>避免重哈希期间单个请求的响应时间剧烈增加</strong>，这与前面提到的“快速响应时间”的设计原则是相符的。</p>
<h3 id="Dict的数据结构定义"><a href="#Dict的数据结构定义" class="headerlink" title="Dict的数据结构定义"></a>Dict的数据结构定义</h3><p>为了实现增量式重哈希（incremental rehashing），dict的数据结构里包含两个哈希表。</p>
<p>在重哈希期间，数据从第一个哈希表向第二个哈希表迁移。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_6.png"></p>
<p>其C代码定义如下(出自Redis源码dict.h)：</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_7.png"></p>
<p>结合上面的代码和结构图，可以很清楚地看出dict的结构。</p>
<h4 id="一个指向dictType结构的指针（type）。"><a href="#一个指向dictType结构的指针（type）。" class="headerlink" title="一个指向dictType结构的指针（type）。"></a>一个指向dictType结构的指针（type）。</h4><ul>
<li>它通过自定义的方式使得dict的key和value能够存储任何类型的数据。</li>
<li>dictType结构包含若干函数指针，用于dict的调用者对涉及key和value的各种操作进行自定义。<ul>
<li>hashFunction，对key进行哈希值计算的哈希算法。</li>
<li>keyDup和valDup，分别定义key和value的拷贝函数，用于在需要的时候对key和value进行深拷贝，而不仅仅是传递对象指针。</li>
<li>keyCompare，定义两个key的比较操作，在根据key进行查找时会用到。 </li>
<li>keyDestructor和valDestructor，分别定义对key和value的析构函数。<h4 id="privdata。"><a href="#privdata。" class="headerlink" title="privdata。"></a>privdata。</h4>一个私有数据指针，由调用者在创建dict的时候传进来，在dictType的某些操作被调用时会传回给调用者。</li>
</ul>
</li>
</ul>
<h4 id="两个哈希表（ht-2-）。"><a href="#两个哈希表（ht-2-）。" class="headerlink" title="两个哈希表（ht[2]）。"></a>两个哈希表（ht[2]）。</h4><p>它定义一个哈希表的结构，由如下若干项组成:</p>
<ul>
<li>一个dictEntry指针数组（table）。<ul>
<li>key的哈希值最终映射到这个数组的某个位置上（对应一个bucket）。</li>
<li>如果多个key映射到同一个位置，就发生了冲突，那么就拉出一个dictEntry链表。</li>
<li>dictEntry结构中包含k, v和指向链表下一项的next指针。<ul>
<li>k是void指针，这意味着它可以指向任何类型。</li>
<li>v是个union，当它的值是uint64_t、int64_t或double类型时，就不再需要额外的存储，这有利于减少内存碎片。</li>
<li>当然，v也可以是void指针，以便能存储任何类型的数据。</li>
</ul>
</li>
</ul>
</li>
<li>size：标识dictEntry指针数组的长度。<ul>
<li>它总是2的指数。</li>
</ul>
</li>
<li>sizemask：用于将哈希值映射到table的位置索引。<ul>
<li>它的值等于(size-1)，比如7, 15, 31, 63，等等，也就是用二进制表示的各个bit全1的数字。每个key先经过hashFunction计算得到一个哈希值，然后计算(哈希值 &amp; sizemask)得到在table上的位置。相当于计算取余(哈希值 % size)。 </li>
</ul>
</li>
</ul>
<h4 id="used"><a href="#used" class="headerlink" title="used"></a>used</h4><p>记录dict中现有的数据个数，它与size的比值就是装载因子（load factor）。</p>
<p>这个比值越大，哈希值冲突概率越高。</p>
<ul>
<li><p>只有在重哈希的过程中，ht[0]和ht[1]才都有效。 而在平常情况下，只有ht[0]有效，ht[1]里面没有任何数据。</p>
</li>
<li><p>上图表示的就是重哈希进行到中间某一步时的情况。</p>
</li>
<li><p>当前重哈希索引（rehashidx）。</p>
<ul>
<li>如果rehashidx = -1，表示当前没有在重哈希过程中；</li>
<li>否则，表示当前正在进行重哈希，且它的值记录了当前重哈希进行到哪一步了。</li>
</ul>
</li>
<li><p>当前正在进行遍历的iterator的个数。这不是我们现在讨论的重点，暂时忽略。</p>
</li>
</ul>
<h3 id="Dict的CURD"><a href="#Dict的CURD" class="headerlink" title="Dict的CURD"></a>Dict的CURD</h3><h4 id="dictCreate"><a href="#dictCreate" class="headerlink" title="dictCreate"></a>dictCreate</h4><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_8.png"></p>
<p>dictCreate为dict的数据结构分配空间并为各个变量赋初值。</p>
<p>其中两个哈希表ht[0]和ht[1]起始都没有分配空间，table指针都赋为NULL。</p>
<p>这意味着要等第一个数据插入时才会真正分配空间。</p>
<h4 id="dictFind"><a href="#dictFind" class="headerlink" title="dictFind"></a>dictFind</h4><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_9.png"></p>
<p>上述dictFind的源码，根据dict当前是否正在重哈希，依次做了这么几件事：</p>
<ul>
<li>如果当前正在进行重哈希，那么将重哈希过程向前推进一步（即调用_dictRehashStep）。实际上，除了查找，插入和删除也都会触发这一动作。这就将重哈希过程分散到各个查找、插入和删除操作中去了，而不是集中在某一个操作中一次性做完。</li>
<li>计算key的哈希值（调用dictHashKey，里面的实现会调用前面提到的hashFunction）。</li>
<li>先在第一个哈希表ht[0]上进行查找。在table数组上定位到哈希值对应的位置（如前所述，通过哈希值与sizemask进行按位与），然后在对应的dictEntry链表上进行查找。查找的时候需要对key进行比较，这时候调用dictCompareKeys，它里面的实现会调用到前面提到的keyCompare。如果找到就返回该项。否则，进行下一步。</li>
<li>判断当前是否在重哈希，如果没有，那么在ht[0]上的查找结果就是最终结果（没找到，返回NULL）。否则，在ht[1]上进行查找（过程与上一步相同）。</li>
</ul>
<p>下面我们有必要看一下增量式重哈希的_dictRehashStep的实现。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_10.png"></p>
<p>dictRehash每次将重哈希至少向前推进n步（除非不到n步整个重哈希就结束了），每一步都将ht[0]上某一个bucket（即一个dictEntry链表）上的每一个dictEntry移动到ht[1]上，它在ht[1]上的新位置根据ht[1]的sizemask进行重新计算。rehashidx记录了当前尚未迁移（有待迁移）的ht[0]的bucket位置。</p>
<p>如果dictRehash被调用的时候，rehashidx指向的bucket里一个dictEntry也没有，那么它就没有可迁移的数据。这时它尝试在ht[0].table数组中不断向后遍历，直到找到下一个存有数据的bucket位置。如果一直找不到，则最多走n*10步，本次重哈希暂告结束。</p>
<p>最后，如果ht[0]上的数据都迁移到ht[1]上了（即d-&gt;ht[0].used == 0），那么整个重哈希结束，ht[0]变成ht[1]的内容，而ht[1]重置为空。</p>
<p>根据以上对于重哈希过程的分析，我们容易看出，本文前面的dict结构图中所展示的正是rehashidx=2时的情况，前面两个bucket（ht[0].table[0]和ht[0].table[1]）都已经迁移到ht[1]上去了。</p>
<h4 id="dictAdd-amp-dictReplace"><a href="#dictAdd-amp-dictReplace" class="headerlink" title="dictAdd &amp; dictReplace"></a>dictAdd &amp; dictReplace</h4><p>dictAdd插入新的一对key和value，如果key已经存在，则插入失败。</p>
<p>dictReplace也是插入一对key和value，不过在key存在的时候，它会更新value。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_11.png"></p>
<p>以上是dictAdd的关键实现代码。我们主要需要注意以下几点：</p>
<ul>
<li>它也会触发推进一步重哈希（_dictRehashStep）。</li>
<li>如果正在重哈希中，它会把数据插入到ht[1]；否则插入到ht[0]。</li>
<li>在对应的bucket中插入数据的时候，总是插入到dictEntry的头部。因为新数据接下来被访问的概率可能比较高，这样再次查找它时就比较次数较少。</li>
<li>_dictKeyIndex在dict中寻找插入位置。如果不在重哈希过程中，它只查找ht[0]；否则查找ht[0]和ht[1]。</li>
<li>_dictKeyIndex可能触发dict内存扩展（_dictExpandIfNeeded，它将哈希表长度扩展为原来两倍，具体请参考dict.c中源码）。</li>
</ul>
<p>dictReplace在dictAdd基础上实现，如下：</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_12.png"></p>
<p>在key已经存在的情况下，dictReplace会同时调用dictAdd和dictFind，这其实相当于两次查找过程。这里Redis的代码不够优化。</p>
<h4 id="dictDelete"><a href="#dictDelete" class="headerlink" title="dictDelete"></a>dictDelete</h4><p>dictDelete的源码这里忽略，具体请参考dict.c。需要稍加注意的是：</p>
<p>dictDelete也会触发推进一步重哈希（_dictRehashStep）</p>
<p>如果当前不在重哈希过程中，它只在ht[0]中查找要删除的key；否则ht[0]和ht[1]它都要查找。</p>
<p>删除成功后会调用key和value的析构函数（keyDestructor和valDestructor）。</p>
<h2 id="Redis-SDS"><a href="#Redis-SDS" class="headerlink" title="Redis SDS"></a>Redis SDS</h2><p>不管在哪门编程语言当中，字符串都几乎是使用最多的数据结构。 sds正是在Redis中被广泛使用的字符串结构，它的全称是Simple Dynamic String。</p>
<p>与其它语言环境中出现的字符串相比，它具有如下显著的特点：</p>
<ul>
<li>可动态扩展内存。sds表示的字符串其内容可以修改，也可以追加。在很多语言中字符串会分为mutable和immutable两种，显然sds属于mutable类型的。</li>
<li>二进制安全（Binary Safe）。sds能存储任意二进制数据，而不仅仅是可打印字符。</li>
<li>与传统的C语言字符串类型兼容。</li>
</ul>
<p>看到这里，很多对Redis有所了解的同学可能已经产生了一个疑问：Redis已经对外暴露了一个字符串结构，叫做string，那这里所说的<strong>sds到底和string是什么关系呢</strong>？可能有人会猜：string是基于sds实现的。这个猜想已经非常接近事实，但在描述上还不太准确。有关string和sds之间关系的详细分析，我们放在后面再讲。现在为了方便讨论，让我们先暂时简单地认为，string的底层实现就是sds。</p>
<p>在讨论sds的具体实现之前，我们先站在Redis使用者的角度，来观察一下string所支持的一些主要操作。下面是一个操作示例：</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_13.png"></p>
<p>以上这些操作都比较简单，我们简单解释一下：</p>
<ul>
<li>初始的字符串的值设为”tielei”。</li>
<li>第3步通过append命令对字符串进行了追加，变成了”tielei zhang”。</li>
<li>然后通过setbit命令将第53个bit设置成了1。bit的偏移量从左边开始算，从0开始。其中第48～55bit是中间的空格那个字符，它的ASCII码是0x20。将第53个bit设置成1之后，它的ASCII码变成了0x24，打印出来就是’$’。因此，现在字符串的值变成了”tielei$zhang”。</li>
<li>最后通过getrange取从倒数第5个字节到倒数第1个字节的内容，得到”zhang”。</li>
</ul>
<p>这些命令的实现，有一部分是和sds的实现有关的。下面我们开始详细讨论。</p>
<h3 id="SDS的数据结构定义"><a href="#SDS的数据结构定义" class="headerlink" title="SDS的数据结构定义"></a>SDS的数据结构定义</h3><p>我们知道，在C语言中，字符串是以’\0’字符结尾（NULL结束符）的字符数组来存储的，通常表达为字符指针的形式（char *）。它不允许字节0出现在字符串中间，因此，它不能用来存储任意的二进制数据。</p>
<p>我们可以在sds.h中找到sds的类型定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef char *sds;</span><br></pre></td></tr></table></figure>
<p>肯定有人感到困惑了，竟然sds就等同于char *？我们前面提到过，sds和传统的C语言字符串保持类型兼容，因此它们的类型定义是一样的，都是char *。在有些情况下，需要传入一个C语言字符串的地方，也确实可以传入一个sds。</p>
<p>但是，sds和char *并不等同。sds是Binary Safe的，它可以存储任意二进制数据，不能像C语言字符串那样以字符’\0’来标识字符串的结束，因此它必然有个长度字段。但这个长度字段在哪里呢？</p>
<p>实际上sds还包含一个header结构：</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_14.png"></p>
<p>sds一共有5种类型的header。之所以有5种，是为了能让不同长度的字符串可以使用不同大小的header。这样，短字符串就能使用较小的header，从而节省内存。</p>
<p>一个sds字符串的完整结构，由在<strong>内存地址上前后相邻</strong>的两部分组成：</p>
<ul>
<li>一个header。通常包含字符串的长度(len)、最大容量(alloc)和flags。sdshdr5有所不同。</li>
<li>一个字符数组。这个字符数组的长度等于最大容量+1。真正有效的字符串数据，其长度通常小于最大容量。在真正的字符串数据之后，是空余未用的字节（一般以字节0填充），允许在不重新分配内存的前提下让字符串数据向后做有限的扩展。在真正的字符串数据之后，还有一个NULL结束符，即ASCII码为0的’\0’字符。这是为了和传统C字符串兼容。之所以字符数组的长度比最大容量多1个字节，就是为了在字符串长度达到最大容量时仍然有1个字节存放NULL结束符。</li>
</ul>
<p>header的类型共有5种，在sds.h中有常量定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define SDS_TYPE_5  0</span><br><span class="line">#define SDS_TYPE_8  1</span><br><span class="line">#define SDS_TYPE_16 2</span><br><span class="line">#define SDS_TYPE_32 3</span><br><span class="line">#define SDS_TYPE_64 4</span><br></pre></td></tr></table></figure>

<p>除了sdshdr5之外，其它4个header的结构都包含3个字段：</p>
<ul>
<li>len: 表示字符串的真正长度（不包含NULL结束符在内）。</li>
<li>alloc: 表示字符串的最大容量（不包含最后多余的那个字节）。</li>
<li>flags: 总是占用一个字节。其中的最低3个bit用来表示header的类型。</li>
</ul>
<p>sds的数据结构，我们有必要非常仔细地去解析它。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_15.png"></p>
<p>上图是sds的一个内部结构的例子。图中展示了两个sds字符串s1和s2的内存结构，一个使用sdshdr8类型的header，另一个使用sdshdr16类型的header。但它们都表达了同样的一个长度为6的字符串的值：”tielei”。下面我们结合代码，来解释每一部分的组成。</p>
<p>sds的字符指针（s1和s2）就是指向真正的数据（字符数组）开始的位置，而header位于内存地址较低的方向。</p>
<p>在sds.h中有一些跟解析header有关的宏定义：</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_16.png"></p>
<p>其中SDS_HDR用来从sds字符串获得header起始位置的指针，比如SDS_HDR(8, s1)表示s1的header指针，SDS_HDR(16, s2)表示s2的header指针。</p>
<p>当然，使用SDS_HDR之前我们必须先知道到底是哪一种header，这样我们才知道SDS_HDR第1个参数应该传什么。由sds字符指针获得header类型的方法是，先向低地址方向偏移1个字节的位置，得到flags字段。比如，s1[-1]和s2[-1]分别获得了s1和s2的flags的值。然后取flags的最低3个bit得到header的类型。</p>
<ul>
<li>由于s1[-1] == 0x01 == SDS_TYPE_8，因此s1的header类型是sdshdr8。</li>
<li>由于s2[-1] == 0x02 == SDS_TYPE_16，因此s2的header类型是sdshdr16。</li>
</ul>
<p>有了header指针，就能很快定位到它的len和alloc字段：</p>
<ul>
<li>s1的header中，len的值为0x06，表示字符串数据长度为6；alloc的值为0x80，表示字符数组最大容量为128。</li>
<li>s2的header中，len的值为0x0006，表示字符串数据长度为6；alloc的值为0x03E8，表示字符数组最大容量为1000。（注意：图中是按小端地址构成）</li>
</ul>
<p>在各个header的类型定义中，还有几个需要我们注意的地方：</p>
<ul>
<li>在各个header的定义中使用了__attribute__ ((packed))，是为了让编译器以紧凑模式来分配内存。如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。</li>
<li>在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。</li>
<li>sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。</li>
</ul>
<p>至此，我们非常清楚地看到了：sds字符串的header，其实隐藏在真正的字符串数据的前面（低地址方向）。这样的一个定义，有如下几个好处：</p>
<ul>
<li>header和数据相邻，而不用分成两块内存空间来单独分配。这有利于减少内存碎片，提高存储效率（memory efficiency）。</li>
<li>虽然header有多个类型，但sds可以用统一的char *来表达。且它与传统的C语言字符串保持类型兼容。如果一个sds里面存储的是可打印字符串，那么我们可以直接把它传给C函数，比如使用strcmp比较字符串大小，或者使用printf进行打印。</li>
</ul>
<p>弄清了sds的数据结构，它的具体操作函数就比较好理解了。</p>
<h3 id="sds的一些基础函数"><a href="#sds的一些基础函数" class="headerlink" title="sds的一些基础函数"></a>sds的一些基础函数</h3><ul>
<li>sdslen(const sds s): 获取sds字符串长度。</li>
<li>sdssetlen(sds s, size_t newlen): 设置sds字符串长度。</li>
<li>sdsinclen(sds s, size_t inc): 增加sds字符串长度。</li>
<li>sdsalloc(const sds s): 获取sds字符串容量。</li>
<li>sdssetalloc(sds s, size_t newlen): 设置sds字符串容量。</li>
<li>sdsavail(const sds s): 获取sds字符串空余空间（即alloc - len）。</li>
<li>sdsHdrSize(char type): 根据header类型得到header大小。</li>
<li>sdsReqType(size_t string_size): 根据字符串数据长度计算所需要的header类型。</li>
</ul>
<p>这里我们挑选sdslen和sdsReqType的代码，察看一下。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_17.png"></p>
<p>sdslen先用s跟前面的分析类似:</p>
<ul>
<li>先用s[-1]向低地址方向偏移1个字节，得到flags；</li>
<li>然后与SDS_TYPE_MASK进行按位与，得到header类型；</li>
<li>然后根据不同的header类型，调用SDS_HDR得到header起始指针，进而获得len字段。</li>
</ul>
<p>通过sdsReqType的代码，很容易看到：</p>
<ul>
<li>长度在0和2^5-1之间，选用SDS_TYPE_5类型的header。</li>
<li>长度在2^5和2^8-1之间，选用SDS_TYPE_8类型的header。</li>
<li>长度在2^8和2^16-1之间，选用SDS_TYPE_16类型的header。</li>
<li>长度在2^16和2^32-1之间，选用SDS_TYPE_32类型的header。</li>
<li>长度大于2^32的，选用SDS_TYPE_64类型的header。能表示的最大长度为2^64-1。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：sdsReqType的实现代码，直到3.2.0，它在长度边界值上都一直存在问题，直到3.2 branch上的commit 6032340才修复。</span><br></pre></td></tr></table></figure>

<h3 id="sds的CURD"><a href="#sds的CURD" class="headerlink" title="sds的CURD"></a>sds的CURD</h3><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_18.png"></p>
<h4 id="sdsnewlen-创建sds字符串"><a href="#sdsnewlen-创建sds字符串" class="headerlink" title="sdsnewlen 创建sds字符串"></a>sdsnewlen 创建sds字符串</h4><p>创建一个长度为initlen的sds字符串，并使用init指向的字符数组（任意二进制数据）来初始化数据。如果init为NULL，那么使用全0来初始化数据。</p>
<p>它的实现中，我们需要注意的是：</p>
<ul>
<li>如果要创建一个长度为0的空字符串，那么不使用SDS_TYPE_5类型的header，而是转而使用SDS_TYPE_8类型的header。这是因为创建的空字符串一般接下来的操作很可能是追加数据，但SDS_TYPE_5类型的sds字符串不适合追加数据（会引发内存重新分配）。</li>
<li>需要的内存空间一次性进行分配，其中包含三部分：header、数据、最后的多余字节（hdrlen+initlen+1）。</li>
<li>初始化的sds字符串数据最后会追加一个NULL结束符（s[initlen] = ‘\0’）。</li>
</ul>
<h4 id="sdsfree-释放内存"><a href="#sdsfree-释放内存" class="headerlink" title="sdsfree 释放内存"></a>sdsfree 释放内存</h4><p>需要注意的是：内存要整体释放，所以要先计算出header起始指针，把它传给s_free函数。</p>
<p>这个指针也正是在sdsnewlen中调用s_malloc返回的那个地址。</p>
<h4 id="sdscatlen-追加操作"><a href="#sdscatlen-追加操作" class="headerlink" title="sdscatlen 追加操作"></a>sdscatlen 追加操作</h4><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_19.png"></p>
<p>sdscatlen将t指向的长度为len的任意二进制数据追加到sds字符串s的后面。本文开头演示的string的append命令，内部就是调用sdscatlen来实现的。</p>
<p>在sdscatlen的实现中，先调用sdsMakeRoomFor来保证字符串s有足够的空间来追加长度为len的数据。sdsMakeRoomFor可能会分配新的内存，也可能不会。</p>
<p>sdsMakeRoomFor是sds实现中很重要的一个函数。关于它的实现代码，我们需要注意的是：</p>
<ul>
<li>如果原来字符串中的空余空间够用（avail &gt;= addlen），那么它什么也不做，直接返回。</li>
<li>如果需要分配空间，它会比实际请求的要多分配一些，以防备接下来继续追加。它在字符串已经比较长的情况下要至少多分配SDS_MAX_PREALLOC个字节，这个常量在sds.h中定义为(1024*1024)=1MB。</li>
<li>按分配后的空间大小，可能需要更换header类型（原来header的alloc字段太短，表达不了增加后的容量）。</li>
<li>如果需要更换header，那么整个字符串空间（包括header）都需要重新分配（s_malloc），并拷贝原来的数据到新的位置。</li>
<li>如果不需要更换header（原来的header够用），那么调用一个比较特殊的s_realloc，试图在原来的地址上重新分配空间。s_realloc的具体实现得看Redis编译的时候选用了哪个allocator（在Linux上默认使用jemalloc）。但不管是哪个realloc的实现，它所表达的含义基本是相同的：它尽量在原来分配好的地址位置重新分配，如果原来的地址位置有足够的空余空间完成重新分配，那么它返回的新地址与传入的旧地址相同；否则，它分配新的地址块，并进行数据搬迁。参见<a target="_blank" rel="noopener" href="http://man.cx/realloc%E3%80%82">http://man.cx/realloc。</a></li>
</ul>
<p>从sdscatlen的函数接口，我们可以看到一种使用模式：<strong>调用它的时候，传入一个旧的sds变量，然后它返回一个新的sds变量</strong>。由于它的内部实现可能会造成地址变化，因此调用者在调用完之后，原来旧的变量就失效了，而都应该用新返回的变量来替换。不仅仅是sdscatlen函数，sds中的其它函数（比如sdscpy、sdstrim、sdsjoin等），还有Redis中其它一些能自动扩展内存的数据结构（如ziplist），也都是同样的使用模式。</p>
<h3 id="浅谈sds与string的关系"><a href="#浅谈sds与string的关系" class="headerlink" title="浅谈sds与string的关系"></a>浅谈sds与string的关系</h3><p>现在我们回过头来看看本文开头给出的string操作的例子：</p>
<ul>
<li>append操作使用sds的sdscatlen来实现。</li>
<li>setbit和getrange都是先根据key取到整个sds字符串，然后再从字符串选取或修改指定的部分。由于sds就是一个字符数组，所以对它的某一部分进行操作似乎都比较简单。</li>
</ul>
<p>但是，string除了支持这些操作之外，当它存储的值是个数字的时候，它还支持incr、decr等操作。 当string存储数字值的时候，它的内部存储就不是sds了。而且，这种情况下，setbit和getrange的实现也会有所不同。这些细节，我们放在后续robj的时候再进行系统地讨论。</p>
<h2 id="Redis-robj"><a href="#Redis-robj" class="headerlink" title="Redis robj"></a>Redis robj</h2><p>从Redis的使用者的角度来看，一个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系。这个映射关系的key是string类型，而value可以是多种数据类型，比如：string, list, hash等。我们可以看到，key的类型固定是string，而value可能的类型是多个。</p>
<p>而从Redis内部实现的角度来看，一个database内的这个映射关系是用一个dict来维护的。dict的key固定用一种数据结构来表达就够了，这就是动态字符串sds。而value则比较复杂，为了在同一个dict内能够存储不同类型的value，这就需要一个通用的数据结构，这个通用的数据结构就是robj（全名是redisObject）。</p>
<p>举个例子：</p>
<ul>
<li>如果value是一个list，那么它的内部存储结构是一个quicklist（quicklist的具体实现我们放在后面的文章讨论）；</li>
<li>如果value是一个string，那么它的内部存储结构一般情况下是一个sds。</li>
<li>当然实际情况更复杂一点，比如一个string类型的value，如果它的值是一个数字，那么Redis内部还会把它转成long型来存储，从而减小内存使用。</li>
</ul>
<p>一个robj既能表示一个sds，也能表示一个quicklist，甚至还能表示一个long型。</p>
<h3 id="robj的数据结构定义"><a href="#robj的数据结构定义" class="headerlink" title="robj的数据结构定义"></a>robj的数据结构定义</h3><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_20.png"></p>
<p>一个robj包含如下5个字段：</p>
<ul>
<li>type: 对象的数据类型。<ul>
<li>占4个bit。</li>
<li>可能的取值有5种：OBJ_STRING, OBJ_LIST, OBJ_SET, OBJ_ZSET, OBJ_HASH，分别对应Redis对外暴露的5种数据结构（即我们在第一篇文章中提到的第一个层面的5种数据结构）。</li>
</ul>
</li>
<li>encoding: 对象的内部表示方式（也可以称为编码）。<ul>
<li>占4个bit。</li>
<li>可能的取值有10种，即前面代码中的10个OBJ_ENCODING_XXX常量。</li>
</ul>
</li>
<li>lru: 做LRU替换算法用<ul>
<li>占24个bit。 </li>
<li>这个不是我们这里讨论的重点，暂时忽略。</li>
</ul>
</li>
<li>refcount: 引用计数。<ul>
<li>它允许robj对象在某些情况下被共享。</li>
</ul>
</li>
<li>ptr: 数据指针。 <ul>
<li>指向真正的数据。</li>
<li>比如，一个代表string的robj，它的ptr可能指向一个sds结构；一个代表list的robj，它的ptr可能指向一个quicklist。</li>
</ul>
</li>
</ul>
<p>对于同一个type，还可能对应不同的encoding，这说明同样的一个数据类型，可能存在不同的内部表示方式。而不同的内部表示，在内存占用和查找性能上会有所不同。</p>
<p>这里特别需要仔细察看的是encoding字段。对于同一个type，还可能对应不同的encoding，这说明同样的一个数据类型，可能存在不同的内部表示方式。而不同的内部表示，在内存占用和查找性能上会有所不同。</p>
<p>比如，当type = OBJ_STRING的时候，表示这个robj存储的是一个string，这时encoding可以是下面3种中的一种：</p>
<ul>
<li>OBJ_ENCODING_RAW: string采用原生的表示方式，即用sds来表示。</li>
<li>OBJ_ENCODING_INT: string采用数字的表示方式，实际上是一个long型。</li>
<li>OBJ_ENCODING_EMBSTR: string采用一种特殊的嵌入式的sds来表示。接下来我们会讨论到这个细节。</li>
</ul>
<p>再举一个例子：当type = OBJ_HASH的时候，表示这个robj存储的是一个hash，这时encoding可以是下面2种中的一种：</p>
<ul>
<li>OBJ_ENCODING_HT: hash采用一个dict来表示。</li>
<li>OBJ_ENCODING_ZIPLIST: hash采用一个ziplist来表示。</li>
</ul>
<p>前面代码段中出现的所有10种encoding，在这里我们先简单解释一下：</p>
<ul>
<li>OBJ_ENCODING_RAW: 最原生的表示方式。其实只有string类型才会用这个encoding值（表示成sds）。</li>
<li>OBJ_ENCODING_INT: 表示成数字。实际用long表示。</li>
<li>OBJ_ENCODING_HT: 表示成dict。</li>
<li>OBJ_ENCODING_ZIPMAP: 是个旧的表示方式，已不再用。在小于Redis 2.6的版本中才有。</li>
<li>OBJ_ENCODING_LINKEDLIST: 也是个旧的表示方式，已不再用。</li>
<li>OBJ_ENCODING_ZIPLIST: 表示成ziplist。</li>
<li>OBJ_ENCODING_INTSET: 表示成intset。用于set数据结构。</li>
<li>OBJ_ENCODING_SKIPLIST: 表示成skiplist。用于sorted set数据结构。</li>
<li>OBJ_ENCODING_EMBSTR: 表示成一种特殊的嵌入式的sds。</li>
<li>OBJ_ENCODING_QUICKLIST: 表示成quicklist。用于list数据结构。</li>
</ul>
<p>我们来总结一下robj的作用：</p>
<ul>
<li>为多种数据类型提供一种统一的表示方式。</li>
<li>允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。</li>
<li>支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。</li>
</ul>
<h3 id="string-robj的编码过程"><a href="#string-robj的编码过程" class="headerlink" title="string robj的编码过程"></a>string robj的编码过程</h3><p>当我们执行Redis的set命令的时候，Redis首先将接收到的value值（string类型）表示成一个type = OBJ_STRING并且encoding = OBJ_ENCODING_RAW的robj对象，然后在存入内部存储之前先执行一个编码过程，试图将它表示成另一种更节省内存的encoding方式。这一过程的核心代码，是object.c中的tryObjectEncoding函数。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_21.png"></p>
<p>这段代码执行的操作比较复杂，我们有必要仔细看一下每一步的操作：</p>
<ul>
<li>第1步检查，检查type。确保只对string类型的对象进行操作。</li>
<li>第2步检查，检查encoding。sdsEncodedObject是定义在server.h中的一个宏，确保只对OBJ_ENCODING_RAW和OBJ_ENCODING_EMBSTR编码的string对象进行操作。这两种编码的string都采用sds来存储，可以尝试进一步编码处理。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define sdsEncodedObject(objptr) (objptr-&gt;encoding == OBJ_ENCODING_RAW </span><br></pre></td></tr></table></figure></li>
<li>第3步检查，检查refcount。引用计数大于1的共享对象，在多处被引用。由于编码过程结束后robj的对象指针可能会变化（我们在介绍sdscatlen函数的时候提到过类似这种接口使用模式），这样对于引用计数大于1的对象，就需要更新所有地方的引用，这不容易做到。因此，对于计数大于1的对象不做编码处理。</li>
<li>试图将字符串转成64位的long。64位的long所能表达的数据范围是-2^63到2^63-1，用十进制表达出来最长是20位数（包括负号）。这里判断小于等于21，似乎是写多了，实际判断小于等于20就够了（如果我算错了请一定告诉我哦）。string2l如果将字符串转成long转成功了，那么会返回1并且将转好的long存到value变量里。<ul>
<li>如果Redis的配置不要求运行LRU替换算法，且转成的long型数字的值又比较小（小于OBJ_SHARED_INTEGERS，在目前的实现中这个值是10000），那么会使用共享数字对象来表示。之所以这里的判断跟LRU有关，是因为LRU算法要求每个robj有不同的lru字段值，所以用了LRU就不能共享robj。shared.integers是一个长度为10000的数组，里面预存了10000个小的数字对象。这些小数字对象都是encoding = OBJ_ENCODING_INT的string robj对象。</li>
<li>如果前一步不能使用共享小对象来表示，那么将原来的robj编码成encoding = OBJ_ENCODING_INT，这时ptr字段直接存成这个long型的值。注意ptr字段本来是一个void *指针（即存储的是内存地址），因此在64位机器上有64位宽度，正好能存储一个64位的long型值。这样，除了robj本身之外，它就不再需要额外的内存空间来存储字符串值。</li>
</ul>
</li>
<li>接下来是对于那些不能转成64位long的字符串进行处理。最后再做两步处理：<ul>
<li>如果字符串长度足够小（小于等于OBJ_ENCODING_EMBSTR_SIZE_LIMIT，定义为44），那么调用createEmbeddedStringObject编码成encoding = OBJ_ENCODING_EMBSTR；<br><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_22.png"><br>createEmbeddedStringObject对sds重新分配内存，将robj和sds放在一个连续的内存块中分配，这样对于短字符串的存储有利于减少内存碎片。这个连续的内存块包含如下几部分：<ul>
<li>16个字节的robj结构。</li>
<li>3个字节的sdshdr8头。</li>
<li>最多44个字节的sds字符数组。 </li>
<li>1个NULL结束符。</li>
</ul>
加起来一共不超过64字节（16+3+44+1），因此这样的一个短字符串可以完全分配在一个64字节长度的内存块中。</li>
<li>如果前面所有的编码尝试都没有成功（仍然是OBJ_ENCODING_RAW），且sds里空余字节过多，那么做最后一次努力，调用sds的sdsRemoveFreeSpace接口来释放空余字节。</li>
</ul>
</li>
</ul>
<h3 id="string-robj的解码过程"><a href="#string-robj的解码过程" class="headerlink" title="string robj的解码过程"></a>string robj的解码过程</h3><p>当我们需要获取字符串的值，比如执行get命令的时候，我们需要执行与前面讲的编码过程相反的操作——解码。</p>
<p>这一解码过程的核心代码，是object.c中的getDecodedObject函数。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_23.png"></p>
<p>这个过程比较简单，需要我们注意的点有：</p>
<ul>
<li><p>编码为OBJ_ENCODING_RAW和OBJ_ENCODING_EMBSTR的字符串robj对象，不做变化，原封不动返回。站在使用者的角度，这两种编码没有什么区别，内部都是封装的sds。</p>
</li>
<li><p>编码为数字的字符串robj对象，将long重新转为十进制字符串的形式，然后调用createStringObject转为sds的表示。注意：这里由long转成的sds字符串长度肯定不超过20，而根据createStringObject的实现，它们肯定会被编码成OBJ_ENCODING_EMBSTR的对象。createStringObject的代码如下：<br><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_24.png"></p>
</li>
</ul>
<h3 id="再谈sds与string的关系"><a href="#再谈sds与string的关系" class="headerlink" title="再谈sds与string的关系"></a>再谈sds与string的关系</h3><p>在SDS章节中，我们简单地提到了sds与string的关系；在本节介绍了robj的概念之后，我们重新总结一下sds与string的关系。</p>
<ul>
<li>确切地说，string在Redis中是用一个robj来表示的。</li>
<li>用来表示string的robj可能编码成3种内部表示：OBJ_ENCODING_RAW, OBJ_ENCODING_EMBSTR, OBJ_ENCODING_INT。其中前两种编码使用的是sds来存储，最后一种OBJ_ENCODING_INT编码直接把string存成了long型。</li>
<li>在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接进行加减操作；如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。</li>
<li>对一个内部表示成long型的string执行append, setbit, getrange这些命令，针对的仍然是string的值（即十进制表示的字符串），而不是针对内部表示的long型进行操作。比如字符串”32”，如果按照字符数组来解释，它包含两个字符，它们的ASCII码分别是0x33和0x32。当我们执行命令setbit key 7 0的时候，相当于把字符0x33变成了0x32，这样字符串的值就变成了”22”。而如果将字符串”32”按照内部的64位long型来解释，那么它是0x0000000000000020，在这个基础上执行setbit位操作，结果就完全不对了。因此，在这些命令的实现中，会把long型先转成字符串再进行相应的操作。由于篇幅原因，这三个命令的实现代码这里就不详细介绍了，有兴趣的读者可以参考Redis源码：<ul>
<li>t_string.c中的appendCommand函数；</li>
<li>biops.c中的setbitCommand函数；</li>
<li>t_string.c中的getrangeCommand函数。</li>
</ul>
</li>
</ul>
<p>值得一提的是，append和setbit命令的实现中，都会最终调用到db.c中的dbUnshareStringValue函数，将string对象的内部编码转成OBJ_ENCODING_RAW的（只有这种编码的robj对象，其内部的sds 才能在后面自由追加新的内容），并解除可能存在的对象共享状态。这里面调用了前面提到的getDecodedObject。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_25.png"></p>
<h3 id="robj的引用计数操作"><a href="#robj的引用计数操作" class="headerlink" title="robj的引用计数操作"></a>robj的引用计数操作</h3><p>将robj的引用计数加1和减1的操作，定义在object.c中：</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_26.png"></p>
<p>我们特别关注一下将引用计数减1的操作decrRefCount。如果只剩下最后一个引用了（refcount已经是1了），那么在decrRefCount被调用后，整个robj将被释放。</p>
<p>注意：<strong>Redis的del命令就依赖decrRefCount操作将value释放掉</strong>。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们很容易看出，robj所表示的就是Redis对外暴露的第一层面的数据结构：string, list, hash, set, sorted set，而每一种数据结构的底层实现所对应的是哪个（或哪些）第二层面的数据结构（dict, sds, ziplist, quicklist, skiplist, 等），则通过不同的encoding来区分。</p>
<p>可以说，robj是联结两个层面的数据结构的桥梁。</p>
<h2 id="Redis-ziplist"><a href="#Redis-ziplist" class="headerlink" title="Redis ziplist"></a>Redis ziplist</h2><p>我们首先介绍一个新的Redis内部数据结构——ziplist，然后在后半部分我们会讨论一下在robj, dict和ziplist的基础上，Redis对外暴露的hash结构是怎样构建起来的。</p>
<p>我们在讨论中还会涉及到两个Redis配置（在redis.conf中的ADVANCED CONFIG部分）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br></pre></td></tr></table></figure>

<p>后续会对这两个配置做详细的解释。</p>
<h3 id="什么是ziplist"><a href="#什么是ziplist" class="headerlink" title="什么是ziplist"></a>什么是ziplist</h3><p>Redis官方对于ziplist的定义是（出自ziplist.c的文件头部注释）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters. It allows push and pop operations on either side of the list in O(1) time.</span><br></pre></td></tr></table></figure>
<p>翻译一下就是说：ziplist是一个经过特殊编码的双向链表，它的设计目标就是为了提高存储效率。ziplist可以用于存储字符串或整数，其中整数是按真正的二进制表示进行编码的，而不是编码成字符串序列。它能以O(1)的时间复杂度在表的两端提供push和pop操作。</p>
<p>实际上，ziplist充分体现了Redis对于存储效率的追求。一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用地址指针（或引用）连接起来。这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内存。而ziplist却是将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。它是一个表（list），但其实不是一个链表（linked list）。</p>
<p>另外，ziplist为了在细节上节省内存，对于值的存储采用了变长的编码方式，大概意思是说，对于大的整数，就多用一些字节来存储，而对于小的整数，就少用一些字节来存储。我们接下来很快就会讨论到这些实现细节。</p>
<h3 id="ziplist的数据结构定义"><a href="#ziplist的数据结构定义" class="headerlink" title="ziplist的数据结构定义"></a>ziplist的数据结构定义</h3><p>ziplist的数据结构组成是ziplist要讨论的重点。实际上，ziplist还是稍微有点复杂的，它复杂的地方就在于它的数据结构定义。一旦理解了数据结构，它的一些操作也就比较容易理解了。</p>
<p>从宏观上看，ziplist的内存结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry&gt;...&lt;entry&gt;&lt;zlend&gt;</span><br></pre></td></tr></table></figure>

<p>各个部分在内存上是前后相邻的，它们分别的含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt;: 32bit，表示ziplist占用的字节总数（也包括&lt;zlbytes&gt;本身占用的4个字节）。</span><br><span class="line"></span><br><span class="line">&lt;zltail&gt;: 32bit，表示ziplist表中最后一项（entry）在ziplist中的偏移字节数。&lt;zltail&gt;的存在，使得我们可以很方便地找到最后一项（不用遍历整个ziplist），从而可以在ziplist尾端快速地执行push或pop操作。</span><br><span class="line"></span><br><span class="line">&lt;zllen&gt;: 16bit， 表示ziplist中数据项（entry）的个数。zllen字段因为只有16bit，所以可以表达的最大值为2^16-1。这里需要特别注意的是，如果ziplist中数据项个数超过了16bit能表达的最大值，ziplist仍然可以来表示。那怎么表示呢？这里做了这样的规定：如果&lt;zllen&gt;小于等于2^16-2（也就是不等于2^16-1），那么&lt;zllen&gt;就表示ziplist中数据项的个数；否则，也就是&lt;zllen&gt;等于16bit全为1的情况，那么&lt;zllen&gt;就不表示数据项个数了，这时候要想知道ziplist中数据项总数，那么必须对ziplist从头到尾遍历各个数据项，才能计数出来。</span><br><span class="line"></span><br><span class="line">&lt;entry&gt;: 表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构，这个稍后再解释。</span><br><span class="line"></span><br><span class="line">&lt;zlend&gt;: ziplist最后1个字节，是一个结束标记，值固定等于255。</span><br></pre></td></tr></table></figure>

<p>上面的定义中还值得注意的一点是：<code>&lt;zlbytes&gt;, &lt;zltail&gt;,&lt;zllen&gt;</code>既然占据多个字节，那么在存储的时候就有大端（big endian）和小端（little endian）的区别。</p>
<p>ziplist采取的是<strong>小端模式</strong>来存储，这在下面我们介绍具体例子的时候还会再详细解释。</p>
<p>我们再来看一下每一个数据项<code>&lt;entry&gt;</code>的构成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;prevrawlen&gt;&lt;len&gt;&lt;data&gt;</span><br></pre></td></tr></table></figure>
<p>我们看到在真正的数据（<data>）前面，还有两个字段：</data></p>
<ul>
<li><code>&lt;prevrawlen&gt;</code>: 表示前一个数据项占用的总字节数。这个字段的用处是为了让ziplist能够从后向前遍历（从后一项的位置，只需向前偏移prevrawlen个字节，就找到了前一项）。这个字段采用变长编码。</li>
<li><code>&lt;len&gt;</code>: 表示当前数据项的数据长度（即<data>部分的长度）。也采用变长编码。</data></li>
</ul>
<p>那么<code>&lt;prevrawlen&gt;</code>和<code>&lt;len&gt;</code>是怎么进行变长编码的呢？各位读者打起精神了，我们终于讲到了ziplist的定义中最繁琐的地方了。</p>
<p>先说<code>&lt;prevrawlen&gt;</code>。它有两种可能，或者是1个字节，或者是5个字节：</p>
<ul>
<li>如果前一个数据项占用字节数小于254，那么<code>&lt;prevrawlen&gt;</code>就只用一个字节来表示，这个字节的值就是前一个数据项的占用字节数。</li>
<li>如果前一个数据项占用字节数大于等于254，那么<code>&lt;prevrawlen&gt;</code>就用5个字节来表示，其中第1个字节的值是254（作为这种情况的一个标记），而后面4个字节组成一个整型值，来真正存储前一个数据项的占用字节数。</li>
</ul>
<p>为什么没有255的情况呢？这是因为：255已经定义为ziplist结束标记<code>&lt;zlend&gt;</code>的值了。</p>
<p>在ziplist的很多操作的实现中，都会根据数据项的第1个字节是不是255来判断当前是不是到达ziplist的结尾了，因此一个正常的数据的第1个字节（也就是<code>&lt;prevrawlen&gt;</code>的第1个字节）是不能够取255这个值的，否则就冲突了。</p>
<p>而<code>&lt;len&gt;</code>字段就更加复杂了，它根据第1个字节的不同，总共分为9种情况（下面的表示法是按二进制表示）：</p>
<ol>
<li>|00pppppp| - 1 byte。第1个字节最高两个bit是00，那么<code>&lt;len&gt;</code>字段只有1个字节，剩余的6个bit用来表示长度值，最高可以表示63 (2^6-1)。</li>
<li>|01pppppp|qqqqqqqq| - 2 bytes。第1个字节最高两个bit是01，那么<code>&lt;len&gt;</code>字段占2个字节，总共有14个bit用来表示长度值，最高可以表示16383 (2^14-1)。</li>
<li>|10__|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes。第1个字节最高两个bit是10，那么len字段占5个字节，总共使用32个bit来表示长度值（6个bit舍弃不用），最高可以表示2^32-1。</li>
</ol>
<p>需要注意的是：在前三种情况下，<code>&lt;data&gt;</code>都是按字符串来存储的；从下面第4种情况开始，<code>&lt;data&gt;</code>开始变为按整数来存储了。</p>
<ol start="4">
<li>|11000000| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xC0，后面的数据<code>&lt;data&gt;</code>存储为2个字节的int16_t类型。</li>
<li>|11010000| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xD0，后面的数据<code>&lt;data&gt;</code>存储为4个字节的int32_t类型。</li>
<li>|11100000| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xE0，后面的数据<code>&lt;data&gt;</code>存储为8个字节的int64_t类型。</li>
<li>|11110000| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xF0，后面的数据<code>&lt;data&gt;</code>存储为3个字节长的整数。</li>
<li>|11111110| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xFE，后面的数据<code>&lt;data&gt;</code>存储为1个字节的整数。</li>
<li>|1111xxxx| – (xxxx的值在0001和1101之间)。这是一种特殊情况，xxxx从1到13一共13个值，这时就用这13个值来表示真正的数据。注意，这里是表示真正的数据，而不是数据长度了。也就是说，在这种情况下，后面不再需要一个单独的<code>&lt;data&gt;</code>字段来表示真正的数据了，而是<code>&lt;len&gt;</code>和<code>&lt;data&gt;</code>合二为一了。另外，由于xxxx只能取0001和1101这13个值了（其它可能的值和其它情况冲突了，比如0000和1110分别同前面第7种第8种情况冲突，1111跟结束标记冲突），而小数值应该从0开始，因此这13个值分别表示0到12，即xxxx的值减去1才是它所要表示的那个整数数据的值。</li>
</ol>
<p>好了，ziplist的数据结构定义，我们介绍了完了，现在我们看一个具体的例子。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_27.png"></p>
<p>上图是一份真实的ziplist数据。我们逐项解读一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 这个ziplist一共包含33个字节。字节编号从byte[0]到byte[32]。图中每个字节的值使用16进制表示。</span><br><span class="line">* 头4个字节（0x21000000）是按小端（little endian）模式存储的&lt;zlbytes&gt;字段。什么是小端呢？就是指数据的低字节保存在内存的低地址中（参见维基百科词条Endianness）。因此，这里&lt;zlbytes&gt;的值应该解析成0x00000021，用十进制表示正好就是33。</span><br><span class="line">* 接下来4个字节（byte[4..7]）是&lt;zltail&gt;，用小端存储模式来解释，它的值是0x0000001D（值为29），表示最后一个数据项在byte[29]的位置（那个数据项为0x05FE14）。</span><br><span class="line">* 再接下来2个字节（byte[8..9]），值为0x0004，表示这个ziplist里一共存有4项数据。</span><br><span class="line">* 接下来6个字节（byte[10..15]）是第1个数据项。其中，prevrawlen=0，因为它前面没有数据项；len=4，相当于前面定义的9种情况中的第1种，表示后面4个字节按字符串存储数据，数据的值为&quot;name&quot;。</span><br><span class="line">* 接下来8个字节（byte[16..23]）是第2个数据项，与前面数据项存储格式类似，存储1个字符串&quot;tielei&quot;。</span><br><span class="line">* 接下来5个字节（byte[24..28]）是第3个数据项，与前面数据项存储格式类似，存储1个字符串&quot;age&quot;。</span><br><span class="line">* 接下来3个字节（byte[29..31]）是最后一个数据项，它的格式与前面的数据项存储格式不太一样。其中，第1个字节prevrawlen=5，表示前一个数据项占用5个字节；第2个字节=FE，相当于前面定义的9种情况中的第8种，所以后面还有1个字节用来表示真正的数据，并且以整数表示。它的值是20（0x14）。</span><br><span class="line">* 最后1个字节（byte[32]）表示&lt;zlend&gt;，是固定的值255（0xFF）。</span><br></pre></td></tr></table></figure>
<p>总结一下，这个ziplist里存了4个数据项，分别为：</p>
<ul>
<li>字符串: “name”</li>
<li>字符串: “tielei”</li>
<li>字符串: “age”</li>
<li>整数: 20</li>
</ul>
<p>实际上，这个ziplist是通过两个hset命令创建出来的。这个我们后边会再提到。</p>
<h3 id="ziplist的接口"><a href="#ziplist的接口" class="headerlink" title="ziplist的接口"></a>ziplist的接口</h3><p>我们先不着急看实现，先来挑几个ziplist的重要的接口，看看它们长什么样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned char *ziplistNew(void);</span><br><span class="line">unsigned char *ziplistMerge(unsigned char **first, unsigned char **second);</span><br><span class="line">unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where);</span><br><span class="line">unsigned char *ziplistIndex(unsigned char *zl, int index);</span><br><span class="line">unsigned char *ziplistNext(unsigned char *zl, unsigned char *p);</span><br><span class="line">unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p);</span><br><span class="line">unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen);</span><br><span class="line">unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p);</span><br><span class="line">unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip);</span><br><span class="line">unsigned int ziplistLen(unsigned char *zl);</span><br></pre></td></tr></table></figure>
<p>我们从这些接口的名字就可以粗略猜出它们的功能，下面简单解释一下：</p>
<ul>
<li>ziplist的数据类型，没有用自定义的struct之类的来表达，而就是简单的unsigned char *。这是因为ziplist本质上就是一块连续内存，内部组成结构又是一个高度动态的设计（变长编码），也没法用一个固定的数据结构来表达。</li>
<li>ziplistNew: 创建一个空的ziplist（只包含<code>&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;zlend&gt;</code>）。</li>
<li>ziplistMerge: 将两个ziplist合并成一个新的ziplist。</li>
<li>ziplistPush: 在ziplist的头部或尾端插入一段数据（产生一个新的数据项）。注意一下这个接口的返回值，是一个新的ziplist。调用方必须用这里返回的新的ziplist，替换之前传进来的旧的ziplist变量，而经过这个函数处理之后，原来旧的ziplist变量就失效了。为什么一个简单的插入操作会导致产生一个新的ziplist呢？这是因为ziplist是一块连续空间，对它的追加操作，会引发内存的realloc，因此ziplist的内存位置可能会发生变化。实际上，我们在之前介绍sds的文章中提到过类似这种接口使用模式（参见sdscatlen函数的说明）。</li>
<li>ziplistIndex: 返回index参数指定的数据项的内存位置。index可以是负数，表示从尾端向前进行索引。</li>
<li>ziplistNext和ziplistPrev分别返回一个ziplist中指定数据项p的后一项和前一项。</li>
<li>ziplistInsert: 在ziplist的任意数据项前面插入一个新的数据项。</li>
<li>ziplistDelete: 删除指定的数据项。</li>
<li>ziplistFind: 查找给定的数据（由vstr和vlen指定）。注意它有一个skip参数，表示查找的时候每次比较之间要跳过几个数据项。为什么会有这么一个参数呢？其实这个参数的主要用途是当用ziplist表示hash结构的时候，是按照一个field，一个value来依次存入ziplist的。也就是说，偶数索引的数据项存field，奇数索引的数据项存value。当按照field的值进行查找的时候，就需要把奇数项跳过去。</li>
<li>ziplistLen: 计算ziplist的长度（即包含数据项的个数）。</li>
</ul>
<h4 id="ziplist的插入逻辑解析"><a href="#ziplist的插入逻辑解析" class="headerlink" title="ziplist的插入逻辑解析"></a>ziplist的插入逻辑解析</h4><p>ziplist的相关接口的具体实现，还是有些复杂的，限于篇幅的原因，我们这里只结合代码来讲解插入的逻辑。插入是很有代表性的操作，通过这部分来一窥ziplist内部的实现，其它部分的实现我们也就会很容易理解了。</p>
<p>ziplistPush和ziplistInsert都是插入，只是对于插入位置的限定不同。</p>
<p>它们在内部实现都依赖一个名为__ziplistInsert的内部函数:</p>
<details>
<summary>__ziplistInsert源码（出自ziplist.c）</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">static unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) &#123;</span><br><span class="line">    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class="line">    unsigned int prevlensize, prevlen = 0;</span><br><span class="line">    size_t offset;</span><br><span class="line">    int nextdiff = 0;</span><br><span class="line">    unsigned char encoding = 0;</span><br><span class="line">    long long value = 123456789; </span><br><span class="line">    zlentry tail;</span><br><span class="line"></span><br><span class="line">    /* Find out prevlen for the </span><br><span class="line">     * entry that is inserted. */</span><br><span class="line">    if (p[0] != ZIP_END) &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        if (ptail[0] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    /* See if the entry can be encoded */</span><br><span class="line">    if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;        </span><br><span class="line">        /* &#x27;encoding&#x27; is set to the </span><br><span class="line">         * appropriate integer encoding */</span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; else &#123;        </span><br><span class="line">        /* &#x27;encoding&#x27; is untouched, </span><br><span class="line">         * however zipEncodeLength will use </span><br><span class="line">         * the string length to figure out </span><br><span class="line">         * how to encode it. */</span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    /* We need space for both the length </span><br><span class="line">     * of the previous entry and</span><br><span class="line">     * the length of the payload. */</span><br><span class="line">    reqlen += zipPrevEncodeLength(NULL,prevlen);</span><br><span class="line">    reqlen += zipEncodeLength(NULL,encoding,slen);</span><br><span class="line"></span><br><span class="line">    /* When the insert position is not </span><br><span class="line">     * equal to the tail, we need to</span><br><span class="line">     * make sure that the next entry can </span><br><span class="line">     * hold this entry&#x27;s length in</span><br><span class="line">     * its prevlen field. */</span><br><span class="line">    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;</span><br><span class="line"></span><br><span class="line">    /* Store offset because a realloc</span><br><span class="line">     * may change the address of zl. */</span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    /* Apply memory move when necessary </span><br><span class="line">     * and update tail offset. */</span><br><span class="line">    if (p[0] != ZIP_END) &#123;       </span><br><span class="line">        /* Subtract one because of </span><br><span class="line">         * the ZIP_END bytes */</span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);</span><br><span class="line"></span><br><span class="line">        /* Encode this entry&#x27;s raw </span><br><span class="line">         * length in the next entry. */</span><br><span class="line">        zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        /* Update offset for tail */</span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line"></span><br><span class="line">        /* When the tail contains more </span><br><span class="line">         * than one entry, we need to take</span><br><span class="line">         * &quot;nextdiff&quot; in account as well. </span><br><span class="line">         * Otherwise, a change in the</span><br><span class="line">         * size of prevlen doesn&#x27;t have an </span><br><span class="line">         * effect on the *tail* offset. */</span><br><span class="line">        zipEntry(p+reqlen, &amp;tail);</span><br><span class="line">        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;        </span><br><span class="line">        /* This element will be the new tail. */</span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;    </span><br><span class="line">    /* When nextdiff != 0, the raw </span><br><span class="line">     *length of the next entry has changed, so</span><br><span class="line">     * we need to cascade the update </span><br><span class="line">     * throughout the ziplist */</span><br><span class="line">    if (nextdiff != 0) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    /* Write the entry */</span><br><span class="line">    p += zipPrevEncodeLength(p,prevlen);</span><br><span class="line">    p += zipEncodeLength(p,encoding,slen);</span><br><span class="line">    if (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        memcpy(p,s,slen);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,1);</span><br><span class="line">    return zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>我们来简单解析一下这段代码：</p>
<ul>
<li>这个函数是在指定的位置p插入一段新的数据，待插入数据的地址指针是s，长度为slen。<br>插入后形成一个新的数据项，占据原来p的配置，原来位于p位置的数据项以及后面的所有数据项，需要统一向后移动，给新插入的数据项留出空间。<br>参数p指向的是ziplist中某一个数据项的起始位置，或者在向尾端插入的时候，它指向ziplist的结束标记<code>&lt;zlend&gt;</code>。</li>
<li>函数开始先计算出待插入位置前一个数据项的长度<code>prevlen</code>。这个长度要存入新插入的数据项的<code>&lt;prevrawlen&gt;</code>字段。</li>
<li>然后计算当前数据项占用的总字节数reqlen，它包含三部分：<code>&lt;prevrawlen&gt;, &lt;len&gt;, 真正的数据</code>。<br>其中的数据部分会通过调用<code>zipTryEncoding</code>先来尝试转成整数。</li>
<li>由于插入导致的ziplist对于内存的新增需求，除了待插入数据项占用的reqlen之外，还要考虑原来p位置的数据项（现在要排在待插入数据项之后）的<code>&lt;prevrawlen&gt;</code>字段的变化。<br>本来它保存的是前一项的总长度，现在变成了保存当前插入的数据项的总长度。<br>这样它的<code>&lt;prevrawlen&gt;</code>字段本身需要的存储空间也可能发生变化，这个变化可能是变大也可能是变小。<br>这个变化了多少的值nextdiff，是调用zipPrevLenByteDiff计算出来的。<br>如果变大了，nextdiff是正值，否则是负值。</li>
<li>现在很容易算出来插入后新的ziplist需要多少字节了，然后调用ziplistResize来重新调整大小。<br>ziplistResize的实现里会调用allocator的zrealloc，它有可能会造成数据拷贝。</li>
<li>现在额外的空间有了，接下来就是将原来p位置的数据项以及后面的所有数据都向后挪动，并为它设置新的<code>&lt;prevrawlen&gt;</code>字段。此外，还可能需要调整ziplist的<code>&lt;zltail&gt;</code>字段。</li>
<li>最后，组装新的待插入数据项，放在位置p。</li>
</ul>
<h3 id="hash与ziplist"><a href="#hash与ziplist" class="headerlink" title="hash与ziplist"></a>hash与ziplist</h3><p>hash是Redis中可以用来存储一个对象结构的比较理想的数据类型。一个对象的各个属性，正好对应一个hash结构的各个field。</p>
<p>我们在网上很容易找到这样一些技术文章，它们会说存储一个对象，使用hash比string要节省内存。<br>实际上这么说是有前提的，具体取决于对象怎么来存储：</p>
<ul>
<li>如果你把对象的多个属性存储到多个key上（各个属性值存成string），当然占的内存要多。</li>
<li>但如果你采用一些序列化方法，比如Protocol Buffers，或者Apache Thrift，先把对象序列化为字节数组，然后再存入到Redis的string中，那么跟hash相比，哪一种更省内存，就不一定了。</li>
</ul>
<p>当然，hash比序列化后再存入string的方式，在支持的操作命令上，还是有优势的：</p>
<ul>
<li>它既支持多个field同时存取（hmset/hmget），</li>
<li>也支持按照某个特定的field单独存取（hset/hget）。</li>
</ul>
<p>实际上，hash随着数据的增大，其底层数据结构的实现是会发生变化的，当然存储效率也就不同。</p>
<ul>
<li>在field比较少，各个value值也比较小的时候，hash采用ziplist来实现；</li>
<li>而随着field增多和value值增大，hash可能会变成dict来实现。</li>
</ul>
<p>当hash底层变成dict来实现的时候，它的存储效率就没法跟那些序列化方式相比了。</p>
<p>当我们为某个key第一次执行 hset key field value 命令的时候，Redis会创建一个hash结构，这个新创建的hash底层就是一个ziplist。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">robj *createHashObject(void) &#123;</span><br><span class="line">    unsigned char *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(OBJ_HASH, zl);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的createHashObject函数，出自object.c，它负责的任务就是创建一个新的hash结构。可以看出，它创建了一个type = OBJ_HASH但encoding = OBJ_ENCODING_ZIPLIST的robj对象。</p>
<p>实际上，本文前面给出的那个ziplist实例，就是由如下两个命令构建出来的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hset user:100 name tielei</span><br><span class="line">hset user:100 age 20</span><br></pre></td></tr></table></figure>

<p>每执行一次hset命令，插入的field和value分别作为一个新的数据项插入到ziplist中（即每次hset产生两个数据项）。</p>
<p>当随着数据的插入，hash底层的这个ziplist就可能会转成dict。那么到底插入多少才会转呢？</p>
<p>还记得本文开头提到的两个Redis配置吗？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br></pre></td></tr></table></figure>

<p>这个配置的意思是说，在如下两个条件之一满足的时候，ziplist会转成dict：</p>
<ul>
<li>当hash中的数据项（即field-value对）的数目超过512的时候，也就是ziplist数据项超过1024的时候（请参考t_hash.c中的hashTypeSet函数）。</li>
<li>当hash中插入的任意一个value的长度超过了64的时候（请参考t_hash.c中的hashTypeTryConversion函数）。</li>
</ul>
<p>Redis的hash之所以这样设计，是因为当ziplist变得很大的时候，它有如下几个缺点：</p>
<ul>
<li>每次插入或修改引发的realloc操作会有更大的概率造成内存拷贝，从而降低性能。</li>
<li>一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据。</li>
<li>当ziplist数据项过多的时候，在它上面查找指定的数据项就会性能变得很低，因为ziplist上的查找需要进行遍历。</li>
</ul>
<p>总之，ziplist本来就设计为各个数据项挨在一起组成连续的内存空间，这种结构<strong>并不擅长做修改操作</strong>。一旦数据发生改动，就会引发内存realloc，可能导致内存拷贝。</p>
<h2 id="Redis-quicklist"><a href="#Redis-quicklist" class="headerlink" title="Redis quicklist"></a>Redis quicklist</h2><h3 id="quickList概述"><a href="#quickList概述" class="headerlink" title="quickList概述"></a>quickList概述</h3><p>Redis对外暴露的上层list数据类型，经常被用作队列使用。比如它支持的如下一些操作：</p>
<ul>
<li>lpush: 在左侧（即列表头部）插入数据。</li>
<li>rpop: 在右侧（即列表尾部）删除数据。</li>
<li>rpush: 在右侧（即列表尾部）插入数据。</li>
<li>lpop: 在左侧（即列表头部）删除数据。</li>
</ul>
<p>这些操作都是O(1)时间复杂度的。</p>
<p>当然，list也支持在任意中间位置的存取操作，比如lindex和linsert，但它们都需要对list进行遍历，所以时间复杂度较高。</p>
<p>概况起来，list具有这样的一些特点：</p>
<ul>
<li>它是一个有序列表，便于在表的两端追加和删除数据，而对于中间位置的存取具有O(N)的时间复杂度。 </li>
</ul>
<p>这不正是一个双向链表所具有的特点吗？ list的内部实现quicklist正是一个双向链表。</p>
<p>在quicklist.c的文件头部注释中，是这样描述quicklist的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A doubly linked list of ziplists</span><br></pre></td></tr></table></figure>
<p>它确实是一个双向链表，而且是一个ziplist的双向链表。</p>
<p>ziplist本身也是一个有序列表，而且是一个内存紧缩的列表（各个数据项在内存上前后相邻）。</p>
<p>比如，一个包含3个节点的quicklist，如果每个节点的ziplist又包含4个数据项，那么对外表现上，这个list就总共包含12个数据项。</p>
<p>quicklist的结构为什么这样设计呢？总结起来，大概又是一个空间和时间的折中：</p>
<ul>
<li>双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</li>
<li>ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</li>
</ul>
<p>于是，结合了双向链表和ziplist的优点，quicklist就应运而生了。</p>
<p>不过，这也带来了一个新问题：到底一个quicklist节点包含多长的ziplist合适呢？比如，同样是存储12个数据项，既可以是一个quicklist包含3个节点，而每个节点的ziplist又包含4个数据项，也可以是一个quicklist包含6个节点，而每个节点的ziplist又包含2个数据项。</p>
<p>这又是一个需要找平衡点的难题。我们只从存储效率上分析一下：</p>
<ul>
<li>每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能在内存中产生很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个quicklist节点上的ziplist只包含一个数据项，这就蜕化成一个普通的双向链表了。</li>
<li>每个quicklist节点上的ziplist越长，则为ziplist分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间（它们加起来很多），但却找不到一块足够大的空闲空间分配给ziplist的情况。这同样会降低存储效率。这种情况的极端是整个quicklist只有一个节点，所有的数据项都分配在这仅有的一个节点的ziplist里面。这其实蜕化成一个ziplist了。</li>
</ul>
<p>可见，一个quicklist节点上的ziplist要保持一个合理的长度。那到底多长合理呢？这可能取决于具体应用场景。实际上，Redis提供了一个配置参数list-max-ziplist-size，就是为了让使用者可以来根据自己的情况进行调整。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list-max-ziplist-size -2</span><br></pre></td></tr></table></figure>
<p>我们来详细解释一下这个参数的含义。它可以取正值，也可以取负值。</p>
<p>当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。</p>
<p>当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下：</p>
<ul>
<li>-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb =&gt; 1024 bytes）</li>
<li>-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。</li>
<li>-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。 </li>
<li>-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）</li>
<li>-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。</li>
</ul>
<p>另外，list的设计目标是能够用来<strong>存储很长的数据列表</strong>的。</p>
<p>当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低（访问起来性能也很低）。如果应用场景符合这个特点，那么list还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list-compress-depth 0</span><br></pre></td></tr></table></figure>
<p>这个参数表示一个quicklist两端不被压缩的节点个数。注：这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。实际上，一个quicklist节点上的ziplist，如果被压缩，就是整体被压缩的。</p>
<p>参数list-compress-depth的取值含义如下：</p>
<ul>
<li>0: 是个特殊值，表示都不压缩。这是Redis的默认值。</li>
<li>1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。</li>
<li>2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。</li>
<li>3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。</li>
<li>依此类推…</li>
</ul>
<p>由于0是个特殊值，很容易看出quicklist的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。</p>
<p>Redis对于quicklist内部节点的压缩算法，采用的<a target="_blank" rel="noopener" href="http://oldhome.schmorp.de/marc/liblzf.html">LZF</a>——一种无损压缩算法。</p>
<h3 id="quicklist的数据结构定义"><a href="#quicklist的数据结构定义" class="headerlink" title="quicklist的数据结构定义"></a>quicklist的数据结构定义</h3><details><summary>quicklist相关的数据结构定义</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef struct quicklistNode &#123;</span><br><span class="line">    struct quicklistNode *prev;</span><br><span class="line">    struct quicklistNode *next;</span><br><span class="line">    unsigned char *zl;</span><br><span class="line">    unsigned int sz;             /* ziplist size in bytes */</span><br><span class="line">    unsigned int count : 16;     /* count of items in ziplist */</span><br><span class="line">    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */</span><br><span class="line">    unsigned int container : 2;  /* NONE==1 or ZIPLIST==2 */</span><br><span class="line">    unsigned int recompress : 1; /* was this node previous compressed? */</span><br><span class="line">    unsigned int attempted_compress : 1; /* node can&#x27;t compress; too small */</span><br><span class="line">    unsigned int extra : 10; /* more bits to steal for future usage */</span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line">typedef struct quicklistLZF &#123;</span><br><span class="line">    unsigned int sz; /* LZF size in bytes*/</span><br><span class="line">    char compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line">typedef struct quicklist &#123;</span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    unsigned long count; /* total count of all entries in all ziplists */</span><br><span class="line">    unsigned int len; /* number of quicklistNodes */</span><br><span class="line">    int fill : 16; /* fill factor for individual nodes */</span><br><span class="line">    unsigned int compress : 16; /* depth of end nodes not to compress;0=off */</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>
</details>

<p>quicklistNode结构代表quicklist的一个节点，其中各个字段的含义如下：</p>
<ul>
<li>prev: 指向链表前一个节点的指针。</li>
<li>next: 指向链表后一个节点的指针。</li>
<li>zl: 数据指针。如果当前节点的数据没有压缩，那么它指向一个ziplist结构；否则，它指向一个quicklistLZF结构。</li>
<li>sz: 表示zl指向的ziplist的总大小（包括zlbytes, zltail,zllen, zlend和各个数据项）。需要注意的是：如果ziplist被压缩了，那么这个sz的值仍然是压缩前的ziplist大小。</li>
<li>count: 表示ziplist里面包含的数据项个数。这个字段只有16bit。稍后我们会一起计算一下这16bit是否够用。</li>
<li>encoding: 表示ziplist是否压缩了（以及用了哪个压缩算法）。目前只有两种取值：2表示被压缩了（而且用的是LZF压缩算法），1表示没有压缩。</li>
<li>container: 是一个预留字段。本来设计是用来表明一个quicklist节点下面是直接存数据，还是使用ziplist存数据，或者用其它的结构来存数据（用作一个数据容器，所以叫container）。但是，在目前的实现中，这个值是一个固定的值2，表示使用ziplist作为数据容器。</li>
<li>recompress: 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress=1做一个标记，等有机会再把数据重新压缩。</li>
<li>attempted_compress: 这个值只对Redis的自动化测试程序有用。我们不用管它。</li>
<li>extra: 其它扩展字段。目前Redis的实现里也没用上。</li>
</ul>
<p>quicklistLZF结构表示一个被压缩过的ziplist。其中：</p>
<ul>
<li>sz: 表示压缩后的ziplist大小。</li>
<li>compressed: 是个柔性数组（flexible array member），存放压缩后的ziplist字节数组。</li>
</ul>
<p>真正表示quicklist的数据结构是同名的quicklist这个struct：</p>
<ul>
<li>head: 指向头节点（左侧第一个节点）的指针。</li>
<li>tail: 指向尾节点（右侧第一个节点）的指针。</li>
<li>count: 所有ziplist数据项的个数总和。</li>
<li>len: quicklist节点的个数。</li>
<li>fill: 16bit，ziplist大小设置，存放list-max-ziplist-size参数的值。</li>
<li>compress: 16bit，节点压缩深度设置，存放list-compress-depth参数的值。</li>
</ul>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_32.png"><br>上图是一个quicklist的结构图举例（点击可以看大图）。图中例子对应的ziplist大小配置和节点压缩深度配置，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list-max-ziplist-size 3</span><br><span class="line">list-compress-depth 2</span><br></pre></td></tr></table></figure>
<p>这个例子中我们需要注意的几点是：</p>
<ul>
<li>两端各有2个橙黄色的节点，是没有被压缩的。它们的数据指针zl指向真正的ziplist。中间的其它节点是被压缩过的，它们的数据指针zl指向被压缩后的ziplist结构，即一个quicklistLZF结构。</li>
<li>左侧头节点上的ziplist里有2项数据，右侧尾节点上的ziplist里有1项数据，中间其它节点上的ziplist里都有3项数据（包括压缩的节点内部）。这表示在表的两端执行过多次push和pop操作后的一个状态。</li>
</ul>
<p>现在我们来大概计算一下quicklistNode结构中的count字段这16bit是否够用。</p>
<p>我们已经知道，ziplist大小受到list-max-ziplist-size参数的限制。按照正值和负值有两种情况：</p>
<ul>
<li>当这个参数取正值的时候，就是恰好表示一个quicklistNode结构中zl所指向的ziplist所包含的数据项的最大值。list-max-ziplist-size参数是由quicklist结构的fill字段来存储的，而fill字段是16bit，所以它所能表达的值能够用16bit来表示。</li>
<li>当这个参数取负值的时候，能够表示的ziplist最大长度是64 Kb。而ziplist中每一个数据项，最少需要2个字节来表示：1个字节的prevrawlen，1个字节的data（len字段和data合二为一；详见上一篇）。所以，ziplist中数据项的个数不会超过32 K，用16bit来表达足够了。</li>
</ul>
<p>实际上，在目前的quicklist的实现中，ziplist的大小还会受到另外的限制，根本不会达到这里所分析的最大值。</p>
<h3 id="quicklist执行过程源码"><a href="#quicklist执行过程源码" class="headerlink" title="quicklist执行过程源码"></a>quicklist执行过程源码</h3><h4 id="quicklist的创建"><a href="#quicklist的创建" class="headerlink" title="quicklist的创建"></a>quicklist的创建</h4><p>当我们使用lpush或rpush命令第一次向一个不存在的list里面插入数据的时候，Redis会首先调用</p>
<details><summary>quicklistCreate</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">quicklist *quicklistCreate(void) &#123;</span><br><span class="line">    struct quicklist *quicklist;</span><br><span class="line"></span><br><span class="line">    quicklist = zmalloc(sizeof(*quicklist));</span><br><span class="line">    quicklist-&gt;head = quicklist-&gt;tail = NULL;</span><br><span class="line">    quicklist-&gt;len = 0;</span><br><span class="line">    quicklist-&gt;count = 0;</span><br><span class="line">    quicklist-&gt;compress = 0;</span><br><span class="line">    quicklist-&gt;fill = -2;    </span><br><span class="line">    return quicklist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details> 

<p>接口创建一个空的quicklist。</p>
<p>在很多介绍数据结构的书上，实现双向链表的时候经常会多增加一个空余的头节点，主要是为了插入和删除操作的方便。从上面quicklistCreate的代码可以看出，quicklist是一个不包含空余头节点的双向链表（head和tail都初始化为NULL）。</p>
<h4 id="quicklist的push操作"><a href="#quicklist的push操作" class="headerlink" title="quicklist的push操作"></a>quicklist的push操作</h4><p>quicklist的push操作是调用</p>
<details><summary>quicklistPush</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">void quicklistPush(quicklist *quicklist, void *value, const size_t sz,                   int where) &#123;    </span><br><span class="line">    if (where == QUICKLIST_HEAD) &#123;</span><br><span class="line">        quicklistPushHead(quicklist, value, sz);</span><br><span class="line">    &#125; else if (where == QUICKLIST_TAIL) &#123;</span><br><span class="line">        quicklistPushTail(quicklist, value, sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Add new entry to head node of quicklist.</span><br><span class="line"> *</span><br><span class="line"> * Returns 0 if used existing head.</span><br><span class="line"> * Returns 1 if new head created. */</span><br><span class="line">int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) &#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    if (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;    </span><br><span class="line">    return (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Add new entry to tail node of quicklist.</span><br><span class="line"> *</span><br><span class="line"> * Returns 0 if used existing tail.</span><br><span class="line"> * Returns 1 if new tail created. */</span><br><span class="line">int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) &#123;</span><br><span class="line">    quicklistNode *orig_tail = quicklist-&gt;tail;</span><br><span class="line">    if (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;tail, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        quicklist-&gt;tail-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;tail-&gt;zl, value, sz, ZIPLIST_TAIL);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;tail);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;tail-&gt;count++;    </span><br><span class="line">    return (orig_tail != quicklist-&gt;tail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>来实现的。</p>
<p>不管是在头部还是尾部插入数据，都包含两种情况：</p>
<ul>
<li>如果头节点（或尾节点）上ziplist大小没有超过限制（即_quicklistNodeAllowInsert返回1），那么新数据被直接插入到ziplist中（调用ziplistPush）。</li>
<li>如果头节点（或尾节点）上ziplist太大了，那么新创建一个quicklistNode节点（对应地也会新创建一个ziplist），然后把这个新创建的节点插入到quicklist双向链表中（调用_quicklistInsertNodeAfter）。</li>
</ul>
<p>在_quicklistInsertNodeAfter的实现中，还会根据list-compress-depth的配置将里面的节点进行压缩。它的实现比较繁琐，我们这里就不展开讨论了。</p>
<h4 id="quicklist的其它操作"><a href="#quicklist的其它操作" class="headerlink" title="quicklist的其它操作"></a>quicklist的其它操作</h4><p>quicklist的操作较多，且实现细节都比较繁杂，这里就不一一分析源码了，我们简单介绍一些比较重要的操作。</p>
<p>quicklist的pop操作是调用quicklistPopCustom来实现的。<br>quicklistPopCustom的实现过程基本上跟quicklistPush相反，先从头部或尾部节点的ziplist中把对应的数据项删除，如果在删除后ziplist为空了，那么对应的头部或尾部节点也要删除。<br>删除后还可能涉及到里面节点的解压缩问题。</p>
<p>quicklist不仅实现了从头部或尾部插入，也实现了从任意指定的位置插入。quicklistInsertAfter和quicklistInsertBefore就是分别在指定位置后面和前面插入数据项。这种在任意指定位置插入数据的操作，情况比较复杂，有众多的逻辑分支。</p>
<ul>
<li>当插入位置所在的ziplist大小没有超过限制时，直接插入到ziplist中就好了；</li>
<li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小没有超过限制，那么就转而插入到相邻的那个quicklist链表节点的ziplist中；</li>
<li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小也超过限制，这时需要新创建一个quicklist链表节点插入。</li>
<li>对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。</li>
</ul>
<p>quicklistSetOptions用于设置ziplist大小配置参数（list-max-ziplist-size）和节点压缩深度配置参数（list-compress-depth）。代码比较简单，就是将相应的值分别设置给quicklist结构的fill字段和compress字段。</p>
<h2 id="Redis-SkipList"><a href="#Redis-SkipList" class="headerlink" title="Redis SkipList"></a>Redis SkipList</h2><h3 id="什么是跳跃表"><a href="#什么是跳跃表" class="headerlink" title="什么是跳跃表"></a>什么是跳跃表</h3><p>skiplist本质上也是一种<strong>查找结构</strong>，用于解决算法中的查找问题（Searching），即根据给定的key，快速查到它所在的位置（或者对应的value）。</p>
<p>介绍dict的时候，曾经讨论过：一般查找问题的解法分为两个大类：</p>
<ul>
<li>一个是基于各种平衡树，</li>
<li>一个是基于哈希表。</li>
</ul>
<p>但skiplist却比较特殊，它没法归属到这两大类里面。</p>
<h4 id="skiplist数据结构简介"><a href="#skiplist数据结构简介" class="headerlink" title="skiplist数据结构简介"></a>skiplist数据结构简介</h4><p>跳跃表是一种<strong>有序的</strong>数据结构，它通过在<strong>每个节点中维持多个指向其他节点的指针</strong>，从而达到快速访问节点的目的。</p>
<p>这么说，我们可能很难理解，我们可以先回忆一下链表。</p>
<p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img.png"></p>
<p>如果我们想要提高其查找效率，可以考虑在链表上建索引的方式。每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_1.png"></p>
<p>这个时候，我们假设要查找节点8，我们可以先在索引层遍历，当遍历到索引层中值为 7 的结点时，发现下一个节点是9，那么要查找的节点8肯定就在这两个节点之间。</p>
<p>我们下降到链表层继续遍历就找到了8这个节点。</p>
<p>原先我们在单链表中找到8这个节点要遍历8个节点，而现在有了一级索引后只需要遍历五个节点。</p>
<p>从这个例子里，我们看出，加来一层索引之后，查找一个结点需要遍的结点个数减少了，也就是说查找效率提高了。</p>
<p>同理再加一级索引：</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_2.png"></p>
<p>从图中我们可以看出，查找效率又有提升。在例子中我们的数据很少，当有大量的数据时，我们可以增加多级索引，其查找效率可以得到明显提升。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_3.png"></p>
<p>skiplist正是受这种多层链表的想法的启发而设计出来的。</p>
<p>实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。</p>
<p>但是，这种方法在插入数据的时候有很大的问题。</p>
<p>新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。<br>如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。<br>删除数据也有同样的问题。</p>
<p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是**为每个节点随机出一个层数(level)**。</p>
<p>比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。</p>
<p>为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程（点击看大图）：</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_28.png"></p>
<p>从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。</p>
<p>实际上，这是skiplist的一个很重要的特性，这让它在<strong>插入性能上明显优于平衡树</strong>的方案。这在后面我们还会提到。</p>
<p>根据上图中的skiplist结构，我们很容易理解这种数据结构的名字的由来。</p>
<p>skiplist，翻译成中文，可以翻译成“跳表”或“跳跃表”，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。</p>
<p>这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。</p>
<p>在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。</p>
<p>刚刚创建的这个skiplist总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了查找路径：</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_29.png"></p>
<p>需要注意的是，前面演示的各个节点的插入过程，实际上在插入之前也要先经历一个类似的查找过程，在确定插入位置后，再完成插入操作。</p>
<p>至此，skiplist的查找和插入操作，我们已经很清楚了。而删除操作与插入操作类似，我们也很容易想象出来。这些操作我们也应该能很容易地用代码实现出来。</p>
<p>当然，实际应用中的skiplist每个节点应该包含key和value两部分。前面的描述中我们没有具体区分key和value，但实际上列表中是按照key进行排序的，查找过程也是根据key在比较。</p>
<h4 id="skiplist算法性能"><a href="#skiplist算法性能" class="headerlink" title="skiplist算法性能"></a>skiplist算法性能</h4><p>节点插入时随机出一个层数，仅仅依靠这样一个简单的随机数操作而构建出来的多层链表结构，能保证它有一个良好的查找性能吗？</p>
<p>在分析之前，我们还需要着重指出的是，执行插入操作时计算随机数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。</p>
<p>这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：</p>
<ul>
<li>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。</li>
<li>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。</li>
<li>节点最大的层数不允许超过一个最大值，记为MaxLevel。</li>
</ul>
<p>这个计算随机层数的伪码如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">randomLevel()</span><br><span class="line">    level := 1</span><br><span class="line">    // random()返回一个[0...1)的随机数</span><br><span class="line">    while random() &lt; p and level &lt; MaxLevel do</span><br><span class="line">        level := level + 1</span><br><span class="line">    return level</span><br></pre></td></tr></table></figure>

<p>randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = 1/4</span><br><span class="line">MaxLevel = 32</span><br></pre></td></tr></table></figure>

<p>我们先来计算一下每个节点所包含的平均指针数目（概率期望）。节点包含的指针数目，相当于这个算法在空间上的额外开销(overhead)，可以用来度量空间复杂度。</p>
<p>根据前面randomLevel()的伪码，我们很容易看出，产生越高的节点层数，概率越低。定量的分析如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">节点层数至少为1。而大于1的节点层数，满足一个概率分布。</span><br><span class="line">节点层数恰好等于1的概率为1-p。</span><br><span class="line">节点层数大于等于2的概率为p，而节点层数恰好等于2的概率为p(1-p)。</span><br><span class="line">节点层数大于等于3的概率为p2，而节点层数恰好等于3的概率为p2(1-p)。</span><br><span class="line">节点层数大于等于4的概率为p3，而节点层数恰好等于4的概率为p3(1-p)。</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>因此，一个节点的平均层数（也即包含的平均指针数目），计算如下：</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_30.png"></p>
<p>现在很容易计算出：</p>
<ul>
<li>当p=1/2时，每个节点所包含的平均指针数目为2；</li>
<li>当p=1/4时，每个节点所包含的平均指针数目为1.33。这也是Redis里的skiplist实现在空间上的开销。</li>
</ul>
<p>接下来，为了分析时间复杂度，我们计算一下skiplist的平均查找长度。查找长度指的是查找路径上跨越的跳数，而查找过程中的比较次数就等于查找长度加1。<br>以前面图中标出的查找23的查找路径为例，从左上角的头结点开始，一直到结点22，查找长度为6。</p>
<p>为了计算查找长度，这里我们需要利用一点小技巧。我们注意到，每个节点插入的时候，它的层数是由随机函数randomLevel()计算出来的，而且随机的计算不依赖于其它节点，每次插入过程都是完全独立的。所以，从统计上来说，一个skiplist结构的形成与节点的插入顺序无关。</p>
<p>这样的话，为了计算查找长度，我们可以将查找过程倒过来看，从右下方第1层上最后到达的那个节点开始，沿着查找路径向左向上回溯，类似于爬楼梯的过程。我们假设当回溯到某个节点的时候，它才被插入，这虽然相当于改变了节点的插入顺序，但从统计上不影响整个skiplist的形成结构。</p>
<p>现在假设我们从一个层数为i的节点x出发，需要向左向上攀爬k层。这时我们有两种可能：</p>
<ul>
<li>如果节点x有第(i+1)层指针，那么我们需要向上走。这种情况概率为p。</li>
<li>如果节点x没有第(i+1)层指针，那么我们需要向左走。这种情况概率为(1-p)。</li>
</ul>
<p>用C(k)表示向上攀爬k个层级所需要走过的平均查找路径长度（概率期望）,得到一个差分方程并化简：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C(k)=(1-p)(C(k)+1) + p(C(k-1)+1)</span><br><span class="line">C(k)=1/p+C(k-1)</span><br><span class="line">C(k)=k/p</span><br></pre></td></tr></table></figure>

<p>这个结果的意思是，我们每爬升1个层级，需要在查找路径上走1/p步。而我们总共需要攀爬的层级数等于整个skiplist的总层数-1。</p>
<p>那么接下来我们需要分析一下当skiplist中有n个节点的时候，它的总层数的概率均值是多少。这个问题直观上比较好理解。根据节点的层数随机算法，容易得出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第1层链表固定有n个节点；</span><br><span class="line">第2层链表平均有n*p个节点；</span><br><span class="line">第3层链表平均有n*p2个节点；</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>所以，从第1层到最高层，各层链表的平均节点数是一个指数递减的等比数列。容易推算出，总层数的均值为log1/pn，而最高层的平均节点数为1/p。</p>
<p>综上，粗略来计算的话，平均查找长度约等于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C(log1/pn-1)=(log1/pn-1)/p</span><br></pre></td></tr></table></figure>
<p>即，**平均时间复杂度为O(log n)**。</p>
<p>当然，这里的时间复杂度分析还是比较粗略的：</p>
<ul>
<li>比如，沿着查找路径向左向上回溯的时候，可能先到达左侧头结点，然后沿头结点一路向上；</li>
<li>还可能先到达最高层的节点，然后沿着最高层链表一路向左。</li>
</ul>
<p>但这些细节不影响平均时间复杂度的最后结果。</p>
<p>另外，这里给出的时间复杂度只是一个概率平均值，但实际上计算一个精细的概率分布也是有可能的。</p>
<h4 id="skiplist与平衡树、哈希表的比较"><a href="#skiplist与平衡树、哈希表的比较" class="headerlink" title="skiplist与平衡树、哈希表的比较"></a>skiplist与平衡树、哈希表的比较</h4><ul>
<li>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</li>
<li>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li>
<li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li>
<li>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li>
<li>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</li>
<li>从算法实现难度上来比较，skiplist比平衡树要简单得多。</li>
</ul>
<h3 id="Redis中SkipList使用"><a href="#Redis中SkipList使用" class="headerlink" title="Redis中SkipList使用"></a>Redis中SkipList使用</h3><p>Redis使用跳跃表作为有序集合键(sorted set)的底层实现之一(sorted set底层不仅仅使用了skiplist，还使用了ziplist和dict),</p>
<ul>
<li>如果一个有序集合包含的<strong>元素数量比较多</strong></li>
<li>又或者有序集合中元素的成员是<strong>比较长的字符串</strong>时,<br>Redis就会使用跳跃表来作为有序集合健的底层实现。</li>
</ul>
<p>这里我们需要思考一个问题——为什么元素数量比较多或者成员是比较长的字符串的时候Redis要使用跳跃表来实现？</p>
<p>从上面我们可以知道，跳跃表在链表的基础上增加了多级索引以提升查找的效率，但其是一个空间换时间的方案，必然会带来一个问题——<strong>索引是占内存的</strong>。</p>
<p>原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值值和几个指针，并不需要存储对象，因此当<strong>节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略</strong>。</p>
<h3 id="Redis中SkipList的实现"><a href="#Redis中SkipList的实现" class="headerlink" title="Redis中SkipList的实现"></a>Redis中SkipList的实现</h3><h4 id="Redis中SkipList实现的特殊性"><a href="#Redis中SkipList实现的特殊性" class="headerlink" title="Redis中SkipList实现的特殊性"></a>Redis中SkipList实现的特殊性</h4><p>我们简单分析一下几个查询命令：</p>
<ul>
<li>zrevrank由数据查询它对应的排名，这在前面介绍的skiplist中并不支持。</li>
<li>zscore由数据查询它对应的分数，这也不是skiplist所支持的。</li>
<li>zrevrange根据一个排名范围，查询排名在这个范围内的数据。这在前面介绍的skiplist中也不支持。</li>
<li>zrevrangebyscore根据分数区间查询数据集合，是一个skiplist所支持的典型的范围查找（score相当于key）。</li>
</ul>
<p>实际上，Redis中sorted set的实现是这样的：</p>
<ul>
<li>当数据较少时，sorted set是由一个ziplist来实现的。</li>
<li>当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。<ul>
<li>dict用来查询数据到分数的对应关系</li>
<li>而skiplist用来根据分数查询数据（可能是范围查找）。</li>
</ul>
</li>
</ul>
<p>现在我们集中精力来看一下sorted set与skiplist的关系，：</p>
<ul>
<li>zscore(由数据查分数)的查询，不是由skiplist来提供的，而是由那个dict来提供的。 </li>
<li>为了支持排名(rank)，Redis里对skiplist做了扩展，使得根据排名能够快速查到数据，或者根据分数查到数据之后，也同时很容易获得排名。<ul>
<li>根据排名的查找，时间复杂度也为O(log n)。</li>
</ul>
</li>
<li>zrevrange的查询，是根据排名查数据，由扩展后的skiplist来提供。</li>
<li>zrevrank是先在dict中由数据查到分数，再拿分数到skiplist中去查找，查到后也同时获得了排名。</li>
</ul>
<p>前述的查询过程，也暗示了各个操作的时间复杂度：</p>
<ul>
<li>zscore只用查询一个dict，所以时间复杂度为O(1)</li>
<li>zrevrank, zrevrange, zrevrangebyscore由于要查询skiplist，所以<ul>
<li>zrevrank的时间复杂度为O(log n)，</li>
<li>而zrevrange, zrevrangebyscore的时间复杂度为O(log(n)+M)，其中M是当前查询返回的元素个数。</li>
</ul>
</li>
</ul>
<p>总结起来，Redis中的skiplist跟前面介绍的经典的skiplist相比，有如下不同：</p>
<ul>
<li>分数(score)允许重复，即skiplist的key允许重复。这在最开始介绍的经典skiplist中是不允许的。</li>
<li>在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。</li>
<li>第1层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。</li>
<li>在skiplist中可以很方便地计算出每个元素的排名(rank)。</li>
</ul>
<h4 id="SkipList的数据结构定义"><a href="#SkipList的数据结构定义" class="headerlink" title="SkipList的数据结构定义"></a>SkipList的数据结构定义</h4><p>Redis的跳跃表由zskiplistNode和skiplist两个结构定义,其中 </p>
<ul>
<li>zskiplistNode结构用于表示跳跃表节点,</li>
<li>而zskiplist结构则用于保存跳跃表节点的相关信息,比如节点的数量,以及指向表头节点和表尾节点的指针等等。</li>
</ul>
<details><summary>zskiplistNode & zskiplist 源码 (出自server.h)</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define ZSKIPLIST_MAXLEVEL 32</span><br><span class="line">#define ZSKIPLIST_P 0.25</span><br><span class="line"></span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    robj *obj;</span><br><span class="line">    double score;</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        unsigned int span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line">    unsigned long length;</span><br><span class="line">    int level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<ul>
<li>开头定义了两个常量，ZSKIPLIST_MAXLEVEL和ZSKIPLIST_P，分别对应我们前面讲到的skiplist的两个参数：一个是MaxLevel，一个是p。</li>
<li>zskiplistNode定义了skiplist的节点结构。</li>
<li>zskiplist定义了真正的skiplist结构。</li>
</ul>
</details>

<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_4.png"></p>
<p>上图展示了一个跳跃表示例,其中最左边的是 <strong>skiplist</strong> 结构,该结构包含以下属性:</p>
<p><strong>头指针header、 尾指针tail</strong>: 通过这个指针程序定位表头、表尾节点的时间复杂度就为O(1)</p>
<p><strong>总层数level</strong>: 当前所有节点层数的最大值(表头节点的层数不计算在内)，通过这个属性可以再O(1)的时间复杂度内获取层高最好的节点的层数。</p>
<p><strong>链表长度length</strong>: 记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(新创建的skiplist包含一个空的头指针，这个头指针不计算在内)，通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度。</p>
<p>结构右方的是四个 <strong>zskiplistNode</strong> 结构,该结构包含以下属性。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_5.png"></p>
<p><strong>level[]</strong>: 指向各层链表后一个节点的指针（后向指针）</p>
<ul>
<li>每层对应1个后向指针，用forward字段表示。 </li>
<li>每个后向指针还对应了一个span值，它表示当前的指针跨越了多少个节点<ul>
<li>span用于计算元素排名(rank)，这正是前面我们提到的Redis对于skiplist所做的一个扩展。</li>
<li>注意的是，level[]是一个柔性数组（flexible array member），因此它占用的内存不在zskiplistNode结构里面，而需要插入节点的时候单独为它分配。</li>
<li>也正因为如此，skiplist的每个节点所包含的指针数目才是不固定的，我们前面分析过的结论——skiplist每个节点包含的指针数目平均为1/(1-p)——才能有意义。</li>
</ul>
</li>
<li>每次创建一个新跳跃表节点的时候,程序都根据幂次定律(powerlaw,越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小,这个大小就是层的“高度”。</li>
</ul>
<p><strong>backward指针</strong>：指向链表前一个节点的指针（前向指针）</p>
<ul>
<li>节点中用BW字样标记节点的前向指针,它指向位于当前节点的前一个节点。</li>
<li>前向指针在程序从表尾向表头遍历时使用。</li>
<li>与后向指针所不同的是每个节点只有一个前向指针，因此每次只能后退一个节点（所以只有第1层链表是一个双向链表。）。</li>
</ul>
<p><strong>分值(score)</strong>: 数据对应的分数</p>
<ul>
<li>在跳跃表中,节点按各自所保存的分值<strong>从小到大</strong>排列。</li>
</ul>
<p><strong>成员对象(oj)</strong>: 一个string robj的节点对象</p>
<ul>
<li>本来一个string robj可能存放的不是sds，而是long型，但zadd命令在将数据插入到skiplist里面之前先进行了解码，所以这里的obj字段里存储的一定是一个sds。 </li>
<li>方便在查找的时候对数据进行字典序的比较（分值相同的节点将按照成员对象在字典序中的大小来进行排序），而且，skiplist里的数据部分是数字的可能性也比较小。</li>
<li>成员对象较小的节点会排在前面(靠近表头的方向),而成员对象较大的节点则会排在后面(靠近表尾的方向)。</li>
</ul>
<p>下图以一个常规的代数课成绩表为例，展示了Redis中一个skiplist的可能结构：</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_31.png"></p>
<p>注意：图中前向指针上面括号中的数字，表示对应的span的值。即当前指针跨越了多少个节点，这个计数不包括指针的起点节点，但包括指针的终点节点。</p>
<p>假设我们在这个skiplist中查找score=89.0的元素（即Bob的成绩数据），在查找路径中，我们会跨域图中标红的指针，这些指针上面的span值累加起来，就得到了Bob的排名(2+2+1)-1=4（减1是因为rank值以0起始）。需要注意这里算的是从小到大的排名，而如果要算从大到小的排名，只需要用skiplist长度减去查找路径上的span累加值，即6-(2+2+1)=1。</p>
<p>可见，在查找skiplist的过程中，通过累加span值的方式，我们就能很容易算出排名。相反，如果指定排名来查找数据（类似zrange和zrevrange那样），也可以不断累加span并时刻保持累加值不超过指定的排名，通过这种方式就能得到一条O(log n)的查找路径。</p>
<h4 id="Redis中的SortedSet"><a href="#Redis中的SortedSet" class="headerlink" title="Redis中的SortedSet"></a>Redis中的SortedSet</h4><p>我们前面提到过，Redis中的sorted set，是在skiplist, dict和ziplist基础上构建起来的:</p>
<ul>
<li>当数据较少时，sorted set是由一个ziplist来实现的。</li>
<li>当数据多的时候，sorted set是由一个叫zset的数据结构来实现的，这个zset包含一个dict + 一个skiplist。dict用来查询数据到分数(score)的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</li>
</ul>
<p>在这里我们先来讨论一下前一种情况——基于ziplist实现的sorted set。ziplist是由很多数据项组成的一大块连续内存。</p>
<p>由于sorted set的每一项元素都由数据和score组成，因此，当使用zadd命令插入一个(数据, score)对的时候，底层在相应的ziplist上就插入两个数据项：数据在前，score在后。</p>
<p>ziplist的主要优点是节省内存，但它上面的查找操作只能按顺序查找（可以正序也可以倒序）。因此，sorted set的各个查询操作，就是在ziplist上从前向后（或从后向前）一步步查找，每一步前进两个数据项，跨域一个(数据, score)对。</p>
<p>随着数据的插入，sorted set底层的这个ziplist就可能会转成zset的实现（转换过程详见t_zset.c的zsetConvert）。那么到底插入多少才会转呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br></pre></td></tr></table></figure>

<p>这个配置的意思是说，在如下两个条件之一满足的时候，ziplist会转成zset（具体的触发条件参见t_zset.c中的zaddGenericCommand相关代码）：</p>
<ul>
<li>当sorted set中的元素个数，即(数据, score)对的数目超过128的时候，也就是ziplist数据项超过256的时候。</li>
<li>当sorted set中插入的任意一个数据的长度超过了64的时候。</li>
</ul>
<p>最后，zset结构的代码定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<h3 id="Redis中SkipList常用操作时间复杂度"><a href="#Redis中SkipList常用操作时间复杂度" class="headerlink" title="Redis中SkipList常用操作时间复杂度"></a>Redis中SkipList常用操作时间复杂度</h3><table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>创建一个跳跃表</td>
<td>O(1)</td>
</tr>
<tr>
<td>释放给定跳跃表以及其中包含的节点</td>
<td>O(N)</td>
</tr>
<tr>
<td>添加给定成员和分值的新节点</td>
<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>
</tr>
<tr>
<td>删除除跳跃表中包含给定成员和分值的节点</td>
<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>
</tr>
<tr>
<td>返回给定成员和分值的节点再表中的排位</td>
<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>
</tr>
<tr>
<td>返回在给定排位上的节点</td>
<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>
</tr>
<tr>
<td>给定一个分值范围,返回跳跃表中第一个符合这个范围的节点</td>
<td>O(1)</td>
</tr>
<tr>
<td>给定一个分值范围,返回跳跃表中最后一个符合这个范围的节点</td>
<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>
</tr>
<tr>
<td>给定一个分值范围,除跳跃表中所有在这个范围之内的节点</td>
<td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>
</tr>
<tr>
<td>给定一个排位范围,鼎除跳跃表中所有在这个范围之内的节点</td>
<td>O(N),N为被除节点数量</td>
</tr>
<tr>
<td>给定一个分值范固(range),比如0到15,20到28,诸如此类,如果跳氏表中有至少一个节点的分值在这个范間之内,那么返回1,否则返回0</td>
<td>O(N),N为被除节点数量</td>
</tr>
</tbody></table>
<h2 id="Redis-IntSet"><a href="#Redis-IntSet" class="headerlink" title="Redis IntSet"></a>Redis IntSet</h2><p>Redis里面使用intset是为了实现集合(set)这种对外的数据结构。<br>set结构类似于数学上的集合的概念，它包含的元素无序，且不能重复。<br>Redis里的set结构还实现了基础的集合并、交、差的操作。</p>
<p>与Redis对外暴露的其它数据结构类似，set的底层实现，随着元素类型是否是整型以及添加的元素的数目多少，而有所变化。<br>概括来讲：</p>
<ul>
<li>当set中添加的元素都是整型且元素数目较少时，set使用intset作为底层数据结构，</li>
<li>否则，set使用dict作为底层数据结构。</li>
</ul>
<h3 id="intset数据结构简介"><a href="#intset数据结构简介" class="headerlink" title="intset数据结构简介"></a>intset数据结构简介</h3><p>intset顾名思义，是由整数组成的集合。</p>
<p>实际上，intset是一个由整数组成的有序集合，从而便于在上面进行二分查找，用于快速地判断一个元素是否属于这个集合。</p>
<p>它在内存分配上与ziplist有些类似，是连续的一整块内存空间，而且对于大整数和小整数（按绝对值）采取了不同的编码，尽量对内存的使用进行了优化。</p>
<details><summary>intset的数据结构定义</summary>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    uint32_t length;</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line"></span><br><span class="line">#define INTSET_ENC_INT16 (sizeof(int16_t))</span><br><span class="line">#define INTSET_ENC_INT32 (sizeof(int32_t))</span><br><span class="line">#define INTSET_ENC_INT64 (sizeof(int64_t))</span><br></pre></td></tr></table></figure>
</details>

<p>各个字段含义如下：</p>
<ul>
<li><p>encoding: 数据编码，表示intset中的每个数据元素用几个字节来存储。它有三种可能的取值：</p>
<ul>
<li>INTSET_ENC_INT16表示每个元素用2个字节存储，</li>
<li>INTSET_ENC_INT32表示每个元素用4个字节存储，</li>
<li>INTSET_ENC_INT64表示每个元素用8个字节存储。</li>
</ul>
<p>因此，intset中存储的整数最多只能占用64bit。</p>
</li>
<li><p>length: 表示intset中的元素个数。encoding和length两个字段构成了intset的头部（header）。</p>
</li>
<li><p>contents: 是一个柔性数组（flexible array member），表示intset的header后面紧跟着数据元素。</p>
<ul>
<li>这个数组的总长度（即总字节数）等于encoding * length。</li>
<li>柔性数组在Redis的很多数据结构的定义中都出现过（例如sds,quicklist, skiplist），用于表达一个偏移量。</li>
<li>contents需要单独为其分配空间，这部分内存不包含在intset结构当中。</li>
</ul>
</li>
</ul>
<p>其中需要注意的是，intset可能会随着数据的添加而改变它的数据编码：</p>
<ul>
<li>最开始，新创建的intset使用占内存最小的INTSET_ENC_INT16（值为2）作为数据编码。</li>
<li>每添加一个新元素，则根据元素大小决定是否对数据编码进行升级。</li>
</ul>
<p>下图给出了一个添加数据的具体例子（点击看大图）。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_33.png"></p>
<p>在上图中：</p>
<ul>
<li>新创建的intset只有一个header，总共8个字节。其中encoding = 2, length = 0。</li>
<li>添加13, 5两个元素之后，因为它们是比较小的整数，都能使用2个字节表示，所以encoding不变，值还是2。</li>
<li>当添加32768的时候，它不再能用2个字节来表示了（2个字节能表达的数据范围是-215~215-1，而32768等于215，超出范围了），因此encoding必须升级到INTSET_ENC_INT32（值为4），即用4个字节表示一个元素。</li>
<li>在添加每个元素的过程中，intset始终保持从小到大有序。</li>
<li>与ziplist类似，intset也是按小端（little endian）模式存储的（参见维基百科词条Endianness）。比如，在上图中intset添加完所有数据之后，表示encoding字段的4个字节应该解释成0x00000004，而第5个数据应该解释成0x000186A0 = 100000。</li>
</ul>
<p>intset与ziplist相比：</p>
<ul>
<li>ziplist可以存储任意二进制串，而intset只能存储整数。</li>
<li>ziplist是无序的，而intset是从小到大有序的。因此，在ziplist上查找只能遍历，而在intset上可以进行二分查找，性能更高。</li>
<li>ziplist可以对每个数据项进行不同的变长编码（每个数据项前面都有数据长度字段len），而intset只能整体使用一个统一的编码（encoding）。</li>
</ul>
<h3 id="intset的查找和添加操作"><a href="#intset的查找和添加操作" class="headerlink" title="intset的查找和添加操作"></a>intset的查找和添加操作</h3><p>要理解intset的一些实现细节，只需要关注intset的两个关键操作基本就可以了：查找（intsetFind）和添加（intsetAdd）元素。</p>
<h4 id="intsetFind"><a href="#intsetFind" class="headerlink" title="intsetFind"></a>intsetFind</h4><p>intsetFind的关键代码如下：</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_34.png"></p>
<p>关于以上代码，我们需要注意的地方包括：</p>
<ul>
<li>intsetFind在指定的intset中查找指定的元素value，找到返回1，没找到返回0。</li>
<li>_intsetValueEncoding函数会根据要查找的value落在哪个范围而计算出相应的数据编码（即它应该用几个字节来存储）。</li>
<li>如果value所需的数据编码比当前intset的编码要大，则它肯定在当前intset所能存储的数据范围之外（特别大或特别小），所以这时会直接返回0；否则调用intsetSearch执行一个二分查找算法。</li>
<li>intsetSearch在指定的intset中查找指定的元素value，如果找到，则返回1并且将参数pos指向找到的元素位置；如果没找到，则返回0并且将参数pos指向能插入该元素的位置。</li>
<li>intsetSearch是对于二分查找算法的一个实现，它大致分为三个部分：<ul>
<li>特殊处理intset为空的情况。</li>
<li>特殊处理两个边界情况：当要查找的value比最后一个元素还要大或者比第一个元素还要小的时候。实际上，这两部分的特殊处理，在二分查找中并不是必须的，但它们在这里提供了特殊情况下快速失败的可能。</li>
<li>真正执行二分查找过程。注意：如果最后没找到，插入位置在min指定的位置。</li>
</ul>
</li>
<li>代码中出现的intrev32ifbe是为了在需要的时候做大小端转换的。<br>前面我们提到过，intset里的数据是按小端（little endian）模式存储的，因此在大端（big endian）机器上运行时，这里的intrev32ifbe会做相应的转换。</li>
</ul>
<p>这个查找算法的总的时间复杂度为O(log n)。</p>
<h4 id="intsetAdd"><a href="#intsetAdd" class="headerlink" title="intsetAdd"></a>intsetAdd</h4><p>intsetAdd的关键代码如下（出自intset.c）</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_35.png"></p>
<p>关于以上代码，我们需要注意的地方包括：</p>
<ul>
<li>intsetAdd在intset中添加新元素value。<ul>
<li>如果value在添加前已经存在，则不会重复添加， 这时参数success被置为0；</li>
<li>如果value在原来intset中不存在，则将value插入到适当位置，这时参数success被置为0。</li>
</ul>
</li>
<li>如果要添加的元素value所需的数据编码比当前intset的编码要大，那么则调用intsetUpgradeAndAdd将intset的编码进行升级后再插入value。</li>
<li>调用intsetSearch，如果能查到，则不会重复添加。</li>
<li>如果没查到，则调用intsetResize对intset进行内存扩充，使得它能够容纳新添加的元素。<ul>
<li><a target="_blank" rel="noopener" href="http://man.cx/realloc">因为intset是一块连续空间，因此这个操作会引发内存的realloc, 这有可能带来一次数据拷贝</a></li>
<li>同时调用intsetMoveTail将待插入位置后面的元素统一向后移动1个位置，这也涉及到一次数据拷贝。<ul>
<li>值得注意的是，在intsetMoveTail中是调用memmove完成这次数据拷贝的。</li>
<li><a target="_blank" rel="noopener" href="http://man.cx/memmove">memmove保证了在拷贝过程中不会造成数据重叠或覆盖</a></li>
</ul>
</li>
</ul>
</li>
<li>intsetUpgradeAndAdd的实现中也会调用intsetResize来完成内存扩充。<ul>
<li>在进行编码升级时，intsetUpgradeAndAdd的实现会把原来intset中的每个元素取出来，再用新的编码重新写入新的位置。</li>
</ul>
</li>
<li>注意一下intsetAdd的返回值，它返回一个新的intset指针。<ul>
<li>它可能与传入的intset指针is相同，也可能不同。调用方必须用这里返回的新的intset，替换之前传进来的旧的intset变量。类似这种接口使用模式，在Redis的实现代码中是很常见的，比如我们之前在介绍sds和ziplist的时候都碰到过类似的情况。</li>
</ul>
</li>
</ul>
<p>显然，这个intsetAdd算法总的时间复杂度为O(n)。</p>
<h3 id="Redis-Set结构"><a href="#Redis-Set结构" class="headerlink" title="Redis Set结构"></a>Redis Set结构</h3><p>为了更好地理解Redis对外暴露的set数据结构，我们先看一下set的一些关键的命令。下面是一些命令举例：</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_36.png"></p>
<p>上面这些命令的含义：</p>
<ul>
<li>sadd用于分别向集合s1和s2中添加元素。添加的元素既有数字，也有非数字（”a”和”b”）。</li>
<li>sismember用于判断指定的元素是否在集合内存在。</li>
<li>sinter, sunion和sdiff分别用于计算集合的交集、并集和差集。</li>
</ul>
<p>我们前面提到过，set的底层实现，随着元素类型是否是整型以及添加的元素的数目多少，而有所变化。<br>例如，具体到上述命令的执行过程中，集合s1的底层数据结构会发生如下变化：</p>
<ul>
<li>在开始执行完sadd s1 13 5之后，由于添加的都是比较小的整数，所以s1底层是一个intset，其数据编码encoding= 2。</li>
<li>在执行完sadd s1 32768 10 100000之后，s1底层仍然是一个intset，但其数据编码encoding从2升级到了4。</li>
<li>在执行完sadd s1 a b之后，由于添加的元素不再是数字，s1底层的实现会转成一个dict。</li>
</ul>
<p>我们知道，dict是一个用于维护key和value映射关系的数据结构，那么当set底层用dict表示的时候，它的key和value分别是什么呢？</p>
<p>实际上，key就是要添加的集合元素，而value是NULL。</p>
<p>除了前面提到的由于添加非数字元素造成集合底层由intset转成dict之外，还有两种情况可能造成这种转换：</p>
<ul>
<li>添加了一个数字，但它无法用64bit的有符号数来表达。intset能够表达的最大的整数范围为-264~264-1，因此，如果添加的数字超出了这个范围，这也会导致intset转成dict。</li>
<li>添加的集合元素个数超过了set-max-intset-entries配置的值的时候，也会导致intset转成dict（具体的触发条件参见t_set.c中的setTypeAdd相关代码）。</li>
</ul>
<p>对于小集合使用intset来存储，主要的原因是节省内存。特别是当存储的元素个数较少的时候，dict所带来的内存开销要大得多（包含两个哈希表、链表指针以及大量的其它元数据）。所以，当存储大量的小集合而且集合元素都是数字的时候，用intset能节省下一笔可观的内存空间。</p>
<p>实际上，从时间复杂度上比较，intset的平均情况是没有dict性能高的。以查找为例，intset是O(log n)的，而dict可以认为是O(1)的。但是，由于使用intset的时候集合元素个数比较少，所以这个影响不大。</p>
<h3 id="RedisSet的并、交、叉算法"><a href="#RedisSet的并、交、叉算法" class="headerlink" title="RedisSet的并、交、叉算法"></a>RedisSet的并、交、叉算法</h3><p>Redis set的并、交、差算法的实现代码，在t_set.c中。</p>
<p>其中计算交集调用的是sinterGenericCommand，计算并集和差集调用的是sunionDiffGenericCommand。</p>
<p>它们都能同时对多个（可以多于2个）集合进行运算。</p>
<p>当对多个集合进行差集运算时，它表达的含义是：用第一个集合与第二个集合做差集，所得结果再与第三个集合做差集，依次向后类推。</p>
<h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><p>计算交集的过程大概可以分为三部分：</p>
<ol>
<li>检查各个集合，对于不存在的集合当做空集来处理。一旦出现空集，则不用继续计算了，最终的交集就是空集。</li>
<li>对各个集合按照元素个数由少到多进行排序。这个排序有利于后面计算的时候从最小的集合开始，需要处理的元素个数较少。</li>
<li>对排序后第一个集合（也就是最小集合）进行遍历，对于它的每一个元素，依次在后面的所有集合中进行查找。只有在所有集合中都能找到的元素，才加入到最后的结果集合中。</li>
</ol>
<p>需要注意的是，上述第3步在集合中进行查找，对于intset和dict的存储来说时间复杂度分别是O(log n)和O(1)。</p>
<p>但由于只有小集合才使用intset，所以可以粗略地认为intset的查找也是常数时间复杂度的。</p>
<p>因此,<br><a target="_blank" rel="noopener" href="http://redis.io/commands/sinter">如Redis官方文档上所说</a><br>sinter命令的时间复杂度为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets.</span><br></pre></td></tr></table></figure>

<h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><p>计算并集最简单，只需要遍历所有集合，将每一个元素都添加到最后的结果集合中。 向集合中添加元素会自动去重。</p>
<p>由于要遍历所有集合的每个元素，所以<br><a target="_blank" rel="noopener" href="http://redis.io/commands/sunion">Redis官方文档</a><br>给出的sunion命令的时间复杂度为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(N) where N is the total number of elements in all given sets.</span><br></pre></td></tr></table></figure>
<p>注意，这里同前面讨论交集计算一样，将元素插入到结果集合的过程，忽略intset的情况，认为时间复杂度为O(1)。</p>
<h4 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h4><p>计算差集有两种可能的算法，它们的时间复杂度有所区别。</p>
<p>第一种算法：</p>
<ul>
<li>对第一个集合进行遍历，对于它的每一个元素，依次在后面的所有集合中进行查找。只有在所有集合中都找不到的元素，才加入到最后的结果集合中。</li>
</ul>
<p>这种算法的时间复杂度为O(N*M)，其中N是第一个集合的元素个数，M是集合数目。</p>
<p>第二种算法：</p>
<ul>
<li>将第一个集合的所有元素都加入到一个中间集合中。</li>
<li>遍历后面所有的集合，对于碰到的每一个元素，从中间集合中删掉它。</li>
<li>最后中间集合剩下的元素就构成了差集。</li>
</ul>
<p>这种算法的时间复杂度为O(N)，其中N是所有集合的元素个数总和。</p>
<p>在计算差集的开始部分，会先分别估算一下两种算法预期的时间复杂度，然后选择复杂度低的算法来进行运算。</p>
<p>还有两点需要注意：</p>
<ul>
<li>在一定程度上优先选择第一种算法，因为它涉及到的操作比较少，只用添加，而第二种算法要先添加再删除。</li>
<li>如果选择了第一种算法，那么在执行该算法之前，Redis的实现中对于第二个集合之后的所有集合，按照元素个数由多到少进行了排序。这个排序有利于以更大的概率查找到元素，从而更快地结束查找。</li>
</ul>
<p>对于sdiff的时间复杂度，<br><a target="_blank" rel="noopener" href="http://redis.io/commands/sdiff">Redis官方文档</a><br>只给出了第二种算法的结果，是不准确的。</p>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c2841d65df4c">死磕Redis5.0之跳跃表</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/3TU9qxHJyxHJgVDaYXoluA">Redis内部数据结构详解</a></p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/%E8%B7%B3%E8%B7%83%E8%A1%A8/">跳跃表</a><a class="post-meta__tags" href="/tags/%E7%B4%A2%E5%BC%95/">索引</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"><i class="fa fa-chevron-left">  </i><span>Redis初探之常见问题汇总</span></a></div><div class="next-post pull-right"><a href="/2022/03/08/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E4%BB%8E%E4%B8%BB%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9C%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/"><span>从主流中间件看分布式系统主从同步策略</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By 何鹏 [smile.hepeng@qq.com]</div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>