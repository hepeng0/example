<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Redis初探之常见问题汇总"><meta name="keywords" content="Redis"><meta name="author" content="何鹏 [smile.hepeng@qq.com]"><meta name="copyright" content="何鹏 [smile.hepeng@qq.com]"><title>Redis初探之常见问题汇总 | 沉默者</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><link rel="alternate" href="/atom.xml" title="沉默者" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8%E4%BC%98%E7%BC%BA%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">Redis 缓存使用优缺点总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">Redis 支持的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">基础数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">布隆过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">布隆过滤器解决什么问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%AF%A5%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.2.</span> <span class="toc-text">布隆过滤器怎么解决该问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.3.</span> <span class="toc-text">布隆过滤器有什么优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">2.2.4.</span> <span class="toc-text">Redis如何实现布隆过滤器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">Redis 线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">为什么说Redis是单线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%BC%80%E5%A7%8B%E8%A6%81%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">Redis为什么一开始要使用单线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">Redis为什么要引入多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">Redis 高可用架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A6%96%E5%85%88%EF%BC%8C%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%A2%E5%A4%B1-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">首先，保证数据不丢失-数据持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RDB"><span class="toc-number">4.1.1.</span> <span class="toc-text">RDB</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">快照的过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E9%85%8D%E7%BD%AE"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">快照配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">快照优势与劣势</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF"><span class="toc-number">4.1.2.</span> <span class="toc-text">AOF</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF-%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">AOF 重写机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF%E9%85%8D%E7%BD%AE"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">AOF配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%80%9C%E5%86%99%E5%90%8E%E6%97%A5%E5%BF%97%E2%80%9D"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">“写后日志”</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%86%99%E5%90%8E%E6%97%A5%E5%BF%97"><span class="toc-number">4.1.2.3.1.</span> <span class="toc-text">为什么使用写后日志</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%99%E5%90%8E%E6%97%A5%E5%BF%97%E6%9C%89%E4%BB%80%E4%B9%88%E9%A3%8E%E9%99%A9"><span class="toc-number">4.1.2.3.2.</span> <span class="toc-text">写后日志有什么风险</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF%E4%BC%98%E5%8A%BF"><span class="toc-number">4.1.2.4.</span> <span class="toc-text">AOF优势</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">4.1.3.</span> <span class="toc-text">持久化机制如何选择</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E6%AC%A1%EF%BC%8C%E8%A7%A3%E5%86%B3%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C-%E5%A4%8D%E5%88%B6%E5%89%AF%E6%9C%AC"><span class="toc-number">4.2.</span> <span class="toc-text">其次，解决单点故障-复制副本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-number">4.2.1.</span> <span class="toc-text">全量同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-number">4.2.2.</span> <span class="toc-text">增量同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.2.3.</span> <span class="toc-text">主从同步注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%EF%BC%8C%E6%BB%A1%E8%B6%B3%E4%B8%8D%E5%90%8C%E6%9E%B6%E6%9E%84%E9%9C%80%E6%B1%82-%E5%A4%9A%E7%A7%8D%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.</span> <span class="toc-text">最后，满足不同架构需求-多种架构模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">单机模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">主从模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.3.</span> <span class="toc-text">哨兵模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Sentinel%E5%85%B3%E9%94%AE%E5%90%8D%E8%AF%8D"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">Sentinel关键名词</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Sentinel%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">Sentinel工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">哨兵模式的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">4.3.3.3.1.</span> <span class="toc-text">哨兵模式的优点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">4.3.3.3.2.</span> <span class="toc-text">哨兵模式的缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.4.</span> <span class="toc-text">集群模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E7%89%87"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">分片</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">主从</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis-Cluster%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.3.4.3.</span> <span class="toc-text">Redis Cluster优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">4.3.4.3.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">4.3.4.3.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img2.baidu.com/it/u=928705063,3876627980&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg"></div><div class="author-info__name text-center">何鹏 [smile.hepeng@qq.com]</div><div class="author-info__description text-center">路漫漫其修远兮，吾将上下而求索</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">63</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">52</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默者</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Redis初探之常见问题汇总</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"> 中间件</a><span class="post-meta__separator">|</span><span class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">10.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 33 分钟</span></span></div><div class="article-container" id="post-content"><p>拓展阅读: <a href="/2020/10/09/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F02%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%89%E5%A4%A7%E5%88%A9%E5%99%A8%E4%B9%8B%E7%BC%93%E5%AD%98/" title="高并发系统02之高并发三大利器之缓存">高并发系统02之高并发三大利器之缓存</a></p>
<h2 id="Redis-缓存使用优缺点总结"><a href="#Redis-缓存使用优缺点总结" class="headerlink" title="Redis 缓存使用优缺点总结"></a>Redis 缓存使用优缺点总结</h2><p>Redis 是完全开源免费的，是一个高性能的key-value类型的内存数据库。</p>
<p>整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p>
<p>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><p>速度快，因为数据存在内存中，读的速度是 110000 次 /s, 写的速度是 81000 次 /s；</p>
<ul>
<li>值得注意的是，该测试结果还是早些年旧机器上的测试结果。如果与今天的机器设备相比，预估可能是以下结果的两倍。</li>
</ul>
</li>
<li><p>支持丰富数据类型，支持string，list，set，sorted set，hash；</p>
</li>
<li><p>支持事务，操作都是原子性，对数据的更改要么全部执行，要么全部不执行，事务中任意命令执行失败，其余命令依然被执行。也就是说 Redis 事务不保证原子性，也不支持回滚；事务中的多条命令被一次性发送给服务器，服务器在执行命令期间，不会去执行其他客户端的命令请求。</p>
</li>
<li><p>丰富的特性：可用于缓存，消息（支持 publish/subscribe 通知），按key设置过期时间，过期后将会自动删除。</p>
<p> 具体<strong>淘汰策略</strong>有：</p>
<ul>
<li>volatile-lru：从已经设置过期时间的数据集中，挑选最近最少使用的数据淘汰 </li>
<li>volatile-ttl：从已经设置过期时间的数据集中，挑选即将要过期的数据淘汰 </li>
<li>volatile-random：从已经设置过期时间的数据集中，随机挑选数据淘汰</li>
<li>allkeys-lru：从所有的数据集中，挑选最近最少使用的数据淘汰 </li>
<li>allkeys-random：从所有的数据集中，随机挑选数据淘汰</li>
<li>no-enviction：禁止淘汰数据</li>
</ul>
<p> 具体<strong>过期键的策略</strong>有：</p>
<ul>
<li>定时删除（缓存过期时间到就删除，创建timer耗CPU）</li>
<li>惰性删除（获取的时候检查，不获取一直留在内存，对内存不友好）</li>
<li>定期删除（CPU和内存的折中方案）</li>
</ul>
</li>
<li><p>支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用；</p>
</li>
<li><p>支持数据的备份，即 master - slave 模式的数据备份。</p>
</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在<strong>较小数据量的高性能操作和运算</strong>上。</p>
<h2 id="Redis-支持的数据类型"><a href="#Redis-支持的数据类型" class="headerlink" title="Redis 支持的数据类型"></a>Redis 支持的数据类型</h2><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><p>Redis 支持 5 中数据类型：string（字符串），hash（哈希），list（列表），set（集合），zset（sorted set：有序集合）。</p>
<ul>
<li><p><strong>String</strong> key-value, 最基本的数据类型，二进制安全的字符串，最大存储数据512M</p>
</li>
<li><p><strong>List</strong> 简单的字符串列表，按插入顺序排序，可以左添加/右添加，最大存储数据量2^32-1。list 内的元素是可重复的。可以做消息队列或最新消息排行等功能。</p>
</li>
<li><p><strong>Hash</strong> String类型key-value集合映射表，适合存储对象，并且可以像数据库中一样只对某一项属性值进行存储、读取、修改等操作。最大存储数据量2^32-1。</p>
</li>
<li><p><strong>Set</strong> hash表实现，无序的字符串集合，不存在重复的元素，添加、删除、查找复杂度O（1），最大存储数据量2^32-1</p>
</li>
<li><p><strong>SortedSet</strong> 每个元素关联一个double类型分数，redis 通过分数来为集合中的成员进行从小到大的排序。zset 的元素是唯一的，但是分数（score）却可以重复，可用作排行榜等场景。</p>
</li>
</ul>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><h4 id="布隆过滤器解决什么问题"><a href="#布隆过滤器解决什么问题" class="headerlink" title="布隆过滤器解决什么问题"></a>布隆过滤器解决什么问题</h4><p>大数据量集合，如何准确快速的判断某个数据是否在大数据量集合中，并且不占用内存？</p>
<h4 id="布隆过滤器怎么解决该问题"><a href="#布隆过滤器怎么解决该问题" class="headerlink" title="布隆过滤器怎么解决该问题"></a>布隆过滤器怎么解决该问题</h4><p>一种数据结构，是由一串很长的二进制向量组成，可以将其看成一个二进制数组。既然是二进制，那么里面存放的不是0，就是1，但是初始默认值都是0。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_2.png"></p>
<p>添加数据：自定义几个Hash函数，分别算出Key对应的各个值，将值的位置都置为1。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_1.png"></p>
<p>判断存在性：如果通过哈希函数算出来的值，对应的地方有0，则数据一定不存在；无法判断数据一定存在。</p>
<h4 id="布隆过滤器有什么优缺点"><a href="#布隆过滤器有什么优缺点" class="headerlink" title="布隆过滤器有什么优缺点"></a>布隆过滤器有什么优缺点</h4><ul>
<li>优点：内存占用极小，插入&amp;查询极快</li>
<li>缺点：无法判断数据一定存在；随着数据量增大，误判率增加；无法删除数据。</li>
</ul>
<h4 id="Redis如何实现布隆过滤器"><a href="#Redis如何实现布隆过滤器" class="headerlink" title="Redis如何实现布隆过滤器"></a>Redis如何实现布隆过滤器</h4><p>Redis本身支持bitmap数据结构，通过setbit和getbit即可实现一个Bloom Filter，具体实现参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017370384">基于Redis的BloomFilter实现</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zwx900102/article/details/110307834?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&spm=1001.2101.3001.4242">如何利用一个支持元素删除的布隆过滤器来解决缓存穿透问题</a></p>
<h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><h3 id="为什么说Redis是单线程模型"><a href="#为什么说Redis是单线程模型" class="headerlink" title="为什么说Redis是单线程模型"></a>为什么说Redis是单线程模型</h3><p>Redis的单线程，其实是指执行Redis命令的<strong>核心模块是单线程</strong>的，也就是文件事件处理器，主要由四个部分组成：</p>
<ul>
<li>套接字</li>
<li>IO多路复用</li>
<li>文件事件分派器</li>
<li>事件处理器。</li>
</ul>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img.png"></p>
<h3 id="Redis为什么一开始要使用单线程"><a href="#Redis为什么一开始要使用单线程" class="headerlink" title="Redis为什么一开始要使用单线程"></a>Redis为什么一开始要使用单线程</h3><ul>
<li>使用非阻塞IO和多路复用IO<ul>
<li>使用IO多路复用机制同时监听多个文件描述符的可读和可写状态</li>
<li>绝大部分操作纯内存，在单线程模式下，处理的网络请求得到忽略</li>
</ul>
</li>
<li>可维护性高<ul>
<li>单线程不存在并发读写问题</li>
<li>无上下文切换，可以避免线程切换带来的开销</li>
</ul>
</li>
<li>Redis本身是基于内存的，数据都存放在内存中，单线程效率依旧高</li>
<li>普通 KV 存储<strong>瓶颈压根不在 CPU，而往往可能受到内存和网络I/O的制约</strong></li>
<li>可以通过开启多个Redis实例来利用多核</li>
</ul>
<p>Redis6.0其实已经支持多线程来提高性能了。</p>
<h3 id="Redis为什么要引入多线程"><a href="#Redis为什么要引入多线程" class="headerlink" title="Redis为什么要引入多线程"></a>Redis为什么要引入多线程</h3><p>Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。</p>
<p>对网络事件进行监听，分发给work thread进行处理，处理完以后将主动权交还给主线程，进行执行操作，当然后续还会有，执行后依然交由 work thread 进行响应数据的 socket write 操作。</p>
<p>大元素异步删除支持。</p>
<h2 id="Redis-高可用架构"><a href="#Redis-高可用架构" class="headerlink" title="Redis 高可用架构"></a>Redis 高可用架构</h2><h3 id="首先，保证数据不丢失-数据持久化"><a href="#首先，保证数据不丢失-数据持久化" class="headerlink" title="首先，保证数据不丢失-数据持久化"></a>首先，保证数据不丢失-数据持久化</h3><p>Redis 数据是存储在内存中的，为了保证 Redis 数据不丢失，那就要把数据从内存存储到磁盘上，以便在服务器重启后还能够从磁盘中恢复原有数据，这就是 Redis 的数据持久化。</p>
<p>Redis 数据持久化有三种方式： 1）AOF 日志（Append Only File，文件追加方式）：记录所有的操作命令，并以文本的形式追加到文件中。 2）RDB 快照（Redis<br>DataBase）：将某一个时刻的内存数据，以二进制的方式写入磁盘。 3）混合持久化方式：Redis 4.0 新增了混合持久化的方式，集成了 RDB 和 AOF 的优点。</p>
<p><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1662843885312435398">详解Redis持久化（RDB和AOF）</a></p>
<h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>Redis DataBase：采用的是内存快照的方式，它记录的是某一时刻的数据，而不是操作。</p>
<p>故障恢复时只需要直接把 RDB 文件读入内存即可实现快速恢复。</p>
<h5 id="快照的过程"><a href="#快照的过程" class="headerlink" title="快照的过程"></a>快照的过程</h5><ul>
<li> Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；</li>
<li> 父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；</li>
<li> 当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成。</li>
<li> 在执行fork的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令 ），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。</li>
</ul>
<p>Redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说<strong>任何时候RDB文件都是完整的</strong>。</p>
<p>这使得我们可以通过定时备份RDB文件来实现Redis数据库备份。</p>
<p>RDB文件是经过压缩（可以配置rdbcompression参数以禁用压缩节省CPU占用）的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。</p>
<p>除了自动快照，还可以手动发送SAVE或BGSAVE命令让Redis执行快照。</p>
<ul>
<li>SAVE: 是由主进程进行快照操作，会阻塞住其他请求</li>
<li>BGSAVE: 会通过fork子进程进行快照操作。</li>
</ul>
<p>redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。 </p>
<p>通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。<strong>如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化</strong>。</p>
<h5 id="快照配置"><a href="#快照配置" class="headerlink" title="快照配置"></a>快照配置</h5><p>RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的所有数据进行快照并存储在硬盘上。</p>
<p>进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：时间和改动的键的个数。</p>
<p>当在指定的时间内被更改的键的个数大于指定的数值时就会进行快照。</p>
<p>RDB是redis默认采用的持久化方式，在配置文件中已经预置了3个条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1      #900秒内有至少1个键被更改则进行快照</span><br><span class="line">save 300 10     #300秒内有至少10个键被更改则进行快照</span><br><span class="line">save 60 10000   #60秒内有至少10000个键被更改则进行快照</span><br></pre></td></tr></table></figure>

<p>可以存在多个条件，条件之间是”或”的关系，只要满足其中一个条件，就会进行快照。</p>
<p>如果想要禁用自动快照，只需要将所有的save参数删除即可。</p>
<p>Redis默认会将快照文件存储在当前目录(可CONFIG GET dir来查看)的dump.rdb文件中，可以通过配置dir和dbfilename两个参数分别指定快照文件的存储路径和文件名。</p>
<h5 id="快照优势与劣势"><a href="#快照优势与劣势" class="headerlink" title="快照优势与劣势"></a>快照优势与劣势</h5><p>优势：</p>
<ul>
<li>全量备份，适合做冷备；</li>
<li>fork子进程，让子进程执行磁盘 IO 操作，性能影响小；</li>
<li>相对于 AOF 持久化机制来说，恢复更快；</li>
<li>fork子进程生成快照时可以会暂停服务。</li>
</ul>
<p>劣势：</p>
<ul>
<li>如果想要在 Redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好；</li>
<li>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li>
</ul>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>Append Only File：采用的是“<strong>写后日志</strong>”的方式，Redis 先执行命令把数据写入内存，然后再记录日志到文件中。</p>
<p>AOF 日志记录的是操作命令，不是实际的数据，如果采用 AOF 方法做故障恢复时需要将全量日志都执行一遍。</p>
<h5 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h5><ul>
<li>解决AOF文件体积膨胀的问题，使用更小的体积来保存数据库状态</li>
<li>Redis增加了一个AOF重写缓存，这个缓存在fork出子进程之后开始启用，Redis服务器主进程在执行完写命令之后，会同时将这个写命令追加到AOF缓冲区和AOF重写缓冲区</li>
<li>AOF缓冲区的内容会定期被写入和同步到AOF文件中，对现有的AOF文件的处理工作会正常进行，从创建子进程开始，服务器执行的所有写操作都会被记录到AOF重写缓冲区中；</li>
<li>当子进程完成对AOF文件重写之后，它会向父进程发送一个完成信号，父进程接到该完成信号之后，会调用一个信号处理函数，该函数完成以下工作：</li>
<li>将AOF重写缓存中的内容全部写入到新的AOF文件中；这个时候新的AOF文件所保存的数据库状态和服务器当前的数据库状态一致；</li>
<li>新的AOF文件进行改名，原子的覆盖原有的AOF文件；完成新旧两个AOF文件的替换。</li>
<li>在整个AOF后台重写过程中，只有最后的“主进程写入命令到AOF缓存”和“对新的AOF文件进行改名，覆盖原有的AOF文件。”<ul>
<li>这<strong>两个步骤（信号处理函数执行期间）会造成主进程阻塞</strong>，在其他时候，AOF后台重写都不会对主进程造成阻塞，这将AOF重写对性能造成的影响降到最低。</li>
</ul>
</li>
</ul>
<h5 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h5><p>默认情况下Redis没有开启AOF(append only file)方式的持久化，可以在redis.conf中通过appendonly参数开启：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<p>在启动时Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入的速度相较RDB会慢一些</p>
<p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfilename appendonly.aof</span><br></pre></td></tr></table></figure>
<p>配置redis自动重写AOF文件的条件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100  # 当目前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据</span><br><span class="line"> </span><br><span class="line">auto-aof-rewrite-min-size 64mb   # 允许重写的最小AOF文件大小</span><br><span class="line">配置写入AOF文件后，要求系统刷新硬盘缓存的机制</span><br><span class="line"> </span><br><span class="line"># appendfsync always   # 每次执行写入都会执行同步，最安全也最慢</span><br><span class="line">appendfsync everysec   # 每秒执行一次同步操作</span><br><span class="line"></span><br><span class="line"># appendfsync no       # 不主动进行同步操作，而是完全交由操作系统来做（即每30秒一次），最快也最不安全</span><br></pre></td></tr></table></figure>

<h5 id="“写后日志”"><a href="#“写后日志”" class="headerlink" title="“写后日志”"></a>“写后日志”</h5><h6 id="为什么使用写后日志"><a href="#为什么使用写后日志" class="headerlink" title="为什么使用写后日志"></a>为什么使用写后日志</h6><p>Redis 在写入日志之前，不对命令进行语法检查，所以只记录执行成功的命令，避免出现记录错误命令的情况，而且在命令执行后再写日志不会阻塞当前的写操作。</p>
<h6 id="写后日志有什么风险"><a href="#写后日志有什么风险" class="headerlink" title="写后日志有什么风险"></a>写后日志有什么风险</h6><ul>
<li>数据可能会丢失：如果 Redis 刚执行完命令，此时发生故障宕机，会导致这条命令存在丢失的风险。</li>
<li>可能阻塞其他操作：AOF 日志其实也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li>
</ul>
<h5 id="AOF优势"><a href="#AOF优势" class="headerlink" title="AOF优势"></a>AOF优势</h5><ul>
<li>数据安全，aof持久化，可以配置appendfsync属性，有always，每进行一次命令操作就记录到aof文件中一次。</li>
<li>通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。</li>
<li>适合误删除紧急恢复-AOF机制的rewrite模式。AOF文件没被rewrite之前（文件过大时，会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）)</li>
<li>写QPS性能降低(每秒一次性能影响不高)</li>
</ul>
<h4 id="持久化机制如何选择"><a href="#持久化机制如何选择" class="headerlink" title="持久化机制如何选择"></a>持久化机制如何选择</h4><p>redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制。</p>
<p>用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</p>
<h3 id="其次，解决单点故障-复制副本"><a href="#其次，解决单点故障-复制副本" class="headerlink" title="其次，解决单点故障-复制副本"></a>其次，解决单点故障-复制副本</h3><p>为解决单点数据库问题，Redis会把数据复制多个副本部署到其他节点上。</p>
<p>通过复制，实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。</p>
<p>Redis的主从结构可以采用一主多从或者级联结构，Redis主从复制可以根据是否是全量分为全量同步和增量同步。下图为级联结构。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_3.png"></p>
<h4 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h4><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_4.png"></p>
<p>具体步骤如下：</p>
<ul>
<li> 从服务器连接主服务器，发送SYNC命令；</li>
<li> 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；</li>
<li> 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li>
<li> 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li>
<li> 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li>
<li> 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li>
</ul>
<p>完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。</p>
<h4 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h4><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。</p>
<p>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p>
<p>增量同步功能组成部分</p>
<ol>
<li>主服务器的复制偏移量和从服务器的复制偏移量；<ul>
<li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加N；</li>
<li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。</li>
</ul>
</li>
<li>主服务器的复制积压缓冲区；<ul>
<li>由主服务器维护的一个固定长度队列，默认为1M，当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面。</li>
</ul>
</li>
<li>服务器的运行ID。<ul>
<li>每个服务器在启动时随机生成运行ID（runid）。</li>
</ul>
</li>
</ol>
<p>Redis增量同步功能实现：</p>
<ol>
<li>从服务器向主服务器发送PSYNC命令，携带主服务器的runid和复制偏移量；</li>
<li>主服务器验证runid和自身runid是否一致，如不一致，则进行全量复制；</li>
<li>主服务器验证复制偏移量是否在积压缓冲区内，如不在，则进行全量复制；</li>
<li>如都验证通过，则主服务器将保持在积压区内的偏移量后的所有数据发送给从服务器，主从服务器再次回到一致状态。</li>
</ol>
<p>总结： </p>
<ol>
<li>只有当从服务器的携带的主服务器runid和offset都符合，Redis才会采用增量同步的策略，存在着很大的局限性；</li>
<li>因此从服务器重启、更换主服务器、以及断连时间过长，redis都会采用全量同步的策略。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机</span><br></pre></td></tr></table></figure>

<h4 id="主从同步注意事项"><a href="#主从同步注意事项" class="headerlink" title="主从同步注意事项"></a>主从同步注意事项</h4><ol>
<li>Redis使用异步复制。但从Redis 2.8开始，从服务器会周期性的应答从复制流中处理的数据量。<ul>
<li>主从服务器之间会定期进行通话，但是如果master上设置了密码，那么如果不给slave设置密码就会导致slave不能跟master进行任何操作，所以如果你的master服务器<br>上有密码，那么也需要给slave相应的设置一下密码（通过设置配置文件中的masterauth）</li>
</ul>
</li>
<li>一个主服务器可以有多个从服务器。<ul>
<li>一般slave服务器不能进行写操作，但是这不是死的，之所以这样是为了更容易的保证主和各个从之间数据的一致性，如果slave服务器上数据进行了修改， 那么要保证所有主从服务器都能一致，可能在结构上和处理逻辑上更为负责。不过你也可以通过配置文件让从服务器支持写操作。（所带来的影响还得自己承担）   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">从服务器默认只读模式，这个行为是由Redis.conf文件中的slave-read-only 参数控制的，可以在运行中通过CONFIG SET来启用或者禁用。</span><br><span class="line"></span><br><span class="line">只读的从服务器会拒绝所有写命令，所以对从服务器不会有误写操作。但这不表示可以把从服务器实例暴露在危险的网络环境下。</span><br><span class="line">因为像DEBUG或者CONFIG这样的管理命令还是可以运行的。不过你可以通过使用rename-command命令来为这些命令改名来增加安全性。</span><br><span class="line"></span><br><span class="line">你可能想知道为什么只读限制还可以被还原，使得从服务器还可以进行写操作。虽然当主从服务器进行重新同步或者从服务器重启后，</span><br><span class="line">这些写操作都会失效，还是有一些使用场景会想从服务器中写入临时数据的，但将来这个特性可能会被去掉。</span><br></pre></td></tr></table></figure></li>
<li>可以配置主服务器连接N个以上从服务器才允许对主服务器进行写操作。   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">因为Redis使用的是异步主从复制，</span><br><span class="line">没办法确保从服务器确实收到了要写入的数据，所以还是有一定的数据丢失的可能性。</span><br><span class="line"></span><br><span class="line">这一特性的工作原理如下：</span><br><span class="line">1）从服务器每秒钟ping一次主服务器，确认处理的复制流数量。</span><br><span class="line">2）主服务器记住每个从服务器最近一次ping的时间。</span><br><span class="line">3）用户可以配置最少要有N个服务器有小于M秒的确认延迟。</span><br><span class="line">4）如果有N个以上从服务器，并且确认延迟小于M秒，主服务器接受写操作。</span><br><span class="line"></span><br><span class="line">还可以把这看做是CAP原则（一致性，可用性，分区容错性）不严格的一致性实现，虽然不能百分百确保一致性，但至少保证了丢失的数据不会超过M秒内的数据量。</span><br><span class="line"></span><br><span class="line">如果条件不满足，主服务器会拒绝写操作并返回一个错误。</span><br><span class="line">1）min-slaves-to-write（最小从服务器数）</span><br><span class="line">2）min-slaves-max-lag（从服务器最大确认延迟）</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>从服务器也可以接受其他从服务器的连接。<ul>
<li>除了多个从服务器连接到一个主服务器之外，多个从服务器也可以连接到一个从服务器上，形成一个<br>图状结构。</li>
</ul>
</li>
<li>Redis主从复制不阻塞主服务器端。也就是说当若干个从服务器在进行初始同步时，主服务器仍然可以处理请求。</li>
<li>主从复制也不阻塞从服务器端。<ul>
<li>当从服务器进行初始同步时，它使用旧版本的数据来应对查询请求，假设你在redis.conf配置文件是这么配置的。</li>
<li>否则的话，你可以配置当复制流关闭时让从服务器给客户端返回一个错误。但是，当初始同步完成后，需要删除旧的数据集和加载新的数据集，在这个短暂的时间内，从服务器会阻塞连接进来的请求。</li>
</ul>
</li>
<li>主从复制可以用来增强扩展性，使用多个从服务器来处理只读的请求（比如，繁重的排序操作可以放到从服务器去做），也可以简单的用来做数据冗余。</li>
<li>使用主从复制可以为主服务器免除把数据写入磁盘的消耗：在主服务器的redis.conf文件中配置“避免保存”（注释掉所有“保存“命令），然后连接一个配置为“进行保存”的从服务器即可。<ul>
<li>这个配置要确保主服务器不会自动重启，主redis服务器一旦重启，因为主redis服务器数据为空，这时候通过主从同步可能导致从redis服务器上的数据也被清空。</li>
<li>全量同步过程中，master会将数据保存在rdb文件中然后发送给slave服务器，但是如果master上的磁盘空间有效怎么办呢？那么此时全部同步对于master来说将是一份十分有压力的操作了。此时可以通过<strong>无盘复制</strong>来达到目的，由master直接开启一个socket将rdb文件发送给slave服务器。（无盘复制一般应用在磁盘空间有限但是网络状态良好的情况下）</li>
<li>强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设置节点A为主服务器，关闭持久化，节点B和C从节点A复制数据。</span><br><span class="line">这时出现了一个崩溃，但Redis具有自动重启系统，重启了进程，因为关闭了持久化，节点重启后只有一个空的数据集。</span><br><span class="line">节点B和C从节点A进行复制，现在节点A是空的，所以节点B和C上的复制数据也会被删除。</span><br><span class="line">当在高可用系统中使用Redis Sentinel，关闭了主服务器的持久化，并且允许自动重启，这种情况是很危险的。</span><br><span class="line">比如主服务器可能在很短的时间就完成了重启，以至于Sentinel都无法检测到这次失败，那么上面说的这种失败的情况就发生了。</span><br><span class="line">    </span><br><span class="line">如果数据比较重要，并且在使用主从复制时关闭了主服务器持久化功能的场景中，都应该禁止实例自动重启。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>关于slave服务器上过期键的处理，由master服务器负责键的过期删除处理，然后将相关删除命令已数据同步的方式同步给slave服务器，slave服务器根据删除命令删除<br>本地的key。</li>
</ol>
<h3 id="最后，满足不同架构需求-多种架构模式"><a href="#最后，满足不同架构需求-多种架构模式" class="headerlink" title="最后，满足不同架构需求-多种架构模式"></a>最后，满足不同架构需求-多种架构模式</h3><p>为了满足开发市场需求，Redis 支持<strong>单机、主从、哨兵、集群</strong>多种架构模式。</p>
<h4 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h4><p>单机模式顾名思义就是安装一个 Redis，启动起来，业务调用即可。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_5.png"></p>
<p>一些简单的应用，并非必须保证高可用的情况下可以使用该模式。</p>
<p>优点：</p>
<ul>
<li>部署简单；</li>
<li>成本低，无备用节点；</li>
<li>高性能，单机不需要同步数据，数据天然一致性。</li>
</ul>
<p>缺点:</p>
<ul>
<li>可靠性保证不是很好，单节点有宕机的风险。</li>
<li>单机高性能受限于 CPU 的处理能力，Redis 是单线程的。</li>
</ul>
<p>单机 Redis 能够承载的 QPS（每秒查询速率）大概在几万左右。 取决于业务操作的复杂性，Lua 脚本复杂性就极高。假如是简单的 key value 查询那性能就会很高。</p>
<p>假设上千万、上亿用户同时访问 Redis，QPS 达到 10 万+。这些请求过来，单机 Redis 直接就挂了。系统的瓶颈就出现在 Redis 单机问题上，此时我们可以通过<strong>主从复制</strong>解决该问题，实现系统的高并发</p>
<h4 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h4><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_6.png"></p>
<p>Redis 的复制（Replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（Master），而通过复制创建出来的复制品则为从服务器（Slave）。 只要主从服务器之间的网络连接正常，主服务器就会将写入自己的数据同步更新给从服务器，从而保证主从服务器的数据相同。</p>
<p>数据的复制是单向的，只能由主节点到从节点，简单理解就是从节点只支持读操作，不允许写操作。主要是读高并发的场景下用主从架构。</p>
<p>主从模式需要考虑的问题是：当 Master 节点宕机，需要选举产生一个新的 Master 节点，从而保证服务的高可用性。</p>
<p>优点：</p>
<ul>
<li>Master/Slave 角色方便水平扩展，QPS 增加，增加 Slave 即可；</li>
<li>降低 Master 读压力，转交给 Slave 节点；</li>
<li>主节点宕机，从节点作为主节点的备份可以随时顶上继续提供服务；</li>
</ul>
<p>缺点： </p>
<ul>
<li>可靠性保证不是很好，主节点故障便无法提供写入服务；</li>
<li>没有解决主节点写的压力；</li>
<li>数据冗余（为了高并发、高可用和高性能，一般是允许有冗余存在的）；</li>
<li>一旦主节点宕机，从节点晋升成主节点，需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预；</li>
<li>主节点的写能力受到单机的限制；</li>
<li>主节点的存储能力受到单机的限制。</li>
</ul>
<h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>主从模式中，当主节点宕机之后，从节点是可以作为主节点顶上来继续提供服务，但是需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。</p>
<p>于是，在 Redis 2.8 版本开始，引入了哨兵（Sentinel）这个概念，在主从复制的基础上，哨兵实现了自动化故障恢复。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_7.png"></p>
<p>如图所示，哨兵模式由两部分组成，哨兵节点和数据节点：</p>
<ul>
<li>哨兵节点：哨兵节点是特殊的 Redis 节点，不存储数据；</li>
<li>数据节点：主节点和从节点都是数据节点。</li>
</ul>
<p>Redis Sentinel 是分布式系统中监控 Redis 主从服务器，并提供主服务器下线时自动故障转移功能的模式。</p>
<p>其中三个特性为：</p>
<ul>
<li>监控(Monitoring)：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常；</li>
<li>提醒(Notification)：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知；</li>
<li>自动故障迁移(Automatic failover)：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</li>
</ul>
<h5 id="Sentinel关键名词"><a href="#Sentinel关键名词" class="headerlink" title="Sentinel关键名词"></a>Sentinel关键名词</h5><p>####### 定时任务<br>Sentinel 内部有 3 个定时任务，分别是：</p>
<ul>
<li>每 1 秒每个 Sentinel 对其他 Sentinel 和 Redis 节点执行 PING 操作（监控），这是一个心跳检测，是失败判定的依据。</li>
<li>每 2 秒每个 Sentinel 通过 Master 节点的 channel 交换信息（Publish/Subscribe）；</li>
<li>每 10 秒每个 Sentinel 会对 Master 和 Slave 执行 INFO 命令，这个任务主要达到两个目的：<ul>
<li>发现 Slave 节点；</li>
<li>确认主从关系。</li>
</ul>
</li>
</ul>
<p>####### 主观下线<br>所谓主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断，即单个 Sentinel 认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。</p>
<p>主观下线就是说如果服务器在给定的毫秒数之内，没有返回 Sentinel 发送的 PING 命令的回复，或者返回一个错误，那么 Sentinel 会将这个服务器标记为主观下线（SDOWN）。</p>
<p>####### 客观下线<br>客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断，并且通过命令互相交流之后，得出的服务器下线判断，然后开启 failover。</p>
<p>只有在足够数量的 Sentinel 都将一个服务器标记为主观下线之后， 服务器才会被标记为客观下线（ODOWN）。</p>
<p>只有当 Master 被认定为客观下线时，才会发生故障迁移。</p>
<p>####### 仲裁<br>仲裁指的是配置文件中的 <code>quorum</code> 选项。</p>
<p>某个 Sentinel 先将 Master 节点标记为主观下线，然后会将这个判定通过 sentinel is-master-down-by-addr 命令询问其他 Sentinel 节点是否也同样认为该 addr 的 Master 节点要做主观下线。</p>
<p>最后当达成这一共识的 Sentinel 个数达到前面说的 <code>quorum</code> 设置的值时，该 Master 节点会被认定为客观下线并进行故障转移。</p>
<p><code>quorum</code> 的值一般设置为 Sentinel 个数的二分之一加 1，例如 3 个 Sentinel 就设置为 2。</p>
<h5 id="Sentinel工作原理"><a href="#Sentinel工作原理" class="headerlink" title="Sentinel工作原理"></a>Sentinel工作原理</h5><ol>
<li>每个 Sentinel 以每秒一次的频率向它所知的 Master，Slave 以及其他 Sentinel 节点发送一个 PING 命令；</li>
<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过配置文件 own-after-milliseconds 选项所指定的值，则这个实例会被 Sentinel 标记为主观下线；</li>
<li>如果一个 Master 被标记为主观下线，那么正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 是否真的进入主观下线状态；</li>
<li>当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认 Master 的确进入了主观下线状态，则 Master 会被标记为客观下线；</li>
<li>如果 Master 处于 ODOWN 状态，则投票自动选出新的主节点。将剩余的从节点指向新的主节点继续进行数据复制；</li>
<li>在正常情况下，每个 Sentinel 会以每 10 秒一次的频率向它已知的所有 Master，Slave 发送 INFO 命令；当 Master 被 Sentinel 标记为客观下线时，Sentinel 向已下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次；</li>
<li>若没有足够数量的 Sentinel 同意 Master 已经下线，Master 的客观下线状态就会被移除。若 Master 重新向 Sentinel 的 PING 命令返回有效回复，Master 的主观下线状态就会被移除。</li>
</ol>
<h5 id="哨兵模式的优缺点"><a href="#哨兵模式的优缺点" class="headerlink" title="哨兵模式的优缺点"></a>哨兵模式的优缺点</h5><h6 id="哨兵模式的优点"><a href="#哨兵模式的优点" class="headerlink" title="哨兵模式的优点"></a>哨兵模式的优点</h6><ul>
<li>哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都有；</li>
<li>主从可以自动切换，系统更健壮，可用性更高；</li>
<li>Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
</ul>
<h6 id="哨兵模式的缺点"><a href="#哨兵模式的缺点" class="headerlink" title="哨兵模式的缺点"></a>哨兵模式的缺点</h6><ul>
<li>主从切换需要时间，会丢失数据；</li>
<li>还是没有解决主节点写的压力；</li>
<li>主节点的写能力，存储能力受到单机的限制；</li>
<li>动态扩容困难复杂，对于集群，容量达到上限时在线扩容会变得很复杂。</li>
</ul>
<h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h4><p>假设上千万、上亿用户同时访问 Redis，QPS 达到 10 万+。这些请求过来，<strong>单机</strong> Redis 直接就挂了。系统的瓶颈就出现在 Redis 单机问题上，此时我们可以通过<strong>主从复制</strong>解决该问题，实现系统的高并发。</p>
<p>主从模式中，当主节点宕机之后，从节点是可以作为主节点顶上来继续提供服务，但是需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。于是，在 Redis 2.8 版本开始，引入了<strong>哨兵</strong>（Sentinel）这个概念，在<strong>主从复制</strong>的基础上，哨兵实现了<strong>自动化故障恢复</strong>。</p>
<p>哨兵模式中，单个节点的写能力，存储能力受到单机的限制，动态扩容困难复杂。于是，Redis 3.0 版本正式推出 <strong>Redis Cluster 集群</strong>模式，有效地解决了 Redis 分布式方面的需求。Redis Cluster 集群模式具有<strong>高可用、可扩展性、分布式、容错</strong>等特性。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_8.png"></p>
<p>Redis Cluster 采用无中心结构，<strong>每个节点都可以保存数据和整个集群状态</strong>，每个节点都和其他所有节点连接。</p>
<p>Cluster 一般由多个节点组成，节点数量至少为 6 个才能保证组成完整高可用的集群，其中三个为主节点，三个为从节点。</p>
<p>三个主节点会分配<strong>槽</strong>，处理客户端的命令请求，而从节点可用在主节点故障后，顶替主节点。</p>
<p>如上图所示，该集群中包含 6 个 Redis 节点，3 主 3 从，分别为 M1，M2，M3，S1，S2，S3。</p>
<p>除了主从 Redis 节点之间进行数据复制外，所有 Redis 节点之间采用 <strong>Gossip 协议</strong>进行通信，交换维护节点元数据信息。</p>
<p>总结下来就是：读请求分配给 Slave 节点，写请求分配给 Master，数据同步从 Master 到 Slave 节点。</p>
<h5 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h5><p>单机、主从、哨兵的模式数据都是存储在一个节点上，其他节点进行数据的复制。</p>
<p>而单个节点存储是存在上限的，集群模式就是把数据进行<strong>分片存储</strong>，当一个分片数据达到上限的时候，还可以分成多个分片。</p>
<p>Redis Cluster 采用<strong>虚拟哈希槽分区</strong>，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：HASH_SLOT = CRC16(key) % 16384。</p>
<p>每一个节点负责维护一部分槽以及槽所映射的键值数据。</p>
<p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_9.png"></p>
<p>Redis Cluster 提供了灵活的节点扩容和缩容方案。在不影响集群对外服务的情况下，可以为集群添加节点进行扩容也可以下线部分节点进行缩容。</p>
<p>可以说，槽是 Redis Cluster 管理数据的基本单位，集群伸缩就是槽和数据在节点之间的移动。</p>
<p>简单的理解就是：扩容或缩容以后，槽需要重新分配，数据也需要重新迁移，但是服务不需要下线。</p>
<p>假如，这里有 3 个节点的集群环境如下：</p>
<ul>
<li>节点 A 哈希槽范围为 0 ~ 5500；</li>
<li>节点 B 哈希槽范围为 5501 ~ 11000；</li>
<li>节点 C 哈希槽范围为 11001 ~ 16383。</li>
</ul>
<p>此时，我们如果要存储数据，按照 Redis Cluster 哈希槽的算法，假设结果是： CRC16(key) % 16384 = 6782。 那么就会把这个 key 的存储分配到 B 节点。此时连接 A、B、C 任何一个节点获取 key，都会这样计算，最终通过 B 节点获取数据。</p>
<p>假如这时我们新增一个节点 D，Redis Cluster 会从各个节点中拿取一部分 Slot 到 D 上，比如会变成这样：</p>
<ul>
<li>节点 A 哈希槽范围为 1266 ~ 5500；</li>
<li>节点 B 哈希槽范围为 6827 ~ 11000；</li>
<li>节点 C 哈希槽范围为 12288 ~ 16383；</li>
<li>节点 D 哈希槽范围为 0 ~ 1265，5501 ~ 6826，11001 ~ 12287</li>
</ul>
<p>这种特性允许在集群中轻松地添加和删除节点。</p>
<p>同样的如果我想删除节点 D，只需要将节点 D 的哈希槽移动到其他节点，当节点是空时，便可完全将它从集群中移除。</p>
<h5 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h5><p>Redis Cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点复制主节点数据备份，当这个主节点挂掉后，就会通过这个主节点的从节点选取一个来充当主节点，从而保证集群的高可用。</p>
<p>回到刚才的例子中，集群有 A、B、C 三个主节点，如果这 3 个节点都没有对应的从节点，如果 B 挂掉了，则集群将无法继续，因为我们不再有办法为 5501 ~ 11000 范围内的哈希槽提供服务。</p>
<p>所以我们在创建集群的时候，一定要为每个主节点都添加对应的从节点。比如，集群包含主节点 A、B、C，以及从节点 A1、B1、C1，那么即使 B 挂掉系统也可以继续正确工作。</p>
<p>因为 B1 节点属于 B 节点的子节点，所以 Redis 集群将会选择 B1 节点作为新的主节点，集群将会继续正确地提供服务。当 B 重新开启后，它就会变成 B1 的从节点。但是请注意，如果节点 B 和 B1 同时挂掉，Redis Cluster 就无法继续正确地提供服务了。</p>
<h5 id="Redis-Cluster优缺点"><a href="#Redis-Cluster优缺点" class="headerlink" title="Redis Cluster优缺点"></a>Redis Cluster优缺点</h5><h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><ul>
<li>无中心架构；</li>
<li>可扩展性，数据按照 Slot 存储分布在多个节点，节点间数据共享，节点可动态添加或删除，可动态调整数据分布；</li>
<li>高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本。</li>
<li>实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升。</li>
</ul>
<h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><ul>
<li>数据通过异步复制，<strong>无法保证数据强一致性</strong>；</li>
<li>集群环境搭建复杂，不过基于 Docker 的搭建方案会相对简单。</li>
</ul>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"><i class="fa fa-chevron-left">  </i><span>数据库MySQL系列之分区分片分库分表</span></a></div><div class="next-post pull-right"><a href="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"><span>Redis底层存储结构之用户数据结构存储模式详解</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '83850031ee87c27765eb',
  clientSecret: '6c5e13a8b6670d5bfa85ba548ba3570cae29e671',
  repo: 'blob-comment',
  owner: 'hepeng0',
  admin: 'hepeng0',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By 何鹏 [smile.hepeng@qq.com]</div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>