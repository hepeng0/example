<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="网络是怎么连接的-浏览器输入一个网址的全过程"><meta name="keywords" content="网络协议"><meta name="author" content="何鹏 [smile.hepeng@qq.com]"><meta name="copyright" content="何鹏 [smile.hepeng@qq.com]"><title>网络是怎么连接的-浏览器输入一个网址的全过程 | 沉默者</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><link rel="alternate" href="/atom.xml" title="沉默者" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%94%9F%E6%88%90%E6%B6%88%E6%81%AF-%E2%80%93-%E6%8E%A2%E7%B4%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E9%83%A8"><span class="toc-number">1.</span> <span class="toc-text">浏览器生成消息 – 探索浏览器内部</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%88%87%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%BC%80%E5%A7%8B"><span class="toc-number">1.1.</span> <span class="toc-text">一切从浏览器中输入网址开始</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A6%81%E5%85%88%E8%A7%A3%E6%9E%90URL"><span class="toc-number">1.1.1.</span> <span class="toc-text">浏览器要先解析URL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90HTTP%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF"><span class="toc-number">1.1.2.</span> <span class="toc-text">生成HTTP请求消息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9F%A5%E8%AF%A2Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84IP%E5%9C%B0%E5%9D%80"><span class="toc-number">1.2.</span> <span class="toc-text">向DNS服务器查询Web服务器的IP地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">DNS解析器的内部原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E4%B8%96%E7%95%8CDNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%A7%E6%8E%A5%E5%8A%9B"><span class="toc-number">1.2.2.</span> <span class="toc-text">全世界DNS服务器大接力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%BC%93%E5%AD%98%E5%8A%A0%E5%BF%ABDNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%93%8D%E5%BA%94"><span class="toc-number">1.2.3.</span> <span class="toc-text">通过缓存加快DNS服务器的响应</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">1.3.</span> <span class="toc-text">委托协议栈发送消息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">收发数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E7%94%B5%E4%BF%A1%E5%8F%B7%E4%BC%A0%E8%BE%93TCP-IP-%E2%80%93-%E6%8E%A2%E7%B4%A2%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%92%8C%E7%BD%91%E5%8D%A1"><span class="toc-number">2.</span> <span class="toc-text">用电信号传输TCP&#x2F;IP – 探索协议栈和网卡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">2.1.</span> <span class="toc-text">创建套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">2.1.1.</span> <span class="toc-text">什么是套接字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E7%94%A8Socket%E5%BA%93%E6%97%B6%EF%BC%8C%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.1.2.</span> <span class="toc-text">浏览器调用Socket库时，协议栈如何工作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">连接服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">什么是连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">2.2.2.</span> <span class="toc-text">连接的目的</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E5%BF%85%E8%A6%81%E7%9A%84%E4%BF%A1%E6%81%AF%EF%BC%88%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%8CIP%EF%BC%89%E7%BB%99%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">传递必要的信息（端口号，IP）给协议栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A9%E9%80%9A%E4%BF%A1%E5%8F%8C%E6%96%B9%E8%8E%B7%E5%8F%96%E5%AF%B9%E6%96%B9%E7%9A%84%E9%80%9A%E4%BF%A1%E5%BF%85%E8%A6%81%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">让通信双方获取对方的通信必要的信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E4%BA%8E%E5%AD%98%E6%94%BE%E4%BF%A1%E6%81%AF%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">创建用于存放信息的内存空间</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%B4%A3%E4%BF%9D%E5%AD%98%E6%8E%A7%E5%88%B6%E4%BF%A1%E6%81%AF%E7%9A%84%E5%A4%B4%E9%83%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">负责保存控制信息的头部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E9%99%85%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.4.</span> <span class="toc-text">连接操作的实际过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE-1"><span class="toc-number">2.3.</span> <span class="toc-text">收发数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8ETCP%E7%9A%84%E4%BA%A4%E4%BA%92%E2%80%93%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%86%E6%95%B0%E6%8D%AE%E5%A7%94%E6%89%98%E7%BB%99%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-number">2.3.1.</span> <span class="toc-text">应用程序与TCP的交互–浏览器将数据委托给协议栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%97%B6%E6%9C%BA"><span class="toc-number">2.3.2.</span> <span class="toc-text">协议栈发送数据时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.3.</span> <span class="toc-text">TCP发送数据机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%86%E5%8C%85"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">拆包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E8%BF%87ACK%E5%8F%B7%E7%A1%AE%E8%AE%A4%E7%BD%91%E7%BB%9C%E5%8C%85%E5%B7%B2%E6%94%B6%E5%88%B0-%E2%80%93-TCP%E7%9A%84%E6%A3%80%E9%94%99%E7%A1%AE%E8%AE%A4"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">通过ACK号确认网络包已收到 – TCP的检错确认</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TCP%E7%9A%84%E9%94%99%E8%AF%AF%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">TCP的错误补偿机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%9A%84%E7%BD%91%E7%BB%9C%E9%94%99%E8%AF%AF%E6%A3%80%E6%B5%8B%E5%92%8C%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.4.</span> <span class="toc-text">详细的网络错误检测和补偿机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E7%BD%91%E7%BB%9C%E5%8C%85%E5%B9%B3%E5%9D%87%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4%E8%B0%83%E6%95%B4ACK%E5%8F%B7%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4-%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">根据网络包平均往返时间调整ACK号等待时间-超时时间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AA%97%E5%8F%A3%E6%8F%90%E9%AB%98%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E6%95%88%E7%8E%87"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">使用窗口提高网络传输效率</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%B8%A6%E6%9D%A5%E6%96%B0%E9%97%AE%E9%A2%98-%E8%B6%85%E8%BF%87%E5%A4%84%E7%90%86%E8%83%BD%E5%8A%9B-%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.4.2.1.</span> <span class="toc-text">滑动窗口带来新问题: 超过处理能力 及其解决方案</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%B8%A6%E6%9D%A5%E6%96%B0%E9%97%AE%E9%A2%98%EF%BC%9A-%E8%BF%94%E5%9B%9EACK%E5%8F%B7%E5%92%8C%E6%9B%B4%E6%96%B0%E7%AA%97%E5%8F%A3%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">2.3.4.2.2.</span> <span class="toc-text">滑动窗口带来新问题： 返回ACK号和更新窗口的时机</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6HTTP%E5%93%8D%E5%BA%94%E6%B6%88%E6%81%AF"><span class="toc-number">2.3.5.</span> <span class="toc-text">接收HTTP响应消息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">协议栈接收数据的具体操作过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%AD%E5%BC%80%E5%B9%B6%E5%88%A0%E9%99%A4%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">2.4.</span> <span class="toc-text">从服务器断开并删除套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.4.1.</span> <span class="toc-text">断开连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">2.4.2.</span> <span class="toc-text">删除套接字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E4%B8%8E%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%9A%84%E5%8C%85%E6%94%B6%E5%8F%91%E6%93%8D%E4%BD%9C"><span class="toc-number">2.5.</span> <span class="toc-text">IP与以太网的包收发操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E5%A4%B4%E9%83%A8%E4%B8%8EMAC%E5%A4%B4%E9%83%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">IP头部与MAC头部</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E6%94%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E6%A6%82%E8%A7%88"><span class="toc-number">2.5.2.</span> <span class="toc-text">包收发操作概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%8C%85%E5%90%AB%E6%8E%A5%E6%94%B6%E6%96%B9IP%E5%9C%B0%E5%9D%80%E7%9A%84IP%E5%A4%B4%E9%83%A8-IP%E6%A8%A1%E5%9D%97"><span class="toc-number">2.5.3.</span> <span class="toc-text">生成包含接收方IP地址的IP头部-IP模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%BB%A5%E5%A4%AA%E7%BD%91%E7%94%A8%E7%9A%84MAC%E5%8D%8F%E8%AE%AE-IP%E6%A8%A1%E5%9D%97"><span class="toc-number">2.5.4.</span> <span class="toc-text">生成以太网用的MAC协议-IP模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86IP%E5%8C%85%E8%BD%AC%E6%8D%A2%E6%88%90%E7%94%B5%E6%88%96%E8%80%85%E5%85%89%E4%BF%A1%E5%8F%B7%E5%8F%91%E9%80%81%E5%87%BA%E5%8E%BB-%E7%BD%91%E5%8D%A1"><span class="toc-number">2.5.5.</span> <span class="toc-text">将IP包转换成电或者光信号发送出去-网卡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E7%BD%91%E7%BB%9C%E5%8C%85%E5%86%8D%E5%8A%A03%E4%B8%AA%E6%8E%A7%E5%88%B6%E6%95%B0%E6%8D%AE-MAC%E6%A8%A1%E5%9D%97"><span class="toc-number">2.5.6.</span> <span class="toc-text">给网络包再加3个控制数据-MAC模块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%94%B6%E5%8F%91%E6%93%8D%E4%BD%9C"><span class="toc-number">2.6.</span> <span class="toc-text">UDP协议的收发操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E7%BD%91%E7%BA%BF%E5%88%B0%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87-%E2%80%93-%E6%8E%A2%E7%B4%A2%E9%9B%86%E7%BA%BF%E5%99%A8%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">从网线到网络设备 – 探索集线器、交换机和路由器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E5%9C%A8%E7%BD%91%E7%BA%BF%E5%92%8C%E9%9B%86%E7%BA%BF%E5%99%A8%E4%B8%AD%E4%BC%A0%E8%BE%93"><span class="toc-number">3.1.</span> <span class="toc-text">信号在网线和集线器中传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E5%8C%85%E8%BD%AC%E5%8F%91%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.</span> <span class="toc-text">交换机的包转发操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%85%E8%BD%AC%E5%8F%91%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.</span> <span class="toc-text">路由器的包转发操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E9%99%84%E5%8A%A0%E5%8A%9F%E8%83%BD"><span class="toc-number">3.4.</span> <span class="toc-text">路由器的附加功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%8E%A5%E5%85%A5%E7%BD%91%E8%BF%9B%E5%85%A5%E4%BA%92%E8%81%94%E7%BD%91%E5%86%85%E9%83%A8-%E2%80%93-%E6%8E%A2%E7%B4%A2%E6%8E%A5%E5%85%A5%E7%BD%91%E5%92%8C%E7%BD%91%E7%BB%9C%E8%BF%90%E8%90%A5%E5%95%86"><span class="toc-number">4.</span> <span class="toc-text">通过接入网进入互联网内部 – 探索接入网和网络运营商</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img2.baidu.com/it/u=928705063,3876627980&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg"></div><div class="author-info__name text-center">何鹏 [smile.hepeng@qq.com]</div><div class="author-info__description text-center">路漫漫其修远兮，吾将上下而求索</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">69</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">53</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默者</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">网络是怎么连接的-浏览器输入一个网址的全过程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-08-11</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA%E5%BC%80%E5%8F%91/">JAVA开发</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">10.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 29 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>网络是由很多计算机等设备相互连接组成的，因此在通信的过程中需要确定正确的通信对象，并将请求和响应发送给它们。</p>
<p>而请求和响应在传递的过程中可能会丢失或损坏。</p>
<p>我们需要一种机制，无论遇到任何情况都能够将请求和响应准确无误地发送给对方。</p>
<p>由于请求和响应都是由0和1组成的数字信息，所以可以说，我们需要的是一种<strong>能够将数字信息搬运到指定目的地的机制</strong>。</p>
<p>这种机制是由操作系统中的网络控制软件，以及交换机、路由器等设备分工合作来实现的。</p>
<p>它的基本思路是将数字信息分割成一个一个的小块，然后装入一些被称为“包”（Packet）的容器中来运送。</p>
<pre><code>包相当于信件或者包裹，而交换机和路由器则相当于邮局或快递公司的分拣处理区。包的头部存有目的地等控制信息，通过许多交换机和路由器的接力，就可以根据控制信息对这些包进行分拣，然后将它们一步一步地搬运到目的地
</code></pre>
<p>这个负责搬运数字信息的机制，再加上浏览器和Web服务器这些网络应用程序，这两部分就组成了网络。</p>
<h2 id="浏览器生成消息-–-探索浏览器内部"><a href="#浏览器生成消息-–-探索浏览器内部" class="headerlink" title="浏览器生成消息 – 探索浏览器内部"></a>浏览器生成消息 – 探索浏览器内部</h2><h3 id="一切从浏览器中输入网址开始"><a href="#一切从浏览器中输入网址开始" class="headerlink" title="一切从浏览器中输入网址开始"></a>一切从浏览器中输入网址开始</h3><h4 id="浏览器要先解析URL"><a href="#浏览器要先解析URL" class="headerlink" title="浏览器要先解析URL"></a>浏览器要先解析URL</h4><p>实际上，浏览器本身是一个具备多种客户端功能的综合性客户端软件，因此它需要一些东西来判断应该使用其中哪种功能来访问相应的数据，URL也就有了各种不同的格式。</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img.png" alt="URL的各种协议"></p>
<p>我们根据HTTP的规格，对URL进行拆分，就可以得到浏览器解析URL的过程：</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_1.png" alt="Web浏览器解析URL过程"></p>
<h4 id="生成HTTP请求消息"><a href="#生成HTTP请求消息" class="headerlink" title="生成HTTP请求消息"></a>生成HTTP请求消息</h4><p>对URL进行解析之后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息来生成HTTP请求消息了。</p>
<p>实际上，HTTP消息在格式上是有严格规定的，因此浏览器和Web服务器会按照规定的格式来生成请求消息。</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_2.png" alt="HTTP消息格式"></p>
<h3 id="向DNS服务器查询Web服务器的IP地址"><a href="#向DNS服务器查询Web服务器的IP地址" class="headerlink" title="向DNS服务器查询Web服务器的IP地址"></a>向DNS服务器查询Web服务器的IP地址</h3><p>对于DNS服务器，我们的计算机上一定有相应的DNS客户端（称为DNS解析器），根据域名查询IP地址时，浏览器会使用Socket库中的解析器。</p>
<p>调用解析器后，解析器会向DNS服务器发送查询消息，然后DNS服务器会返回响应消息。响应消息中包含查询到的IP地址，解析器会取出IP地址，并将其写入浏览器指定的内存地址中。</p>
<p>浏览器在向Web服务器发送消息时，只要从该内存地址取出IP地址，并将它与HTTP请求消息一起交给操作系统就可以了。</p>
<h4 id="DNS解析器的内部原理"><a href="#DNS解析器的内部原理" class="headerlink" title="DNS解析器的内部原理"></a>DNS解析器的内部原理</h4><ul>
<li>浏览器调用解析器</li>
<li>浏览器对于程序被暂停，Socket库中的解析器开始运行，完成应用程序委托的操作（控制流程转移）；</li>
<li>当控制流程转移到解析器后，解析器会生成要发送给DNS服务器的查询消息；</li>
<li>委托给操作系统内部的协议栈来执行消息发送（解析器本身也不具备使用网络收发数据的功能）；</li>
<li>解析器调用协议栈后，控制流程会再次转移，协议栈会执行发送消息的操作，然后通过网卡将消息发送给DNS服务器；<ul>
<li>DNS服务器地址在TCP/IP事先已经设置完成</li>
</ul>
</li>
<li>协议栈将DNS服务器返回信息传递给解析器；</li>
<li>解析器取出IP地址写入应用程序指定内存中；</li>
<li>应用程序从内存中取出地址，委托协议栈发送消息。</li>
</ul>
<h4 id="全世界DNS服务器大接力"><a href="#全世界DNS服务器大接力" class="headerlink" title="全世界DNS服务器大接力"></a>全世界DNS服务器大接力</h4><p>DNS服务器会从域名与IP地址的对照表中查找相应的记录，并返回IP地址。 然而，互联网中存在着不计其数的服务器，将这些服务器的信息全部保存在一台DNS服务器中是不可能的，因此一定会出现在DNS服务器中找不到要查询的信息的情况。</p>
<p>因此，我们需要将信息分布保存在多台DNS服务器中，这些DNS服务器多次相互配合接力，从而找到要查询的信息。</p>
<ul>
<li>DNS服务器中的所有信息都是按照域名以分层次的结构来保存的<ul>
<li>用句点分隔</li>
<li>越靠右的位置层级越高</li>
</ul>
</li>
<li>具有层次结构的域名信息会注册到DNS服务器中，而每个域都是作为一个整体来处理的<ul>
<li><strong>一个域的信息是作为一个整体存放在DNS服务器中的</strong>，不能将一个域拆开来存放在多台DNS服务器中。</li>
<li>每个域的信息都存放在相应层级的DNS服务器中。</li>
</ul>
</li>
<li>互联网中所有的域都是由更上层的域分配而来的，类似于操作系统中父子进程的关系。</li>
</ul>
<p>问题的关键在于如何找到我们要访问的Web服务器的信息归哪一台DNS服务器管。</p>
<p>原理如下：</p>
<ol>
<li>将负责管理下级域的DNS服务器的IP地址注册到它们的上级DNS服务器中</li>
<li>然后上级DNS服务器的IP地址再注册到更上一级的DNS服务器中</li>
</ol>
<p>具体操作如下：</p>
<ol>
<li>客户端访问最近的一台DNS服务器（这台服务器在客户端的TCP/IP设置中就有填写）</li>
<li>如果最近的那台DNS服务器中没有存放目标服务器对应的信息，我们就从顶层开始向下找，将查询消息转发给根域DNS服务器</li>
<li>然后根服务器开始一层一层往下找，依次类推，就能找到对应目标服务器了</li>
<li>最后目标服务器将对应的IP地址作为响应消息发回给客户端</li>
</ol>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_3.png"></p>
<p>在互联网中，最顶级的域叫做<strong>根域</strong>，没有自己的名字所以一般被省略。</p>
<ul>
<li>如果要明确表示根域，应该像<a target="_blank" rel="noopener" href="http://www.lab.glasscom.com.这样在域名的最后再加上一个句点,而这个最后的句点就代表根域/">www.lab.glasscom.com．这样在域名的最后再加上一个句点，而这个最后的句点就代表根域</a></li>
<li>根域的DNS服务器信息保存在互联网中所有的DNS服务器中，这样一来，任何DNS服务器就都可以找到并访问根域DNS服务器，我们就可以从根域开始一路往下顺藤摸瓜找到任意一个域的DNS服务器。</li>
</ul>
<h4 id="通过缓存加快DNS服务器的响应"><a href="#通过缓存加快DNS服务器的响应" class="headerlink" title="通过缓存加快DNS服务器的响应"></a>通过缓存加快DNS服务器的响应</h4><p>DNS服务器有一个缓存功能，如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。</p>
<p>这个缓存机制中有一点需要注意，那就是信息被缓存后，原本的注册信息可能会发生改变，这时缓存中的信息就有可能是不正确的。</p>
<p>因此，DNS服务器中保存的信息都设置有一个有效期。而且，在对查询进行响应时，DNS服务器也会告知客户端这一响应的结果是来自缓存中还是来自负责管理该域名的DNS服务器。</p>
<h3 id="委托协议栈发送消息"><a href="#委托协议栈发送消息" class="headerlink" title="委托协议栈发送消息"></a>委托协议栈发送消息</h3><h4 id="收发数据"><a href="#收发数据" class="headerlink" title="收发数据"></a>收发数据</h4><p>协议栈通过调用Socket库中程序组件完成发送数据操作</p>
<ul>
<li>但这些程序组件仅充当了一个桥梁，并不执行任何实质性的操作，应用程序的委托内容最终会被原原本本地传递给协议栈</li>
</ul>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_4.png"></p>
<ul>
<li>创建客户端和服务器端的套接字（创建套接字阶段）<ol>
<li>调用Socket库中的socket程序组件创建套接字，并返回一个描述符。</li>
<li>同一时间可能有多个程序在利用套接字进行信息传输，识别套接字的方法就是描述符。</li>
</ol>
</li>
<li>客户端将管道连接到服务器端的套接字上（连接阶段）<ul>
<li>调用Socket库中的名为connect的程序组件，连接时需要指定描述符、服务器IP地址和端口号三个参数<ul>
<li>描述符是用来在一台计算机内部识别套接字的机制，是对自身的概念；</li>
<li>端口号是用来让通信的另一方能够识别出自身套接字的机制，是对外部设备的概念。</li>
</ul>
</li>
<li>当双方的套接字连接起来之后，通信准备就完成了。</li>
</ul>
</li>
<li>收发数据（通信阶段）<ul>
<li>依赖Socket库的write程序组件将要传输的数据送入套接字，数据就会被发送到对方的套接字中。</li>
<li>依赖Socket库的read程序组件委托协议栈来完成接收信息的操作，使用read时需要指定存放数据的缓冲区地址。</li>
<li>服务器端与客户端的收发数据操作同理。</li>
</ul>
</li>
<li>断开并删除套接字（断开阶段）<ul>
<li>Socket库中的close程序组件断开连接，断开时可以由客户端或服务器任意一方发起。</li>
<li>套接字之间的管道被断开，套接字也会被删除。</li>
<li>Web使用的HTTP协议规定，Web服务器发送完响应消息后，主动调用close断开连接。接下来浏览器调用read执行接收数据操作时，read会告知浏览器收发数据操作已结束，连接已经断开，于是户端的套接字也会执行close进入断开阶段。</li>
<li>后来人们又设计出了能够在一次连接中收发多个请求和响应的方法，在这种情况下，当所有数据都请求完成后，浏览器会主动触发断开连接的操作</li>
</ul>
</li>
</ul>
<h2 id="用电信号传输TCP-IP-–-探索协议栈和网卡"><a href="#用电信号传输TCP-IP-–-探索协议栈和网卡" class="headerlink" title="用电信号传输TCP/IP – 探索协议栈和网卡"></a>用电信号传输TCP/IP – 探索协议栈和网卡</h2><p>我们已经从浏览器视角看到了HTTP消息生成和委托发送流程，接下来，我们将视角切换到协议栈内部继续探索。</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_5.png" alt="TCP/IP软件采用分层结构"></p>
<p>上层会向下层逐层委派工作。</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_19.png" alt="TCP整体流程"></p>
<h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><h4 id="什么是套接字"><a href="#什么是套接字" class="headerlink" title="什么是套接字"></a>什么是套接字</h4><p>在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的IP地址、端口号、通信操作的进行状态等。</p>
<p>本来套接字就只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字的实体。</p>
<p>套接字的作用： </p>
<ul>
<li><strong>协议栈根据套接字中记录的控制信息来工作</strong>。 </li>
<li>协议栈在执行操作时需要参阅这些控制信息，类似于进程中PCB的控制作用一样，操作系统操作进程时需要这些信息。</li>
</ul>
<p>套接字的内容：</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_6.png"></p>
<h4 id="浏览器调用Socket库时，协议栈如何工作"><a href="#浏览器调用Socket库时，协议栈如何工作" class="headerlink" title="浏览器调用Socket库时，协议栈如何工作"></a>浏览器调用Socket库时，协议栈如何工作</h4><p>无论是发送请求消息，还是建立连接，浏览器本身不做这些工作而委托给协议栈完成，浏览器通过Socket中的程序组件来完成委托。</p>
<ol>
<li>创建套接字<ul>
<li>协议栈首先会分配用于存放一个套接字所需的内存空间</li>
<li>然后向其中写入初始状态</li>
</ul>
</li>
<li>将创建的套接字描述符告知应用程序<ul>
<li>应用程序在向协议栈进行收发数据委托时就需要提供这个描述符（相当于一个指针，不需要每次都传递详细信息）</li>
</ul>
</li>
</ol>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_7.png" alt="消息收发操作"></p>
<h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><h4 id="什么是连接"><a href="#什么是连接" class="headerlink" title="什么是连接"></a>什么是连接</h4><p>客户端和服务器两边都建立好套接字后，连接就是在两个套接字间建立一条管道的过程。</p>
<h4 id="连接的目的"><a href="#连接的目的" class="headerlink" title="连接的目的"></a>连接的目的</h4><h5 id="传递必要的信息（端口号，IP）给协议栈"><a href="#传递必要的信息（端口号，IP）给协议栈" class="headerlink" title="传递必要的信息（端口号，IP）给协议栈"></a>传递必要的信息（端口号，IP）给协议栈</h5><ul>
<li>套接字刚刚创建完成的时候，里面并没有存放任何数据，也不知道通信的对象是谁。</li>
<li>浏览器可以根据网址来查询服务器的IP地址，而且根据规则也知道应该使用80号端口，但此时也只有浏览器知道这些信息，协议栈是不知道的。</li>
<li>因此，我们需要把服务器的IP地址和端口号等信息告知协议栈。</li>
</ul>
<h5 id="让通信双方获取对方的通信必要的信息"><a href="#让通信双方获取对方的通信必要的信息" class="headerlink" title="让通信双方获取对方的通信必要的信息"></a>让通信双方获取对方的通信必要的信息</h5><p>服务器上也会创建套接字，客户端在发起请求时一般是用户指定通信对方的IP和端口，必要信息还是有的，而服务器完全什么都没有。</p>
<p>于是，我们需要让客户端向服务器告知必要的信息。</p>
<p>连接的本质：<strong>通信双方交换控制信息</strong></p>
<h5 id="创建用于存放信息的内存空间"><a href="#创建用于存放信息的内存空间" class="headerlink" title="创建用于存放信息的内存空间"></a>创建用于存放信息的内存空间</h5><p>当执行数据收发操作时，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为<strong>缓冲区</strong>，它也是在连接操作的过程中分配的。</p>
<h4 id="负责保存控制信息的头部"><a href="#负责保存控制信息的头部" class="headerlink" title="负责保存控制信息的头部"></a>负责保存控制信息的头部</h4><p>连接的控制信息大体上可以区分为两类：</p>
<ol>
<li>客户端和服务器相互联络时交换的控制信息 – 头部中记录的信息。<ol>
<li>连接、收发和断开连接操作的整个通信过程中都需要，这些内容在TCP协议的规格中进行了定义（固定不变）。</li>
<li>这些信息会被添加在客户端与服务器之间传递的网络包的开头，我们有把他们称为头部信息（含TCP头部、MAC头部、IP头部等）。<br><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_8.png"></li>
</ol>
</li>
<li>用来控制协议栈操作的信息 – 保存在套接字（协议栈中的内存空间）中<ol>
<li>包含应用程序传递来的信息，从通信对象接收到的信息，收发数据操作的执行状态等信息。</li>
<li>套接字的控制信息和协议栈的程序本身其实是一体的，其内容仅自己可见，所以他的内容会根据协议栈本身实现方式不同而不同。<br><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_9.png"></li>
</ol>
</li>
</ol>
<h4 id="连接操作的实际过程"><a href="#连接操作的实际过程" class="headerlink" title="连接操作的实际过程"></a>连接操作的实际过程</h4><p>经典的网络问题： <strong>TCP/IP三次握手</strong></p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_10.png"></p>
<ol>
<li>第一次握手： 在TCP模块处创建表示连接控制信息的头部，然后发送出去</li>
</ol>
<ul>
<li>告诉服务器，客户端的IP/端口号等重要信息</li>
<li>客户端建立一个只含有控制信息的包，将包头中的SYN比特设置为1（表示请求连接）</li>
<li>通过TCP头部中的发送方和接收方端口号可以找到要连接的套接字 </li>
<li>IP模块执行网络包发送操作后，网络包就会通过网络到达服务器，服务端处理：  <ul>
<li>服务器上的IP模块会将接收到的数据传递给TCP模块 </li>
<li>TCP模块根据TCP头部中的信息找到端口号对应的套接字 </li>
<li>将信息写入对应的套接字中，并将状态改为正在连接</li>
</ul>
</li>
</ul>
<ol start="2">
<li>第二次握手： 服务器返回响应消息</li>
</ol>
<ul>
<li>和客户端一样，需要在TCP头部中设置发送方和接收方IP/端口号</li>
<li>将包头中SYN比特设置为1（表示接受连接），如果不接受，那么将RTS比特设置为1</li>
<li>还需要将ACK控制位设为1，表示确认收到请求。</li>
<li>网络包返回客户端，客户端处理：<ul>
<li>通过TCP头部的信息确认连接服务器的操作是否成功。如果SYN为1则表示连接成功。 </li>
<li>向套接字中写入服务器的IP地址、端口号等信息，将状态改为连接完毕</li>
</ul>
</li>
</ul>
<ol start="3">
<li>第三次握手： 客户端告诉服务器刚才的响应包已经收到<ul>
<li>需要将ACK比特设置为1</li>
</ul>
</li>
</ol>
<p>握手过程中的筛选过滤与超时重传机制(简单示例)：</p>
<ul>
<li>客户端给服务器发连接请求，SYN位设置为1，等待响应信息；</li>
<li>如果一段时间内，客户端没有收到响应消息，那么认为包丢失了，重新发送；</li>
<li>服务器每时每刻都有海量的信息吞吐量，我们需要对包进行一个合理的分类和筛选，比如说客户端等待连接的套接字，对于SYN不为1的包一概不接受。</li>
<li>客户端发送了连接请求的套接字只会接收ACK为1的包…</li>
</ul>
<h3 id="收发数据-1"><a href="#收发数据-1" class="headerlink" title="收发数据"></a>收发数据</h3><h4 id="应用程序与TCP的交互–浏览器将数据委托给协议栈"><a href="#应用程序与TCP的交互–浏览器将数据委托给协议栈" class="headerlink" title="应用程序与TCP的交互–浏览器将数据委托给协议栈"></a>应用程序与TCP的交互–浏览器将数据委托给协议栈</h4><ol>
<li>数据收发操作从应用程序调用write将要发送的数据（含数据长度）交给协议栈开始</li>
<li>协议栈并不关心应用程序传来的数据是什么内容。在协议栈看来，要发送的数据就是一定长度的二进制字节序列。</li>
</ol>
<h4 id="协议栈发送数据时机"><a href="#协议栈发送数据时机" class="headerlink" title="协议栈发送数据时机"></a>协议栈发送数据时机</h4><p>协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。</p>
<p>数据是由应用程序转交的，而不同应用程序在转交数据的实现上各有差异，有些程序会一次性传递所有的数据，有些程序则会逐字节或者逐行传递数据，协议栈无法控制。</p>
<p>如果一收到数据就马上发送出去，就可能会发送大量的小包，导致网络效率下降。为了保证网络效率，我们为将被发送的数据设置发送缓冲区，在数据积累到一定量时再发送出去。</p>
<p>确认发送时机:</p>
<ol>
<li>网络包所能容纳的数据长度 <ul>
<li>MTU：一个网络包的最大长度，以太网中一般为1500字节。</li>
<li>MSS：除去头部之后，一个网络包所能容纳的TCP数据的最大长度。<br><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_11.png"></li>
</ul>
</li>
<li>时间<ul>
<li>协议栈的内部有一个计时器，一定时间之后，就会把网络包发送出去，无论网络包是否达MSS的长度</li>
</ul>
</li>
<li>时间和网络包大小间关系的把握<ul>
<li>如果长度优先，那么网络的效率会提高，但可能会因为等待填满缓冲区而产生延迟；</li>
<li>相反地，如果时间优先，那么延迟时间会变少，但又会降低网络的效率。</li>
</ul>
</li>
<li>自定义发送时机<ul>
<li>协议栈也给应用程序保留了控制发送时机的余地，应用程序在发送数据时可以指定一些选项。</li>
</ul>
</li>
</ol>
<h4 id="TCP发送数据机制"><a href="#TCP发送数据机制" class="headerlink" title="TCP发送数据机制"></a>TCP发送数据机制</h4><h5 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h5><p>当HTTP请求消息的长度就超过一个网络包所能容纳的数据量时，发送缓冲区中的数据会被以MSS长度为单位进行拆分，拆分出来的每块数据会被放进单独的网络包中，然后交给IP模块来执行发送数据的操作。</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_12.png"></p>
<p>TCP模块在拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块数据时，将算好的字节数写在TCP头部中，“序号”字段就是派在这个用场上的。</p>
<p>然后，发送数据的长度也需要告知接收方，不过这个并不是放在TCP头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度。</p>
<h5 id="通过ACK号确认网络包已收到-–-TCP的检错确认"><a href="#通过ACK号确认网络包已收到-–-TCP的检错确认" class="headerlink" title="通过ACK号确认网络包已收到 – TCP的检错确认"></a>通过ACK号确认网络包已收到 – TCP的检错确认</h5><p>TCP具备确认对方是否成功收到网络包的功能，以及当对方没收到时进行重发的功能（即确保通信的稳定，可靠，UDP就不会），因此在发送网络包之后，接下来还需要进行确认操作。</p>
<p>实现机制：段号 + ACK号</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_13.png" alt="TCP头部"></p>
<p>如果确认没有遗漏，接收方会将到目前为止接收到的数据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入TCP头部的ACK号中发送给发送方。</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_14.png"></p>
<p>总结来说：</p>
<ul>
<li>发送方将数据包分片包好，并发送出去，然后进入等待状态，等待接收方发出的确认信息，如果超过时间没有收到则认为包丢失，重新发送；</li>
<li>而接收方收到信息后，会根据上一轮收到的数据计算出”相应的序号“，然后在收到当前数据包时将本地序号与包头中序号信息对比以确定数据收发是否正常；如果正常再发送确认信息给发送方（ACK号）。</li>
</ul>
<p>注： </p>
<ul>
<li>在实际的通信中，序号用随机数计算出一个初始值（不用1开始防止攻击），在三次握手中的第一次，发送方将SUN控制位设置为1发送给服务器时，将设置的序号字段的值也一并传过去了。</li>
<li>TCP数据收发是双向的，客户端和服务器双方都需要各自计算序号，因此双方需要在连接过程中互相告知自己计算的序号初始值。</li>
</ul>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_15.png" alt="数据双向传输时序号和ACK号的交互"></p>
<h5 id="TCP的错误补偿机制"><a href="#TCP的错误补偿机制" class="headerlink" title="TCP的错误补偿机制"></a>TCP的错误补偿机制</h5><p>TCP采用这样的方式确认对方是否收到了数据，在得到对方确认之前，发送过的包都会保存在发送缓冲区中。</p>
<p>如果对方没有返回某些包对应的ACK号，那么就重新发送这些包。有了这一机制，我们就不需要在其他地方对错误进行补救了。 </p>
<p>因此，网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。</p>
<p><strong>极端情况</strong>： 发生网络中断、服务器宕机等问题，那么无论TCP怎样重传都不管用。这种情况下，无论如何尝试都是徒劳，因此TCP会在尝试几次重传无效之后强制结束通信，并向应用程序报错。</p>
<h4 id="详细的网络错误检测和补偿机制"><a href="#详细的网络错误检测和补偿机制" class="headerlink" title="详细的网络错误检测和补偿机制"></a>详细的网络错误检测和补偿机制</h4><p>前面说的只是一些基本原理，实际上网络的错误检测和补偿机制非常复杂。</p>
<h5 id="根据网络包平均往返时间调整ACK号等待时间-超时时间"><a href="#根据网络包平均往返时间调整ACK号等待时间-超时时间" class="headerlink" title="根据网络包平均往返时间调整ACK号等待时间-超时时间"></a>根据网络包平均往返时间调整ACK号等待时间-超时时间</h5><p>网络的的错误检测和补偿机制是通过通信双方交换确认信息来实现的，若没有收到确认信息就重发，系统会设置一个计时器，到超过指定时间就会认为出现错误，触发补偿机制。</p>
<p>有一个很大的问题：</p>
<pre><code>当网络传输繁忙时就会发生拥塞，ACK号的返回会变慢，从而在没有出错的情况下触发补偿机制，这样的重传是多余的，ACK号的返回变慢大多是由于网络拥塞引起的，因此如果此时再出现很多多余的重传，那么更加加重了网络的负担，从而恶性循环。

这时我们就必须将等待时间设置得稍微长一点，但是并不是越长越好，如果等待时间过长，那么包的重传就会出现很大的延迟，也会导致网络速度变慢。
</code></pre>
<p>所以这里的一个关键问题在于如何把握这个判定包为丢失的等待时间。</p>
<pre><code>但是，这很不容易，网络包的传输速度是由很多因素决定的，比如距离，根据服务器物理距离的远近，ACK号的返回时间也会产生很大的波动，而且我们还必须考虑到拥塞带来的影响。
</code></pre>
<p>TCP采用了<strong>根据ACK号返回所需的时间动态调整等待时间</strong>的方法。</p>
<p>具体来说，TCP会在发送数据的过程中持续测量ACK号的返回时间：</p>
<ul>
<li>如果ACK号返回变慢，则相应延长等待时间；</li>
<li>如果ACK号马上就能返回，则相应缩短等待时间。</li>
</ul>
<h5 id="使用窗口提高网络传输效率"><a href="#使用窗口提高网络传输效率" class="headerlink" title="使用窗口提高网络传输效率"></a>使用窗口提高网络传输效率</h5><p>之前我们所说的网络包的收发模式一直是发送方先发然后什么也不做等待接收方的确认通知，然后发送方再发送下一个包。</p>
<p>大家会发现这样效率很低，于是人们引入了新的发送网络包的规则即：<strong>滑动窗口</strong>。</p>
<p>所谓滑动窗口，就是在发送一个包之后，不等待ACK号返回，而是直接发送后续的一系列包。这样一来，等待ACK号的这段时间就被有效利用起来了。</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_16.png"></p>
<h6 id="滑动窗口带来新问题-超过处理能力-及其解决方案"><a href="#滑动窗口带来新问题-超过处理能力-及其解决方案" class="headerlink" title="滑动窗口带来新问题: 超过处理能力 及其解决方案"></a>滑动窗口带来新问题: <code>超过处理能力</code> 及其解决方案</h6><p>如果不等返回ACK号就连续发送包，就有可能会出现发送包的频率超过接收方处理能力的情况。</p>
<p>接收方接收数据时，并不是直接将数据拿来用而是放在了一个缓冲区中，对于被拆分的数据，接收方还需要将数据块组装起来还原为原本的数据，最后这些接受的数据会被应用程序拿走。</p>
<p>如果数据到达的速率比处理这些数据并传递给应用程序的速率还要快，那么接收缓冲区中的数据就会越堆越多，最后就会溢出。缓冲区溢出之后，后面的数据就进不来了，因此接收方就收不到后面的包了，这就和中途出错的结果是一样的，也就意味着超出了接收方处理能力</p>
<p>解决方案：</p>
<p>接收方会通过TCP头部中的窗口字段将自己能接收的数据量告知发送方。这样一来，发送方就不会发送过多的数据，导致超出接收方的处理能力了，如图：</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_17.png"></p>
<h6 id="滑动窗口带来新问题：-返回ACK号和更新窗口的时机"><a href="#滑动窗口带来新问题：-返回ACK号和更新窗口的时机" class="headerlink" title="滑动窗口带来新问题： 返回ACK号和更新窗口的时机"></a>滑动窗口带来新问题： <code>返回ACK号和更新窗口的时机</code></h6><p>刚收到数据填入缓冲区时，没有必要每次都向发送方更新窗口大小，发送方在每次发送数据时减掉已发送的数据长度就可以自行计算出当前窗口的剩余长度。</p>
<p>需要更新的时机是：接收方从缓冲区中取出数据传递给应用程序的时候。 这个操作是接收方应用程序发出请求时才会进行的，而发送方不知道什么时候会进行这样的操作。</p>
<p>对于ACK号，接收方每收到一个包就需要向发送方分别发送一次ACK号，当程序拿走数据时又需要发送窗口更新的包。这样一来，接收方发给发送方的包就太多了，导致网络效率下降。</p>
<p>接收方在发送ACK号和窗口更新时，并不会马上把包发送出去，而是会等待一段时间，在这个过程中很有可能会出现其他的通知操作，这样就可以把两种通知合并在一个包里面发送了。</p>
<h4 id="接收HTTP响应消息"><a href="#接收HTTP响应消息" class="headerlink" title="接收HTTP响应消息"></a>接收HTTP响应消息</h4><p>发送HTTP请求消息后，浏览器还需要等待Web服务器返回响应消息。</p>
<p>接收操作也需要协议栈的参与。浏览器在委托协议栈发送请求消息之后，会调用read程序，来获取响应消息。</p>
<p>响应消息的返回还需要等待一段时间，但是浏览器程序不会阻塞在这里。 这时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起，等服务器返回的响应消息到达之后再继续执行接收操作，如此才能实现滑动窗口的机制提高传输效率。</p>
<h5 id="协议栈接收数据的具体操作过程"><a href="#协议栈接收数据的具体操作过程" class="headerlink" title="协议栈接收数据的具体操作过程"></a>协议栈接收数据的具体操作过程</h5><ol>
<li>检查数据块和TCP头部，判断是否发生错误，没有问题则返回ACK确认信息。</li>
<li>将数据暂存到接收缓冲区，将拆分的数据包还原为原始数据。</li>
<li>将数据交给应用程序</li>
<li>找到合适的时机向发送方发送窗口更新</li>
</ol>
<h3 id="从服务器断开并删除套接字"><a href="#从服务器断开并删除套接字" class="headerlink" title="从服务器断开并删除套接字"></a>从服务器断开并删除套接字</h3><h4 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h4><ul>
<li>理论上： 收发数据结束的时间点应该是应用程序判断所有数据都已经发送完毕的时候。 这时，数据发送完毕的一方会发起断开过程。</li>
<li>实际上： 不同的应用程序会选择不同的断开时机，这一判断是应用程序作出的，协议栈在设计上允许任何一方先发起断开过程。</li>
<li>具体流程：<br><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_18.png" alt="四次挥手"><ul>
<li>服务器一方调用Socket库中close组件</li>
<li>服务器的协议栈会生成包含断开信息的TCP头部，并发送给客户端。同时，服务器的套接字中也会记录下断开操作的相关信息(具体来说就是将控制位中的FIN比特设为1)</li>
<li>客户端收到FIN为1的TCP头部，标记自己的套接字进入断开操作状态</li>
<li>客户端会向服务器返回一个ACK号确认收到FIN为1的包，并且调用自身的close组件</li>
<li>服务器返回ACK号确认收到，至此客户端和服务器通信结束</li>
</ul>
</li>
</ul>
<h4 id="删除套接字"><a href="#删除套接字" class="headerlink" title="删除套接字"></a>删除套接字</h4><p>通信结束后，并不会马上删除套接字，而是<strong>等一段时间</strong>，等待这段时间是为了<strong>防止误操作</strong>。</p>
<pre><code>如果最后客户端返回的ACK号丢失了，这时，服务器没有接收到ACK号，可能会重发一次FIN。如果这时客户端的套接字已经删除了，那么套接字中保存的控制信息也就跟着消失了，套接字对应的端口号就会被释放出来。如果别的应用程序要创建套接字，新的套接字碰巧被分配了同一个端口号，而服务器重发的FIN正好到达，会怎么样呢？本来这个FIN是要发给刚刚删除的那个套接字的，但新套接字具有相同的端口号，于是这个FIN就会错误地跑到新套接字里面，新套接字就开始执行断开操作了。之所以不马上删除套接字，就是为了防止这样的误操作
</code></pre>
<p>至于具体等待多长时间，这和包重传的操作方式有关。</p>
<h3 id="IP与以太网的包收发操作"><a href="#IP与以太网的包收发操作" class="headerlink" title="IP与以太网的包收发操作"></a>IP与以太网的包收发操作</h3><h4 id="IP头部与MAC头部"><a href="#IP头部与MAC头部" class="headerlink" title="IP头部与MAC头部"></a>IP头部与MAC头部</h4><p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_21.png"></p>
<p>包是由头部和数据两部分构成的，头部包含目的地址等控制信息，头部后面就是委托方要发送给对方的数据。</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_20.png"></p>
<p>在子网概念中：</p>
<ul>
<li>IP协议根据目标地址判断下一个IP转发设备的位置（路由器）</li>
<li>子网中的以太网协议将包传输到下一个转发设备（集线器）</li>
</ul>
<p>因此，TCP/IP包包含如下两个头部：</p>
<ul>
<li>MAC头部（用于以太网协议）</li>
<li>IP头部（用于IP协议）</li>
</ul>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_22.png"></p>
<p>这两个头部分别具有不同的作用</p>
<ul>
<li>发送方将包的目的地，也就是要访问的服务器的IP地址写入IP头部中，IP协议通过这一地址找到下一个路由器的位置；</li>
<li>然后委托以太网协议将包传输过去，这是IP协议会查找下一个路由器的以太网地址(MAC地址)并写入MAC头部中；</li>
<li>由此，以太网协议就知道要将这个包发到哪一个路由器上了；</li>
<li>网络传输中会通过集线器，集线器维护了一张表，可以通过以太网头部记录的目的地（MAC地址）查出对应的传输方向。</li>
</ul>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_23.png" alt="IP网络包传输方式"></p>
<p>将IP和负责传输的网络分开，可以更好地根据需要使用各种通信技术。例如： 以太网的部分也可以替换成其他的东西，例如无线局域网、ADSL、FTTH等，它们都可以替代以太网的角色帮助IP协议来传输网络包。</p>
<h4 id="包收发操作概览"><a href="#包收发操作概览" class="headerlink" title="包收发操作概览"></a>包收发操作概览</h4><ol>
<li>TCP模块委托IP模块发送包的操作<ol>
<li>TCP模块在数据块前加上TCP头部，传递给IP模块</li>
<li>TCP模块指定通信对象地址</li>
</ol>
</li>
<li>IP模块收到委托后在前面加上包含控制信息的头部，病假封装好的包交给网络硬件（网卡）<ol>
<li>IP头部： 含IP地址</li>
<li>MAC头部： 含MAC地址</li>
</ol>
</li>
<li>传递给网卡的网络包是由一连串0和1组成的数字信息，网卡会将这些数字信息转换为电信号或光信号，并通过网线（或光纤）发送出去</li>
<li>然后这些信号就会到达集线器、路由器等转发设备，再由转发设备一步一步地送达接收方</li>
<li>包送达对方之后，对方会作出响应。<ol>
<li>接收的过程和发送的过程是相反的，信息先以电信号的形式从网线传输进来</li>
<li>然后由网卡将其转换为数字信息并传递给IP模块</li>
<li>接下来，IP模块会将MAC头部和IP头部后面的内容，也就是TCP头部加上数据块，传递给TCP模块。</li>
</ol>
</li>
<li>返回的包也会通过转发设备发送回来，然后我们需要接收这个包。</li>
</ol>
<p><em><strong>无论要收发的包是控制包还是数据包，IP对各种类型的包的收发操作都是相同的。</strong></em></p>
<h4 id="生成包含接收方IP地址的IP头部-IP模块"><a href="#生成包含接收方IP地址的IP头部-IP模块" class="headerlink" title="生成包含接收方IP地址的IP头部-IP模块"></a>生成包含接收方IP地址的IP头部-IP模块</h4><p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_24.png"><br><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_25.png"></p>
<ul>
<li>接收方IP地址： 通信对象的IP地址。</li>
<li>发送方IP地址： 判断发送所使用的网卡，并填写该网卡的IP地址。<br>  <img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_26.png" alt="通过路由表获取网卡示例"></li>
<li>协议号<ul>
<li>TCP: 06(十六进制)</li>
<li>UDP: 17(十六进制)</li>
</ul>
</li>
</ul>
<h4 id="生成以太网用的MAC协议-IP模块"><a href="#生成以太网用的MAC协议-IP模块" class="headerlink" title="生成以太网用的MAC协议-IP模块"></a>生成以太网用的MAC协议-IP模块</h4><p>生成了IP头部之后，接下来IP模块还需要在IP头部的前面加上MAC头部。</p>
<p>IP头部中的接收方IP地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，TCP/IP的这个思路是行不通的。</p>
<p>以太网在判断网络包目的地时和TCP/IP的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而MAC头部就是干这个用的。</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_27.png"></p>
<ul>
<li>以太类型：协议值</li>
<li>发送方MAC地址： MAC地址是在网卡生产时写入ROM里的，只要将这个值读取出来写入MAC头部就可以了</li>
<li>接收方MAC地址： IP模块根据路由表Gateway栏的内容判断应该把包发送给谁。<ul>
<li>通过ARP查询目标路由器的MAC地址： 通过广播方式对所有设备提问，并将结果放到ARP缓存</li>
</ul>
</li>
</ul>
<details><summary>以太网的基本知识</summary>

<p>可以认为具备这3个性质的网络就是以太网: </p>
<ul>
<li>将包发送到MAC头部的接收方MAC地址代表的目的地</li>
<li>用发送方MAC地址识别发送方</li>
<li>用以太类型识别包的内容。</li></ul></details>

<h4 id="将IP包转换成电或者光信号发送出去-网卡"><a href="#将IP包转换成电或者光信号发送出去-网卡" class="headerlink" title="将IP包转换成电或者光信号发送出去-网卡"></a>将IP包转换成电或者光信号发送出去-网卡</h4><p>负责执行这一操作的是网卡，但网卡也无法单独工作，要控制网卡还需要网卡驱动程序。</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_28.png" alt="网卡组成要素概念图"></p>
<ul>
<li>网卡的ROM中保存着全世界唯一的MAC地址，这是在生产网卡时写入的。</li>
<li>网卡中保存的MAC地址会由网卡驱动程序读取并分配给MAC模块。</li>
</ul>
<p>网卡驱动从IP模块获取包之后，会将其复制到网卡内的缓冲区中，然后向MAC模块发送发送包的命令。</p>
<h4 id="给网络包再加3个控制数据-MAC模块"><a href="#给网络包再加3个控制数据-MAC模块" class="headerlink" title="给网络包再加3个控制数据-MAC模块"></a>给网络包再加3个控制数据-MAC模块</h4><ol>
<li>MAC模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列<br><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_29.png"></li>
<li>MAC头部很容易被误解为是由网卡来处理的，实际上它是由TCP/IP软件来负责的。</li>
<li>接收方在收到信号时，遇到报头对应的波形就可以判断读取数据的时机。<br><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_30.png"><ul>
<li>每个包的包头都有报头和起始帧分界符（SFD），报头用来测定时机，SFD用来确定帧的起始位置。<br><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_31.png"></li>
<li>当信号连续为1或连续为0时，比特之间的界限就会消失，如果将时钟信号叠加进去，就可以判断出比特之间的界限了。<ul>
<li>但是这种方法存在问题：当距离较远，网线较长时，两条线路的长度会发生差异，数据信号和时钟信号的传输会产生时间差，时钟就会发生偏移。</li>
</ul>
</li>
<li>要解决这个问题，可以采用将数据信号和时钟信号叠加在一起的方法。</li>
</ul>
</li>
</ol>
<h3 id="UDP协议的收发操作"><a href="#UDP协议的收发操作" class="headerlink" title="UDP协议的收发操作"></a>UDP协议的收发操作</h3><p>为了实现传输可靠性，我们需要确认对方是否收到了我们发送的数据，如果没有还需要再发一遍。</p>
<p>要实现上面的要求，最简单的方法是数据全部发送完毕之后让接收方返回一个接收确认。</p>
<p>这样一来，如果没收到直接全部重新发送一遍就好了，根本不用像TCP一样要管理发送和确认的进度。</p>
<p>但是，如果漏掉了一个包就要全部重发一遍，怎么看都很低效。为了实现高效的传输，我们要避免重发已经送达的包，而是只重发那些出错的或者未送达的包。TCP之所以复杂，就是因为要实现这一点。</p>
<p>看一下下列情况，单个包的重发没有意义，TCP的设计就变得冗余:</p>
<ul>
<li>当数据很短，不用考虑那哪个包未达（只有一个包）；此外，可以把回复的数据当作确认数据。</li>
<li>无需重发数据，或者是重发了也没什么意义。</li>
</ul>
<p>UDP没有TCP的接收确认、窗口等机制，因此：</p>
<ul>
<li>在收发数据之前也不需要交换控制信息，也就是说不需要建立和断开连接的步骤，只要在从应用程序获取的数据前面加上UDP头部，然后交给IP进行发送就可以了。 </li>
<li>接收也很简单，只要根据IP头部中的接收方和发送方IP地址，以及UDP头部中的接收方和发送方端口号，找到相应的套接字并将数据交给相应的应用程序就可以了。</li>
</ul>
<p>因为UDP不像TCP一样会对包的送达状态进行监控，所以协议栈也不知道有没有发生错误。但这样并不会引发什么问题，因此出错时就收不到来自对方的回复，应用程序会注意到这个问题，并重新发送一遍数据。</p>
<p><img src="/2022/08/11/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/img_32.png" alt="UDP头部信息"></p>
<h2 id="从网线到网络设备-–-探索集线器、交换机和路由器"><a href="#从网线到网络设备-–-探索集线器、交换机和路由器" class="headerlink" title="从网线到网络设备 – 探索集线器、交换机和路由器"></a>从网线到网络设备 – 探索集线器、交换机和路由器</h2><h3 id="信号在网线和集线器中传输"><a href="#信号在网线和集线器中传输" class="headerlink" title="信号在网线和集线器中传输"></a>信号在网线和集线器中传输</h3><p>信号从计算机中流出之后，会在网线中经过集线器等设备前进，此时：</p>
<ul>
<li>信号是如何在网线和集线器传输的。</li>
<li>信号在传输过程中会衰减，还会受到噪声干扰而失真，如何抑制这些影响。</li>
</ul>
<h3 id="交换机的包转发操作"><a href="#交换机的包转发操作" class="headerlink" title="交换机的包转发操作"></a>交换机的包转发操作</h3><h3 id="路由器的包转发操作"><a href="#路由器的包转发操作" class="headerlink" title="路由器的包转发操作"></a>路由器的包转发操作</h3><h3 id="路由器的附加功能"><a href="#路由器的附加功能" class="headerlink" title="路由器的附加功能"></a>路由器的附加功能</h3><h2 id="通过接入网进入互联网内部-–-探索接入网和网络运营商"><a href="#通过接入网进入互联网内部-–-探索接入网和网络运营商" class="headerlink" title="通过接入网进入互联网内部 – 探索接入网和网络运营商"></a>通过接入网进入互联网内部 – 探索接入网和网络运营商</h2></div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">网络协议</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2022/07/19/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%E4%B9%8B%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%90%9E%E5%90%90%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"><span>高并发系统总结之如何设计一个高吞吐的系统概述</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By 何鹏 [smile.hepeng@qq.com]</div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>