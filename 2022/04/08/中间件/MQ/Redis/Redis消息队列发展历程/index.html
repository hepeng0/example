<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Redis消息队列发展历程"><meta name="keywords" content="MQ,Redis"><meta name="author" content="何鹏 [smile.hepeng@qq.com]"><meta name="copyright" content="何鹏 [smile.hepeng@qq.com]"><title>Redis消息队列发展历程 | 沉默者</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><link rel="alternate" href="/atom.xml" title="沉默者" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis1-0-List"><span class="toc-number">2.</span> <span class="toc-text">Redis1.0 - List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">List的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E7%9A%84%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84"><span class="toc-number">2.2.</span> <span class="toc-text">List的不足之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.</span> <span class="toc-text">List总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">2.3.1.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%B6%B3"><span class="toc-number">2.3.2.</span> <span class="toc-text">不足</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis2-0-Pub-Sub"><span class="toc-number">3.</span> <span class="toc-text">Redis2.0 - Pub&#x2F;Sub</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pubsub%E7%89%B9%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">pubsub特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pubsub%E7%9A%84%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84"><span class="toc-number">3.2.</span> <span class="toc-text">pubsub的不足之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pubsub%E6%80%BB%E7%BB%93"><span class="toc-number">3.3.</span> <span class="toc-text">pubsub总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%B6%B3-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">不足</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis5-0-stream"><span class="toc-number">4.</span> <span class="toc-text">Redis5.0 - stream</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stream%E7%89%B9%E6%80%A7"><span class="toc-number">4.1.</span> <span class="toc-text">stream特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stream%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-number">4.2.</span> <span class="toc-text">stream的不足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stream%E6%80%BB%E7%BB%93"><span class="toc-number">4.3.</span> <span class="toc-text">stream总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF-2"><span class="toc-number">4.3.1.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%B6%B3-2"><span class="toc-number">4.3.2.</span> <span class="toc-text">不足</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E6%9D%A5"><span class="toc-number">5.</span> <span class="toc-text">未来</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img2.baidu.com/it/u=928705063,3876627980&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg"></div><div class="author-info__name text-center">何鹏 [smile.hepeng@qq.com]</div><div class="author-info__description text-center">路漫漫其修远兮，吾将上下而求索</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">63</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">52</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">9</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默者</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">Redis消息队列发展历程</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-04-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"> 中间件</a><span class="post-meta__separator">|</span><span class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 18 分钟</span></span></div><div class="article-container" id="post-content"><p>文档说明： 转自<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/gCUT5TcCQRAxYkTJfTRjJw">阿里开发者-阿里巴巴官方技术号</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis是目前最受欢迎的kv类数据库，当然它的功能越来越多，早已不限定在kv场景，消息队列就是Redis中一个重要的功能。</p>
<p>Redis从2010年发布1.0版本就具备一个消息队列的雏形，随着10多年的迭代，其消息队列的功能也越来越完善，作为一个全内存的消息队列，适合应用与要求高吞吐、低延时的场景。</p>
<p>我们来盘一下Redis消息队列功能的发展历程，历史版本有哪些不足，后续版本是如何来解决这些问题的。</p>
<p><img src="/2022/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Redis/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/img.png"></p>
<h2 id="Redis1-0-List"><a href="#Redis1-0-List" class="headerlink" title="Redis1.0 - List"></a>Redis1.0 - List</h2><p>从广义上来讲消息队列就是一个队列的数据结构。</p>
<p>生产者从队列一端放入消息，消费者从另一端读取消息，消息保证先入先出的顺序。</p>
<p>一个本地的list数据结构就是一个进程维度的消息队列，它可以让模块A写入消息，模块B消费消息，做到模块A/B的解耦与异步化。</p>
<p>但想要做到应用级别的解耦和异步还需要一个消息队列的服务。</p>
<h3 id="List的特性"><a href="#List的特性" class="headerlink" title="List的特性"></a>List的特性</h3><p>Redis 1.0发布时就具备了list数据结构，应用A可以通过lpush写入消息，应用B通过rpop从队列中读取消息，每个消息只会被读取一次，而且是按照lpush写入的顺序读到。同时Redis的接口是并发安全的，可以同时有多个生产者向一个list中生产消息，多个消费者从list中读取消息。</p>
<p>这里还有个问题，消费者要如何知道list中有消息了，需要不断轮询去查询吗。</p>
<p>轮询无法保证消息被及时的处理，会增加延时，而且当list为空时，大部分轮询的请求都是无效请求，这种方式大量浪费了系统资源。</p>
<p>好在Redis有<strong>brpop接口</strong>，该接口有一个参数是超时时间，如果list为空，那么Redis服务端不会立刻返回结果，它会等待list中有新数据后在返回或是等待最多一个超时时间后返回空。</p>
<p>通过brpop接口实现了<strong>长轮询</strong>，该效果等同于服务端推送，消费者能立刻感知到新的消息，而且通过设置合理的超时时间，使系统资源的消耗降到很低。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">基于list完成消息的生产和消费</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">生产者生产消息msg1</span></span><br><span class="line">lpush listA msg1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">消费者读取到消息msg1</span></span><br><span class="line">rpop listA</span><br><span class="line">&quot;msg1&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">消费者阻塞式读取listA，如果有数据立刻返回，否则最多等待10秒</span></span><br><span class="line">brpop listA 10 </span><br><span class="line">1) &quot;listA&quot;</span><br><span class="line">2) &quot;msg1&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Redis/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/img_1.png"></p>
<p>使用rpop或brpop这样接口消费消息会先从队列中删除消息，然后再由应用消费，如果应用应用在处理消息前异常宕机了，<strong>消息就丢失了</strong>。</p>
<p>但如果使用lindex这样的只读命令先读取消息处理完毕后在删除，又需要额外的机制来<strong>保证一条消息不会被其他消费者重复读到</strong>。</p>
<p>好在list有<strong>rpoplpush或brpoplpush</strong>这样的接口，可以原子性的从一个list中移除一个消息并加入另一个list。</p>
<p>应用程序可以<strong>通过2个list组和来完成消息的消费和确认功能</strong>，使用rpoplpush从list A中消费消息并移入list B，等消息处理完毕后在从list B中删除消息，如果在处理消息过程中应用异常宕机，恢复后应用可以重新从list B中读取未处理的消息并处理。</p>
<p><strong>这种方式为消息的消费增加了ack机制</strong>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">基于2个list完成消息消费和确认</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">从listA中读取消息并写入listB</span></span><br><span class="line">rpoplpush listA listB</span><br><span class="line">&quot;msg1&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">业务逻辑处理msg1完毕后，从listB中删除msg1，完成消息的确认</span></span><br><span class="line">lrem listB 1 msg1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Redis/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/img_2.png"></p>
<h3 id="List的不足之处"><a href="#List的不足之处" class="headerlink" title="List的不足之处"></a>List的不足之处</h3><p>通过Redis 1.0就引入的list结构我们就能实现一个分布式的消息队列，满足一些简单的业务需求。</p>
<p>但list结构作为消息队列服务有一个很致命的问题，它<strong>没有广播功能，一个消息只能被消费一次</strong>。</p>
<p>而在大型系统中，通常一个消息会被下游多个应用同时订阅和消费，例如当用户完成一个订单的支付操作时，需要通知商家发货，要更新物流状态，可能还会提高用户的积分和等级，这些都是不同的下游子系统，他们全部会订阅支付完成的操作，而list一个消息只能被消费一次在这样复杂的大型系统面前就捉襟见肘了。</p>
<p>可能你会说那弄多个list，生产者向每个list中都投递消息，每个消费者处理自己的list不就行了吗。这样第一是性能不会太好，因为同一个消息需要被重复的投递，第二是这样的设计违反了生产者和消费者解耦的原则，这个设计下生产者需要知道下游有哪些消费者，如果业务发生变化，需要额外增加一个消费者，生产者的代码也需要修改。</p>
<h3 id="List总结"><a href="#List总结" class="headerlink" title="List总结"></a>List总结</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>模型简单，和使用本地list基本相同，适配容易</li>
<li>通过brpop做到消息处理的实时性 </li>
<li>通过rpoplpush来联动2个list，可以做到消息先消费后确认，避免消费者应用异常情况下消息丢失</li>
</ul>
<h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul>
<li>消息只能被消费一次，缺乏广播机制</li>
</ul>
<h2 id="Redis2-0-Pub-Sub"><a href="#Redis2-0-Pub-Sub" class="headerlink" title="Redis2.0 - Pub/Sub"></a>Redis2.0 - Pub/Sub</h2><p>list作为消息队列应用场景受到限制很重要的原因在于没有广播，所以Redis 2.0中引入了一个新的数据结构 pubsub 。</p>
<p>pubsub虽然不能算作是list的替代品，但它确实能解决一些list不能解决的问题。</p>
<h3 id="pubsub特性"><a href="#pubsub特性" class="headerlink" title="pubsub特性"></a>pubsub特性</h3><p>pubsub引入一个概念叫channel，生产者通过publish接口投递消息时会指定channel，消费者通过subscribe接口订阅它关心的channel，调用subscribe后这条连接会进入一个特殊的状态，通常不能在发送其他请求，当有消息投递到这个channel时Redis服务端会立刻通过该连接将消息推送到消费者。</p>
<p>这里一个channel可以被多个应用订阅，消息会同时投递到每个订阅者，做到了消息的广播。</p>
<p>另一方面，消费者可以会订阅一批channel，例如一个用户订阅了浙江的新闻的推送，但浙江新闻还会进行细分，例如“浙江杭州xx”、“浙江温州xx”，这里订阅者不需要获取浙江的所有子类在挨个订阅，只需要调用psubscribe“浙江*”就能订阅所有以浙江开头的新闻推送了，这里psubscribe传入一个通配符表达的channel，Redis服务端按照规则推送所有匹配channel的消息给对应的客户端。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">基于pubsub完成channel的匹配和消息的广播</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">消费者1订阅channel1</span></span><br><span class="line">subscribe channel1</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel1&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash">收到消息推送</span></span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;channel1&quot;</span><br><span class="line">3) &quot;msg1&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">消费者2订阅channel*</span></span><br><span class="line">psubscribe channel*</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;channel*&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash">收到消息推送</span></span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;channel*&quot;</span><br><span class="line">3) &quot;channel1&quot;</span><br><span class="line">4) &quot;msg1&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;channel*&quot;</span><br><span class="line">3) &quot;channel2&quot;</span><br><span class="line">4) &quot;msg2&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">生产者发布消息msg1和msg2</span></span><br><span class="line">publish channel1 msg1</span><br><span class="line">(integer) 2</span><br><span class="line">publish channel2 msg2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p><img src="/2022/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Redis/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/img_3.png"></p>
<p>在Redfis 2.8时加入了<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15346415/5188764">keyspace notifications功能</a></p>
<p>此时pubsub除了通知用户自定义消息，也可以通知系统内部消息。</p>
<p>keyspace notifications引入了2个特殊的channel分别是 <code>__keyevent@&lt;db&gt;__:&lt;event&gt;</code> 和 <code>__keyspace@&lt;db&gt;__:&lt;key&gt;</code>, 可以通过开启配置notify-keyspace-events使用</p>
<details><summary>notify-keyspace-events</summary>
服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型：

<p>可以设置的类型如下：</p>
<ul>
<li>想让服务器发送所有类型的键空间通知和键事件通知，可以将选项的值设置为AKE</li>
<li>想让服务器发送所有类型的键空间通知，可以将选项的值设置为AK</li>
<li>想让服务器发送所有类型的键事件通知，可以将选项的值设置为AE</li>
<li>想让服务器只发送和字符串键有关的键空间通知，可以将选项的值设置为K$</li>
<li>想让服务器只发送和列表键有关的键事件通知，可以将选项的值设置为El<br>备注：notify-keyspace-events选项的默认值为空，所以如果不设置上面的值，SUBSCRIBE命令不会有任何效果</li></ul></details>

<p><strong>键空间通知</strong></p>
<p>某个键执行了什么命令, 通过订阅__keyspace客户端可以收到目标key的增删改操作以及过期事件。</p>
<details><summary>键空间通知演示案例</summary>

<ol>
<li><p>先将notify-keyspace-events选项设置为“AKE”，表示服务器可以发送所有类型的键空间通知和键事件通知</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG SET notify-keyspace-events AKE</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET notify-keyspace-events</span><br><span class="line">1) &quot;notify-keyspace-events&quot;</span><br><span class="line">2) &quot;AKE&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>使用下面命令开启对0号数据库中的message键的监视，可以获取其通知消息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE __keyspace@0__:message</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;__keyspace@0__:message&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure></li>
<li><p>我们在另一个客户端命令行先后用SET、EXPIRE、DEL三个命令对键message进行了操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```shell</span><br><span class="line">127.0.0.1:6379&gt; set message HellowWorld</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire message 500</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; del message</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li>
<li><p>可以看到监听一端接收到了服务端发来的message键更改的通知</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE __keyspace@0__:message</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;__keyspace@0__:message&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line"></span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;__keyspace@0__:message&quot;</span><br><span class="line">3) &quot;set&quot;</span><br><span class="line">4) &quot;message&quot;</span><br><span class="line">5) &quot;__keyspace@0__:message&quot;</span><br><span class="line">6) &quot;expire&quot;</span><br><span class="line">7) &quot;message&quot;</span><br><span class="line">8) &quot;__keyspace@0__:message&quot;</span><br><span class="line">9) &quot;del&quot;</span><br></pre></td></tr></table></figure>
</li></ol></details>

<p><strong>键事件通知</strong></p>
<p>某个命令被什么键执行了, 通过订阅__keyevent客户端可以收到某个具体命令调用的回调通知，</p>
<details><summary>键事件通知演示案例</summary>
  
<ol>
<li><p>先将notify-keyspace-events选项设置为“AKE”，表示服务器可以发送所有类型的键空间通知和键事件通知</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG SET notify-keyspace-events AKE</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET notify-keyspace-events</span><br><span class="line">1) &quot;notify-keyspace-events&quot;</span><br><span class="line">2) &quot;AKE&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>下面代码展示了客户端如何获取0号数据库中所有执行DEL命令的键</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE __keyevent@0__:del</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;__keyevent@0__:del&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure></li>
<li><p>我们在另一个客户端命令行执行2次del命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del key</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; del message</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li>
<li><p>可以看到监听一端接收到了服务端发来的del通知</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE __keyevent@0__:del</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;__keyevent@0__:del&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line"></span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;__keyevent@0__:del&quot;</span><br><span class="line">3) &quot;key&quot;</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;__keyevent@0__:del&quot;</span><br><span class="line">3) &quot;message&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
</details>

<h3 id="pubsub的不足之处"><a href="#pubsub的不足之处" class="headerlink" title="pubsub的不足之处"></a>pubsub的不足之处</h3><p>pubsub既能单播又能广播，还支持channel的简单正则匹配，功能上已经能满足大部分业务的需求，而且这个接口发布的时间很早，在2011年Redis 2.0发布时就已经具备，用户基础很广泛，所以现在很多业务都有用到这个功能。</p>
<p>但你要深入了解pubsub的原理后，是肯定不敢把它作为一个一致性要求较高，数据量较大系统的消息服务的。</p>
<p>首先，pubsub的消息数据是瞬时的，它在Redis服务端不做保存，publish发送到Redis的消息会立刻推送到所有当时subscribe连接的客户端，如果当时客户端因为网络问题断连，那么就会错过这条消息，当客户端重连后，它没法重新获取之前那条消息，甚至无法判断是否有消息丢失。</p>
<p>其次，pubsub中消费者获取消息是一个推送模型，这意味着Redis会按消息生产的速度给所有的消费者推送消息，不管消费者处理能力如何，如果消费者应用处理能力不足，消息就会在Redis的client buf中堆积，当堆积数据超过一个阈值后会断开这条连接，这意味着这些消息全部丢失了，在也找不回来了。如果同时有多个消费者的client buf堆积数据但又还没达到断开连接的阈值，那么Redis服务端的内存会膨胀，进程可能因为oom而被杀掉，这导致了整个服务中断。</p>
<h3 id="pubsub总结"><a href="#pubsub总结" class="headerlink" title="pubsub总结"></a>pubsub总结</h3><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul>
<li>消息具备广播能力</li>
<li>psubscribe能按字符串通配符匹配，给予了业务逻辑的灵活性</li>
<li>能订阅特定key或特定命令的系统消息<h4 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h4></li>
<li>Redis异常、客户端断连都会导致消息丢失</li>
<li>消息缺乏堆积能力，不能削峰填谷。推送的方式缺乏背压机制，没有考虑消费者处理能力，推送的消息超过消费者处理能力后可能导致消息丢失或服务异常。</li>
</ul>
<h2 id="Redis5-0-stream"><a href="#Redis5-0-stream" class="headerlink" title="Redis5.0 - stream"></a>Redis5.0 - stream</h2><p>消息丢失、消息服务不稳定的问题严重限制了pubsub的应用场景，所以Redis需要重新设计一套机制，来解决这些问题，这就有了后来的stream结构。</p>
<h3 id="stream特性"><a href="#stream特性" class="headerlink" title="stream特性"></a>stream特性</h3><p>一个稳定的消息服务需要具备几个要点：</p>
<ul>
<li>要保证消息不会丢失</li>
<li>至少被消费一次，</li>
<li>要具备削峰填谷的能力，来匹配生产者和消费者吞吐的差异。</li>
</ul>
<p>在2018年Redis 5.0加入了stream结构，这次考虑了list、pubsub在应用场景下的缺陷，对标kafka的模型重新设计全内存消息队列结构，从这时开始Redis消息队列功能算是能和主流消息队列产品pk一把了。</p>
<p><img src="/2022/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Redis/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/img_4.png"></p>
<p>stream的改进分为多个方面</p>
<p><strong>成本</strong>：</p>
<ul>
<li>存储message数据使用了listpack结构，这是一个紧凑型的数据结构，不同于list的双向链表每个节点都要额外占用2个指针的存储空间，这使得小msg情况下stream的空间利用率更高。</li>
</ul>
<p><strong>功能</strong>：</p>
<ul>
<li>stream引入了消费者组的概念，一个消费者组内可以有多个消费者，同一个组内的消费者共享一个消息位点（last_delivered_id），这使得消费者能够水平的扩容，可以在一个组内加入多个消费者来线性的提升吞吐，对于一个消费者组，每条msg只会被其中一个消费者获取和处理，这是pubsub的广播模型不具备的。</li>
<li>不同消费者组之前是相互隔离的，他们各自维护自己的位点，这使得一条msg能被多个不同的消费者组重复消费，做到了消息广播的能力。</li>
<li>stream中消费者采用拉取的方式，并能设置timeout在没有消息时阻塞，通过这种长轮询机制保证了消息的实时性，而且消费速率是和消费者自身吞吐相匹配。</li>
</ul>
<p><strong>消息不丢失</strong>：</p>
<ul>
<li>stream的数据会存储在aof和rdb文件中，这使Redis重启后能够恢复stream的数据。而pubsub的数据是瞬时的，Redis重启意味着消息全部丢失。</li>
<li>stream中每个消费者组会存储一个last_delivered_id来标识已经读取到的位点，客户端连接断开后重连还是能从该位点继续读取，消息不会丢失。</li>
<li>stream引入了ack机制保证消息至少被处理一次。<ul>
<li>考虑一种场景，如果消费者应用已经读取了消息，但还没来得及处理应用就宕机了，对于这种已经读取但没有ack的消息，stream会标示这条消息的状态为pending，等客户端重连后通过xpending命令可以重新读取到pengind状态的消息，继续处理。</li>
<li>如果这个应用永久宕机了，那么该消费者组内的其他消费者应用也能读取到这条消息，并通过xclaim命令将它归属到自己下面继续处理。</li>
</ul>
</li>
</ul>
<details><summary>基于stream完成消息的生产和消费，并确保异常状态下消息至少被消费一次</summary>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建mystream，并且创建一个consumergroup为mygroup</span></span><br><span class="line">XGROUP CREATE mystream mygroup $ MKSTREAM</span><br><span class="line">OK</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">写入一条消息，由redis自动生成消息id，消息的内容是一个kv数组，这里包含field1 value1 field2 value2</span></span><br><span class="line">XADD mystream * field1 value1 field2 value2</span><br><span class="line">&quot;1645517760385-0&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">消费者组mygroup中的消费者consumer1从mystream读取一条消息，&gt;表示读取一条该消费者组从未读取过的消息</span></span><br><span class="line">XREADGROUP GROUP mygroup consumer1 COUNT 1 STREAMS mystream &gt;</span><br><span class="line">1) 1) &quot;mystream&quot;</span><br><span class="line">   2) 1) 1) &quot;1645517760385-0&quot;</span><br><span class="line">         2) 1) &quot;field1&quot;</span><br><span class="line">            2) &quot;value1&quot;</span><br><span class="line">            3) &quot;field2&quot;</span><br><span class="line">            4) &quot;value2&quot;</span><br><span class="line">            </span><br><span class="line"><span class="meta">#</span><span class="bash">消费完成后ack确认消息</span></span><br><span class="line">xack mystream mygroup 1645517760385-0</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果消费者应用在ack前异常宕机，恢复后重新获取未处理的消息id。</span></span><br><span class="line">XPENDING mystream mygroup - + 10 </span><br><span class="line">1) 1) &quot;1645517760385-0&quot;</span><br><span class="line">   2) &quot;consumer1&quot;</span><br><span class="line">   3) (integer) 305356</span><br><span class="line">   4) (integer) 1</span><br><span class="line">   </span><br><span class="line"><span class="meta"> #</span><span class="bash">如果consumer1永远宕机，其他消费者可以把pending状态的消息移动到自己名下后继续消费</span></span><br><span class="line"><span class="meta"> #</span><span class="bash">将消息id 1645517760385-0移动到consumer2下</span></span><br><span class="line"> XCLAIM mystream mygroup consumer2 0 1645517760385-0</span><br><span class="line"> 1) 1) &quot;1645517760385-0&quot;</span><br><span class="line">   2) 1) &quot;field1&quot;</span><br><span class="line">      2) &quot;value1&quot;</span><br><span class="line">      3) &quot;field2&quot;</span><br><span class="line">      4) &quot;value2&quot;</span><br></pre></td></tr></table></figure>
</details>

<p>Redis stream保证了消息至少被处理一次，但如果想做到每条消息仅被处理一次还需要应用逻辑的介入。</p>
<p>消息被重复处理要么是生产者重复投递，要么是消费者重复消费。</p>
<ul>
<li><p>对于生产者重复投递问题，Redis stream为每个消息都设置了一个唯一递增的id，通过参数可以让Redis自动生成id或者应用自己指定id，应用可以根据业务逻辑为每个msg生成id，当xadd超时后应用并不能确定消息是否投递成功，可以通过xread查询该id的消息是否存在，存在就说明已经投递成功，不存在则重新投递，而且stream限制了id必须递增，这意味了已经存在的消息重复投递会被拒绝。这套机制保证了每个消息可以仅被投递一次。</p>
</li>
<li><p>对于消费者重复消费的问题，考虑一个场景，消费者读取消息后业务处理完毕，但还没来得及ack就发生了异常，应用恢复后对于这条没有ack的消息进行了重复消费。这个问题因为ack和消费消息的业务逻辑发生在2个系统，没法做到事务性，需要业务来改造，保证消息处理的幂等性。</p>
</li>
</ul>
<h3 id="stream的不足"><a href="#stream的不足" class="headerlink" title="stream的不足"></a>stream的不足</h3><p>stream的模型做到了消息的高效分发，而且保证了消息至少被处理一次，通过应用逻辑的改造能做到消息仅被处理一次，它的能力对标kafka，但吞吐高于kafka，在高吞吐场景下成本比kafka低，那它又有哪些不足了。</p>
<p>首先消息队列很重要的一个功能就是削峰填谷，来匹配生产者和消费者吞吐的差异，生产者和消费者吞吐差异越大，持续时间越长，就意味着steam中需要堆积更多的消息，而Redis作为一个全内存的产品，<strong>数据堆积的成本比磁盘高</strong>。</p>
<p>其次stream通过ack机制保证了消息至少被消费一次，但这有个<strong>前提</strong>就是存储在Redis中的消息本身不会丢失。</p>
<ul>
<li>Redis数据的持久化依赖aof和rdb文件，aof落盘方式有几种，通过配置appendfsync决定，通常我们不会配置为always来让每条命令执行完后都做一次fsync，线上配置一般为everysec，每秒做一次fsync，而rdb是全量备份时生成，这意味了宕机恢复可能会丢掉最近一秒的数据。</li>
<li>另一方面线上生产环境的Redis都是高可用架构，当主节点宕机后通常不会走恢复逻辑，而是直接切换到备节点继续提供服务，而Redis的同步方式是异步同步，这意味着主节点上新写入的数据可能还没同步到备节点，在切换后这部分数据就丢失了。所以在<strong>故障恢复中Redis中的数据可能会丢失一部分</strong>，在这样的背景下无论stream的接口设计的多么完善，都不能保证消息至少被消费一次。</li>
</ul>
<h3 id="stream总结"><a href="#stream总结" class="headerlink" title="stream总结"></a>stream总结</h3><h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><ul>
<li>在成本、功能上做了很多改进，支持了紧凑的存储小消息、具备广播能力、消费者能水平扩容、具备背压机制</li>
<li>通过ack机制保证了Redis服务端<strong>正常情况下</strong>消息至少被处理一次的能力</li>
</ul>
<h4 id="不足-2"><a href="#不足-2" class="headerlink" title="不足"></a>不足</h4><ul>
<li>内存型消息队列，数据堆积成本高</li>
<li>Redis本身rpo&gt;0，故障恢复可能会丢数据，所以stream在Redis发生故障恢复后也<strong>不能保证</strong>消息至少被消费一次。</li>
</ul>
<h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>消息队列主要是为了解决3类问题，应用模块的解耦、消息的异步化、削峰填谷。</p>
<p>目前主流的消息队列都能满足这些需求，所以在实际选型时还会考虑一些特殊的功能是否满足，产品的性能如何，具体业务场景下的成本怎么样，开发的复杂度等。</p>
<p>Redis的消息队列功能并不是最全面的，它不希望做成一个大而全的产品，而是做一个小而美的产品，服务好一部分用户在某些场景下的需求。</p>
<p>目前用户选型Redis作为消息队列服务的原因，主要有Redis在相同成本下吞吐更高、Redis的延时更低、应用需要一个消息服务但又不想额外引入一堆依赖等。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MQ/">MQ</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/04/11/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E4%B8%80%E4%B8%AA%E6%B3%A8%E8%A7%A3%E6%90%9E%E5%AE%9A%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%E4%B9%8Bspring-retry%E6%A1%86%E6%9E%B6/"><i class="fa fa-chevron-left">  </i><span>一个注解搞定重试机制之spring-retry框架</span></a></div><div class="next-post pull-right"><a href="/2022/04/07/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E6%8E%92%E6%8A%80%E6%9C%AF/"><span>AOP实现机制详解与字节码编排技术</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '83850031ee87c27765eb',
  clientSecret: '6c5e13a8b6670d5bfa85ba548ba3570cae29e671',
  repo: 'blob-comment',
  owner: 'hepeng0',
  admin: 'hepeng0',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By 何鹏 [smile.hepeng@qq.com]</div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>