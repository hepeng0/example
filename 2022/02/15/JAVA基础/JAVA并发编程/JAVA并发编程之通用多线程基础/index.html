<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JAVA并发编程之通用多线程基础"><meta name="keywords" content="并发,锁,线程"><meta name="author" content="何鹏 [smile.hepeng@qq.com]"><meta name="copyright" content="何鹏 [smile.hepeng@qq.com]"><title>JAVA并发编程之通用多线程基础 | 沉默者</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.0'
} </script><link rel="alternate" href="/atom.xml" title="沉默者" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Java多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B-amp-%E7%A8%8B%E5%BA%8F-amp-%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">线程&amp;程序&amp;进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">线程基本状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep-amp-wait"><span class="toc-number">1.3.</span> <span class="toc-text">sleep&amp;wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#start-amp-run"><span class="toc-number">1.4.</span> <span class="toc-text">start() &amp; run()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">Java锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9C%8B%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">从对象头看锁实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">对象头转换过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Monitor%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.2.</span> <span class="toc-text">Monitor对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Monitor%E4%B8%8ESynchronized"><span class="toc-number">2.1.3.</span> <span class="toc-text">Monitor与Synchronized</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Synchronized"><span class="toc-number">2.1.4.</span> <span class="toc-text">Synchronized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">2.2.</span> <span class="toc-text">偏向锁、轻量级锁、重量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">重量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">2.2.3.</span> <span class="toc-text">自适应自旋锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">2.2.4.</span> <span class="toc-text">轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">2.2.5.</span> <span class="toc-text">偏向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.2.6.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">2.3.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">2.4.</span> <span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">2.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.2.</span> <span class="toc-text">ThreadLocal 内存泄露问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.5.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.5.1.</span> <span class="toc-text">为什么使用线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Runnable-amp-Callable"><span class="toc-number">2.5.2.</span> <span class="toc-text">Runnable&amp;Callable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#execute-amp-submit"><span class="toc-number">2.5.3.</span> <span class="toc-text">execute() &amp; submit()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Atomic%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">2.6.</span> <span class="toc-text">Atomic原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicInteger%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.6.1.</span> <span class="toc-text">AtomicInteger使用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicInteger%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.2.</span> <span class="toc-text">AtomicInteger线程安全原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractQueuedSynchronizer"><span class="toc-number">2.7.</span> <span class="toc-text">AbstractQueuedSynchronizer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">2.7.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS-%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="toc-number">2.7.2.</span> <span class="toc-text">AQS 对资源的共享方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.7.3.</span> <span class="toc-text">模板方法模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">2.7.4.</span> <span class="toc-text">参考文章</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%BE%85%E5%8A%A9%E7%B1%BB"><span class="toc-number">2.8.</span> <span class="toc-text">同步辅助类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CountDownLatch-%E2%80%94-%E5%87%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.8.1.</span> <span class="toc-text">CountDownLatch — 减计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CyclicBarrier-%E2%80%94-%E5%8A%A0%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">2.8.2.</span> <span class="toc-text">CyclicBarrier — 加计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">2.8.3.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Semaphore%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8E%A7%E5%88%B6"><span class="toc-number">2.8.4.</span> <span class="toc-text">Semaphore并发数控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exchanger-%E2%80%94-%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2"><span class="toc-number">2.8.5.</span> <span class="toc-text">Exchanger — 线程数据交换</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://img2.baidu.com/it/u=928705063,3876627980&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg"></div><div class="author-info__name text-center">何鹏 [smile.hepeng@qq.com]</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">60</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">51</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div class="plain" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">沉默者</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div></div><div class="layout" id="content-inner"><article id="post"><div class="plain" id="post-title">JAVA并发编程之通用多线程基础</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-02-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%B9%B6%E5%8F%91/"> 并发</a><span class="post-meta__separator">|</span><span class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 10 分钟</span></span></div><div class="article-container" id="post-content"><h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><h3 id="线程-amp-程序-amp-进程"><a href="#线程-amp-程序-amp-进程" class="headerlink" title="线程&amp;程序&amp;进程"></a>线程&amp;程序&amp;进程</h3><ul>
<li>进程: 程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。<ul>
<li>各进程相互独立</li>
</ul>
</li>
<li>线程：比进程更小的执行单位。<ul>
<li>同类的多个线程共享进程的堆和方法区资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。</li>
<li>每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</li>
<li>同一进程中的线程极有可能会相互影响。</li>
</ul>
</li>
</ul>
<h3 id="线程基本状态"><a href="#线程基本状态" class="headerlink" title="线程基本状态"></a>线程基本状态</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。<br><img src="/2022/02/15/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%80%9A%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/Java线程的状态.png" alt="Java线程状态"></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：<br><img src="/2022/02/15/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%80%9A%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/Java%20线程状态变迁.png" alt="Java线程状态变迁"></p>
<ul>
<li>线程创建之后它将处于 NEW（新建） 状态</li>
<li>调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。</li>
<li>可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 RUNNING（运行） 状态。</li>
<li>当线程执行 wait()方法之后，线程进入 WAITING（等待）状态， 进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态</li>
<li>而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。</li>
<li>当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。</li>
<li>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。</li>
<li>线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。</span><br></pre></td></tr></table></figure>
<h3 id="sleep-amp-wait"><a href="#sleep-amp-wait" class="headerlink" title="sleep&amp;wait"></a>sleep&amp;wait</h3><p>两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。<br>两者都可以暂停线程的执行。</p>
<ul>
<li>Wait 通常被用于线程间交互/通信，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法, 可以使用 wait(long timeout)超时后线程会自动苏醒。</li>
<li>sleep 通常被用于暂停执行, 线程会自动苏醒。</li>
</ul>
<h3 id="start-amp-run"><a href="#start-amp-run" class="headerlink" title="start() &amp; run()"></a>start() &amp; run()</h3><ul>
<li>new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。</li>
<li>start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</li>
<li>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</li>
</ul>
<h2 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h2><h3 id="从对象头看锁实现原理"><a href="#从对象头看锁实现原理" class="headerlink" title="从对象头看锁实现原理"></a>从对象头看锁实现原理</h3><h4 id="对象头转换过程"><a href="#对象头转换过程" class="headerlink" title="对象头转换过程"></a>对象头转换过程</h4><p><img src="/2022/02/15/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%80%9A%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/markword.png" alt="markword"></p>
<ul>
<li><p>对象未加锁的时候，lock标志位为01，包含哈希值、年龄分代和偏向锁标志位等，此时偏向锁标志位为0；</p>
</li>
<li><p>当对象被施加偏向锁时，哈希值和一部分无用内存会转化为锁主人的线程信息，以及加锁的时间戳epoch，此时lock标志位没变，偏向锁为1，也就是说，偏向锁和lock标志位共同决定是否偏向锁状态。</p>
<p>偏向锁的加锁步骤：</p>
<ul>
<li>Load-and-test，也就是简单判断一下当前线程id是否与Markword当中的线程id是否一致.</li>
<li>如果一致，则说明此线程已经成功获得了锁，继续执行下面的代码.</li>
<li>如果不一致，则要检查一下对象是否还是可偏向，即“是否偏向锁”标志位的值。</li>
<li>如果还未偏向，则利用CAS操作来竞争锁，也即是第一次获取锁时的操作。</li>
</ul>
</li>
<li><p>当发生锁竞争时，偏向锁会变为轻量级锁，这时需要先将偏向锁进行锁撤销，这一步骤也会消耗不少的性能，轻量级锁的Mark Word中，lock标志位为00，其余内容被替换为一个指针，指向了栈里面的锁记录。</p>
<p>锁撤销的过程如下：</p>
<ul>
<li>在一个安全点停止拥有锁的线程。</li>
<li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。</li>
<li>唤醒当前线程，将当前锁升级成轻量级锁。</li>
</ul>
<p>所以，如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭</p>
<p>轻量级锁的加锁步骤：</p>
<ul>
<li>线程在自己的栈桢中创建锁记录LockRecord。</li>
<li>将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。</li>
<li>将锁记录中的Owner指针指向锁对象。</li>
<li>将锁对象的对象头的MarkWord替换为指向锁记录的指针。</li>
</ul>
<p>轻量级锁主要有两种：自旋锁和自适应自旋锁。自旋锁会导致空耗CPU且很可能锁不公平；自适应是指根据上一次该线程是否成功或者多久获取过该锁设置旋转次数，若上次失败很可能直接进入重量级锁</p>
</li>
<li><p>如果竞争线程增多，锁继续膨胀，变为重量级锁，也是互斥锁，即synchronized，其lock标志位为10，Mark Word其余内容被替换为一个指向对象监视器Monitor的指针。</p>
</li>
<li><p>特殊的是，如果此对象已经被GC标记过，lock会变为11，不含其余内容。</p>
</li>
</ul>
<h4 id="Monitor对象"><a href="#Monitor对象" class="headerlink" title="Monitor对象"></a>Monitor对象</h4><p>每个对象都有一个Monitor对象相关联，Monitor对象中记录了持有锁的线程信息、等待队列等。Monitor对象包含以下三个字段：</p>
<ul>
<li>_owner 记录当前持有锁的线程</li>
<li>_EntryList 是一个队列，记录所有阻塞等待锁的线程</li>
<li>_WaitSet 也是一个队列，记录调用 wait() 方法并还未被通知的线程</li>
</ul>
<p>当线程持有锁的时候，线程id等信息会拷贝进owner字段，其余线程会进入阻塞队列entrylist，当持有锁的线程执行wait方法，会立即释放锁进入waitset，当线程释放锁的时候，owner会被置空，公平锁条件下，entrylist中的线程会竞争锁，竞争成功的线程id会写入owner，其余线程继续在entrylist中等待。</p>
<h4 id="Monitor与Synchronized"><a href="#Monitor与Synchronized" class="headerlink" title="Monitor与Synchronized"></a>Monitor与Synchronized</h4><ul>
<li>对于Synchronized的同步代码块，JVM会在进入代码块之前加上monitorenter ，如果进入monitor成功，线程便获取了锁，一个对象的monitor同一时刻只能被一个线程锁占有；</li>
<li>对于同步方法，JVM会讲方法设置 ACC_SYNCHRONIZED 标志，调用的时候 JVM 根据这个标志判断是否是同步方法。</li>
<li>采用Synchronized给对象加锁会使线程阻塞，因而会造成线程状态的切换，而线程状态的切换必须要操作系统来执行，因此需要将用户态切换为内核态，这个切换的过程是十分耗时的都需要操作系统来帮忙，有可能比用户执行代码的时间还要长。</li>
</ul>
<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><p>JVM级别的锁，它在不断被优化着，从目前来看Synchronized已经远没有以前那么“重”了，也大概就是JUC包源码（如ConcurrentHashMap）中大量使用Synchronized的原因吧。</p>
<p><img src="/2022/02/15/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%80%9A%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/Java%20Synchronized.png" alt="java syschronized"></p>
<h3 id="偏向锁、轻量级锁、重量级锁"><a href="#偏向锁、轻量级锁、重量级锁" class="headerlink" title="偏向锁、轻量级锁、重量级锁"></a>偏向锁、轻量级锁、重量级锁</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cxuanBlog/p/11684390.html">看完你就明白的锁系列之锁的状态</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/36eedeb3f912">浅谈偏向锁、轻量级锁、重量级锁</a></p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>内置锁在Java中被抽象为监视器锁（monitor），在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。<br>这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。<br>因此，后来称这种锁为“重量级锁”。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>内核态与用户态的切换上不容易优化。但通过自旋锁，可以<strong><em>减少线程阻塞造成的线程切换（包括挂起线程和恢复线程）</em></strong>。</p>
<ul>
<li>当前线程竞争锁失败时，打算阻塞自己</li>
<li>不直接阻塞自己，而是自旋（空等待，比如一个空的有限for循环）一会</li>
<li>在自旋的同时重新竞争锁</li>
<li>如果自旋结束前获得了锁，那么锁获取成功；否则，自旋结束后阻塞自己</li>
</ul>
<p>如果在自旋的时间内，锁就被旧owner释放了，那么当前线程就不需要阻塞自己（也不需要在未来锁释放时恢复），减少了一次线程切换。</p>
<ul>
<li>单核处理器上，不存在实际的并行，当前线程不阻塞自己的话，旧owner就不能执行，锁永远不会释放，此时不管自旋多久都是浪费；进而，如果线程多而处理器少，自旋也会造成不少无谓的浪费。</li>
<li>自旋锁要占用CPU，如果是计算密集型任务，这一优化通常得不偿失，减少锁的使用是更好的选择。</li>
<li><p>如果锁竞争的时间比较长，那么自旋通常不能获得锁，白白浪费了自旋占用的CPU时间。这通常发生在锁持有时间长，且竞争激烈的场景中，此时应主动禁用自旋锁。</p>
<pre><code>使用-XX:-UseSpinning参数关闭自旋锁优化；-XX:PreBlockSpin参数修改默认的自旋次数。
</code></pre></li>
</ul>
<h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p>自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定.</p>
<ul>
<li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。</li>
<li>相反的，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。</li>
</ul>
<p>自适应自旋解决的是“锁竞争时间不确定”的问题。<em>自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定，因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间。</em></p>
<ul>
<li>如果默认的自旋次数设置不合理（过高或过低），那么自适应的过程将很难收敛到合适的值。</li>
</ul>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。</p>
<ul>
<li>使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record</li>
<li>如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁</li>
<li>否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。</li>
</ul>
<p>由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，自旋失败后再膨胀为重量级锁。</p>
<ul>
<li>如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费。</li>
</ul>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。</p>
<ul>
<li>“偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁）</li>
<li>因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空）</li>
<li>如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁</li>
<li>否则，说明有其他线程竞争，膨胀为轻量级锁。</li>
</ul>
<p>偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定</p>
<ul>
<li>如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁。</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。</li>
<li>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。</li>
<li>重量级锁：有实际竞争，且锁竞争时间长。</li>
</ul>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。</p>
<details>
<summary>使用</summary>
<pre><code>
public class Printer  &#123; 
    private Lock lock = new ReentrantLock();// 锁对象   
    public void printLetters(char c) &#123;
         lock.lock();// 得到锁  
         try &#123;
             for(int i = 0; i<5; i++) &#123; system.out.print(c); &#125; system.out.println(); &#125;finally lock.unlock(); 释放锁 < code></5;></code></pre>
</details>

<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p>创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<ul>
<li>Thread 类中有一个 threadLocals 和 一个  inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap;</li>
<li>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</li>
<li>同一个线程中声明了两个 ThreadLocal 对象的话，会使用 Thread内部都是使用仅有那个ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal对象，value 就是 ThreadLocal 对象调用set方法设置的值。</li>
<li>ThreadLocalMap是ThreadLocal的静态内部类。</li>
</ul>
<h4 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal 内存泄露问题"></a>ThreadLocal 内存泄露问题</h4><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。</p>
<p>所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后最好手动调用remove()方法。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h4><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h4 id="Runnable-amp-Callable"><a href="#Runnable-amp-Callable" class="headerlink" title="Runnable&amp;Callable"></a>Runnable&amp;Callable</h4><p>Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。</p>
<h4 id="execute-amp-submit"><a href="#execute-amp-submit" class="headerlink" title="execute() &amp; submit()"></a>execute() &amp; submit()</h4><ul>
<li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li>
<li>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<h3 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h3><h4 id="AtomicInteger使用示例"><a href="#AtomicInteger使用示例" class="headerlink" title="AtomicInteger使用示例"></a>AtomicInteger使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">      <span class="comment">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AtomicInteger线程安全原理"><a href="#AtomicInteger线程安全原理" class="headerlink" title="AtomicInteger线程安全原理"></a>AtomicInteger线程安全原理</h4><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<h3 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>
<pre><code>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。
</code></pre><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>
<p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h4><ul>
<li>Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li>Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock</li>
</ul>
<p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p>
<h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><ul>
<li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li>
<li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ul>
<p>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br><span class="line">tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br><span class="line">tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br><span class="line">tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br><span class="line">tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><br></pre></td></tr></table></figure>
<p>这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484832&amp;idx=1&amp;sn=f902febd050eac59d67fc0804d7e1ad5&amp;source=41#wechat_redirect">并发编程面试必备：AQS 原理以及 AQS 同步组件总结</a></p>
<h3 id="同步辅助类"><a href="#同步辅助类" class="headerlink" title="同步辅助类"></a>同步辅助类</h3><p><img src="/2022/02/15/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%80%9A%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/并发辅助类.png" alt="并发辅助类"></p>
<h4 id="CountDownLatch-—-减计数器"><a href="#CountDownLatch-—-减计数器" class="headerlink" title="CountDownLatch — 减计数器"></a>CountDownLatch — 减计数器</h4><p>允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。</p>
<details>
    <summary>使用示例</summary>
    <pre><code>
public class CountDownLatchDemo &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        //定义：允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。
        //用途：1.一个CountDownLatch为一个计数的CountDownLatch用作一个简单的开/关锁存器，或者门：
        //      所有线程调用await在门口等待，直到被调用countDown()的线程打开。
        //     2.一个CountDownLatch初始化N可以用来做一个线程等待，直到N个线程完成某项操作，或某些动作已经完成N次
        CountDownLatch countDownLatch = new CountDownLatch(20);
        for (int i=1 ;i<=20;i++)&#123; new thread(()->&#123;
                countDownLatch.countDown();
                System.out.println(Thread.currentThread().getName()+">="+countDownLatch.getCount());
            //&#125;,String.valueOf(i)).start();
        &#125;
        // 特性：它不要求调用countDown线程等待计数到达零之前继续，
        // 它只是阻止任何线程通过await ，直到所有线程可以通过。
        System.out.println("我可以在Await方法之前执行");
        countDownLatch.await();
        System.out.println("我为什么在最后执行呢");
    &#125;
&#125;
</=20;i++)&#123;></code></pre>
</details>

<p>CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。<br>当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。<br>如果有某个解析sheet的线程处理得比较慢，我们不可能让主线程一直等待，所以可以使用另外一个带指定时间的await方法——await（long time，TimeUnit unit），这个方法等待特定时间后，就会不再阻塞当前线程。join也有类似的方法。</p>
<ul>
<li>计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程</li>
<li>CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值</li>
<li>一个线程调用countDown方法happen-before，另外一个线程调用await方法</li>
</ul>
<details>
<summary>源码</summary>
<pre><code>
public class CountDownLatch &#123;
    /**Synchronization control For CountDownLatch. Uses AQS state to represent count.*/
    private static final class Sync extends AbstractQueuedSynchronizer &#123;
        private static final long serialVersionUID = 4982264981922014374L;
        Sync(int count) &#123;
            setState(count);//初始化同步状态
        &#125;
        int getCount() &#123;
            return getState();
        &#125;
        protected int tryAcquireShared(int acquires) &#123;
            return (getState() == 0) ? 1 : -1;
        &#125;
        protected boolean tryReleaseShared(int releases) &#123;
            // Decrement count; signal when transition to zero
            for (;;) &#123;
                int c = getState();
                if (c == 0)
                    return false;
                int nextc = c-1;
                if (compareAndSetState(c, nextc))
                    return nextc == 0;
            &#125;
        &#125;
    &#125;
    private final Sync sync;//组合一个同步器（AQS）
    public CountDownLatch(int count) &#123;
        if (count < 0) throw new IllegalArgumentException("count < 0");
        this.sync = new Sync(count);//初始化同步状态
    &#125;
    /*Causes the current thread to wait until the latch has counted down to
     * zero, unless the thread is &#123;@linkplain Thread#interrupt interrupted&#125;.*/
    public void await() throws InterruptedException &#123;
        sync.acquireSharedInterruptibly(1);//
    &#125;
    public boolean await(long timeout, TimeUnit unit)
        throws InterruptedException &#123;
        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
    &#125;
    public void countDown() &#123;
        sync.releaseShared(1);//释放同步状态
    &#125;
    public long getCount() &#123;
        return sync.getCount();
    &#125;
    public String toString() &#123;
        return super.toString() + "[Count = " + sync.getCount() + "]";
    &#125;
&#125;
</code></pre>
</details>

<h4 id="CyclicBarrier-—-加计数器"><a href="#CyclicBarrier-—-加计数器" class="headerlink" title="CyclicBarrier — 加计数器"></a>CyclicBarrier — 加计数器</h4><p>等待多个操作完成，再执行下一步</p>
<details>
    <summary>使用示例</summary>
    <pre><code>
public class CyclicBarrierDemo &#123;
    public static void main(String[] args) throws BrokenBarrierException, InterruptedException &#123;
        //适用需等待多个操作完成，再执行下一步
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()->&#123;
            System.out.println("舍利子集齐成功，如来重生");
        &#125;);
        for (int i=1;i<=7;i++)&#123; int finali="i;" new thread(()->&#123;
                System.out.println(Thread.currentThread().getName()+"：收集了"+ finalI +"颗");
                try &#123;
                    //等待，舍利子集齐，一起向下执行
                    cyclicBarrier.await();
                    System.out.println("无天必须在如来重生之后，再死");
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125; catch (BrokenBarrierException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;).start();
        &#125;
    &#125;
&#125;
    </=7;i++)&#123;></code></pre>
</details>

<h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>可循环使用（Cyclic）的屏障（Barrier）。<br>它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<p>CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p>
<details>
<summary>使用示例</summary>
<pre><code>
import java.util.Random; 
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.atomic.AtomicInteger;
public class CyclicBarrierTest &#123;
    private static Random sr=new Random(47); 
    private static AtomicInteger result=new AtomicInteger(0);
    private static int threadCount=10;
    //屏障后面执行汇总
    private static CyclicBarrier barrier=new CyclicBarrier(threadCount,new Accumulate());
    private static class Parser implements Runnable&#123; 
        String name;
        public Parser(String name)&#123;
            this.name=name;
        &#125;
        @Override
        public void run() &#123;
            int sum=0;
            int seed=Math.abs(sr.nextInt()) ;
            Random r=new Random(47); 
            for(int i=0;i<(seed%100*100000);i++)&#123; sum+="r.nextInt(seed);" &#125; result.addandget(sum); system.out.println(system.currenttimemillis()+"-"+name+"线程的解析结果："+sum); try &#123; barrier.await(); system.out.println(system.currenttimemillis()+"-"+name+"线程越过屏障！"); catch (exception e) e.printstacktrace(); static class accumulate implements runnable&#123; @override public void run() system.out.println("所有线程解析结束！"); system.out.println("所有线程的解析结果："+result); main(string[] args) throws interruptedexception thread[] threads="new" thread[threadcount]; for(int i="0;i<threadCount;i++)&#123;" threads[i]="new" thread(new parser("parser-"+i)); threads[i].start(); < code></(seed%100*100000);i++)&#123;></code></pre>
</details>

<ul>
<li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。</li>
<li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。</li>
</ul>
<h4 id="Semaphore并发数控制"><a href="#Semaphore并发数控制" class="headerlink" title="Semaphore并发数控制"></a>Semaphore并发数控制</h4><p>限流、多个资源的互斥使用</p>
<details>
<summary>使用示例</summary>
<pre><code>
public class SemaphoreDemo &#123;
    public static void main(String[] args) &#123;
        // 限流：停车位为3，车位满之后，等待车走，再进一个。
        // 多个资源的互斥使用
        Semaphore semaphore = new Semaphore(3);
        for (int i = 1; i <= 6; i++) &#123; new thread(() -> &#123;
                try &#123;
                    //先占一个位
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + "抢到了车位");
                    TimeUnit.SECONDS.sleep(2);
                    System.out.println(Thread.currentThread().getName() + "离开了车位");
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125; finally &#123;
                    // 释放一个位置
                    semaphore.release();
                &#125;
            &#125;, String.valueOf(i)).start();
        &#125;
    &#125;
&#125;
</=></code></pre>
</details>

<p>Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore（10）表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。<br>还可以用tryAcquire()方法尝试获取许可证。</p>
<ul>
<li>int availablePermits()：返回此信号量中当前可用的许可证数。</li>
<li>int getQueueLength()：返回正在等待获取许可证的线程数。</li>
<li>boolean hasQueuedThreads()：是否有线程正在等待获取许可证。</li>
<li>void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。</li>
<li>Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。</li>
</ul>
<h4 id="Exchanger-—-线程数据交换"><a href="#Exchanger-—-线程数据交换" class="headerlink" title="Exchanger — 线程数据交换"></a>Exchanger — 线程数据交换</h4><p>Exchanger用于进行线程间的数据交换。</p>
<p>它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。<br>这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p>
<ul>
<li>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。</li>
<li>Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致.</li>
</ul>
<details>
<summary>使用示例</summary>
<pre><code>
public class ExchangerTest &#123;
    private static final Exchanger<String> exgr = new Exchanger<String>();
    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);
    public static void main(String[] args) &#123;
        threadPool.execute(new Runnable() &#123;
            @Override
            public void run() &#123;
                try &#123;
                    String A = "银行流水100";// A录入银行流水数据
                    String B=exgr.exchange(A);
                    System.out.println("A的视角：A和B数据是否一致：" + A.equals(B) + 
"，A录入的是：" + A + "，B录入是：" + B);
                &#125; catch (InterruptedException e) &#123;
                &#125;
            &#125;
        &#125;);
        threadPool.execute(new Runnable() &#123;
            @Override
            public void run() &#123;
                try &#123;
                    String B = "银行流水200";// B录入银行流水数据
                    String A = exgr.exchange(B);
                    System.out.println("B的视角：A和B数据是否一致：" + A.equals(B) + 
"，A录入的是：" + A + "，B录入是：" + B);
                &#125; catch (InterruptedException e) &#123;
                &#125;
            &#125;
        &#125;);
        threadPool.shutdown();
    &#125;
&#125;
结果：
B的视角：A和B数据是否一致：false，A录入的是：银行流水100，B录入是：银行流水200
A的视角：A和B数据是否一致：false，A录入的是：银行流水100，B录入是：银行流水200
</String></String></code></pre>
</details>

<p>如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长。</p>
</div></article><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a><a class="post-meta__tags" href="/tags/%E9%94%81/">锁</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/02/18/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%99%E4%B8%AA%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%84%BF%E5%8F%AB%E9%94%81/"><i class="fa fa-chevron-left">  </i><span>JAVA并发编程之这个&quot;破玩意儿&quot;叫锁</span></a></div><div class="next-post pull-right"><a href="/2021/12/08/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF/%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B9%8BDebezium%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"><span>增量数据同步之Debezium技术研究</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '83850031ee87c27765eb',
  clientSecret: '6c5e13a8b6670d5bfa85ba548ba3570cae29e671',
  repo: 'blob-comment',
  owner: 'hepeng0',
  admin: 'hepeng0',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By 何鹏 [smile.hepeng@qq.com]</div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>