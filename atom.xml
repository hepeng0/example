<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沉默者</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-23T07:38:57.998Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>何鹏 [smile.hepeng@qq.com]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>事务数据库特性及隔离级别</title>
    <link href="http://example.com/2022/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%B9%E6%80%A7%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://example.com/2022/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%B9%E6%80%A7%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2022-02-23T03:08:57.000Z</published>
    <updated>2022-02-23T07:38:57.998Z</updated>
    
    <content type="html"><![CDATA[<p>说明： 文章转账自<a href="https://www.cnblogs.com/z-sm/p/7245981.html">数据库事务的特性、隔离级别、传播策略</a></p><h2 id="事务ACID特性"><a href="#事务ACID特性" class="headerlink" title="事务ACID特性"></a>事务ACID特性</h2><p>数据库管理系统中事务(transaction)的四个特性（分析时根据首字母缩写依次解释）：</p><ul><li>原子性（Atomicity）</li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持久性（Durability）</li></ul><p>所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。（执行单个逻辑功能的一组指令或操作称为事务）</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性是指事务是一个<strong>不可再分割的工作单元</strong>，事务中的操作要么都发生，要么都不发生。</p><p>可采用“<strong>A向B转账</strong>”这个例子来说明解释。</p><p>在DBMS中，默认情况下<strong>一条SQL就是一个单独事务，事务是自动提交的</strong>。</p><p>只有显式的使用<strong>start transaction</strong>开启一个事务，才能将一个代码块放在事务中执行。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性是指在<strong>事务开始之前和事务结束以后，数据库的完整性约束没有被破坏</strong>。这是说数据库事务不能破坏关系<strong>数据的完整性以及业务逻辑上的一致性</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如A给B转账，不论转账的事务操作是否成功，其两者的存款总额不变（这是业务逻辑的一致性，至于数据库关系约束的完整性就更好理解了）。</span><br></pre></td></tr></table></figure><p>保障机制：</p><ul><li>数据库层面: 在一个事务执行之前和之后，数据符合你设置的约束（唯一约束，外键约束,check约束等)和触发器设置；</li><li>此外: 数据库的内部数据结构（如 B 树索引或双向链表）都必须是正确的。</li></ul><p>业务的一致性一般由开发人员进行保证，亦可转移至数据库层面。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p><strong>多个事务并发访问时，事务之间是隔离的</strong>，一个事务不应该影响其它事务运行效果。</p><p>在并发环境中，当<strong>不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间</strong>。</p><p>由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</p><p>事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，<strong>事务不会查看到中间状态的数据</strong>。</p><p>事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响性能。</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p><p>完成的事务是系统永久的部分，对系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write-Ahead Logging：SQL Server中使用了WAL（Write-Ahead Logging）技术来保证事务日志的ACID特性，在数据写入到数据库之前，先写入到日志，再将日志记录变更到存储器中。</span><br></pre></td></tr></table></figure><h2 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h2><p>当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性。</p><h3 id="不用事务隔离带来的问题"><a href="#不用事务隔离带来的问题" class="headerlink" title="不用事务隔离带来的问题"></a>不用事务隔离带来的问题</h3><h4 id="更新丢失"><a href="#更新丢失" class="headerlink" title="更新丢失"></a>更新丢失</h4><p>此写彼写： 两事务同时更新，一个失败回滚覆盖另一个事务的更新。或事务1执行更新操作，在事务1结束前事务2也更新，则事务1的更新结果被事务2的覆盖了。</p><ul><li>两个事务分别写，然后：都回滚则没问题；</li><li>一回滚一提交 或 都提交 则会出现更新丢失问题<ol><li>更新丢失（Lostupdate）: 两个事务都做更新操作，一个事务回滚会覆盖另一个事务更新的数据，导致更新丢失</li><li>两次更新问题（Secondlost updates problem）: 两个事务都做更新操作，后提交事务者会覆盖先提交者的更新。</li></ol></li></ul><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>此写彼读： 事务T2读取到事务T1修改了但是事务1还未提交的数据，之后事务T1又回滚其更新操作，导致事务T2读到的是脏数据。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>此读彼写： 对于数据库中的某个数据，一个事务内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p><p>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p><p>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主；但在另一些情况下就有可能发生问题，例如对于同一个数据被A和B依次查询得到的结果就可能不同，A和B就可能打起来了……</p><h4 id="幻读-虚读"><a href="#幻读-虚读" class="headerlink" title="幻读/虚读"></a>幻读/虚读</h4><p>此读彼写： 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p><h4 id="各问题区别"><a href="#各问题区别" class="headerlink" title="各问题区别"></a>各问题区别</h4><ul><li><p>脏读和不可重复读的区别：脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p></li><li><p>不可重复读和幻读的异同：都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p></li></ul><h3 id="事务隔离的级别"><a href="#事务隔离的级别" class="headerlink" title="事务隔离的级别"></a>事务隔离的级别</h3><p>为此我们需要通过提供不同类型的“锁”机制针对数据库事务进行不同程度的并发访问控制，由此产生了不同的事务隔离级别：隔离级别（低-&gt;高）。</p><p>SQL、SQL2标准定义了四种隔离级别：</p><h4 id="读未提交（Read-Uncommitted）"><a href="#读未提交（Read-Uncommitted）" class="headerlink" title="读未提交（Read Uncommitted）"></a>读未提交（Read Uncommitted）</h4><p>含义解释：只限制同一数据写事务禁止其他写事务。解决”更新丢失”。（一事务写时禁止其他事务写）</p><p>名称解释：可读取未提交数据</p><p>所需的锁：排他写锁</p><h4 id="读提交（Read-Committed）"><a href="#读提交（Read-Committed）" class="headerlink" title="读提交（Read Committed）"></a>读提交（Read Committed）</h4><p>含义解释：只限制同一数据写事务禁止其它读写事务。解决”脏读”，以及”更新丢失”。（一事务写时禁止其他事务读写）</p><p>名称解释：必须提交以后的数据才能被读取</p><p>所需的锁：排他写锁、瞬间共享读锁</p><h4 id="可重复读（Repeatable-Read）"><a href="#可重复读（Repeatable-Read）" class="headerlink" title="可重复读（Repeatable Read）"></a>可重复读（Repeatable Read）</h4><p>含义解释：限制同一数据写事务禁止其他读写事务，读事务禁止其它写事务(允许读)。解决”不可重复读”，以及”更新丢失”和”脏读”。（一事务写时禁止其他事务读写、一事务读时禁止其他事务写）</p><p>注意没有解决幻读，解决幻读的方法是增加范围锁（range lock）或者表锁。</p><p>名称解释：能够重复读取</p><p>所需的锁：排他写锁、共享读锁</p><h4 id="串行化（Serializable）"><a href="#串行化（Serializable）" class="headerlink" title="串行化（Serializable）"></a>串行化（Serializable）</h4><p>含义解释：限制所有读写事务都必须串行化实行。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。（一事务写时禁止其他事务读写、一事务读时禁止其他事务读写）</p><p>所须的锁：范围锁或表锁</p><h3 id="各隔离级别对各种异常的控制能力"><a href="#各隔离级别对各种异常的控制能力" class="headerlink" title="各隔离级别对各种异常的控制能力"></a>各隔离级别对各种异常的控制能力</h3><table><thead><tr><th></th><th>更新丢失</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>RU(读未提交)</td><td>避免</td><td></td><td></td><td></td></tr><tr><td>RC（读提交）</td><td>避免</td><td>避免</td><td></td><td></td></tr><tr><td>RR（可重复读）</td><td>避免</td><td>避免</td><td>避免</td><td></td></tr><tr><td>S（串行化）</td><td>避免</td><td>避免</td><td>避免</td><td>避免</td></tr></tbody></table><p>四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，数据完整性越好，但执行效率就越低。</p><p>像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。</p><h3 id="常见数据库的默认事务隔离级别"><a href="#常见数据库的默认事务隔离级别" class="headerlink" title="常见数据库的默认事务隔离级别"></a>常见数据库的默认事务隔离级别</h3><table><thead><tr><th>数据库</th><th>默认隔离级别</th><th>备注</th></tr></thead><tbody><tr><td>MySQL</td><td>可重复读（Repeatable Read）</td><td>MySQL的Repeatable Read隔离级别也解决了幻读问题（通过Next-key lock加锁方法即范围锁解决不可重复读和幻读问题，如select * from t where a&gt;10会对key为[10,infinite）范围的行加锁，这样其他事务就不能对此范围内key对应的行更改）达到了SQL、SQL2标准中的Serializable级别。</td></tr><tr><td>Oracle</td><td>读提交（Read Committed）</td><td>只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别</td></tr><tr><td>SQLServer</td><td>读提交（Read Committed）</td><td></td></tr><tr><td>DB2</td><td>读提交（Read Committed）</td><td></td></tr><tr><td>PostgreSQL</td><td>读提交（Read Committed）</td><td></td></tr></tbody></table><p>在MySQL数据库中查看当前事务的隔离级别：</p><pre><code>select @@tx_isolation;</code></pre><p>在MySQL数据库中设置事务的隔离级别：</p><pre><code>set  [glogal | session]  transaction isolation level 隔离级别名称; //设置全部连接或当前连接的事务隔离级别set tx_isolation=’隔离级别名称; //设置当前连接的事务隔离级别</code></pre><p><strong>设置数据库的隔离级别一定要是在开启事务之前！</strong></p><p>如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前链接的隔离级别，至于参数level，可以使用Connection对象的字段：</p><p><img src="/2022/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%B9%E6%80%A7%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/img.png"></p><p>在JDBC中设置隔离级别的部分代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try (Connection conn = JdbcUtils.getConnection()) &#123;</span><br><span class="line">  conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);</span><br><span class="line">  conn.setAutoCommit(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后记：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。</p><h2 id="事务传播"><a href="#事务传播" class="headerlink" title="事务传播"></a>事务传播</h2><p>事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。</p><p>需要注意的是，传播是指一个线程内的传播，不同线程间是没有传播一说的，即不同线程间无法在一个事务内（不然还要事务隔离干嘛），因为他们通常是不同的数据库连接。因此子异步线程事务回滚与否不会影响父线程的事务回滚与否。</p><p>以Spring Transaction为例，在TransactionDefinition接口定义中包括了如下几个表示传播行为的常量（3+3+1）：</p><ul><li>TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</li><li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则新建事务。</li></ul><p>示例可参阅：<a href="https://blog.csdn.net/f641385712/article/details/98642777">https://blog.csdn.net/f641385712/article/details/98642777</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;说明： 文章转账自&lt;a href=&quot;https://www.cnblogs.com/z-sm/p/7245981.html&quot;&gt;数据库事务的特性、隔离级别、传播策略&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;事务ACID特性&quot;&gt;&lt;a href=&quot;#事务ACID特性&quot; class=&quot;he</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据库MySQL系列之MVCC浅探</title>
    <link href="http://example.com/2022/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8BInnoDB%E4%B8%ADMVCC%E6%B5%85%E6%8E%A2/"/>
    <id>http://example.com/2022/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8BInnoDB%E4%B8%ADMVCC%E6%B5%85%E6%8E%A2/</id>
    <published>2022-02-23T03:08:57.000Z</published>
    <updated>2022-02-23T04:21:57.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVCC简介"><a href="#MVCC简介" class="headerlink" title="MVCC简介"></a>MVCC简介</h1><h2 id="MVCC名词解释"><a href="#MVCC名词解释" class="headerlink" title="MVCC名词解释"></a>MVCC名词解释</h2><p>MVCC (Multiversion Concurrency Control)，即多版本并发控制技术。</p><h2 id="MVCC解决了什么问题"><a href="#MVCC解决了什么问题" class="headerlink" title="MVCC解决了什么问题"></a>MVCC解决了什么问题</h2><p>它使得大部分支持行锁的事务引擎（InnoDB,Falcon以及PBXT等），不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来。<br>只需要很小的开销，就可以实现非锁定读，从而大大提高数据库系统的并发性能。</p><h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><ul><li><strong>读锁</strong>：也叫共享锁、S锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li><li><strong>写锁</strong>：又称排他锁、X锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</li><li><strong>表锁</strong>：操作对象是数据表。Mysql大多数锁策略都支持(常见mysql innodb)，是系统开销最低但并发性最低的一个锁策略。事务t对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行。</li><li><strong>行级锁</strong>：操作对象是数据表中的一行。是MVCC技术用的比较多的，但在MYISAM用不了，行级锁用mysql的储存引擎实现而不是mysql服务器。但行级锁对系统开销较大，处理高并发较好。</li></ul><h1 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h1><p>MVCC是通过保存数据在某个时间点的快照来实现的。不同存储引擎的MVCC实现是不同的，典型的有乐观并发控制和悲观并发控制。</p><h2 id="InnoDB-MVCC具体实现分析"><a href="#InnoDB-MVCC具体实现分析" class="headerlink" title="InnoDB MVCC具体实现分析"></a>InnoDB MVCC具体实现分析</h2><p>innodb MVCC主要是为<strong>Repeatable-Read事务隔离级别</strong>做的。在此隔离级别下，A、B客户端所示的数据相互隔离，互相更新不可见。</p><p>innodb存储的最基本row中包含一些额外的存储信息： DATA_TRX_ID，DATA_ROLL_PTR，DB_ROW_ID，DELETE BIT。</p><ul><li>6字节的DATA_TRX_ID 标记了最新更新这条行记录的transaction id，每处理一个事务，其值自动+1；</li><li>7字节的DATA_ROLL_PTR 指向当前记录项的rollback segment的undo log记录，找之前版本的数据就是通过这个指针；</li><li>6字节的DB_ROW_ID，当由innodb自动产生聚集索引时，聚集索引包括这个DB_ROW_ID的值，否则聚集索引中不包括这个值，这个用于索引当中；</li><li>DELETE BIT位用于标识该记录是否被删除，这里的不是真正的删除数据，而是标志出来的删除，真正意义的删除是在commit的时候。</li></ul><p><img src="/2022/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8BInnoDB%E4%B8%ADMVCC%E6%B5%85%E6%8E%A2/img.png" alt="img.png"></p><p>具体的执行过程</p><p>begin-&gt;用排他锁锁定该行-&gt;记录redo log-&gt;记录undo log-&gt;修改当前行的值，写事务编号，回滚指针指向undo log中的修改前的行</p><p>该过程准确说是UPDATE的事务过程，其实undo log分insert和update undo log，因为insert时，原始的数据并不存在，所以回滚时把insert undo log丢弃即可，而update undo log则必须遵守上述过程。</p><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>Innodb检查每行数据，确保他们符合两个标准：</p><ol><li><p>InnoDB只查找版本早于当前事务版本的数据行(也就是数据行的版本必须小于或等于当前事务的版本)，这确保当前事务读取的行要么是事务之前已经存在的，要么是由当前事务创建或修改的；</p></li><li><p>行的删除版本要么未定义,要么大于当前事务版本号,这可以确保事务读取到的行，在事务开始之前未被删除。</p></li></ol><p>只有a,b同时满足的记录，才能返回作为查询结果。</p><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p>InnoDB为新插入的每一行保存当前事务版本号作为版本号。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>InnoDB会为删除的每一行保存当前事务的版本号(事务的ID)作为删除标识。</p><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要UPDATE的行的删除时间。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>insert操作时 “创建时间”=DB_ROW_ID，这时，“删除时间 ”是未定义的；</p><p>update时，复制新增行的“创建时间”=DB_ROW_ID，删除时间未定义，旧数据行“创建时间”不变，删除时间=该事务的DB_ROW_ID；</p><p>delete操作，相应数据行的“创建时间”不变，删除时间=该事务的DB_ROW_ID；</p><p>select操作对两者都不修改，只读相应的数据</p><h1 id="对于MVCC的总结"><a href="#对于MVCC的总结" class="headerlink" title="对于MVCC的总结"></a>对于MVCC的总结</h1><p>上述更新前建立undo log，根据各种策略读取时非阻塞就是MVCC，undo log中的行就是MVCC中的多版本。</p><p>这个可能与我们所理解的MVCC有较大的出入，一般我们认为MVCC有下面几个特点：</p><ul><li>每行数据都存在一个版本，每次数据更新时都更新该版本</li><li>修改时Copy出当前版本随意修改，各个事务之间无干扰 </li><li>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）</li></ul><p>就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道。</p><p>而Innodb的实现方式是：</p><ul><li>事务以排他锁的形式修改原始数据</li><li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li><li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li></ul><p>二者最本质的区别是，当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？ </p><p>Innodb的实现真算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。</p><p>但理想的MVCC是难以实现的，当事务仅修改一行记录使用理想的MVCC模式是没有问题的，可以通过比较版本号进行回滚；但当事务影响到多行数据时，理想的MVCC据无能为力了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。</span><br></pre></td></tr></table></figure><p>理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。</p><p>修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二提交是目前这种场景保证一致性的唯一手段。</p><p>二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVCC简介&quot;&gt;&lt;a href=&quot;#MVCC简介&quot; class=&quot;headerlink&quot; title=&quot;MVCC简介&quot;&gt;&lt;/a&gt;MVCC简介&lt;/h1&gt;&lt;h2 id=&quot;MVCC名词解释&quot;&gt;&lt;a href=&quot;#MVCC名词解释&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MVCC" scheme="http://example.com/tags/MVCC/"/>
    
    <category term="InnoDB" scheme="http://example.com/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程之线程安全及解决方案大纲</title>
    <link href="http://example.com/2022/02/18/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%A4%A7%E7%BA%B2/"/>
    <id>http://example.com/2022/02/18/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%A4%A7%E7%BA%B2/</id>
    <published>2022-02-18T11:32:45.000Z</published>
    <updated>2022-02-23T07:50:11.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要多线程"><a href="#为什么需要多线程" class="headerlink" title="为什么需要多线程"></a>为什么需要多线程</h2><p>线程是Java语言中不可或缺的重要部分，它们能使复杂的异步代码变得简单，简化复杂系统的开发；能充分发挥多处理器系统的强大计算能力。</p><h3 id="多线程优点"><a href="#多线程优点" class="headerlink" title="多线程优点"></a>多线程优点</h3><ol><li><p><strong>充分利用硬件资源</strong>。由于线程是cpu的基本调度单位，所以如果是单线程，那么最多只能同时在一个处理器上运行，意味着其他的CPU资源都将被浪费。而多线程可以同时在多个处理器上运行，只要各个线程间的通信设计正确，那么多线程将能充分利用处理器的资源。</p></li><li><p><strong>结构优雅</strong>。多线程程序能将代码量巨大，复杂的程序分成一个个简单的功能模块，每块实现复杂程序的一部分单一功能，这将会使得程序的建模，测试更加方便，结构更加清晰，更加优雅。</p></li><li><p><strong>简化异步处理</strong>。为了避免阻塞，单线程应用程序必须使用非阻塞I/O,这样的I/O复杂性远远高于同步I/O，并且容易出错。</p></li></ol><h3 id="多线程缺点"><a href="#多线程缺点" class="headerlink" title="多线程缺点"></a>多线程缺点</h3><ol><li><p><strong>线程安全</strong>：由于统一进程下的多个线程是共享同样的地址空间和数据的，又由于线程执行顺序的不可预知性，一个线程可能会修改其他线程正在使用的变量，这一方面是给数据共享带来了便利；另一方面，如果处理不当，会产生脏读，幻读等问题，好在Java提供了一系列的同步机制来帮助解决这一问题，例如内置锁。</p></li><li><p><strong>活跃性问题</strong>。可能会发生长时间的等待锁，甚至是死锁。</p></li><li><p><strong>性能问题</strong>。 线程的频繁调度切换会浪费资源，同步机制会导致内存缓冲区的数据无效，以及增加同步流量。</p></li></ol><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替运行，并且在主调试代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，则称这个类时线程安全的。</p><p>线程安全类中封装了必要的同步机制，因此客户端无须进一步采取同步措施。</p><h3 id="线程安全问题产生的原因"><a href="#线程安全问题产生的原因" class="headerlink" title="线程安全问题产生的原因"></a>线程安全问题产生的原因</h3><p>正确性取决于多个线程的交替执行时序，产生了竞态条件。</p><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>应尽量使用原子类，这样会让你分析线程安全时更加方便，但需要注意的是用线程安全类构建的类并不能保证线程安全。</p><p>例如，一个AtomicInteger get() 和 AtomicInteger set() 是线程安全的，在一个类的一个方法 f()中同时用到了这两个方法，此时的f()就是线程不安全的，因为你不能保证这个复合操作中的get 和 set同时更新。</p><h2 id="线程安全的解决方案"><a href="#线程安全的解决方案" class="headerlink" title="线程安全的解决方案"></a>线程安全的解决方案</h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><ol><li><p>锁能使其保护的代码以串行的形式来访问，当给一个复合操作加锁后，能使其成为原子操作。一种错误的思想是只要对写数据的方法加锁，其实这是错的，对数据进行操作的所有方法都需加锁，不管是读还是写。</p></li><li><p>加锁时需要考虑性能问题，不能总是一味地给整个方法加锁synchronized就了事了，应该将方法中不影响共享状态且执行时间比较长的代码分离出去。</p></li><li><p>加锁的含义不仅仅局限于互斥，还包括可见性。为了确保所有线程都能看见最新值，读操作和写操作必须使用同样的锁对象。</p></li></ol><h3 id="不共享状态"><a href="#不共享状态" class="headerlink" title="不共享状态"></a>不共享状态</h3><ol><li><p>无状态对象： 无状态对象一定是线程安全的，因为不会影响到其他线程。</p></li><li><p>线程关闭： 仅在单线程环境下使用。</p></li></ol><h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><p>可以使用final修饰的对象保证线程安全，由于final修饰的引用型变量(除String外)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，也即不能对外提供可以修改final对象的接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么需要多线程&quot;&gt;&lt;a href=&quot;#为什么需要多线程&quot; class=&quot;headerlink&quot; title=&quot;为什么需要多线程&quot;&gt;&lt;/a&gt;为什么需要多线程&lt;/h2&gt;&lt;p&gt;线程是Java语言中不可或缺的重要部分，它们能使复杂的异步代码变得简单，简化复杂系统的开发；</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程之这个&quot;破玩意儿&quot;叫锁</title>
    <link href="http://example.com/2022/02/18/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%99%E4%B8%AA%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%84%BF%E5%8F%AB%E9%94%81/"/>
    <id>http://example.com/2022/02/18/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%99%E4%B8%AA%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%84%BF%E5%8F%AB%E9%94%81/</id>
    <published>2022-02-18T11:32:45.000Z</published>
    <updated>2022-02-23T10:05:41.588Z</updated>
    
    <content type="html"><![CDATA[<p>说明： 转载自<a href="https://mp.weixin.qq.com/s/PL-oTc5J_pe5Oyb8mdltjQ">中间件兴趣圈-你管这“破玩意儿”叫锁</a></p><h2 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h2><p>首先以一个非常常见的生活场景举例，例如一个三口之家居住在一个二房一厅的房子里，只有一个卫生间，早上一起床，大家都有抢卫生间，这里就会发生： 一人在如厕，其他人排队等待的场景。</p><p>这个场景下有如下几个关键的特征：</p><ul><li>独占 “厕所“作为一个资源，在任意时刻只能被一个人占用，为了实现该效果，使用资源之前，需要先获得与该资源关联的锁</li><li>当多个线程都需要访问该资源时，必须先获得锁，而且在同一时刻有且只会有一个线程获得锁，那没有获得锁的线程就需要排队等待。是一直等，还是等得不耐烦时就放弃？</li><li>当有多人排队时，一个线程将锁释放后，交给谁？什么样的策略？</li></ul><p>上面是最常见的锁应用场景，有一个非常响亮的名称：<strong>互斥锁、排它锁</strong>。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>在java领域中，实现互斥锁通常有两种方式：</p><ul><li>synchronized</li><li>ReentrantLock</li></ul><p>互斥锁的基本语义：</p><table><thead><tr><th>语义</th><th>说明</th><th>ReentrantLock</th><th>synchronized</th></tr></thead><tbody><tr><td>可重入性</td><td>一个线程获取锁后，没有释放之前，继续申请</td><td>支持</td><td>支持</td></tr><tr><td>锁只能被锁的拥有者释放</td><td><strong>基于redis实现分布式锁时，要特别注意这个特质</strong></td><td>——</td><td>——</td></tr><tr><td>中断</td><td>申请锁时是否支持被中断</td><td>调用lockInterruptibly方法，可以支持线程中断，即停止继续申请锁</td><td>不支持</td></tr><tr><td>公平锁或非公平锁</td><td>当拥有锁的线程释放锁后，锁的下一个获取者就是锁等待队列中的第一个元素</td><td>支持</td><td>不支持</td></tr></tbody></table><h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>与互斥锁相对应的是共享锁，所谓的共享锁是<strong>同一时间可以被多个线程共同申请</strong>，一个非常经典的使用场景就是<strong>读写锁</strong>。</p><p>例如在一个缓存场景，在一个商品系统中，为了提供对商品的访问性能，通常会引入一个缓存区(Map)来缓存商品的数据，缓存数据对查询请求(读请求)是可以并行执行的，即多个线程同时查询缓存区的数据，这个是一个非常安全的操作，但不允许多个线程对缓存区进行修改。这里共享锁的意义就发挥出来了。</p><p>既然多个线程对缓存区可以同时进行读操作，那为什么还要加共享锁呢？主要的目的是<strong>避免写操作与读操作同时进行</strong>。</p><p>只要当前有读操作在进行，写操作就需要排队，请看如下示例图：<br><img src="/2022/02/18/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%99%E4%B8%AA%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%84%BF%E5%8F%AB%E9%94%81/img.png"><br>如上图所示：例如 线程T1,T2,T3连续申请共享锁，然后T4申请写锁，再T5申请读锁，那各个线程的并发执行情况如下所示：</p><ul><li>线程 T1、T2、T3 将并发执行</li><li>T4由于是申请的写锁，必须等 T1、T2、T3释放锁后，才能执行。</li><li>T5虽然申请是共享锁，但由于T4持有写锁，故T5也需要阻塞，直至T4释放锁。</li></ul><p>在Java等世界中按<strong>锁的排斥性</strong>来分基本就包含<strong>排它锁与共享锁</strong>，其他读写锁、间隙锁等是以锁的粒度这个纬度进行细分。</p><h2 id="锁的实现原理"><a href="#锁的实现原理" class="headerlink" title="锁的实现原理"></a>锁的实现原理</h2><p>从某种意义上来说，锁的实现原理就是两个队列：<strong>同步阻塞队列、条件等待队列</strong>。</p><h3 id="同步阻塞队列"><a href="#同步阻塞队列" class="headerlink" title="同步阻塞队列"></a>同步阻塞队列</h3><p>阻塞队列的作用说明如下图所示：</p><p><img src="/2022/02/18/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%99%E4%B8%AA%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%84%BF%E5%8F%AB%E9%94%81/img_1.png"></p><p>上面使用synchronized，其传入的是一个锁对象，如果此时有5个线程同时去执行这段代码，由于锁的互斥性，同一时间只有一个线程能获得锁，<strong>其他线程需要排队等待</strong>，故需要引入一个队列来存储在这些排队的线程，所以<strong>synchronized的实现机制中，会在锁对象中开辟一个队列，用来存储等待获取当前锁的线程</strong>。</p><h3 id="条件等待队列"><a href="#条件等待队列" class="headerlink" title="条件等待队列"></a>条件等待队列</h3><p>Object对象中有一对特殊的方法：wait()/notify()/notifyAll()，消费者/生产者中示例中，使用过wait,notify方法，示例代码如下：</p><p><img src="/2022/02/18/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%99%E4%B8%AA%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%84%BF%E5%8F%AB%E9%94%81/img_2.png"></p><p>wait方法必须在synchronized中调用，并且通常是<strong>线程调用锁对象的wait方法</strong>，表示当前继续往下执行的条件不足，当前线程需要等待，故需要为锁对象再维护一个个队列，用来存储等待的线程，俗称条件等待队列。</p><p>当其他线程调用锁对象的notify方法或notifyAll方法，会唤醒等待队列中的线程。</p><pre><code>温馨提示： Object.wait方法，会使当前线程进入等待状态，并且释放锁。通常条件等待会使用while语句，避免条件不满足时被误唤醒，故使用while对条件进行再一次的判断。当被唤醒后，并不立即去执行while条件判断，而是需要重新去申请锁，即可能会进入到阻塞队列。</code></pre><h2 id="锁的优化思路"><a href="#锁的优化思路" class="headerlink" title="锁的优化思路"></a>锁的优化思路</h2><p>大家都对锁很敏感，因为性能低下，但锁肯定有其存在的原因，主要解决<strong>数据访问的安全性</strong></p><p>大家可能会感到惊讶，作为一款高性能的消息中间件(RocketMQ)，在消息写入时也使用了锁，其代码如下:</p><p><img src="/2022/02/18/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%99%E4%B8%AA%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%84%BF%E5%8F%AB%E9%94%81/img_3.png"></p><p>这是因为RocketMQ是顺序写文件，多个请求同时申请写一个文件，必须排队执行，否则会带来逻辑异常，此时锁是不用不行了。</p><p>对锁的优化策略，通常基于如下原则：</p><ul><li>能不用锁就不使用锁，</li><li>必须使用锁则尽量保证被锁包裹代码的快速执行</li><li>降低锁的粒度。</li></ul><h3 id="优化锁执行时间"><a href="#优化锁执行时间" class="headerlink" title="优化锁执行时间"></a>优化锁执行时间</h3><p>当然能不用锁就不用锁，但有些场景是必须使用锁来保证多线程环境下结果的正确性。</p><p>就以RocketMQ顺序写commitlog文件为例，对同一个文件写入，需要记录当前的写入位置，然后另外一个线程就进行追加，故这个为写入位置是多线程不安全的，故必须引入锁。</p><p>那RocketMQ作为一款高性能的消息中间件，是如何做到消息发送的高并发，低延迟能力低呢？</p><p>核心法宝：<strong>控制锁的范围，确保被锁包含的代码执行性能高效</strong>，接下来我们看一下RocketMQ消息写入的几个重要步骤：</p><p><img src="/2022/02/18/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%99%E4%B8%AA%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%84%BF%E5%8F%AB%E9%94%81/img_4.png"></p><p>并不是需要将上述三个步骤都加锁，而是只对写内存这段加锁即可，这段代码非常高效。</p><h3 id="优化锁的粒度"><a href="#优化锁的粒度" class="headerlink" title="优化锁的粒度"></a>优化锁的粒度</h3><p>锁的性能优化是一个永恒的主旨，另外一个核心思路是：<strong>降低锁的粒度，提高并发度</strong>。</p><p>接下来我们以JDK中的HashTable与ConcurrentHashMap的实现原理为例，让大家体会一下如何降低锁的粒度从而提高并发度。</p><p>Hashtable的性能低下是众所周知，因为整个容器就一把锁，因为它的get、put都是被synchronized修饰，synchronized用来修饰非static方法，其锁对象为Hashtable是对象锁。</p><ul><li>并发度：同一时间只有一个线程能向该容器添加数据、获取数据。</li></ul><p>而jkd1.7及其版本，ConcurrentHashMap的内部数据结构如下图所示：</p><p><img src="/2022/02/18/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%99%E4%B8%AA%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%84%BF%E5%8F%AB%E9%94%81/img_5.png"></p><p>可以看出ConcurrentHashMap的设计思路是将整个HashMap分割成多个小的HashMap，然后为每一个HashMap加锁，从而降低锁的粒度，从而提高并发度。</p><p>在JDK1.8及版本后，ConcurrentHashMap的存储结构又发了很大改变，摒弃分段思想，使用来数组 + Node ，进一步释放读写的并发度，其数据结构如下图所示：</p><p><img src="/2022/02/18/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%99%E4%B8%AA%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%84%BF%E5%8F%AB%E9%94%81/img_6.png"></p><p>其中，对每一个链表的Node节点，写操作时会加锁，但在查询时候，并不会对各个Node加锁，提高读操作的并发度；并且会基于CAS机制实现无锁化处理，使用volatile保证可见性。</p><h3 id="无锁化设计"><a href="#无锁化设计" class="headerlink" title="无锁化设计"></a>无锁化设计</h3><p>锁的存在必然有其使用场景，特别是需要<strong>被锁保护的资源众多</strong>，即临界区中的逻辑复杂，对其进行拆分会使代码变的臃肿，直接使用锁保护会清晰明了，但评估是否需要引入锁时需要慎重，特别是一些对吞吐量有极高要求的场景，能不用锁就不要用锁.</p><p><strong>无锁化设计的基础：CAS，比较和交换。</strong></p><p>在Java领域也提供了对应的原子操作工具：CAS</p><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。</p><ul><li>如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。</li><li>否则，处理器不做任何操作。</li><li>*CAS是CPU指令级命令**。</li></ul><p>CAS简单使用示例如下：</p><p><img src="/2022/02/18/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%99%E4%B8%AA%E7%A0%B4%E7%8E%A9%E6%84%8F%E5%84%BF%E5%8F%AB%E9%94%81/img_7.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;说明： 转载自&lt;a href=&quot;https://mp.weixin.qq.com/s/PL-oTc5J_pe5Oyb8mdltjQ&quot;&gt;中间件兴趣圈-你管这“破玩意儿”叫锁&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;锁的种类&quot;&gt;&lt;a href=&quot;#锁的种类&quot; class=&quot;header</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA并发编程之这个&quot;破玩意儿&quot;叫锁</title>
    <link href="http://example.com/2022/02/15/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%80%9A%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/02/15/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%80%9A%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2022-02-15T12:28:17.000Z</published>
    <updated>2022-02-23T10:50:36.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a>Java多线程</h2><h3 id="线程-amp-程序-amp-进程"><a href="#线程-amp-程序-amp-进程" class="headerlink" title="线程&amp;程序&amp;进程"></a>线程&amp;程序&amp;进程</h3><ul><li>进程: 程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。<ul><li>各进程相互独立</li></ul></li><li>线程：比进程更小的执行单位。<ul><li>同类的多个线程共享进程的堆和方法区资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多。</li><li>每个线程有自己的程序计数器、虚拟机栈和本地方法栈。</li><li>同一进程中的线程极有可能会相互影响。</li></ul></li></ul><h3 id="线程基本状态"><a href="#线程基本状态" class="headerlink" title="线程基本状态"></a>线程基本状态</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。<br><img src="/2022/02/15/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%80%9A%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java线程状态"></p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：<br><img src="/2022/02/15/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%80%9A%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/Java%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java线程状态变迁"></p><ul><li>线程创建之后它将处于 NEW（新建） 状态</li><li>调用 start() 方法后开始运行，线程这时候处于 READY（可运行） 状态。</li><li>可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 RUNNING（运行） 状态。</li><li>当线程执行 wait()方法之后，线程进入 WAITING（等待）状态， 进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态</li><li>而 TIME_WAITING(超时等待) 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。</li><li>当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。</li><li>当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 BLOCKED（阻塞） 状态。</li><li>线程在执行 Runnable 的run()方法之后将会进入到 TERMINATED（终止） 状态。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态，所以 Java 系统一般将这两个状态统称为 RUNNABLE（运行中） 状态 。</span><br></pre></td></tr></table></figure><h3 id="sleep-amp-wait"><a href="#sleep-amp-wait" class="headerlink" title="sleep&amp;wait"></a>sleep&amp;wait</h3><p>两者最主要的区别在于：sleep 方法没有释放锁，而 wait 方法释放了锁 。<br>两者都可以暂停线程的执行。</p><ul><li>Wait 通常被用于线程间交互/通信，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法, 可以使用 wait(long timeout)超时后线程会自动苏醒。</li><li>sleep 通常被用于暂停执行, 线程会自动苏醒。</li></ul><h3 id="start-amp-run"><a href="#start-amp-run" class="headerlink" title="start() &amp; run()"></a>start() &amp; run()</h3><ul><li>new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。</li><li>start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</li><li>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</li></ul><h2 id="Java锁"><a href="#Java锁" class="headerlink" title="Java锁"></a>Java锁</h2><h3 id="从对象头看锁实现原理"><a href="#从对象头看锁实现原理" class="headerlink" title="从对象头看锁实现原理"></a>从对象头看锁实现原理</h3><h4 id="对象头转换过程"><a href="#对象头转换过程" class="headerlink" title="对象头转换过程"></a>对象头转换过程</h4><p><img src="/2022/02/15/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%80%9A%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/markword.png" alt="markword"></p><ul><li><p>对象未加锁的时候，lock标志位为01，包含哈希值、年龄分代和偏向锁标志位等，此时偏向锁标志位为0；</p></li><li><p>当对象被施加偏向锁时，哈希值和一部分无用内存会转化为锁主人的线程信息，以及加锁的时间戳epoch，此时lock标志位没变，偏向锁为1，也就是说，偏向锁和lock标志位共同决定是否偏向锁状态。</p><p>偏向锁的加锁步骤：</p><ul><li>Load-and-test，也就是简单判断一下当前线程id是否与Markword当中的线程id是否一致.</li><li>如果一致，则说明此线程已经成功获得了锁，继续执行下面的代码.</li><li>如果不一致，则要检查一下对象是否还是可偏向，即“是否偏向锁”标志位的值。</li><li>如果还未偏向，则利用CAS操作来竞争锁，也即是第一次获取锁时的操作。</li></ul></li><li><p>当发生锁竞争时，偏向锁会变为轻量级锁，这时需要先将偏向锁进行锁撤销，这一步骤也会消耗不少的性能，轻量级锁的Mark Word中，lock标志位为00，其余内容被替换为一个指针，指向了栈里面的锁记录。</p><p>锁撤销的过程如下：</p><ul><li>在一个安全点停止拥有锁的线程。</li><li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。</li><li>唤醒当前线程，将当前锁升级成轻量级锁。</li></ul><p>所以，如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭</p><p>轻量级锁的加锁步骤：</p><ul><li>线程在自己的栈桢中创建锁记录LockRecord。</li><li>将锁对象的对象头中的MarkWord复制到线程的刚刚创建的锁记录中。</li><li>将锁记录中的Owner指针指向锁对象。</li><li>将锁对象的对象头的MarkWord替换为指向锁记录的指针。</li></ul><p>轻量级锁主要有两种：自旋锁和自适应自旋锁。自旋锁会导致空耗CPU且很可能锁不公平；自适应是指根据上一次该线程是否成功或者多久获取过该锁设置旋转次数，若上次失败很可能直接进入重量级锁</p></li><li><p>如果竞争线程增多，锁继续膨胀，变为重量级锁，也是互斥锁，即synchronized，其lock标志位为10，Mark Word其余内容被替换为一个指向对象监视器Monitor的指针。</p></li><li><p>特殊的是，如果此对象已经被GC标记过，lock会变为11，不含其余内容。</p></li></ul><h4 id="Monitor对象"><a href="#Monitor对象" class="headerlink" title="Monitor对象"></a>Monitor对象</h4><p>每个对象都有一个Monitor对象相关联，Monitor对象中记录了持有锁的线程信息、等待队列等。Monitor对象包含以下三个字段：</p><ul><li>_owner 记录当前持有锁的线程</li><li>_EntryList 是一个队列，记录所有阻塞等待锁的线程</li><li>_WaitSet 也是一个队列，记录调用 wait() 方法并还未被通知的线程</li></ul><p>当线程持有锁的时候，线程id等信息会拷贝进owner字段，其余线程会进入阻塞队列entrylist，当持有锁的线程执行wait方法，会立即释放锁进入waitset，当线程释放锁的时候，owner会被置空，公平锁条件下，entrylist中的线程会竞争锁，竞争成功的线程id会写入owner，其余线程继续在entrylist中等待。</p><h4 id="Monitor与Synchronized"><a href="#Monitor与Synchronized" class="headerlink" title="Monitor与Synchronized"></a>Monitor与Synchronized</h4><ul><li>对于Synchronized的同步代码块，JVM会在进入代码块之前加上monitorenter ，如果进入monitor成功，线程便获取了锁，一个对象的monitor同一时刻只能被一个线程锁占有；</li><li>对于同步方法，JVM会讲方法设置 ACC_SYNCHRONIZED 标志，调用的时候 JVM 根据这个标志判断是否是同步方法。</li><li>采用Synchronized给对象加锁会使线程阻塞，因而会造成线程状态的切换，而线程状态的切换必须要操作系统来执行，因此需要将用户态切换为内核态，这个切换的过程是十分耗时的都需要操作系统来帮忙，有可能比用户执行代码的时间还要长。</li></ul><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><p>JVM级别的锁，它在不断被优化着，从目前来看Synchronized已经远没有以前那么“重”了，也大概就是JUC包源码（如ConcurrentHashMap）中大量使用Synchronized的原因吧。</p><p><img src="/2022/02/15/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%80%9A%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/Java%20Synchronized.png" alt="java syschronized"></p><h3 id="偏向锁、轻量级锁、重量级锁"><a href="#偏向锁、轻量级锁、重量级锁" class="headerlink" title="偏向锁、轻量级锁、重量级锁"></a>偏向锁、轻量级锁、重量级锁</h3><p><a href="https://www.cnblogs.com/cxuanBlog/p/11684390.html">看完你就明白的锁系列之锁的状态</a></p><p><a href="https://www.jianshu.com/p/36eedeb3f912">浅谈偏向锁、轻量级锁、重量级锁</a></p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>内置锁在Java中被抽象为监视器锁（monitor），在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。<br>这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。<br>因此，后来称这种锁为“重量级锁”。</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>内核态与用户态的切换上不容易优化。但通过自旋锁，可以<em><strong>减少线程阻塞造成的线程切换（包括挂起线程和恢复线程）</strong></em>。</p><ul><li>当前线程竞争锁失败时，打算阻塞自己</li><li>不直接阻塞自己，而是自旋（空等待，比如一个空的有限for循环）一会</li><li>在自旋的同时重新竞争锁</li><li>如果自旋结束前获得了锁，那么锁获取成功；否则，自旋结束后阻塞自己</li></ul><p>如果在自旋的时间内，锁就被旧owner释放了，那么当前线程就不需要阻塞自己（也不需要在未来锁释放时恢复），减少了一次线程切换。</p><ul><li><p>单核处理器上，不存在实际的并行，当前线程不阻塞自己的话，旧owner就不能执行，锁永远不会释放，此时不管自旋多久都是浪费；进而，如果线程多而处理器少，自旋也会造成不少无谓的浪费。</p></li><li><p>自旋锁要占用CPU，如果是计算密集型任务，这一优化通常得不偿失，减少锁的使用是更好的选择。</p></li><li><p>如果锁竞争的时间比较长，那么自旋通常不能获得锁，白白浪费了自旋占用的CPU时间。这通常发生在锁持有时间长，且竞争激烈的场景中，此时应主动禁用自旋锁。</p><pre><code>使用-XX:-UseSpinning参数关闭自旋锁优化；-XX:PreBlockSpin参数修改默认的自旋次数。</code></pre></li></ul><h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p>自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定.</p><ul><li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。</li><li>相反的，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。</li></ul><p>自适应自旋解决的是“锁竞争时间不确定”的问题。<em>自适应自旋假定不同线程持有同一个锁对象的时间基本相当，竞争程度趋于稳定，因此，可以根据上一次自旋的时间与结果调整下一次自旋的时间。</em></p><ul><li>如果默认的自旋次数设置不合理（过高或过低），那么自适应的过程将很难收敛到合适的值。</li></ul><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。</p><ul><li>使用轻量级锁时，不需要申请互斥量，仅仅将Mark Word中的部分字节CAS更新指向线程栈中的Lock Record</li><li>如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁</li><li>否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。</li></ul><p>由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，自旋失败后再膨胀为重量级锁。</p><ul><li>如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁，那么维持轻量级锁的过程就成了浪费。</li></ul><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗。</p><ul><li>“偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁）</li><li>因此，只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空）</li><li>如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁</li><li>否则，说明有其他线程竞争，膨胀为轻量级锁。</li></ul><p>偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定</p><ul><li>如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁。</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。</li><li>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。</li><li>重量级锁：有实际竞争，且锁竞争时间长。</li></ul><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性。</p><details><summary>使用</summary><pre><code>public class Printer  &#123;     private Lock lock = new ReentrantLock();// 锁对象       public void printLetters(char c) &#123;         lock.lock();// 得到锁           try &#123;             for(int i = 0; i<5; i++) &#123; system.out.print(c); &#125; system.out.println(); &#125;finally lock.unlock(); 释放锁 < code></5;></code></pre></details><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><p>创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p><ul><li>Thread 类中有一个 threadLocals 和 一个  inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap;</li><li>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</li><li>同一个线程中声明了两个 ThreadLocal 对象的话，会使用 Thread内部都是使用仅有那个ThreadLocalMap 存放数据的，ThreadLocalMap的 key 就是 ThreadLocal对象，value 就是 ThreadLocal 对象调用set方法设置的值。</li><li>ThreadLocalMap是ThreadLocal的静态内部类。</li></ul><h4 id="ThreadLocal-内存泄露问题"><a href="#ThreadLocal-内存泄露问题" class="headerlink" title="ThreadLocal 内存泄露问题"></a>ThreadLocal 内存泄露问题</h4><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。</p><p>所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后最好手动调用remove()方法。</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h4><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h4 id="Runnable-amp-Callable"><a href="#Runnable-amp-Callable" class="headerlink" title="Runnable&amp;Callable"></a>Runnable&amp;Callable</h4><p>Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 Runnable 接口，这样代码看起来会更加简洁。</p><h4 id="execute-amp-submit"><a href="#execute-amp-submit" class="headerlink" title="execute() &amp; submit()"></a>execute() &amp; submit()</h4><ul><li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li>submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li></ul><h3 id="Atomic原子类"><a href="#Atomic原子类" class="headerlink" title="Atomic原子类"></a>Atomic原子类</h3><h4 id="AtomicInteger使用示例"><a href="#AtomicInteger使用示例" class="headerlink" title="AtomicInteger使用示例"></a>AtomicInteger使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">      <span class="comment">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  count.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> count.get();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AtomicInteger线程安全原理"><a href="#AtomicInteger线程安全原理" class="headerlink" title="AtomicInteger线程安全原理"></a>AtomicInteger线程安全原理</h4><p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><h3 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p><pre><code>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</code></pre><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure><p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h4><ul><li>Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li>Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock</li></ul><p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。</p><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><ul><li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li><li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ul><p>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。</span><br><span class="line">tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span><br><span class="line">tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span><br><span class="line">tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span><br><span class="line">tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span><br></pre></td></tr></table></figure><p>这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484832&amp;idx=1&amp;sn=f902febd050eac59d67fc0804d7e1ad5&source=41#wechat_redirect">并发编程面试必备：AQS 原理以及 AQS 同步组件总结</a></p><h3 id="同步辅助类"><a href="#同步辅助类" class="headerlink" title="同步辅助类"></a>同步辅助类</h3><p><img src="/2022/02/15/JAVA%E5%9F%BA%E7%A1%80/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%80%9A%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E8%BE%85%E5%8A%A9%E7%B1%BB.png" alt="并发辅助类"></p><h4 id="CountDownLatch-–-减计数器"><a href="#CountDownLatch-–-减计数器" class="headerlink" title="CountDownLatch – 减计数器"></a>CountDownLatch – 减计数器</h4><p>允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。</p><details>    <summary>使用示例</summary>    <pre><code>public class CountDownLatchDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        //定义：允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。        //用途：1.一个CountDownLatch为一个计数的CountDownLatch用作一个简单的开/关锁存器，或者门：        //      所有线程调用await在门口等待，直到被调用countDown()的线程打开。        //     2.一个CountDownLatch初始化N可以用来做一个线程等待，直到N个线程完成某项操作，或某些动作已经完成N次        CountDownLatch countDownLatch = new CountDownLatch(20);        for (int i=1 ;i<=20;i++)&#123; new thread(()->&#123;                countDownLatch.countDown();                System.out.println(Thread.currentThread().getName()+">="+countDownLatch.getCount());            //&#125;,String.valueOf(i)).start();        &#125;        // 特性：它不要求调用countDown线程等待计数到达零之前继续，        // 它只是阻止任何线程通过await ，直到所有线程可以通过。        System.out.println("我可以在Await方法之前执行");        countDownLatch.await();        System.out.println("我为什么在最后执行呢");    &#125;&#125;</=20;i++)&#123;></code></pre></details><p>CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。<br>当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。<br>如果有某个解析sheet的线程处理得比较慢，我们不可能让主线程一直等待，所以可以使用另外一个带指定时间的await方法——await（long time，TimeUnit unit），这个方法等待特定时间后，就会不再阻塞当前线程。join也有类似的方法。</p><ul><li>计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会阻塞当前线程</li><li>CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值</li><li>一个线程调用countDown方法happen-before，另外一个线程调用await方法</li></ul><details><summary>源码</summary><pre><code>public class CountDownLatch &#123;    /**Synchronization control For CountDownLatch. Uses AQS state to represent count.*/    private static final class Sync extends AbstractQueuedSynchronizer &#123;        private static final long serialVersionUID = 4982264981922014374L;        Sync(int count) &#123;            setState(count);//初始化同步状态        &#125;        int getCount() &#123;            return getState();        &#125;        protected int tryAcquireShared(int acquires) &#123;            return (getState() == 0) ? 1 : -1;        &#125;        protected boolean tryReleaseShared(int releases) &#123;            // Decrement count; signal when transition to zero            for (;;) &#123;                int c = getState();                if (c == 0)                    return false;                int nextc = c-1;                if (compareAndSetState(c, nextc))                    return nextc == 0;            &#125;        &#125;    &#125;    private final Sync sync;//组合一个同步器（AQS）    public CountDownLatch(int count) &#123;        if (count < 0) throw new IllegalArgumentException("count < 0");        this.sync = new Sync(count);//初始化同步状态    &#125;    /*Causes the current thread to wait until the latch has counted down to     * zero, unless the thread is &#123;@linkplain Thread#interrupt interrupted&#125;.*/    public void await() throws InterruptedException &#123;        sync.acquireSharedInterruptibly(1);//    &#125;    public boolean await(long timeout, TimeUnit unit)        throws InterruptedException &#123;        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));    &#125;    public void countDown() &#123;        sync.releaseShared(1);//释放同步状态    &#125;    public long getCount() &#123;        return sync.getCount();    &#125;    public String toString() &#123;        return super.toString() + "[Count = " + sync.getCount() + "]";    &#125;&#125;</code></pre></details><h4 id="CyclicBarrier-–-加计数器"><a href="#CyclicBarrier-–-加计数器" class="headerlink" title="CyclicBarrier – 加计数器"></a>CyclicBarrier – 加计数器</h4><p>等待多个操作完成，再执行下一步</p><details>    <summary>使用示例</summary>    <pre><code>public class CyclicBarrierDemo &#123;    public static void main(String[] args) throws BrokenBarrierException, InterruptedException &#123;        //适用需等待多个操作完成，再执行下一步        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()->&#123;            System.out.println("舍利子集齐成功，如来重生");        &#125;);        for (int i=1;i<=7;i++)&#123; int finali="i;" new thread(()->&#123;                System.out.println(Thread.currentThread().getName()+"：收集了"+ finalI +"颗");                try &#123;                    //等待，舍利子集齐，一起向下执行                    cyclicBarrier.await();                    System.out.println("无天必须在如来重生之后，再死");                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125; catch (BrokenBarrierException e) &#123;                    e.printStackTrace();                &#125;            &#125;).start();        &#125;    &#125;&#125;    </=7;i++)&#123;></code></pre></details><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>可循环使用（Cyclic）的屏障（Barrier）。<br>它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><p>CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p><details><summary>使用示例</summary><pre><code>import java.util.Random; import java.util.concurrent.CyclicBarrier;import java.util.concurrent.atomic.AtomicInteger;public class CyclicBarrierTest &#123;    private static Random sr=new Random(47);     private static AtomicInteger result=new AtomicInteger(0);    private static int threadCount=10;    //屏障后面执行汇总    private static CyclicBarrier barrier=new CyclicBarrier(threadCount,new Accumulate());    private static class Parser implements Runnable&#123;         String name;        public Parser(String name)&#123;            this.name=name;        &#125;        @Override        public void run() &#123;            int sum=0;            int seed=Math.abs(sr.nextInt()) ;            Random r=new Random(47);             for(int i=0;i<(seed%100*100000);i++)&#123; sum+="r.nextInt(seed);" &#125; result.addandget(sum); system.out.println(system.currenttimemillis()+"-"+name+"线程的解析结果："+sum); try &#123; barrier.await(); system.out.println(system.currenttimemillis()+"-"+name+"线程越过屏障！"); catch (exception e) e.printstacktrace(); static class accumulate implements runnable&#123; @override public void run() system.out.println("所有线程解析结束！"); system.out.println("所有线程的解析结果："+result); main(string[] args) throws interruptedexception thread[] threads="new" thread[threadcount]; for(int i="0;i<threadCount;i++)&#123;" threads[i]="new" thread(new parser("parser-"+i)); threads[i].start(); < code></(seed%100*100000);i++)&#123;></code></pre></details><ul><li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。</li><li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。</li></ul><h4 id="Semaphore并发数控制"><a href="#Semaphore并发数控制" class="headerlink" title="Semaphore并发数控制"></a>Semaphore并发数控制</h4><p>限流、多个资源的互斥使用</p><details><summary>使用示例</summary><pre><code>public class SemaphoreDemo &#123;    public static void main(String[] args) &#123;        // 限流：停车位为3，车位满之后，等待车走，再进一个。        // 多个资源的互斥使用        Semaphore semaphore = new Semaphore(3);        for (int i = 1; i <= 6; i++) &#123; new thread(() -> &#123;                try &#123;                    //先占一个位                    semaphore.acquire();                    System.out.println(Thread.currentThread().getName() + "抢到了车位");                    TimeUnit.SECONDS.sleep(2);                    System.out.println(Thread.currentThread().getName() + "离开了车位");                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125; finally &#123;                    // 释放一个位置                    semaphore.release();                &#125;            &#125;, String.valueOf(i)).start();        &#125;    &#125;&#125;</=></code></pre></details><p>Semaphore的构造方法Semaphore（int permits）接受一个整型的数字，表示可用的许可证数量。Semaphore（10）表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。<br>还可以用tryAcquire()方法尝试获取许可证。</p><ul><li>int availablePermits()：返回此信号量中当前可用的许可证数。</li><li>int getQueueLength()：返回正在等待获取许可证的线程数。</li><li>boolean hasQueuedThreads()：是否有线程正在等待获取许可证。</li><li>void reducePermits（int reduction）：减少reduction个许可证，是个protected方法。</li><li>Collection getQueuedThreads()：返回所有等待获取许可证的线程集合，是个protected方法。</li></ul><h4 id="Exchanger-–-线程数据交换"><a href="#Exchanger-–-线程数据交换" class="headerlink" title="Exchanger – 线程数据交换"></a>Exchanger – 线程数据交换</h4><p>Exchanger用于进行线程间的数据交换。</p><p>它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。<br>这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p><ul><li>Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。</li><li>Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致.</li></ul><details><summary>使用示例</summary><pre><code>public class ExchangerTest &#123;    private static final Exchanger<String> exgr = new Exchanger<String>();    private static ExecutorService threadPool = Executors.newFixedThreadPool(2);    public static void main(String[] args) &#123;        threadPool.execute(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    String A = "银行流水100";// A录入银行流水数据                    String B=exgr.exchange(A);                    System.out.println("A的视角：A和B数据是否一致：" + A.equals(B) + "，A录入的是：" + A + "，B录入是：" + B);                &#125; catch (InterruptedException e) &#123;                &#125;            &#125;        &#125;);        threadPool.execute(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    String B = "银行流水200";// B录入银行流水数据                    String A = exgr.exchange(B);                    System.out.println("B的视角：A和B数据是否一致：" + A.equals(B) + "，A录入的是：" + A + "，B录入是：" + B);                &#125; catch (InterruptedException e) &#123;                &#125;            &#125;        &#125;);        threadPool.shutdown();    &#125;&#125;结果：B的视角：A和B数据是否一致：false，A录入的是：银行流水100，B录入是：银行流水200A的视角：A和B数据是否一致：false，A录入的是：银行流水100，B录入是：银行流水200</String></String></code></pre></details><p>如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java多线程&quot;&gt;&lt;a href=&quot;#Java多线程&quot; class=&quot;headerlink&quot; title=&quot;Java多线程&quot;&gt;&lt;/a&gt;Java多线程&lt;/h2&gt;&lt;h3 id=&quot;线程-amp-程序-amp-进程&quot;&gt;&lt;a href=&quot;#线程-amp-程序-amp-进程&quot;</summary>
      
    
    
    
    <category term="并发" scheme="http://example.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="并发" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>增量数据同步之Debezium技术研究</title>
    <link href="http://example.com/2021/12/08/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF/%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B9%8BDebezium%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    <id>http://example.com/2021/12/08/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%8A%80%E6%9C%AF/%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B9%8BDebezium%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/</id>
    <published>2021-12-08T02:12:37.000Z</published>
    <updated>2021-12-09T03:22:18.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见关系型数据库数据同步思路"><a href="#常见关系型数据库数据同步思路" class="headerlink" title="常见关系型数据库数据同步思路"></a>常见关系型数据库数据同步思路</h2><h3 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h3><h4 id="JDBC-Batch"><a href="#JDBC-Batch" class="headerlink" title="JDBC-Batch"></a>JDBC-Batch</h4><p>分页查询源端的表，然后通过 jdbc的batch 方式插入到目标表</p><p>需要注意的是，分页查询时，一定要按照主键id来排序分页，避免重复插入。</p><h4 id="数据文件导出导入"><a href="#数据文件导出导入" class="headerlink" title="数据文件导出导入"></a>数据文件导出导入</h4><p>一般只适用于同种数据库之间的同步，如果是不同的数据库，这种方式可能会存在问题。</p><h3 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常见关系型数据库数据同步思路&quot;&gt;&lt;a href=&quot;#常见关系型数据库数据同步思路&quot; class=&quot;headerlink&quot; title=&quot;常见关系型数据库数据同步思路&quot;&gt;&lt;/a&gt;常见关系型数据库数据同步思路&lt;/h2&gt;&lt;h3 id=&quot;全量同步&quot;&gt;&lt;a href=&quot;#全</summary>
      
    
    
    
    <category term="实用工具" scheme="http://example.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="数据同步" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ初探之整体设计简介</title>
    <link href="http://example.com/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/</id>
    <published>2021-12-01T05:33:56.000Z</published>
    <updated>2022-02-23T04:35:21.043Z</updated>
    
    <content type="html"><![CDATA[<p>说明： 文章转账自<a href="https://www.cnblogs.com/weifeng1463/p/12889300.html">RocketMQ之一：RocketMQ整体介绍</a></p><h2 id="什么是RocketMQ"><a href="#什么是RocketMQ" class="headerlink" title="什么是RocketMQ"></a>什么是RocketMQ</h2><p>RocketMQ 是阿里巴巴开源的分布式消息中间件。</p><p>支持:</p><ul><li>事务消息<ul><li>对于分布式事务来说提供了又一种解决思路。</li></ul></li><li>顺序消息：<ul><li>保证消息消费者按照消息发送的顺序对消息进行消费。</li><li>分为全局有序和局部有序</li><li>一般推荐使用局部有序，即生产者通过将某一类消息按顺序发送至同一个队列来实现</li></ul></li><li>批量消息</li><li>定时消息</li><li>消息回溯<ul><li>指消费者已经消费成功的消息，由于业务上需求需要重新消费</li><li>RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯。</li></ul></li></ul><p>它里面有几个区别于标准消息中件间的概念，如</p><ul><li>Group</li><li>Topic</li><li>Queue</li></ul><p>系统组成由</p><ul><li>Producer</li><li>Consumer</li><li>Broker</li><li>NameServer</li></ul><h3 id="RocketMQ特点"><a href="#RocketMQ特点" class="headerlink" title="RocketMQ特点"></a>RocketMQ特点</h3><ul><li>一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式等特点</li><li>Producer、Consumer、队列都可以分布式</li><li>Producer 向一些队列轮流发送消息，队列集合称为 Topic<ul><li>Consumer 如果做广播消费，则一个 Consumer 实例消费这个 Topic 对应的所有队列</li><li><font color="#FF0000">如果做集群消费，则多个 Consumer 实例平均消费这个 Topic 对应的队列集合</font><ul><li>如何实现平均消费？</li></ul></li></ul></li><li>能够保证严格的消息顺序</li><li>支持 <font color="#FF0000">拉（pull）和推（push）两种消息模式</font></li><li>高效的订阅者水平扩展能力</li><li>实时的消息订阅机制</li><li>亿级消息堆积能力，堆积了这么多消息后依然保持写入低延迟</li><li>支持多种消息协议，如 JMS、OpenMessaging 等</li><li>较少的依赖</li></ul><h2 id="RocketMQ概念解读"><a href="#RocketMQ概念解读" class="headerlink" title="RocketMQ概念解读"></a>RocketMQ概念解读</h2><h3 id="RocketMQ核心概念"><a href="#RocketMQ核心概念" class="headerlink" title="RocketMQ核心概念"></a>RocketMQ核心概念</h3><p>消息队列 RocketMQ 在任何一个环境都是可扩展的，生产者必须是一个集群，消息服务器必须是一个集群，消费者也同样。</p><p>集群级别的高可用，是消息队列 RocketMQ 跟其他的消息服务器的主要区别，消息生产者发送一条消息到消息服务器，消息服务器会<font color="#FF0000">随机的选择一个消费者</font><br>，只要这个消费者消费成功就认为是成功了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：文中所提及的消息队列 RocketMQ 的服务端或者服务器包含 Name Server、Broker 等。服务端不等同于 Broker。</span><br></pre></td></tr></table></figure><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112011406.png"></p><p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成。</p><p>其中：</p><ul><li>Producer 负责生产消息，<ul><li>同步<ul><li>指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包</li><li>一般用于重要通知消息，例如重要通知邮件、营销短信。</li></ul></li><li>异步<ul><li>发送方发出数据后，不等接收方发回响应，接着发送下个数据包</li><li>一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。</li></ul></li><li>单向</li></ul></li><li>Consumer 负责消费消息，<ul><li>ConsumerGroup 由多个 Consumer 实例构成。</li></ul></li><li>Broker 负责存储消息。<ul><li>Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。</li><li>Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。</li></ul></li></ul><p>图中所涉及到的概念如下所述：</p><h4 id="Name-Server-名称服务充当路由消息的提供者。"><a href="#Name-Server-名称服务充当路由消息的提供者。" class="headerlink" title="Name Server: 名称服务充当路由消息的提供者。"></a>Name Server: 名称服务充当路由消息的提供者。</h4><p>一个几乎无状态节点，可集群部署，节点之间无任何信息同步。在消息队列 RocketMQ 中提供命名服务，更新和发现 Broker 服务。</p><p><strong>两个功能</strong></p><ul><li>接收broker的请求，注册broker的路由信息</li><li>接收client（producer/consumer）的请求，根据某个topic获取其到broker的路由信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NameServer没有状态，可以横向扩展。</span><br><span class="line"></span><br><span class="line">每个broker在启动的时候会到NameServer注册； Producer在发送消息前会根据topic到NameServer获取路由(到broker)信息； </span><br><span class="line">Consumer也会定时获取topic路由信息。</span><br><span class="line"></span><br><span class="line">无信息同步如何实现数据持久化</span><br></pre></td></tr></table></figure><h4 id="Broker：消息中转角色，负责存储消息，转发消息。"><a href="#Broker：消息中转角色，负责存储消息，转发消息。" class="headerlink" title="Broker：消息中转角色，负责存储消息，转发消息。"></a>Broker：消息中转角色，负责存储消息，转发消息。</h4><p>Broker可以理解为消息队列服务器，提供了消息的接收、存储、拉取和转发服务。 它是RocketMQ的核心，<font color="#FF0000">需要保证broker的高可用</font>。</p><ul><li>broker分为 Master Broker 和 Slave Broker，一个 Master Broker 可以对应多个 Slave Broker，但是一个 Slave Broker<br>只能对应一个 Master Broker。</li><li>Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。</li><li>每个Broker与Name Server集群中的所有节点建立长连接，定时注册Topic信息到所有Name Server。Broker 启动后需要完成一次将自己注册至 Name Server<br>的操作；随后每隔 30s 定期向 Name Server 上报 Topic 路由信息。<ul><li>如果Master挂了，需要30s才能被Name Server感知</li></ul></li></ul><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>与 Name Server 集群中的其中一个节点（随机）建立长链接（Keep-alive），定期从 Name Server 读取 Topic 路由信息，并向提供 Topic 服务的 Master<br>Broker 建立长链接，且定时向 Master Broker 发送心跳。</p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>与 Name Server 集群中的其中一个节点（随机）建立长连接，定期从 Name Server 拉取 Topic 路由信息，并向提供 Topic 服务的 Master Broker、Slave<br>Broker 建立长连接，且定时向 Master Broker、Slave Broker 发送心跳。</p><p>Consumer 既可以从 Master Broker 订阅消息，也可以从 Slave Broker 订阅消息，订阅规则由 Broker 配置决定。</p><h3 id="Topic、Queue、tags"><a href="#Topic、Queue、tags" class="headerlink" title="Topic、Queue、tags"></a>Topic、Queue、tags</h3><p>RocketMQ的Topic/Queue和JMS中的Topic/Queue概念有一定的差异:</p><ul><li>JMS中所有消费者都会消费一个Topic消息的副本，而Queue中消息只会被一个消费者消费；</li><li><strong>RocketMQ中Topic只代表普通的消息队列，而Queue是组成Topic的更小单元</strong>。</li></ul><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p>表示消息的第一级类型，比如一个电商系统的消息可以分为：交易消息、物流消息…… 一条消息必须有一个Topic。</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>主题被划分为一个或多个子主题，称为“message queues”。一个topic下，我们可以设置多个queue(消息队列)。</p><p>当我们发送消息时，需要要指定该消息的topic。RocketMQ会轮询该topic下的所有队列，将消息发送出去。</p><p><strong>定义： Queue是Topic在一个Broker上的分片，在分片基础上再等分为若干份（可指定份数）后的其中一份，是负载均衡过程中资源分配的基本单元。</strong></p><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112011721.png"></p><p>集群消费模式下一个消费者只消费该Topic中部分Queue中的消息，当一个消费者开启广播模式时则会消费该Topic下所有Queue中的消息。</p><h4 id="Tags"><a href="#Tags" class="headerlink" title="Tags"></a>Tags</h4><p>Tags是Topic下的次级消息类型/二级类型（注：Tags也支持TagA || TagB这样的表达式），可以在同一个Topic下基于Tags进行消息过滤。</p><p>Tags的过滤需要经过两次比对，首先会在Broker端通过Tag hashcode进行一次比对过滤，匹配成功传到consumer端后再对具体Tags进行比对，以防止Tag hashcode重复的情况。</p><p>比如交易消息又可以分为：交易创建消息，交易完成消息….. 一条消息可以没有Tag。</p><p>RocketMQ提供2级消息分类，方便大家灵活控制。标签，换句话说，为用户提供了额外的灵活性。有了标签，来自同一个业务模块的不同目的的消息可能具有相同的主题和不同的标签。标签将有助于保持您的代码干净和连贯，并且标签还可以为RocketMQ提供的查询系统提供帮助。</p><p>Queue中具体的存储单元结构如下图，最后面的8个Byte存储Tag信息。</p><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112011726.png"></p><p>具体参考<a href="https://www.cnblogs.com/duanxz/p/5020398.html">RocketMQ消息存储</a></p><h3 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h3><h4 id="Producer-amp-amp-Producer-Group"><a href="#Producer-amp-amp-Producer-Group" class="headerlink" title="Producer &amp;&amp; Producer Group"></a>Producer &amp;&amp; Producer Group</h4><p>Producer表示消息队列的生产者。消息队列的本质就是实现了pub/sub模式，生产者生产消息，消费者消费消息。</p><ul><li>所以这里的Producer就是用来生产和发送消息的，一般指业务系统。</li><li>RocketMQ提供了发送：普通消息（同步、异步和单向（one-way）消息）、定时消息、延时消息、事务消息。</li></ul><p>Producer Group是一类Producer的集合名称，这类Producer通常发送一类消息，且发送逻辑一致。相同角色的生产者被分组在一起。</p><ul><li>同一生产者组的另一个生产者实例可能被broker联系，以提交或回滚事务，以防原始生产者在交易后崩溃。</li></ul><p><font color="#FF0000">警告： 考虑提供的生产者在发送消息时足够强大，每个生产者组只允许一个实例，以避免对生产者实例进行不必要的初始化。</font></p><h4 id="Consumer-amp-amp-Consumer-Group"><a href="#Consumer-amp-amp-Consumer-Group" class="headerlink" title="Consumer &amp;&amp; Consumer Group"></a>Consumer &amp;&amp; Consumer Group</h4><p>Consumer: 消息消费者，一般由业务后台系统异步的消费消息。</p><ul><li>Push Consumer： Consumer 的一种，应用通常向 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调 Listener<br>接口方法。</li><li>Pull Consumer： Consumer 的一种，应用通常主动调用 Consumer 的拉消息方法从 Broker 拉消息，主动权由应用控制。</li></ul><p>Consumer Group： Consumer Group是一类Consumer的集合名称，这类Consumer通常消费一类消息，且消费逻辑一致(使用相同 Group ID<br>的订阅者属于同一个集群。同一个集群下的订阅者消费逻辑必须完全一致（包括 Tag 的使用），这些订阅者在逻辑上可以认为是一个消费节点)。</p><ul><li>消费者群体是一个伟大的概念，它实现了负载平衡和容错的目标，在信息消费方面，是非常容易的。</li></ul><p><font color="#FF0000">警告： 消费者群体的消费者实例<strong>必须</strong>订阅完全相同的主题。</font></p><h2 id="RocketMQ组件关系"><a href="#RocketMQ组件关系" class="headerlink" title="RocketMQ组件关系"></a>RocketMQ组件关系</h2><h3 id="Broker-amp-amp-Producer-amp-amp-Consumer"><a href="#Broker-amp-amp-Producer-amp-amp-Consumer" class="headerlink" title="Broker &amp;&amp; Producer &amp;&amp; Consumer"></a>Broker &amp;&amp; Producer &amp;&amp; Consumer</h3><p>如果不考虑负载均衡和高可用，最简单的Broker，Producer和Consumer之间的关系如下图所示：</p><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112011748.png"></p><h3 id="Topic-amp-amp-Topic分片-amp-amp-Queue"><a href="#Topic-amp-amp-Topic分片-amp-amp-Queue" class="headerlink" title="Topic &amp;&amp; Topic分片 &amp;&amp; Queue"></a>Topic &amp;&amp; Topic分片 &amp;&amp; Queue</h3><p>从本质上来说，RocketMQ中的Queue是数据分片的产物。 为了更好地理解Queue的定义，我们还需要引入一个新的概念：Topic分片。</p><p>在分布式数据库和分布式缓存领域，分片概念已经有了清晰的定义。</p><p>同理，对于RocketMQ，一个Topic可以分布在各个Broker上，我们可以把一个Topic分布在一个Broker上的子集定义为一个Topic分片。</p><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112011757.png"></p><p>对应上图，TopicA有3个Topic分片，分布在Broker1,Broker2和Broker3上，TopicB有2个Topic分片，分布在Broker1和Broker2上，TopicC有2个Topic分片，分布在Broker2和Broker3上。</p><p><strong>将Topic分片再切分为若干等分，其中的一份就是一个Queue</strong></p><p>每个Topic分片等分的Queue的数量可以不同，由用户在创建Topic时指定。</p><p>数据分片的主要目的是突破单点的资源（网络带宽，CPU，内存或文件存储）限制从而实现水平扩展。 RocketMQ<br>在进行Topic分片以后，已经达到水平扩展的目的了，为什么还需要进一步切分为Queue呢？</p><p>解答这个问题还需要从<strong>负载均衡</strong>说起。以消息消费为例，借用Rocket MQ官方文档中的Consumer负载均衡示意图来说明：</p><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112021307.png"></p><p>如图所示，TOPIC_A在一个Broker上的Topic分片有5个Queue，一个Consumer<br>Group内有2个Consumer按照集群消费的方式消费消息，按照平均分配策略进行负载均衡得到的结果是：第一个 Consumer 消费3个Queue，第二个Consumer<br>消费2个Queue。如果增加Consumer，每个Consumer分配到的Queue会相应减少。</p><p>Rocket MQ的负载均衡策略规定：Consumer数量应该小于等于Queue数量，如果Consumer超过Queue数量，那么多余的Consumer 将不能消费消息。</p><p>在一个Consumer<br>Group内，Queue和Consumer之间的对应关系是一对多的关系：一个Queue最多只能分配给一个Consumer，一个Cosumer可以分配得到多个Queue。这样的分配规则，每个Queue只有一个消费者，可以避免消费过程中的多线程处理和资源锁定，有效提高各Consumer消费的并行度和处理效率。</p><p>由此，我们可以给出Queue的定义：</p><p>Queue是Topic在一个Broker上的分片等分为指定份数后的其中一份，是负载均衡过程中资源分配的基本单元。</p><h4 id="Queue数量指定方式"><a href="#Queue数量指定方式" class="headerlink" title="Queue数量指定方式"></a>Queue数量指定方式</h4><ul><li><p>代码指定</p><ul><li>producer.setDefaultTopicQueueNums(8);</li></ul></li><li><p>配置文件指定</p><ul><li>同时设置broker服务器的配置文件broker.properties：defaultTopicQueueNums=16</li></ul></li><li><p>rocket-console控制台指定</p><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112011801.png"></p></li></ul><h2 id="RocketMQ发布订阅大体流程"><a href="#RocketMQ发布订阅大体流程" class="headerlink" title="RocketMQ发布订阅大体流程"></a>RocketMQ发布订阅大体流程</h2><ol><li><p>producer生产者连接nameserver，产生数据放入不同的topic；</p></li><li><p>对于RocketMQ，一个Topic可以分布在各个Broker上，我们可以把一个Topic分布在一个Broker上的子集定义为一个Topic分片；</p></li><li><p>将Topic分片再切分为若干等分，其中的一份就是一个Queue。每个Topic分片等分的Queue的数量可以不同，由用户在创建Topic时指定。</p></li><li><p>consumer消费者连接nameserver，根据broker分配的Queue来消费数据。</p></li></ol><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112021312.png"></p><h2 id="消息分类"><a href="#消息分类" class="headerlink" title="消息分类"></a>消息分类</h2><h3 id="发送类型分类"><a href="#发送类型分类" class="headerlink" title="发送类型分类"></a>发送类型分类</h3><h4 id="同步消息"><a href="#同步消息" class="headerlink" title="同步消息"></a>同步消息</h4><p>指消息发送方发出数据后，<strong>会阻塞直到MQ服务方发回响应消息</strong>。</p><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112021324.png"></p><p>应用场景：此种方式应用场景非常广泛，例如重要通知邮件、报名短信通知、营销短信系统等。</p><p>关键代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SendResult sendResult = producer.send(msg);</span><br></pre></td></tr></table></figure><h4 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h4><p>发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</p><p><strong>MQ<br>的异步发送，需要用户实现异步发送回调接口（SendCallback），在执行消息的异步发送时，应用不需要等待服务器响应即可直接返回，通过回调接口接收服务器响应，并对服务器的响应结果进行处理。</strong></p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112021327.png" class><p>应用场景：异步发送一般用于链路耗时较长，对 RT 响应时间较为敏感的业务场景，例如用户视频上传后通知启动转码服务，转码完成后通知推送转码结果等。</p><p>关键代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.sendAsync(msg, new SendCallback() &#123;//...&#125;);</span><br></pre></td></tr></table></figure><h4 id="单向消息"><a href="#单向消息" class="headerlink" title="单向消息"></a>单向消息</h4><p>只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求不等待应答。</p><p><strong>此方式发送消息的过程耗时非常短，一般在微秒级别。但是可能存在数据丢失</strong></p><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112021330.png"></p><p>应用场景：适用于某些耗时非常短，但对可靠性要求并不高的场景，例如日志收集。</p><p>关键代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.sendOneway(msg);</span><br></pre></td></tr></table></figure><h3 id="按照功能使用划分"><a href="#按照功能使用划分" class="headerlink" title="按照功能使用划分"></a>按照功能使用划分</h3><h4 id="普通消息-amp-amp-顺序消息"><a href="#普通消息-amp-amp-顺序消息" class="headerlink" title="普通消息 &amp;&amp; 顺序消息"></a>普通消息 &amp;&amp; 顺序消息</h4><h4 id="广播消息"><a href="#广播消息" class="headerlink" title="广播消息"></a>广播消息</h4><h4 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h4><h5 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h5><p>定时消息，单位毫秒（ms），在指定时间戳（当前时间之后）进行投递</p><p>核心代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 例如 2016-03-07 16:21:00 投递。</span><br><span class="line">// 如果被设置成当前时间戳之前的某个时刻，消息将立刻投递给消费者。    </span><br><span class="line">long timeStamp = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).parse(&quot;2016-03-07 16:21:00&quot;).getTime();    </span><br><span class="line">msg.setStartDeliverTime(timeStamp);​    </span><br><span class="line">// 发送消息，只要不抛异常就是成功    </span><br><span class="line">SendResult sendResult = producer.send(msg);   </span><br></pre></td></tr></table></figure><h5 id="延时消息-1"><a href="#延时消息-1" class="headerlink" title="延时消息"></a>延时消息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Message sendMsg = new Message(topic, tags, message.getBytes());</span><br><span class="line">sendMsg.setDelayTimeLevel(delayLevel);</span><br><span class="line">// 默认3秒超时</span><br><span class="line">SendResult sendResult = rocketMQProducer.send(sendMsg);</span><br></pre></td></tr></table></figure><h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>RocketMQ提供类似X/Open XA的分布式事务功能来确保业务发送方和MQ消息的最终一致性。</p><p><strong>其本质是通过半消息(prepare消息和commit消息)的方式把分布式事务放在MQ端来处理</strong>。</p><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112031329.png"></p><p>其中：</p><ol><li>发送方向消息队列 RocketMQ 服务端发送消息。</li><li>服务端将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功，此时消息为半消息。</li><li>发送方开始执行本地事务逻辑。</li><li>发送方根据本地事务执行结果向服务端提交二次确认（Commit 或是 Rollback），服务端收到 Commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；服务端收到 Rollback<br>状态则删除半消息，订阅方将不会接受该消息。</li></ol><p>补偿流程：</p><ol start="5"><li>在断网或者是应用重启的特殊情况下，上述步骤 4 提交的二次确认最终未到达服务端，经过固定时间后服务端将对该消息发起消息回查。</li><li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li><li>发送方根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤 4 对半消息进行操作。</li></ol><p><strong><font color="#FF0000">RocketMQ的半消息机制的注意事项是</font></strong></p><ol><li>根据第六步可以看出他要求发送方提供业务回查接口。</li><li>不能保证发送方的消息幂等，在ack没有返回的情况下，可能存在重复消息</li><li>消费方要做幂等处理。</li></ol><h2 id="发布订阅模型"><a href="#发布订阅模型" class="headerlink" title="发布订阅模型"></a>发布订阅模型</h2><p>在RocketMQ中，producer发布消息，consumer订阅消息。消息的收发模型如下图：</p><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112031342.png"></p><h3 id="producer端消息发布原理"><a href="#producer端消息发布原理" class="headerlink" title="producer端消息发布原理"></a>producer端消息发布原理</h3><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112031345.png"></p><p>producer完全无状态，可以集群部署。</p><h3 id="consumer端消息获取模式（push-pull）"><a href="#consumer端消息获取模式（push-pull）" class="headerlink" title="consumer端消息获取模式（push/pull）"></a>consumer端消息获取模式（push/pull）</h3><p>consumer有两种消息的获取模式</p><ul><li>Push模式，即MQServer主动向消费端推送；</li><li>Pull模式，即消费端在需要时，主动到MQServer拉取。</li></ul><p>实际实现中： <strong>Push和Pull模式都是采用消费端主动拉取的方式</strong>。</p><p>消费端的Push模式是通过长轮询的模式来实现的：</p><ul><li>Consumer端每隔一段时间主动向broker发送拉消息请求，broker在收到Pull请求后<ul><li>如果有消息就立即返回数据，Consumer端收到返回的消息后，再回调消费者设置的Listener方法。</li><li>消息队列里没有数据，broker端会阻塞请求直到有数据传递或超时才返回。</li></ul></li><li>当然，Consumer端是通过一个线程将阻塞队列LinkedBlockingQueue<PullRequest>中的PullRequest发送到broker拉取消息，以防止Consumer一致被阻塞。</PullRequest></li><li>而Broker端，在接收到Consumer的PullRequest时，如果发现没有消息，就会把PullRequest扔到ConcurrentHashMap中缓存起来。</li><li>broker在启动时，会启动一个线程不停的从ConcurrentHashMap取出PullRequest检查，直到有数据返回。</li></ul><h3 id="consumer端消息消费模式-集群-广播"><a href="#consumer端消息消费模式-集群-广播" class="headerlink" title="consumer端消息消费模式(集群/广播)"></a>consumer端消息消费模式(集群/广播)</h3><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>消息队列 RocketMQ 是基于发布/订阅模型的消息系统。消息的订阅方订阅关注的 Topic，以获取并消费消息。</p><p>由于订阅方应用一般是分布式系统，以集群方式部署有多台机器。</p><h4 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h4><p>使用相同 Group ID 的订阅者属于同一个集群。同一个集群下的订阅者消费逻辑必须完全一致（包括 Tag 的使用），这些订阅者在逻辑上可以认为是一个消费节点。</p><p>当使用集群消费模式时，消息队列 RocketMQ 认为任意一条消息只需要被集群内的任意一个消费者处理即可。</p><p>一个Consumer Group中的Consumer实例平均分摊消费消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如某个Topic有 9 条消息，其中一个Consumer Group有 3 个实例(可能是 3 个进程,或者 3 台机器)，那么每个实例只消费其中的 3 条消息。</span><br></pre></td></tr></table></figure><h5 id="使用场景-amp-amp-注意事项"><a href="#使用场景-amp-amp-注意事项" class="headerlink" title="使用场景 &amp;&amp; 注意事项"></a>使用场景 &amp;&amp; 注意事项</h5><ul><li>消费端集群化部署，每条消息只需要被处理一次。</li><li>由于消费进度在服务端维护，可靠性更高。</li><li>集群消费模式下，<strong>每一条消息都只会被分发到一台机器上处理</strong>。如果需要被集群下的每一台机器都处理，请使用广播模式。</li><li>集群消费模式下，<strong>不保证每一次失败重投的消息路由到同一台机器上</strong>，因此处理消息时不应该做任何确定性假设。</li></ul><h4 id="广播消费"><a href="#广播消费" class="headerlink" title="广播消费"></a>广播消费</h4><p>当使用广播消费模式时，消息队列 RocketMQ 会将每条消息推送给集群内所有注册过的客户端，保证消息至少被每台机器消费一次。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一条消息被多个Consumer消费，即使这些Consumer属于同一个Consumer Group，消息也会被Consumer Group中的每个Consumer都消费一次。</span><br></pre></td></tr></table></figure><p><strong>在广播消费中的Consumer Group概念可以认为在消息划分方面无意义</strong>。</p><h5 id="使用场景-amp-amp-注意事项-1"><a href="#使用场景-amp-amp-注意事项-1" class="headerlink" title="使用场景 &amp;&amp; 注意事项"></a>使用场景 &amp;&amp; 注意事项</h5><ul><li>广播消费模式下<strong>不支持顺序消息</strong>。</li><li>广播消费模式下<strong>不支持重置消费位点</strong>。</li><li>每条消息都需要被相同逻辑的多台机器处理。</li><li>消费进度在客户端维护，出现重复的概率稍大于集群模式。</li><li>广播模式下，消息队列 RocketMQ 保证每条消息至少被每台客户端消费一次，但是并<strong>不会对消费失败的消息进行失败重投</strong>，因此业务方需要关注消费失败的情况。</li><li>广播模式下，客户端每一次重启都会从最新消息消费。<strong>客户端在被停止期间发送至服务端的消息将会被自动跳过</strong>，请谨慎选择。</li><li>广播模式下，每条消息都会被大量的客户端重复处理，因此推荐尽可能使用集群模式。</li><li>目前仅 Java 客户端支持广播模式。</li><li>广播模式下服务端不维护消费进度，所以消息队列 RocketMQ 控制台<strong>不支持消息堆积查询、消息堆积报警和订阅关系查询功能</strong>。</li></ul><h4 id="使用集群模式模拟广播"><a href="#使用集群模式模拟广播" class="headerlink" title="使用集群模式模拟广播"></a>使用集群模式模拟广播</h4><p>如果业务需要使用广播模式，也可以创建多个 Group ID，用于订阅同一个 Topic。</p><h5 id="适用场景-amp-amp-注意事项"><a href="#适用场景-amp-amp-注意事项" class="headerlink" title="适用场景 &amp;&amp; 注意事项"></a>适用场景 &amp;&amp; 注意事项</h5><ul><li>每条消息都需要被多台机器处理，每台机器的逻辑可以相同也可以不一样。</li><li>消费进度在服务端维护，可靠性高于广播模式。</li><li>对于一个 Group ID 来说，可以部署一个消费端实例，也可以部署多个消费端实例。 <ul><li>当部署多个消费端实例时，实例之间又组成了集群模式（共同分担消费消息）。</li><li>假设 Group ID 1 部署了三个消费者实例 C1、C2、C3，那么这三个实例将共同分担服务器发送给 Group ID 1 的消息。 </li><li>实例之间订阅关系必须保持一致。</li></ul></li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="生产端负载均衡"><a href="#生产端负载均衡" class="headerlink" title="生产端负载均衡"></a>生产端负载均衡</h3><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112031427.png"></p><p>首先分析一下RocketMQ的客户端发送消息的源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DefaultMQProducer defaultMQProducer = new DefaultMQProducer(&quot;ProducerGroupName&quot;);</span><br><span class="line">// 初始化Producer， 整个生命周期只需要一次</span><br><span class="line">producer.start();</span><br><span class="line">// 构造Message</span><br><span class="line">Message msg = new Message(&quot;Topic&quot;, &quot;TagA&quot;, &quot;key&quot;, &quot;aaaaaaaa&quot;.getBytes());</span><br><span class="line">// 发送消息并返回结果</span><br><span class="line">SendResult sendResult = producer.send(msg);</span><br><span class="line">// 清理资源、关闭网络、注销自己</span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure><p>在整个应用生命周期内，生产者需要调用一次start方法来初始化，初始化主要完成的任务有：</p><ul><li>如果没有指定namesrv地址，将会自动寻址</li><li>启动定时任务<ul><li>更新namesrv地址</li><li>从namsrv更新topic路由信息</li><li>清理已经挂掉的broker</li><li>向所有broker发送心跳…</li></ul></li><li>启动负载均衡的服务</li></ul><p>初始化完成后，开始发送消息，发送消息的主要代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">privete SendResult sendDefaultImpl(Message msg, .....) &#123;</span><br><span class="line">  // 检查Producer状态是否Running</span><br><span class="line">  this.makesureStateOK();</span><br><span class="line">  // 检查msg是否合法，是否为null, topic、body是否为空，body是否超长</span><br><span class="line">  Validators.checkMessage(msg, this.defaultMQProducer);</span><br><span class="line">  // 获取路由信息</span><br><span class="line">  TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">  // 从路由中悬着一个消息队列</span><br><span class="line">  MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, info);</span><br><span class="line">  // </span><br><span class="line">  sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中需要关注的两个方法tryToFindTopicPublishInfo和selectOneMessageQueue。</p><ul><li>前面说过在producer初始化时，会启动定时任务获取路由信息并更新到本地缓存，所以tryToFindTopicPublishInfo会首先从缓存中获取topic路由信息，如果没有获取到，则会自己去namesrv获取路由信息。</li><li>selectOneMessageQueue方法通过轮询的方式，返回一个队列，以达到负载均衡的目的。</li></ul><p>如果Producer发送消息失败，会自动重试，重试的策略：</p><ul><li>重试次数 &lt; retryTimesWhenSendFailed（可配置）</li><li>总的耗时（包含重试n次的耗时） &lt; sendMsgTimeout（发送消息时传入的参数）</li><li>同时满足上面两个条件后，Producer会选择另外一个队列发送消息</li></ul><h3 id="消费端负载均衡"><a href="#消费端负载均衡" class="headerlink" title="消费端负载均衡"></a>消费端负载均衡</h3><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112031500.png"></p><p>producer向一些队列轮流发送消息，队列集合称为Topic：</p><ul><li>Consumer如果做广播消费，则一个consumer实例消费这个Topic对应的所有队列；</li><li>如果做集群消费，则多个Consumer实例平均消费这个Topic对应的队列集合</li></ul><p>集群模式里，每个consumer消费部分消息，这里的负载均衡是怎样的呢:</p><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/RocketMQ/RocketMQ%E5%88%9D%E6%8E%A2%E4%B9%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E7%AE%80%E4%BB%8B/202112031503.png"></p><p>消费端会通过RebalanceService线程，20秒钟做一次基于topic下的所有队列负载：</p><ul><li>遍历Consumer下的所有topic，然后根据topic订阅所有的消息</li><li>获取同一topic和Consumer Group下的所有Consumer</li><li>然后根据具体的分配策略来分配消费队列，分配的策略包含：平均分配、消费端配置等</li></ul><p>如同上图所示：如果有 3 个队列，2 个 consumer，那么第一个 Consumer 消费 2 个队列，第二 consumer 消费 1 个队列。这里采用的就是平均分配策略，它类似于我们的分页，TOPIC下面的所有queue就是记录，Consumer的个数就相当于总的页数，那么每页有多少条记录，就类似于某个Consumer会消费哪些队列。</p><p>通过这样的策略来达到大体上的平均消费，这样的设计也可以很方面的水平扩展Consumer来提高消费能力。</p><h2 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h2><ul><li>单Master模式：无需多言，一旦单个broker重启或宕机，一切都结束了！。</li><li>多Master模式：全是Master，没有Slave。<ul><li>当然，一个broker宕机了，应用是无影响的</li><li>缺点在于宕机的Master上未被消费的消息在Master没有恢复之前不可以订阅。</li></ul></li><li>多Master多Slave模式（异步复制）：多对Master-Slave，高可用！<ul><li>采用异步复制的方式，主备之间短暂延迟，MS级别。</li><li>Master宕机，消费者可以从Slave上进行消费，不受影响。</li><li>但是Master的宕机，会导致丢失掉极少量的消息。</li></ul></li><li>多Master多Slave模式（同步双写）：在Master/Slave都写成功的前提下，向应用返回成功<ul><li>不论是数据，还是服务都没有单点，都非常可靠！</li><li>缺点在于同步的性能比异步稍低。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;说明： 文章转账自&lt;a href=&quot;https://www.cnblogs.com/weifeng1463/p/12889300.html&quot;&gt;RocketMQ之一：RocketMQ整体介绍&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是RocketMQ&quot;&gt;&lt;a href=&quot;#什么是</summary>
      
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="消息中间件" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="MQ" scheme="http://example.com/tags/MQ/"/>
    
    <category term="RocketMQ" scheme="http://example.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>MQ详解及四大常用MQ对比</title>
    <link href="http://example.com/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/MQ%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%9B%9B%E5%A4%A7%E5%B8%B8%E7%94%A8MQ%E5%AF%B9%E6%AF%94/"/>
    <id>http://example.com/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/MQ%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%9B%9B%E5%A4%A7%E5%B8%B8%E7%94%A8MQ%E5%AF%B9%E6%AF%94/</id>
    <published>2021-12-01T05:14:56.000Z</published>
    <updated>2021-12-01T05:14:44.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息队列概述"><a href="#消息队列概述" class="headerlink" title="消息队列概述"></a>消息队列概述</h2><h3 id="消息队列使用场景及其优缺点"><a href="#消息队列使用场景及其优缺点" class="headerlink" title="消息队列使用场景及其优缺点"></a>消息队列使用场景及其优缺点</h3><ul><li><p>消息队列使用场景</p><ul><li>异步通信<ul><li>紧急重要（需要立刻响应）的业务放到该调用方法中，响应要求不高的使用消息队列，放到MQ队列中，供消费者处理。</li><li>提高系统响应时长</li></ul></li><li>削峰<ul><li>过载保护和缓冲</li></ul></li><li>解耦<ul><li>降低工程间的强依赖程度，针对异构系统进行适配。</li></ul></li><li>冗余<ul><li>消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。</li><li>许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。</li></ul></li><li>保证执行顺序</li><li>数据流处理<ul><li>ELK</li></ul></li></ul></li><li><p>消息队列优点</p><ul><li>低耦合</li><li>可靠投递</li><li>广播</li><li>流量控制</li><li>最终一致性</li><li>实时处理框架支撑等</li></ul></li><li><p>消息队列的问题</p><ul><li>系统可用性降低<ul><li>如何保证消息队列可用性？</li></ul></li><li>系统复杂度提高<ul><li>消息队列语义</li><li>如何保证没有重复消费</li><li>如何保证没有消息丢失</li><li>如何保证消息顺序</li></ul></li><li>一致性问题<ul><li>部分消费成功部分消费失败？</li></ul></li></ul></li></ul><h3 id="消息中间件组成"><a href="#消息中间件组成" class="headerlink" title="消息中间件组成"></a>消息中间件组成</h3><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p>消息服务器，作为server提供消息核心服务</p><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><p>消息生产者，业务的发起方，负责生产消息传输给broker，</p><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p>主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的<strong>广播</strong></p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>队列，PTP模式下，特定生产者向特定queue发送消息，消费者订阅特定的queue完成指定消息的接收</p><h4 id="Topic-VS-Queue"><a href="#Topic-VS-Queue" class="headerlink" title="Topic VS Queue"></a>Topic VS Queue</h4><ul><li><p><strong>Queue</strong>: 实现了负载均衡，将producer生产的消息发送到消息队列中，由多个消费者消费。但一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者。</p></li><li><p><strong>Topic</strong>: 实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到一个消息的拷贝。</p></li></ul><h4 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h4><p>消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输</p><h3 id="消息中间件模式"><a href="#消息中间件模式" class="headerlink" title="消息中间件模式"></a>消息中间件模式</h3><h4 id="点对点（PTP）"><a href="#点对点（PTP）" class="headerlink" title="点对点（PTP）"></a>点对点（PTP）</h4><p>PTP点对点： <strong>使用Queue作为通信载体</strong></p><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/MQ%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%9B%9B%E5%A4%A7%E5%B8%B8%E7%94%A8MQ%E5%AF%B9%E6%AF%94/202112011037.png"></p><p>说明：</p><ul><li>消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息。</li><li>消息被消费以后，queue中不再存储，所以消息消费者不可能消费到已经被消费的消息。 Queue支持存在多个消费者，<strong>但是对一个消息而言，只会有一个消费者可以消费</strong>。</li></ul><h4 id="发布-订阅-PUB-SUB"><a href="#发布-订阅-PUB-SUB" class="headerlink" title="发布/订阅(PUB/SUB)"></a>发布/订阅(PUB/SUB)</h4><p>Pub/Sub发布订阅（广播）：<strong>使用topic作为通信载体</strong></p><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/MQ%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%9B%9B%E5%A4%A7%E5%B8%B8%E7%94%A8MQ%E5%AF%B9%E6%AF%94/202112011041.png"></p><p>说明：</p><ul><li>消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，<strong>发布到topic的消息会被所有订阅者消费</strong>。</li></ul><h3 id="消息中间件常用协议"><a href="#消息中间件常用协议" class="headerlink" title="消息中间件常用协议"></a>消息中间件常用协议</h3><h4 id="AMQP-Advanced-Message-Queuing-Protocol-协议"><a href="#AMQP-Advanced-Message-Queuing-Protocol-协议" class="headerlink" title="AMQP(Advanced Message Queuing Protocol)协议"></a>AMQP(Advanced Message Queuing Protocol)协议</h4><p>一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。</p><p>基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。</p><p>优点：可靠、通用</p><h4 id="MQTT（Message-Queuing-Telemetry-Transport，消息队列遥测传输）协议"><a href="#MQTT（Message-Queuing-Telemetry-Transport，消息队列遥测传输）协议" class="headerlink" title="MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）协议"></a>MQTT（Message Queuing Telemetry Transport，消息队列遥测传输）协议</h4><p>IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分。</p><p>该协议支持所有平台，几乎可以把所有联网物品和外部连接起来，被用来当做传感器和致动器（比如通过Twitter让房屋联网）的通信协议。 </p><p>优点：格式简洁、占用带宽小、移动端通信、PUSH、嵌入式系统</p><h4 id="STOMP（Streaming-Text-Orientated-Message-Protocol，流文本定向消息协议）协议"><a href="#STOMP（Streaming-Text-Orientated-Message-Protocol，流文本定向消息协议）协议" class="headerlink" title="STOMP（Streaming Text Orientated Message Protocol，流文本定向消息协议）协议"></a>STOMP（Streaming Text Orientated Message Protocol，流文本定向消息协议）协议</h4><p>是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。</p><p>STOMP提供一个可互操作的连接格式，允许客户端与任意STOMP消息代理（Broker）进行交互。</p><p>优点：命令模式（非topic\queue模式）</p><h4 id="XMPP（Extensible-Messaging-and-Presence-Protocol，可扩展消息处理现场协议）协议"><a href="#XMPP（Extensible-Messaging-and-Presence-Protocol，可扩展消息处理现场协议）协议" class="headerlink" title="XMPP（Extensible Messaging and Presence Protocol，可扩展消息处理现场协议）协议"></a>XMPP（Extensible Messaging and Presence Protocol，可扩展消息处理现场协议）协议</h4><p>基于可扩展标记语言（XML）的协议，多用于即时消息（IM）以及在线现场探测。</p><p>适用于服务器之间的准即时操作。</p><p>核心是基于XML流传输，这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。</p><p>优点：通用公开、兼容性强、可扩展、安全性高，但XML编码格式占用带宽大</p><h4 id="其他基于TCP-IP自定义的协议"><a href="#其他基于TCP-IP自定义的协议" class="headerlink" title="其他基于TCP/IP自定义的协议"></a>其他基于TCP/IP自定义的协议</h4><p>有些特殊框架（如：redis、kafka、zeroMq等）根据自身需要未严格遵循MQ规范，而是基于TCP\IP自行封装了一套协议，通过网络socket接口进行传输，实现了MQ的功能。</p><h3 id="常用消息中间件MQ总结"><a href="#常用消息中间件MQ总结" class="headerlink" title="常用消息中间件MQ总结"></a>常用消息中间件MQ总结</h3><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>Apache下的一个子项目，使用scala实现的一个高性能分布式Pub/Sub消息队列系统，具有以下特性：</p><ul><li>快速持久化：通过磁盘顺序读写与零拷贝机制，可以在O(1)的系统开销下进行消息持久化；</li><li>高吞吐：在一台普通的服务器上既可以达到10W/s的吞吐速率；</li><li>高堆积：支持topic下消费者较长时间离线，消息堆积量大；</li><li>完全的分布式系统：Broker、Producer、Consumer都原生自动支持分布式，依赖zookeeper（已移除）自动实现复杂均衡；</li><li>支持Hadoop数据并行加载：对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。</li></ul><h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p>阿里参照kafka设计思想使用java实现的一套mq。同时将阿里系内部多款mq产品（Notify、metaq）进行整合，只维护核心功能，去除了所有其他运行时依赖，保证核心功能最简化，在此基础上配合阿里上述其他开源产品实现不同场景下mq的架构，目前主要多用于订单交易系统。</p><p>具有以下特点：</p><ul><li>能够保证严格的消息顺序</li><li>提供针对消息的过滤功能</li><li>提供丰富的消息拉取模式</li><li>高效的订阅者水平扩展能力</li><li>实时的消息订阅机制</li><li>亿级消息堆积能力</li></ul><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP,STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。</p><p>同时实现了Broker架构，核心思想是生产者不会将消息直接发送给队列，消息在发送给客户端时先在中心队列排队。</p><p>对路由(Routing)，负载均衡(Load balance)、数据持久化都有很好的支持。</p><p>多用于进行企业级的ESB整合。</p><h4 id="ZeroMQ"><a href="#ZeroMQ" class="headerlink" title="ZeroMQ"></a>ZeroMQ</h4><p>号称最快的消息队列系统，专门为高吞吐量/低延迟的场景开发，在金融界的应用中经常使用，偏重于实时数据通信场景。</p><p>ZMQ能够实现RabbitMQ不擅长的高级/复杂的队列，但是开发人员需要自己组合多种技术框架，开发成本高。</p><p>因此ZeroMQ具有一个独特的非中间件的模式，更像一个socket library，你不需要安装和运行一个消息服务器或中间件，因为你的应用程序本身就是使用ZeroMQ API完成逻辑服务的角色。</p><p>但是ZeroMQ仅提供<strong>非持久性的队列</strong>，如果down机，数据将会丢失。如：Twitter的Storm中使用ZeroMQ作为数据流的传输。</p><p>ZeroMQ套接字是与传输层无关的：ZeroMQ套接字对所有传输层协议定义了统一的API接口。默认支持 进程内(inproc) ，进程间(IPC) ，多播，TCP协议，在不同的协议之间切换只要简单的改变连接字符串的前缀。可以在任何时候以最小的代价从进程间的本地通信切换到分布式下的TCP通信。ZeroMQ在背后处理连接建立，断开和重连逻辑。</p><p>特性：</p><ul><li>无锁的队列模型：对于跨线程间的交互（用户端和session）之间的数据交换通道pipe，采用无锁的队列算法CAS；在pipe的两端注册有异步事件，在读或者写消息到pipe的时，会自动触发读写事件。</li><li>批量处理的算法：对于批量的消息，进行了适应性的优化，可以批量的接收和发送消息。</li><li>多核下的线程绑定，无须CPU切换：区别于传统的多线程并发模式，信号量或者临界区，zeroMQ充分利用多核的优势，每个核绑定运行一个工作者线程，避免多线程之间的CPU切换开销。</li></ul><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>本身支持MQ功能，所以完全可以当做一个轻量级的队列服务来使用。</p><p>实验表明：</p><ul><li>入队时，当数据比较小时Redis的性能要高于RabbitMQ，而如果数据大小超过了10K，Redis则慢的无法忍受；</li><li>出队时，无论数据大小，Redis都表现出非常好的性能，而RabbitMQ的出队性能则远低于Redis。</li></ul><h3 id="主要消息中间件的比较"><a href="#主要消息中间件的比较" class="headerlink" title="主要消息中间件的比较"></a>主要消息中间件的比较</h3><p><img src="/2021/12/01/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/MQ%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%9B%9B%E5%A4%A7%E5%B8%B8%E7%94%A8MQ%E5%AF%B9%E6%AF%94/202112011141.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;消息队列概述&quot;&gt;&lt;a href=&quot;#消息队列概述&quot; class=&quot;headerlink&quot; title=&quot;消息队列概述&quot;&gt;&lt;/a&gt;消息队列概述&lt;/h2&gt;&lt;h3 id=&quot;消息队列使用场景及其优缺点&quot;&gt;&lt;a href=&quot;#消息队列使用场景及其优缺点&quot; class=&quot;he</summary>
      
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="消息中间件" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="MQ" scheme="http://example.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>详解HTTP2.0及HTTPS协议</title>
    <link href="http://example.com/2021/11/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AF%A6%E8%A7%A3HTTP2.0%E5%8F%8AHTTPS%E5%8D%8F%E8%AE%AE/"/>
    <id>http://example.com/2021/11/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AF%A6%E8%A7%A3HTTP2.0%E5%8F%8AHTTPS%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-11-26T08:34:43.000Z</published>
    <updated>2021-11-26T08:52:53.273Z</updated>
    
    <content type="html"><![CDATA[<p>说明： 转自<a href="https://juejin.cn/post/7034668672262242318">详解 HTTP2.0 及 HTTPS 协议</a></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文基于运维视角在阐述解析HTTP2.0协议相比较HTTP1.1的优点的同时讲述HTTPS协议的原理，并结合实际业务场景作为案例，目的是可以通过本文掌握HTTP2.0及HTTPS协议，了解原理，具备定位排查问题，调优的能力。</p><h2 id="HTTP1-1-VS-HTTP2"><a href="#HTTP1-1-VS-HTTP2" class="headerlink" title="HTTP1.1 VS HTTP2"></a>HTTP1.1 VS HTTP2</h2><p>严格意义上HTTP2.0和HTTPS并没有什么必然的联系，只是搭配使用更香一些，HTTP2 是1999年HTTP1.1之后的第一次更新。</p><p>HTTP2具有更好的效率和资源利用率，尤其适用于页面比较重，有大量资源加载的场景（公司的业务属于典型的场景），根据网络上的测试数据，在大量图片、资源需要加载的场景下，HTTP2解决HTTP1.1的线头阻塞（一次请求交互必须等待前一次请求交互的完成）问题相比HTTP1.1可以达到5倍以上的速度提升，目前，淘宝，天猫，京东等平台都已启用HTTP2，如果是<strong>页面存在大量惊天资源需要加载</strong>的情况，启用HTTP2.0，绝对物超所值。</p><h3 id="HTTP2-0特性"><a href="#HTTP2-0特性" class="headerlink" title="HTTP2.0特性"></a>HTTP2.0特性</h3><h4 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h4><ul><li>HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。</li><li>HTTP/1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。 HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。</li><li>HTTP1.1 的纯文本形式看起来一目了然，非常直观，但这只是对人的体验而言，事实上这种方式存在多义性，例如大小写、空白字符、回车换行、多字少字等，程序在处理的时候需要复杂的处理。</li><li>而二进制的方式，只是0和1，可以严格规定字段大小，顺序，标志位等，不存在歧义，提交小，同时也提升了数据在网络中传输的效率。</li></ul><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><ul><li>HTTP1.1中一次请求与响应的交互必须要等待前面的请求交互完成，否则后面的只能等待。</li><li>而在HTTP2.0中，一次链接成功后，只要链接还没断开，那么 client 端就可以在一个链接中并发的发起多个请求，且每个请求的响应不需要等待其他请求。<ul><li>多路复用，代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP连接并发完成。 HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。常见的一个情况是，如果一个页面需要加载的静态资源过多，因为只有6-8个并发，所以客户端浏览器的等待时间就会比较久。</li></ul></li></ul><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><ul><li><p>HTTP2中服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当然，如果一次性推送了太多的资源，因为浏览器需要处理所有推送过来的资源。反而会拖累性能。所以需要根据业务场景做权衡。</span><br></pre></td></tr></table></figure></li></ul><h4 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h4><ul><li><p>HTTP 1.1请求的大小变得越来越大，有时甚至会大于TCP窗口的初始大小，因为它们需要等待带着ACK的响应回来以后才能继续被发送。HTTP/2对消息头采用HPACK（专为http/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。像cookie这些信息，每个请求都会附带，产生了很多不必要的资源消耗。为了减少这块的资源消耗并提升性能， HTTP/2对这些首部采取了压缩策略：</p><ul><li>HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；</li><li>首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li><li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ul></li></ul><h3 id="ALPN-应用协议协商"><a href="#ALPN-应用协议协商" class="headerlink" title="ALPN 应用协议协商"></a>ALPN 应用协议协商</h3><p>HTTPS 握手的时候，客户端会首先告诉服务端自己支持的协议，由服务端选择客户端服务端都支持的协议。如果服务端Nginx开启了HTTP2支持，服务端会选择HTTP2协议，否则，服务端就会选择HTTP1.1协议来通讯。</p><h2 id="SSL-TLS模型"><a href="#SSL-TLS模型" class="headerlink" title="SSL/TLS模型"></a>SSL/TLS模型</h2><h3 id="TLS版本"><a href="#TLS版本" class="headerlink" title="TLS版本"></a>TLS版本</h3><p><img src="/2021/11/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AF%A6%E8%A7%A3HTTP2.0%E5%8F%8AHTTPS%E5%8D%8F%E8%AE%AE/img.png"></p><p>历史版本的TLS/SSL因为安全漏洞和性能问题已经慢慢成为历史的尘埃，目前应用最为广泛的是TLS1.2版本，而TLS 1.3 是对于TLS1.2的升级，提供更强大的安全性和更高的性能。</p><h3 id="加密套件"><a href="#加密套件" class="headerlink" title="加密套件"></a>加密套件</h3><p><img src="/2021/11/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AF%A6%E8%A7%A3HTTP2.0%E5%8F%8AHTTPS%E5%8D%8F%E8%AE%AE/img1.png"></p><p>加密套件：TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA</p><p>解释:</p><ul><li>基于TLS协议，使用ECDHE和RSA作为秘钥交换算法，加密算法是AES GCM，秘钥长度128位，哈希算法使用sha256</li><li>AES-GCM 是目前常用的分组加密算法，但是其有一个缺点就是计算量大，导致性能和电量开销比较大。为了解决这个问题，Intel 推出了名为 AES NI（Advanced Encryption Standard new instructions）的 x86 指令拓展集，从硬件上提供对 AES 的支持。对于支持 AES NI 指令的主机来说，使用 AES-GCM 是最佳选择。AES-GCM的优点在于可以利用多核提高加解密性能。</li></ul><h3 id="HTTPS握手过程"><a href="#HTTPS握手过程" class="headerlink" title="HTTPS握手过程"></a>HTTPS握手过程</h3><p><img src="/2021/11/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AF%A6%E8%A7%A3HTTP2.0%E5%8F%8AHTTPS%E5%8D%8F%E8%AE%AE/img2.png"></p><ul><li><p><strong>Client-hello 阶段</strong></p><p>Client-hello 是TCP链接建立后客户端发送的第一条消息，主要目的是把客户端支持的功能和选项告诉服务端。</p><ul><li>浏览器中完成地址输入后, 解析域名获得 IP Host 地址, 浏览器会与此 Host 的443(默认, 如果指定其他端口则会连接此端口) 三次握手建立TCP连接，然后进入TLS 握手协议的 Client-hello。这一步骤中浏览器会将客户端支持的加密套件，目标Host等信息发送给服务器, 并会附上一份随机生成的 session ticket1.</li><li>ALPN协商: 应用层可以协商在安全连接层之上使用什么协议, 避免了额外的往返通讯。<br><img src="/2021/11/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AF%A6%E8%A7%A3HTTP2.0%E5%8F%8AHTTPS%E5%8D%8F%E8%AE%AE/img_1.png"></li></ul></li><li><p><strong>Server-hello阶段</strong></p><ul><li>服务器收到浏览器发送来的 TLS 握手请求后, 存储浏览器发送的session ticket1, 然后根据发送来的 host 寻找对应的服务器证书, 然后会将服务器证书, 服务器从Client Hello提供的客户端支持的加密套件清单中按照优先级选择一个双方都支持的套件（如果服务端支持的套件和client支持的套件交集为空则握手失败）, 和一份随机生成的 session ticket2 返回给浏览器.</li></ul><img src="/2021/11/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AF%A6%E8%A7%A3HTTP2.0%E5%8F%8AHTTPS%E5%8D%8F%E8%AE%AE/11/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AF%A6%E8%A7%A3HTTP2.0%E5%8F%8AHTTPS%E5%8D%8F%E8%AE%AE/img_2.png" class></li></ul><p><strong>Client-hello和server-hello的步骤很像是买东西： 客户端： 我有多少钱，能支付宝也能微信付款， 服务端：需要xxx RMB，我们使用支付宝吧。</strong></p><ul><li><p>Cipher-spec 阶段</p><p>经过Client Hello和Server Hello 客户端和服务端完成了加密套件的协商。进入Cipher-spec 阶段会核验证书的有效性。</p><p>验证步骤如下:</p><ul><li>验证证书有效期</li><li>验证证书域名与实际的host是否匹配。</li><li>验证证书吊销状态(CRL+OCSP)确认证书是否被吊销。</li><li>验证证书颁发机构, 如果颁发机构是中间证书（基本都是）, 再验证中间证书的有效期/颁发机构/吊销状态. 一直验证到最后一层证书, 中途任何一个环节不通过都会提示不信任。</li><li>若检查通过, 随机生成一份 session ticket 3 (这是浏览器生成的第二份 ticket), 通过返回证书中的公钥, 用协商的加密算法加密, 返回给服务器.同时浏览器用 session ticket 1(浏览器) &amp; session ticket 2(服务器) &amp; session ticket 3(浏浏览器) 组合成 session key。</li></ul></li><li><p>内容传输阶段</p><ul><li>TLS 连接建立完成, 在连接销毁前, 浏览器与服务器的交互数据均通过 session key 来进行对称加密.</li></ul></li></ul><h4 id="HTTPS握手过程抓包："><a href="#HTTPS握手过程抓包：" class="headerlink" title="HTTPS握手过程抓包："></a>HTTPS握手过程抓包：</h4><img src="/2021/11/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AF%A6%E8%A7%A3HTTP2.0%E5%8F%8AHTTPS%E5%8D%8F%E8%AE%AE/11/26/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/%E8%AF%A6%E8%A7%A3HTTP2.0%E5%8F%8AHTTPS%E5%8D%8F%E8%AE%AE/img_3.png" class><ul><li>前三行为TCP三次握手，</li><li>第四行客户端发起Client hello，</li><li>第五行服务端ack回复， </li><li>第六行Server Hello，</li><li>第9行Cipher-spec阶段进行证书校验，</li><li>完成握手之后第13行进入数据交互阶段。</li></ul><h3 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h3><p>通常访问网址的时候我们大多不会刻意的在前面写上https，也很少会关注我们是通过HTTP协议还是HTTPS协议在浏览。而要求https访问的站点，在用户通过http访问的时候大多以重定向的方式重定向到HTTPS地址，而如果我劫持了用户流量，拦截向https的重定向请求，然后担当一个代理的角色，如实转发客户端请求并返回，但是客户端跟中间人的交互采用的是明文的HTTP协议，由于没有建立SSL连接，所以客户端提交的信息都会暴露。基于此问题，是国际互联网工程组织 IETF 发布了HSTS的安全策略机制，强制让浏览器使用HTTPS与站点进行通信。</p><p>HSTS（HTTP Strict Transport Security）的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。HSTS主要是通过服务器发送响应头的方式来控制浏览器操作：</p><ul><li><p>当客户端通过 HTTPS 发出请求时，服务器会在返回的 HTTP 响应头中包含 Strict-Transport-Security 字段（HSTS的开关由服务端控制）。</p></li><li><p>浏览器接收到这样的信息之后，在一定期限内对该网站的任何请求都会以 HTTPS 发起（浏览器内部307跳转），而不会以 HTTP发起再由服务器重定向到 HTTPS。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;说明： 转自&lt;a href=&quot;https://juejin.cn/post/7034668672262242318&quot;&gt;详解 HTTP2.0 及 HTTPS 协议&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="JAVA开发" scheme="http://example.com/categories/JAVA%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="网络协议" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>JVM基础系列之对象的创建与访问</title>
    <link href="http://example.com/2021/08/13/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE/"/>
    <id>http://example.com/2021/08/13/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE/</id>
    <published>2021-08-13T01:06:19.000Z</published>
    <updated>2022-02-23T07:34:39.339Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><p><img src="/2021/08/13/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE/f301a9680197b8c1538bc25cf3823c32.jpg" alt="对象创建过程"></p><h5 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h5><p>虚拟机遇到一条 new 指令时: </p><ol><li>检查这个指令的参数是否能在常量池中定位到这个类的符号引用<ul><li>若常量池中没有这个类的符号引用，说明这个类还没有被定义，抛出ClassNotFoundException</li></ul></li><li>这个符号引用代表的类是否已被加载过、解析和初始化过。<ul><li>如果有，为新生对象分配内存</li><li>如果没有，必须先执行相应的类加载过程。</li></ul></li></ol><h5 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h5><p>对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</p><p><code>一个对象所需的内存大小是在这个对象所属类被定义完就能确定的, 因此一个类所生产的所有对象的内存大小是一样的</code></p><p>分配方式无非有两种方法：</p><p><img src="/2021/08/13/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE/da8bf89a0c0434b587b2b37bb1bc3547.png" alt="java类内存分配"></p><ul><li>“指针碰撞”： 通过一个类似于指针的东西为对象分配内存，前提是堆空间是相对规整的。</li><li>“空闲列表”： 堆空间不规整，使用一个列表记录了哪些空间是空闲的，分配内存的时候会更新列表。 </li></ul><p><code>这是两种不同的方法，具体选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。值得注意的是，复制算法内存也是规整的。</code></p><p><strong>java类内存分配如何保证并发线程安全</strong></p><p>多线程并发时会出现正在给对象 A 分配内存，还没来得及修改指针，对象 B 又用这个指针分配内存，这样就出现问题了。解决这种问题有两种方案：</p><ul><li>CAS+失败重试<ul><li>采用同步方法，使用 CAS 配上失败重试的方式保证更新操作的原子性。</li></ul></li><li>本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)<ul><li>为每一个线程预先在 Eden 区分配一块儿内存(线程私有)，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li><li>扩展阅读： <a href="https://juejin.cn/post/6925217498723778568">TLAB</a></li></ul></li></ul><h5 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h5><p>虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头)</p><p><code>注意零值不是初始化方法指定的值，数字设置为0，布尔设置为false</code></p><p>保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h5 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h5><p>虚拟机要对对象进行必要的设置，例如</p><ul><li>这个对象是那个类的实例</li><li>如何才能找到类的元数据信息</li><li>对象的哈希码</li><li>对象的 GC 分代年龄等信息。</li></ul><p>这些信息存放在对象头中。</p><ul><li>另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li></ul><h5 id="执行-init-方法"><a href="#执行-init-方法" class="headerlink" title="执行 init 方法"></a>执行 init 方法</h5><p>在上⾯⼯作都完成之后，从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从Java 程序的视⻆来看，对象创建才刚开始，⽅法还没有执⾏，所有的字段都还为零</p><p>把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><p><strong>初始化顺序</strong></p><p>在new B一个实例时首先要进行类的装载。（<strong>类只有在使用New调用创建的时候才会被java类装载器装入</strong>）</p><ul><li>先装载父类A，完成静态动作（包括静态代码和变量，它们的级别是相同的，按照代码中出现的顺序初始化）</li><li>再装载子类B，完成静态动作</li></ul><p>类装载完成，开始进行实例化</p><ul><li>父类A的成员实例化（非静态代码）</li><li>父类A的构造方法</li><li>子类B的成员实例化（非静态代码）</li><li>子类B的构造方法</li></ul><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p><img src="/2021/08/13/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE/img.png"></p><h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><p>对象头主要划分为三个部分</p><ul><li><p>存储对象自身的运行时数据(markword)</p><ul><li>哈希码[jvm计算得到，对象重写的hashcode未写入对象头]、</li><li>GC 分代年龄: 扩展阅读: <a href="file:///G:\code\example\doc\java\Java多线程.md">从对象头状态变迁看内置锁实现</a></li><li>锁状态标志</li></ul></li><li><p>类型指针（class pointer）</p><ul><li>即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Klass Word  这里其实是虚拟机设计的一个oop-klass model模型，这里的OOP是指Ordinary Object Pointer（普通对象指针），看起来像个指针实际上是藏在指针里的对象。而 klass 则包含 元数据和方法信息，用来描述 Java 类。它在64位虚拟机开启压缩指针的环境下占用 32bits 空间。</span><br></pre></td></tr></table></figure></li><li><p>数组长度（对象数组）</p></li></ul><h5 id="实例数据-instance-data"><a href="#实例数据-instance-data" class="headerlink" title="实例数据(instance data)"></a>实例数据(instance data)</h5><p>对象真正存储的有效信息，在程序中所定义的各种类型的字段内容</p><p>存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在 Java 源码中定义顺序的影响</p><p>分配策略:相同宽度的字段总是放在一起，比如double和long</p><h5 id="对齐填充-padding"><a href="#对齐填充-padding" class="headerlink" title="对齐填充(padding)"></a>对齐填充(padding)</h5><p>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于HotSpot规定对象的大小必须是8的整数倍，对象头刚好是整数倍，如果实例数据不是的话，就需要占位符对齐填充。</span><br></pre></td></tr></table></figure><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>对象的访问方式由虚拟机决定，java虚拟机提供两种主流的方式：句柄访问对象和直接指针访问对象</p><h5 id="句柄访问对象"><a href="#句柄访问对象" class="headerlink" title="句柄访问对象"></a>句柄访问对象</h5><p>Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p><p><img src="/2021/08/13/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE/img_1.png"></p><p>优点:引用中存储的是稳定的句柄地址,在对象被移动【垃圾收集时移动对象是常态】只需改变句柄中实例数据的指针，不需要改动引用【ref】本身。</p><h5 id="直接指针访问对象"><a href="#直接指针访问对象" class="headerlink" title="直接指针访问对象"></a>直接指针访问对象</h5><p>Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</p><p><img src="/2021/08/13/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BF%E9%97%AE/img_2.png"></p><p>优点:优势很明显，就是速度快，相比于句柄访问少了一次指针定位的开销时间。【可能是出于Java中对象的访问时十分频繁的,平时我们常用的JVM HotSpot采用此种方式】</p><h4 id="创建一个新对象的内存分配全流程"><a href="#创建一个新对象的内存分配全流程" class="headerlink" title="创建一个新对象的内存分配全流程"></a>创建一个新对象的内存分配全流程</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h3&gt;&lt;h4 id=&quot;对象的创建&quot;&gt;&lt;a href=&quot;#对象的创建&quot; class=&quot;headerlink&quot; title=&quot;对象的创建&quot;&gt;&lt;/a&gt;对象的创</summary>
      
    
    
    
    <category term="JAVA基础" scheme="http://example.com/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM基础系列之Java类加载机制</title>
    <link href="http://example.com/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8BJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8BJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2021-08-12T08:32:34.000Z</published>
    <updated>2021-08-30T06:45:15.587Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><h4 id="什么叫类加载"><a href="#什么叫类加载" class="headerlink" title="什么叫类加载"></a>什么叫类加载</h4><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8BJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/9f1e696004981c0f9249ad145474feea.jpg" alt="类装载器"></p><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，并为之创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。</p><p>类的加载过程是由类加载器来完成，类加载器由JVM提供。我们开发人员也可以通过继承ClassLoader来实现自己的类加载器。</p><h4 id="什么时候启动类加载"><a href="#什么时候启动类加载" class="headerlink" title="什么时候启动类加载"></a>什么时候启动类加载</h4><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它。</p><p>如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误），如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p><h4 id="从什么地方加载-class文件"><a href="#从什么地方加载-class文件" class="headerlink" title="从什么地方加载.class文件"></a>从什么地方加载.class文件</h4><ul><li>本地磁盘</li><li>网上加载.class文件</li><li>数据库中</li><li>压缩文件（ZAR，JAR等）</li><li>从其他文件生成（JSP应用）</li><li>把一个java源文件动态编译，并执行加载。</li></ul><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：<strong>加载、验证、准备、解析、初始化、使用和卸载</strong>七个阶段。</p><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8BJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/f2f2e86a8bedea038839b34d67e7dc90.jpg" alt="类生命周期"></p><p>类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">加载、验证、准备和初始化这四个阶段发生的顺序是确定的，</span><br><span class="line"></span><br><span class="line">而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始。</span><br><span class="line"></span><br><span class="line">另外,注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</span><br></pre></td></tr></table></figure><h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><ul><li>通过类的全限定名称获取其定义的二进制字节流</li><li>将字节流代表的今天存储结构转化为方法区的运行时数据结构</li><li>在<strong>堆</strong>中生成一个代表这个类的 java.lang.Class 对象，作为方法区这些数据的访问入口。（注意不是方法区的数据结构）</li></ul><h5 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h5><blockquote><p>通过类的加载，内存中已经创建了一个Class对象。链接负责将二进制数据合并到 JRE中。链接需要通过验证、准备、解析三个阶段。</p></blockquote><h6 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h6><blockquote><p>验证阶段用于检查被加载的类是否有正确的内部结构，并和其他类协调一致，即是否满足java虚拟机的约束。</p></blockquote><ol><li>文件格式的验证：验证.class文件字节流是否符合class文件的格式的规范，并且能够被当前版本的虚拟机处理。这里面主要对魔数、主版本号、常量池等等的校验。</li><li>元数据验证：主要是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求，比如说验证这个类是不是有父类，类中的字段方法是不是和父类冲突等等。</li><li>字节码验证：这是整个验证过程最复杂的阶段，主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在元数据验证阶段对数据类型做出验证后，这个阶段主要对类的方法做出分析，保证类的方法在运行时不会做出危害虚拟机安全的事。</li><li>符号引用验证：它是验证的最后一个阶段，发生在虚拟机将符号引用转化为直接引用的时候。主要是对类自身以外的信息进行校验。目的是确保解析动作能够完成。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">符号引用:</span><br><span class="line">以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。</span><br><span class="line">例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。</span><br><span class="line">符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。</span><br><span class="line">在Java中，一个java类将会编译成一个class文件。</span><br><span class="line">在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。</span><br><span class="line">比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。</span><br><span class="line">各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</span><br><span class="line">  </span><br><span class="line">直接引用:</span><br><span class="line">直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）</span><br><span class="line">相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）</span><br><span class="line">一个能间接定位到目标的句柄</span><br><span class="line">直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</span><br></pre></td></tr></table></figure><blockquote><p>对整个类加载机制而言，验证阶段是一个很重要但是非必需的阶段，如果我们的代码能够确保没有问题，那么我们就没有必要去验证，毕竟验证需要花费一定的的时间。当然我们可以使用-Xverfity:none来关闭大部分的验证。</p></blockquote></li></ol><h6 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h6><blockquote><p>准备阶段主要为类变量分配内存并设置初始值。</p></blockquote><ul><li>类变量（static）会分配内存（方法区），但是实例变量不会，实例变量主要随着对象的实例化一块分配到java堆中;</li><li>这里的初始值指的是数据类型默认值(例如int为0， boolean为false)，而不是代码中被显示赋予的值。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int value = 1; //在这里准备阶段过后的value值为0，而不是1。赋值为1的动作在初始化阶段。</span><br></pre></td></tr></table></figure><h6 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h6>在类还未加载到虚拟机时，无法获取实际方法的引用地址。对于一个方法的调用，编译器会生成一个包含目标方法所在的类、目标方法名、接收参数类型以及返回值类型的符号引用，来指代要调用的方法。</li></ul><blockquote><p>解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。</p></blockquote><p>主要针对<strong>类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符</strong>7类符号引用进行。</p><p>如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必会触发解析与初始化）</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><blockquote><p>在初始化阶段，主要为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</p></blockquote><h6 id="类变量初始化方式"><a href="#类变量初始化方式" class="headerlink" title="类变量初始化方式"></a>类变量初始化方式</h6><ol><li>申明类变量时指定初始值</li><li>使用静态代码块为类变量指定初始值</li></ol><h6 id="JVM初始化步骤"><a href="#JVM初始化步骤" class="headerlink" title="JVM初始化步骤"></a>JVM初始化步骤</h6><ul><li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li><li>假如类中有初始化语句，则系统依次执行这些初始化语句</li></ul><h6 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h6><blockquote><p>只有对类的主动使用才会导致类的初始化</p></blockquote><ol><li>当虚拟机启动时(用户需要指定一个主类（包含main()方法的类）)，初始化用户指定的主类。</li><li>当遇到用以新建目标类实例的new指令时，初始化new指令的目标类</li><li>当遇到调用静态方法或者使用静态变量或者对该静态变量赋值(放入常量池中的常量除外)，初始化静态变量或方法所在的类； </li><li>初始化某个类的子类，则其父类也会被初始化</li><li>如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口初始化；</li><li>使用反射API对某个类进行反射调用时（如 Class.forName(“com.hepeng.Test”)），初始化这个类</li><li>使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化。</li></ol><h6 id="lt-clinit-gt-方法"><a href="#lt-clinit-gt-方法" class="headerlink" title="&lt; clinit&gt;方法"></a>&lt; clinit&gt;方法</h6><blockquote><p>虚拟机会收集类及父类中的类变量及类方法组合为&lt; clinit&gt;方法，根据定义的顺序进行初始化。</p></blockquote><ol><li><p>虚拟机会保证子类的&lt; clinit&gt;执行之前，父类的&lt; clinit&gt;方法先执行完毕。</p> <details><summary>一个简单的小Demo</summary>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">10</span>;    </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        A = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> B = A;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line">        System.out.println(Test1.B);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><p> 从输出中看出，父类的静态初始化块在子类静态变量初始化之前初始化完毕，所以输出结果是20，不是10。</p> </details> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因此，虚拟机中第一个被执行完毕的&lt; clinit&gt;方法肯定是java.lang.Object方法</span><br></pre></td></tr></table></figure></li><li><p>如果类或者父类中都没有静态变量及方法，虚拟机不会为其生成&lt; clinit&gt;方法。</p></li><li><p>接口与类不同的是，执行接口的＜clinit＞方法不需要先执行父接口的＜clinit＞方法。 </p><ul><li>只有当父接口中定义的变量使用时，父接口才会初始化。</li><li>另外，接口的实现类在初始化时也一样不会执行接口的＜clinit＞方法。</li></ul> <details><summary>这与普通类加载不一致</summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceInitTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> A = CurrentTime.getTime();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceInitTest1</span> <span class="keyword">extends</span> <span class="title">InterfaceInitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> B = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterfaceInitTestImpl</span> <span class="keyword">implements</span> <span class="title">InterfaceInitTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(InterfaceInitTestImpl.B);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前时间：&quot;</span>+InterfaceInitTestImpl.A);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CurrentTime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加载了InterfaceInitTest接口&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">---------------------------</span><br><span class="line">加载了InterfaceInitTest接口</span><br><span class="line">当前时间：1560158880660</span><br></pre></td></tr></table></figure> </details></li><li><p>虚拟机会保证一个类的&lt; clinit&gt;方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只有一个线程去执行这个类的&lt; clinit&gt;方法，其他线程都需要阻塞等待，直到活动线程执行&lt; clinit&gt;方法完毕。</p> <details><summary>Demo</summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadInitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread()+<span class="string">&quot;init MultiThreadInitTest&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable runnable = () -&gt; &#123; </span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;start&quot;</span>);</span><br><span class="line">            System.out.println(MultiThreadInitTest.A);</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">&quot;run over&quot;</span>); </span><br><span class="line">        &#125;;</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p> 输出结果</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thread[main,5,main]init MultiThreadInitTest</span><br><span class="line">Thread[Thread-0,5,main]start</span><br><span class="line">10</span><br><span class="line">Thread[Thread-0,5,main]run over</span><br><span class="line">Thread[Thread-1,5,main]start</span><br><span class="line">10</span><br><span class="line">Thread[Thread-1,5,main]run over</span><br></pre></td></tr></table></figure><p> 只有第一个线程对MultiThreadInitTest进行了一次初始化，第二个线程一直阻塞等待等第一个线程初始化完毕</p> </details></li></ol><h6 id="final定义的初始化"><a href="#final定义的初始化" class="headerlink" title="final定义的初始化"></a>final定义的初始化</h6><p>对于一个使用final定义的常量，如果在编译时就已经确定了值，在引用时不会触发初始化，因为在编译的时候就已经确定下来，就是“宏变量”。如果在编译时无法确定，在初次使用才会导致初始化。</p><details><summary>单例模式静态内部类实现方式</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingleton</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用静态内部类实现单例：</span></span><br><span class="line"><span class="comment">   * 1：线程安全</span></span><br><span class="line"><span class="comment">   * 2：懒加载</span></span><br><span class="line"><span class="comment">   * 3：非反序列化安全，即反序列化得到的对象与序列化时的单例对象不是同一个，违反单例原则</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerSingleton INNER_SINGLETON = <span class="keyword">new</span> StaticInnerSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INNER_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到单例实例使用final定义，但在编译时无法确定下来，所以在第一次使用StaticInnerSingleton.getInstance()方法时，才会触发静态内部类的加载，也就是延迟加载。</p><p>这里想指出，<strong>如果final定义的变量在编译时无法确定，则在使用时还是会进行类的初始化</strong>。</p></details><h6 id="ClassLoader只会对类进行加载，不会进行初始化"><a href="#ClassLoader只会对类进行加载，不会进行初始化" class="headerlink" title="ClassLoader只会对类进行加载，不会进行初始化"></a>ClassLoader只会对类进行加载，不会进行初始化</h6><h4 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h4><ul><li><p>通过命令行启动应用时由JVM初始化加载含有main()方法的主类。</p></li><li><p>通过Class.forName()方法动态加载，会默认执行初始化块（static{}），但是Class.forName(name,initialize,loader)中的initialze可指定是否要执行初始化块。</p></li><li><p>通过ClassLoader.loadClass()方法动态加载，不会执行初始化块。</p></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便<strong>让应用程序自己决定如何去获取所需的类</strong>。实现这个动作的代码被称为“类加载器”（Class Loader）。</p><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。</p><p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p><p>这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个类在JVM中使用全限定类名（包名+类名）与类加载器联合为唯一的ID，所以如果同一个类使用不同的类加载器，可以被加载到虚拟机，但彼此不兼容。</span><br></pre></td></tr></table></figure><h4 id="类加载机制-1"><a href="#类加载机制-1" class="headerlink" title="类加载机制"></a>类加载机制</h4><ol><li><strong>全盘负责</strong>：   当一个类加载器负责加载某个Class时，该Class所依赖和引用的其他Class也由该类加载器负责载入，除非显示使用另一个类加载器来载入。</li><li><strong>父类委托（双亲委派）</strong>：先让父加载器试图加载该Class，只有在父加载器无法加载时该类加载器才会尝试从自己的类路径中加载该类。</li><li><strong>缓存机制</strong>：缓存机制会将已经加载的class缓存起来，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存中不存在该Class时，系统才会读取该类的二进制数据，并将其转换为Class对象，存入缓存中。这就是为什么更改了class后，需要重启JVM才生效的原因。</li></ol><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>Java语言系统自带有三个类加载器:</p><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8BJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/c2a7c4bf19cfc90945643d8d94ac0f3d.png" alt="双亲委派机制"></p><ul><li><p>Bootstrap ClassLoader：启动类加载器, 最顶层的加载类</p><blockquote><p>这个类加载器使用C++语言实现，是虚拟机自身的一部分<br>其他所有的类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</p></blockquote><ul><li>主要加载核心类库，也就是我们环境变量下面%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等(按照文件名识别，名字不符合的类库即使放在lib目录中也不会被加载)。</li><li>另外需要注意的是可以通过启动jvm时指定-Xbootclasspath和路径来改变Bootstrap ClassLoader的加载目录。比如java -Xbootclasspath/a:path被指定的文件追加到默认的bootstrap路径中。</li><li>我们可以打开我的电脑，在上面的目录下查看，看看这些jar包是不是存在于这个目录。</li></ul></li><li><p>Extention ClassLoader ：扩展的类加载器</p><blockquote><p>类sun.misc.Launcher$ExtClassLoader中以Java方式实现</p></blockquote><ul><li>加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件。</li><li>还可以加载-D java.ext.dirs选项指定的目录。</li></ul></li><li><p>Appclass Loader：也称为SystemAppClass。</p><blockquote><p>sun.misc.Launcher$AppClassLoader来实现。是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”</p></blockquote><ul><li>它负责加载用户类路径（ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。 </li></ul></li></ul><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8BJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p><p>加载器加载顺序： Bootstrap ClassLoader &gt; Extention ClassLoader &gt; Appclass Loader</p><h5 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h5><p>当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。</p><ul><li>可以避免重复加载，父类已经加载了，子类就不需要再次加载</li><li>更加安全，很好的解决了各个类加载器的基础类的统一问题，如果不使用该种方式，那么用户可以随意定义类加载器来加载核心api，会带来相关隐患。</li></ul><blockquote><p>类加载可以理解为通过类加载器（ClassLoader）定制化的类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”的动作，一个复杂的JAVA程序可能会包含大量的依赖，而JAVA&amp;框架本身也有自己依赖，两个不同程序的依赖可能会产生冲突，存在同一个全限定名加载出来的接口也可能有不兼容的情况。<br>通过双亲委派模型（自下而上扫描，扫描结束后不直接加载，交给父加载器，父加载器反馈不能加载后再通过当前加载器加载），有效解决重复加载和加载安全问题。</p></blockquote><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8BJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.png"></p><h4 id="自定义加载器"><a href="#自定义加载器" class="headerlink" title="自定义加载器"></a>自定义加载器</h4><p>实现方案:</p><ul><li>遵守双亲委派模型：继承ClassLoader，重写findClass()方法。</li><li>破坏双亲委派模型：继承ClassLoader,重写loadClass()方法。</li></ul><p>通常我们推荐采用第一种方法自定义类加载器，最大程度上的遵守双亲委派模型。</p><p>实现步骤: </p><ul><li>创建一个类继承ClassLoader抽象类</li><li>重写findClass()方法</li><li>在findClass()方法中调用defineClass()</li></ul><h4 id="OSGI动态模型系统"><a href="#OSGI动态模型系统" class="headerlink" title="OSGI动态模型系统"></a>OSGI动态模型系统</h4><p>OSGi(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系统的一系列规范。</p><p>OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。</p><p>OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于OSGi的程序很可能可以实现<strong>模块级的热插拔功能</strong>，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企 业级程序开发来说是非常具有诱惑力的特性。</p><p>OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;类加载机制&quot;&gt;&lt;a href=&quot;#类加载机制&quot; class=&quot;headerlink&quot; title=&quot;类加载机制&quot;&gt;&lt;/a&gt;类加载机制&lt;/h3&gt;&lt;h4 id=&quot;什么叫类加载&quot;&gt;&lt;a href=&quot;#什么叫类加载&quot; class=&quot;headerlink&quot; title=&quot;什</summary>
      
    
    
    
    <category term="JAVA基础" scheme="http://example.com/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM基础系列之运行时内存分配模型</title>
    <link href="http://example.com/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-08-12T08:32:34.000Z</published>
    <updated>2022-02-23T07:35:03.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM是什么"><a href="#JVM是什么" class="headerlink" title="JVM是什么"></a>JVM是什么</h3><p>而对于不同的操作系统，系统操作指令集（CPU原语）往往是不同的。JVM即Java虚拟机，是基于C/C++开发的一种抽象计算机，它对不同平台的系统指令集进行封装，对外提供了一套固定的指令集，在运行时操作各种内存区域，使JAVA成为可以跨平台的语言。</p><p><code>一般来说，使用特定编译器编译的程序只能在对应的平台运行，这里也可以说编译器是与平台相关的，编译后的文件也是与平台相关的。我们说的语言跨平台是编译后的文件跨平台，而不是源程序跨平台。</code></p><p>虚拟机有很多种，不同厂商提供了不同实现，只要遵循虚拟机规范即可，目前我们所说的虚拟机一般指的是Hot Spot。</p><p>JVM对Java语言一无所知，只知道一种特定的二进制格式，即类文件格式，我们写好的程序最终交给JVM执行的时候会被编译成二进制格式，JVM只认识二进制格式，所以任何语言只要编译后的格式符合要求，都可以在JVM上运行。</p><p><strong>JVM 组成部分</strong></p><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/img.png"></p><ul><li>类加载器，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中。</li><li>内存区，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等。</li><li>执行引擎，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU 。</li><li>本地方法调用，调用 C 或 C++ 实现的本地方法的代码返回结果。</li></ul><p>一个Java类在经过编译好类加载之后，会将加载后的数据放入运行时数据区域，这样我们在运行程序时就可以直接从运行时数据区域中读取信息。</p><h3 id="JVM运行时数据区域详解"><a href="#JVM运行时数据区域详解" class="headerlink" title="JVM运行时数据区域详解"></a>JVM运行时数据区域详解</h3><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/img_1.png"></p><p>JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略 ，保证了 JVM 的高效稳定运行。</p><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/img_8.png"></p><h4 id="从jdk版本差异解读各内存区域"><a href="#从jdk版本差异解读各内存区域" class="headerlink" title="从jdk版本差异解读各内存区域"></a>从jdk版本差异解读各内存区域</h4><p>实际上，为了更好的适应 CPU 性能提升，最大限度提升JVM 运行效率，JDK中各个版本对JVM进行了一些迭代，示意图如下</p><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB.png"></p><p>JDK1.6、JDK1.7、JDK1.8 JVM 内存模型主要有以下差异：</p><ul><li>JDK 1.6：有永久代，静态变量存放在永久代上。</li><li>JDK 1.7：有永久代，但已经把字符串常量池、静态变量，存放在堆上。逐渐的减少永久代的使用。</li><li>JDK 1.8：无永久代，运行时常量池、类常量池，都保存在元数据区，也就是常说的元空间。但字符串常量池仍然存放在堆上。</li></ul><h4 id="从线程是否共享解读各内存区域"><a href="#从线程是否共享解读各内存区域" class="headerlink" title="从线程是否共享解读各内存区域"></a>从线程是否共享解读各内存区域</h4><p>如果按照线程是否共享来分类的话，如下图所示：</p><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/img_9.png"></p><h5 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h5><h6 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h6><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。<code>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，CPU 只有把数据装载到寄存器才能够运行。寄存器存储指令相关的现场信息，由于CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</code><ul><li>每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器用来存放执行指令的偏移量和行号指示器等，线程执行或恢复都要依赖程序计数器。</li></ul></li><li>如果该方法不是Native方法，即PC寄存器会记录当前正在执行的java虚拟机指令的地址; 如果线程当前执行的方法是本地的，那么java虚拟机的PC寄存器的值就是Undefined。</li><li><strong>唯一不会发生OOM的区</strong>，随线程创建而创建、随线程死亡而死亡，因此不需要进行 GC。</li></ul><h6 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h6><ul><li><p>Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：<strong>局部变量表、操作数栈、动态链接、方法出口信息</strong>。</p></li><li><p>局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用</p><ul><li><p>存放方法参数和方法内部定义的局部变量</p><p><code>所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</code> </p><ul><li><p>如果局部变量是Java的8种基本基本数据类型，则存在局部变量表中，如果是引用类型。如new出来的String，局部变量表中存的是引用，而实例在堆中。</p><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/img_10.png"></p></li></ul></li></ul></li><li><p>操作数栈</p><ul><li>操作数栈（Operand Stack）看名字可以知道是一个栈结构。</li><li>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。</li><li>当JVM为方法创建栈帧的时候，在栈帧中为方法创建一个操作数栈，保证方法内指令可以完成工作。</li></ul><details><summary>用实操理解一下</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> Richard_yyf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperandStackTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译生成.class文件之后，再反汇编查看汇编指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac OperandStackTest.java</span><br><span class="line">javap -v OperandStackTest.class &gt; 1.txt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int sum(int, int);</span><br><span class="line">  descriptor: (II)I</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=3, args_size=3 // 最大栈深度为2 局部变量个数为3</span><br><span class="line">       0: iload_1 // 局部变量1 压栈</span><br><span class="line">       1: iload_2 // 局部变量2 压栈</span><br><span class="line">       2: iadd    // 栈顶两个元素相加，计算结果压栈</span><br><span class="line">       3: ireturn</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 10: 0</span><br></pre></td></tr></table></figure></details></li><li><p>动态链接</p><ul><li>每个栈帧中包含一个在常量池中<strong>对当前方法的引用</strong>， 目的是<strong>支持方法调用过程的动态连接</strong>。</li></ul></li><li><p>方法返回地址</p><p>方法执行时有两种退出情况：</p><ul><li>正常退出，即正常执行到任何方法的返回字节码指令，如 RETURN、IRETURN、ARETURN等</li><li>异常退出</li></ul><p>无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：</p><ul><li>返回值压入上层调用栈帧</li><li>异常信息抛给能够处理的栈帧</li><li>PC 计数器指向方法调用后的下一条指令</li></ul><p>扩展阅读： <a href="https://link.juejin.cn/?target=https://louluan.blog.csdn.net/article/details/50412126">JVM机器指令集图解</a></p></li><li><p>为执行字节码服务</p></li><li><p>StackOverFlowError（不允许动态扩展，栈深度大于虚拟机允许的栈深度） 和 OutOfMemoryError （允许动态扩展，内存不足）</p></li><li><p>方法执行时入栈，方法执行完出栈，入栈出栈的时机很明确，所以这块区域不需要进行 GC。<br><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/img4.png"></p></li><li><p>扩展阅读： <a href="https://www.cnblogs.com/noKing/p/8167700.html">栈帧</a></p></li><li><p>扩展阅读： <a href="https://www.pianshen.com/article/9519386034/">逃逸分析-栈上分配-TLAB</a>, 对于开启逃逸分析的程序而言，不会逃逸的对象也会分配在栈上。</p></li></ul><h6 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h6><ul><li>与虚拟机栈相似，为执行Native服务。</li><li>本地方法栈和虚拟机栈在有的虚拟机是合在一起的，例如Hot Spot虚拟机。</li></ul><h5 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h5><h6 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h6><ul><li><p>所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放<strong>对象实例和数组</strong>，<em>几乎</em> 所有的对象实例以及数组都在这里分配内存(随着JIT编译器的发展和逃逸分析技术的成熟，这个说法也不是那么绝对)。</p><p>  <img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/cb25f0d4c52a9ffca1925e9694c6954d.jpg" alt="java堆空间"></p></li><li><p>java8后永久代已移除。</p></li><li><p>堆中的对象永远不会被显式释放，必须由GC回收。GC主要区域，也叫GC堆，采用分代垃圾收集算法（年轻代&amp;老年代）。</p></li><li><p>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。</p><p><code>值得注意的是，在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，会形成不必要的系统压力 所以在线上生产环境中 JVM的Xms和 Xmx会设置成同样大小，避免在GC 后调整堆大小时带来的额外压力。</code></p></li></ul><h6 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h6><ul><li>方法区也是所有线程共享。主要用于存储<strong>类的信息、常量池、方法数据、方法代码</strong>等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。</li><li>JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域, 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。  空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。</li><li>如果方法区的内存无法满足分配请求时也会抛出OutOfMemoryError</li><li>扩展阅读：<a href="https://www.cnblogs.com/paddix/p/5309550.html">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></li></ul><p><em>运行时常量池</em></p><p>方法区的一部分，用于存储编译生成的字面量（基本数据类型或被final修饰的常量或字符串）和符号引用，类或接口的运行时常量池是在java虚拟机创建类或接口时创建的。</p><ul><li>jdk1.6及之前: Java中的字符串是放在方法区中的运行时常量池内，</li><li>jdk1.7以后: 将字符串常量池拿出来放在了堆中。</li></ul><details><summary>一个有趣的例子</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GcDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;lonely&quot;</span>)+<span class="keyword">new</span> String(<span class="string">&quot;wolf&quot;</span>);</span><br><span class="line">        System.out.println(str == str.intern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在jdk1.6中打印false，在jdk1.7和jdk1.8中打印true。 关于intern()方法：</p><ul><li>JDK1.6：调用String.intern()方法，会先去检查常量池中是否存在该字符串，如果不存在，则会在方法区中创建一个字符串，而new String()创建的字符串在堆中，两个字符串的地址当然不相等。</li><li>JDK1.8：字符串常量池从方法区的运行时常量池移到了堆中，调用String.intern()方法，首先会检查常量池是否存在，如果不存在，那么就会创建一个常量，并将引用指向堆，也就是说不会再重新创建一个字符串对象了，两者都会指向堆中的对象，所以返回true。</li></ul><p>只有一个new String()，产生两个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GcDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(<span class="string">&quot;lonely&quot;</span>);</span><br><span class="line">        System.out.println(str == str.intern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有一个new String()，在jdk1.7和jdk1.8也会返回false，我们假设一开始字符串常量池没有任何字符串，执行一个new String(“lonely”)会产生两个对象，一个在堆，一个在字符串常量池。</p><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/img_5.png"></p><p>String.intern()先检查字符串常量池，发现存在”lonely”的字符串，所以直接返回，这时候两个地址不一样，所以返回false。</p><ul><li><p>new String(“lonely”)+new String(“wolf”)会产生5个对象，2个在字符串常量池，3个在堆。<br><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/img_6.png" alt="img.png"></p><ul><li>如果在1.7和1.8中会检查字符串常量池，发现没有lonelywolf的字符串，所以会在字符串常量池创建一个，指向堆中的字符串。</li><li>JDK1.6中不会指向堆，会重新创建一个lonelywolf的字符串放到字符串常量池，所以才会产生不同的结果。</li></ul></li></ul></details><h6 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h6><ul><li>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。</li><li>使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。  这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。</li><li>Java8后<strong>方法区的实现-元空间就在使用了直接内存实现</strong>（不进行GC进而提高了性能）</li><li>Code Cache<ul><li><strong>JVM代码缓存是JVM将其字节码存储为本机代码的区域</strong>。我们将可执行本机代码的每个块称为 nmethod 。该 nmethod可能是一个完整的或内联Java方法。</li><li>实时（JIT）编译器是代码缓存区域的最大消费者。这就是为什么一些开发人员将此内存称为JIT代码缓存的原因。 </li><li>一般情况下我们是不会关心这部分区域的且大部分开发人员对这块区域也不熟悉。如果这块区域OOM了，在日志里面就会看到 java.lang.OutOfMemoryError code cache。</li><li>扩展阅读: <a href="https://link.juejin.cn/?target=https://www.baeldung.com/jvm-code-cache">Introduction to JVM Code Cache</a></li></ul></li><li>也可能导致 OutOfMemoryError 异常出现。</li><li>扩展阅读：<a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/35cf0f348275">堆外内存回收</a></li></ul><h3 id="从进程与线程的角度理解JVM运行时数据区设计原理"><a href="#从进程与线程的角度理解JVM运行时数据区设计原理" class="headerlink" title="从进程与线程的角度理解JVM运行时数据区设计原理"></a>从进程与线程的角度理解JVM运行时数据区设计原理</h3><p>首先，我们回顾一下进程与线程的区别与联系:</p><p><strong>进程 = 线程+内存+文件/网络句柄</strong></p><ul><li>这里的内存是逻辑内存，指的是内存的寻址空间。每个进程的内存是相互独立的。</li><li>文件/网络句柄是所有的进程所共有的，例如打开同一个文件，去抢同一个网络的端口这样的操作是被允许的</li></ul><p><strong>线程 = 栈+PC+TLS</strong></p><ul><li>通常都是说调用堆栈，调用堆栈就是调用栈的意思(这里的堆是没有含义的)。每次调用的时候，会把所有的参数和返回地址压入到栈中。</li><li>Program Counter: 程序计数器，我们的进程只是一个容器。PC就是指向当前的指令，而这个指令是放在内存中。每个线程都有一串自己的指针，去指向自己当前所在内存的指针。</li><li>thread local storage: 线程独立的内存就是TLS，可以用来存储我们线程所独有的数据。</li></ul><p><strong>总结如下</strong></p><ol><li>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；</li><li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li><li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；</li><li>调度和切换：线程上下文切换比进程上下文切换要快得多。</li></ol><p>线程与进程关系的示意图：<br><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/img_2.png"><br><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/img_3.png"></p><p><strong>对于一个JAVA进程而言</strong>：</p><ul><li>JAVA进程间的内存分配保持独立</li><li>JAVA同进程的多线程间共享代码段（方法区）、数据集（堆）</li><li>JAVA各线程分别维护自己的寄存器（程序计数器）和方法栈（分为本地方法栈和虚拟机栈）</li></ul><h3 id="从操作系统层面理解JVM与系统物理内存分配"><a href="#从操作系统层面理解JVM与系统物理内存分配" class="headerlink" title="从操作系统层面理解JVM与系统物理内存分配"></a>从操作系统层面理解JVM与系统物理内存分配</h3><h4 id="系统进程占用的物理内存高于-Xmx"><a href="#系统进程占用的物理内存高于-Xmx" class="headerlink" title="系统进程占用的物理内存高于-Xmx"></a>系统进程占用的物理内存高于-Xmx</h4><p>在实际运行过程中，我们通常会发现: 系统进程占用的物理内存(Res/Rss)会大于设置的Xmx值</p><p>实际上，-Xmx和-Xms参数实际上只是Java堆对象将会占用的内存，而堆只是影响Java程序占用内存数量的一个因素。</p><p>除了堆，影响Java程序所占用内存的因素还包括: 栈、永生代、JVM本身、NIO中的DirectBuffer等。</p><p>因此，一般使用Xmx分配给JVM的，肯定不能太多。</p><p>而且，在操作系统上，运行的不仅仅是JVM应用，还会有其他一些守护进程，比如各种日志收集工具、监控工具、安全工具等。它们虽然占用的内存不是很多，但累加起来还是比较可观的。JVM内存和操作系统的剩余内存是一个此消彼长的关系，这些小内存挤占了JVM的发挥空间，就容易出问题。</p><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/img_7.png"></p><p>JVM是我们的主体，所以要把它放在主人公的位置。这种划分方式，就可以把整个内存搞成JVM内存、操作系统物理内存、SWAP三个部分。</p><p>当JVM和其他程序占满了物理内存，接着占满了SWAP内存（交换分区一般不开，此处不展开），当在需要申请内存空间的时候，操作系统发现没有可用的内存空间了。</p><p>这个时候，Linux会启动oom-killer，杀死占用内存最大的进程，这个时候大概率我们的JVM进程。</p><p>由于这个OOM为操作系统本身的OOM，这个时候会出现的现象为: <strong>java进程死了，但是没有留下任何日志</strong></p><p><code>此日志可以通过dmesg命令找到，属于操作系统范畴</code></p><h4 id="对内存做一些更细致的划分"><a href="#对内存做一些更细致的划分" class="headerlink" title="对内存做一些更细致的划分"></a>对内存做一些更细致的划分</h4><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/%E5%86%85%E5%AD%98.png"></p><ul><li>堆内内存: 是我们平常打交道最多的地方，因为我们大部分Java对象，都是在堆上分配的。<ul><li>一旦有溢出问题，使用jmap + mat等一系列猛如虎的操作，就可以方便快捷的发现问题。</li></ul></li><li>堆外内存<ul><li>元空间<ul><li>jdk8以后才加入的，用来替换原来的永久代，用于存储那些变动很少的数据，稳定为主。</li><li>比如我们在jvm启动时，加载的那些class文件；以及在运行时，动态生成的代理类。</li><li>默认是没有上限的，极端情况下，会一直挤占操作系统的剩余内存。</li></ul></li><li>CodeCache<ul><li>JIT是JVM一个非常重要的特性，CodeCahe存放的，就是即时编译器所生成的二进制代码。</li><li>当然，JNI的代码也是放在这里的。</li><li>在不同的平台，大小都是不一样的，但一般够用了。<code>调的非常小的情况下，JVM不会溢出，这个区域也不会溢出，但是会退化成解释型执行模式，速度和JIT不可同日而语，慢个数量级也是可能的</code></li></ul></li><li>本地内存<ul><li>网络内存<ul><li>可以认为它是操作系统内核所占用的内存，也可以认为是JVM进程占用的内存</li><li>如果你的系统并发非常高，这部分内存的占用也是比较多的。因为连接一般对应着网卡的数据缓冲区，还有文件句柄的耗费。</li></ul></li><li>线程内存<ul><li>如果你造的线程非常多，JVM除了占用Thread对象本身很小的一部分堆内存，大部分是以轻量级进程的方式存在于操作系统。</li><li>这同样是一个积少成多的内存区域，但一般不会发生问题</li></ul></li><li>JNI内存<ul><li>上面谈到CodeCache存放的JNI代码，JNI内存就是指的这部分代码所malloc的具体内存。 </li><li>比如Java的zip库，就不是在JVM的堆里完成的，而是开辟了一个堆外的缓冲池进行运算。</li></ul></li><li>直接内存<ul><li>指的是使用了Java的直接内存API，进行操作的内存。</li><li>这部分内存可以受到JVM的管控，比如ByteBuffer类所做的事情。</li><li>ByteBuffer底层是用的unsafe, 但unsafe是不受直接内存的管控的，因此并不会造成JVM直接内存溢出，反而会造成操作系统内存溢出。。</li></ul></li></ul></li></ul></li></ul><h4 id="如何排查操作系统内存"><a href="#如何排查操作系统内存" class="headerlink" title="如何排查操作系统内存"></a>如何排查操作系统内存</h4><p>linux下有一个命令lsof，可以看到JVM进程所关联的所有句柄信息，一般可作为参考。</p><p>近一步，使用pmap函数，即可观测到具体的内存分布。但是不要怕，有很多是共享内存。</p><p>具体排查思路可以参考 <a href="/2020/06/18/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/JAVA%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E5%85%A8%E5%A5%97%E8%B7%AF/" title="JAVA线上故障排查全套路">JAVA线上故障排查全套路</a> 中的堆外内存溢出。</p><h4 id="内存区域控制参数"><a href="#内存区域控制参数" class="headerlink" title="内存区域控制参数"></a>内存区域控制参数</h4><p><img src="/2021/08/12/JAVA%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80/JVM%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%A8%A1%E5%9E%8B/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%8F%82%E6%95%B0.png"></p><ul><li>堆  <code>-Xmx  -Xms</code></li><li>元空间 <code>-XX:MaxMetaspaceSize  -XX:MetaspaceSize</code></li><li>栈 <code>-Xss</code></li><li>直接内存  <code>-XX:MaxDirectMemorySize</code></li><li>JIT编译后代码存放 <code>-XX:ReservedCodeCacheSize</code></li><li>其他堆外内存 <code>无法控制！随缘吧</code></li></ul><p>可以看到，堆外内存的占用，其实还是比较多的。如果你太贪婪，整个内存很容易就玩玩。</p><p>一般的，我们使用操作系统的2/3作为堆空间，是比较合理的。这是一个经验值。比如6GB的内存，你分配给JVM的，最好不要超过4GB。</p><p>还有，我们上面谈到的swap交换分区，在高并发应用中，一般是关掉的。因为它会造成频繁的页交换，在GC的时候，会引起严重的卡顿。</p><p>但要辩证的思维看待问题。对于低频的，对内存大小有非常大的依赖的情况下，SWAP不仅要开，还要开的大一些。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JVM是什么&quot;&gt;&lt;a href=&quot;#JVM是什么&quot; class=&quot;headerlink&quot; title=&quot;JVM是什么&quot;&gt;&lt;/a&gt;JVM是什么&lt;/h3&gt;&lt;p&gt;而对于不同的操作系统，系统操作指令集（CPU原语）往往是不同的。JVM即Java虚拟机，是基于C/C++开发</summary>
      
    
    
    
    <category term="JAVA基础" scheme="http://example.com/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>代码实用小套路之Java 性能优化的一些细节</title>
    <link href="http://example.com/2021/08/12/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%A5%97%E8%B7%AF%E4%B9%8BJava-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/"/>
    <id>http://example.com/2021/08/12/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%A5%97%E8%B7%AF%E4%B9%8BJava-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/</id>
    <published>2021-08-12T01:40:24.000Z</published>
    <updated>2021-08-22T02:04:00.706Z</updated>
    
    <content type="html"><![CDATA[<p>在JAVA程序中，性能问题的大部分原因并不在于JAVA语言，而是程序本身。养成良好的编码习惯非常重要，能够显著地提升程序性能。</p><ol><li><p>尽量在合适的场合使用单例</p><p> 使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例</p><p> 简单来说，单例主要适用于以下三个方面：</p><ul><li>控制资源的使用，通过线程同步来控制资源的并发访问；</li><li>控制实例的产生，以达到节约资源的目的；</li><li>控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</li></ul></li><li><p>尽量避免随意使用静态变量</p><p> 当某个对象被定义为static变量所引用，那么GC通常是不会回收这个对象所占有的内存，如:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时静态变量 b 的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。</p></li><li><p>尽量避免过多过常地创建Java对象</p><p>尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理。</p><p>在我们可以控制的范围内，最大限度地重用对象，最好能用基本的数据类型或数组来替代对象。</p></li><li><p>尽量使用final修饰符</p><p>带有final修饰符的类是不可派生的。在JAVA核心API中，有许多应用final的例子，例如java、lang、String，为String类指定final防止了使用者覆盖length()方法。</p><p>另外，如果一个类是final的，则该类所有方法都是final的。java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关），此举能够使性能平均提高50%。</p><p>如：让访问实例内变量的getter/setter方法变成”final：简单的getter/setter方法应该被置成final，这会告诉编译器，这个方法不会被重载，所以，可以变成”inlined”,例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MAF</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">     _size = size;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> _size;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 更正</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DAF_fixed</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span> <span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">     _size = size;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> _size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>尽量使用局部变量</p><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快；其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。</p></li><li><p>尽量处理好包装类型和基本类型两者的使用场所</p><p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的</p><ul><li><p>基本类型数据产生和处理都在栈中处理，包装类型作为对象是在堆中产生实例（开启逃逸分析小对象也在栈上分配?）。</p></li><li><p>在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。</p></li></ul></li><li><p>慎用synchronized，尽量减小synchronize的方法</p><p>都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p><p>synchronize方法被调用时，直接会把当前对象锁了，在方法执行完之前其他线程无法调用当前对象的其他方法。</p><p>所以，synchronize的方法尽量减小，并且应<strong>尽量使用方法同步代替代码块同步</strong>。</p></li><li><p>尽量不要使用finalize方法</p><p>实际上，将资源清理放在finalize方法中完成是非常不好的选择</p><p>由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。</p></li><li><p>尽量使用基本数据类型代替对象</p><p>String str = “hello”;</p><p>上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；</p><p>String str = new String(“hello”);</p><p>此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o</p></li><li><p>多线程在未发生线程安全前提下应尽量使用HashMap、ArrayList</p></li></ol><p>   HashTable、Vector等使用了同步机制，降低了性能。</p><ol start="11"><li>尽量合理的创建HashMap</li></ol><p>   当你要创建一个比较大的hashMap时，充分利用这个构造函数</p><p>   public HashMap(int initialCapacity, float loadFactor);</p><p>   避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事</p><p>   在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。</p><ol start="12"><li>尽量减少对变量的重复计算</li></ol><p>   如：</p><p>   <code>for(int i=0;i&lt;list.size();i++)</code></p><p>   应该改为：<br>   <code>for(int i=0,len=list.size();i&lt;len;i++)</code></p><p>   并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。</p><ol start="13"><li>尽量避免不必要的创建</li></ol><p>   如：</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A a = new A();</span><br><span class="line">if(i==1)&#123;</span><br><span class="line">   list.add(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   应该改为：</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(i==1)&#123;</span><br><span class="line">   A a = new A();</span><br><span class="line">   list.add(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="14"><li>尽量在finally块中释放资源</li></ol><p>   程序中使用到的资源应当被释放，以避免资源泄漏，这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。</p><ol start="15"><li>尽量使用移位来代替’a/b’或者’a*b’的操作</li></ol><p>   “/“和”*”是一个代价很高的操作，使用移位的操作将会更快和更有效</p><p>   如：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int num = a / 4;</span><br><span class="line">int num = a / 8;</span><br><span class="line">int num = a * 4;</span><br><span class="line">int num = a * 8;</span><br></pre></td></tr></table></figure></p><p>   应该改为：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int num = a &gt;&gt; 2;</span><br><span class="line">int num = a &gt;&gt; 3;</span><br><span class="line">int num = a &lt;&lt; 2;</span><br><span class="line">int num = a &lt;&lt; 3;</span><br></pre></td></tr></table></figure></p><p>   但注意的是<strong>使用移位应添加注释</strong>，因为移位操作不直观，比较难理解。</p><ol start="16"><li>尽量确定StringBuffer的容量</li></ol><p>   StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。</p><p>   在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再丢弃旧的数组。</p><p>   在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。如：</p><p>   StringBuffer buffer = new StringBuffer(1000);</p><ol start="17"><li>尽量早释放无用对象的引用</li></ol><p>   大部分时，方法局部引用变量所引用的对象会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。例如：</p><p>   Java代码<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Public void test()&#123;</span><br><span class="line">   Object obj = new Object();</span><br><span class="line">   ……</span><br><span class="line">   Obj = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   上面这个就没必要了，随着方法test()的执行完成，程序中obj引用变量的作用域就结束了。</p><p>   但是如果是改成下面：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Public void test()&#123;</span><br><span class="line">   Object obj = new Object();</span><br><span class="line">   ……</span><br><span class="line">   Obj = null;</span><br><span class="line">   //执行耗时，耗内存操作；或调用耗时，耗内存的方法</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>   这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。</p><ol start="18"><li>尽量避免使用二维数组</li></ol><p>   二维数据占用的内存空间比一维数组多得多，大概10倍以上。</p><ol start="19"><li>尽量避免使用split</li></ol><p>   除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低</p><p>   如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果</p><ol start="20"><li>ArrayList &amp; LinkedList</li></ol><p>   一个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据</p><p>   不过这是理论性分析，事实未必如此，重要的是理解好2者得数据结构，对症下药。</p><ol start="21"><li>尽量使用System.arraycopy ()代替通过来循环复制数组</li></ol><p>   System.arraycopy() 要比通过循环来复制数组快的多。</p><ol start="22"><li>尽量缓存经常使用的对象</li></ol><p>   尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降</p><p>   推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO/FLU等缓存算法。</p><ol start="23"><li>尽量避免非常大的内存分配</li></ol><p>   有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。</p><ol start="24"><li>慎用异常</li></ol><p>   当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。</p><p>   构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。</p><p>   当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。</p><p>   如果您创建一个 Exception ，就得付出代价，好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。</p><p>   从技术上讲，你甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。</p><p>   真正要花代价的是创建异常，幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。</p><ol start="25"><li>尽量重用对象</li></ol><p>   特别是String对象的使用中，出现字符串连接情况时应使用StringBuffer代替，由于系统不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理。因此生成过多的对象将会给程序的性能带来很大的影响。</p><ol start="26"><li>不要重复初始化变量</li></ol><p>   默认情况下，调用类的构造函数时，java会把变量初始化成确定的值，所有的对象被设置成null，整数变量设置成0，float和double变量设置成0.0，逻辑值设置成false。</p><p>   当一个类从另一个类派生时，这一点尤其应该注意，因为用new关键字创建一个对象时，构造函数链中的所有构造函数都会被自动调用。</p><p>   这里有个注意，给成员变量设置初始值但需要调用其他方法的时候，最好放在一个方法。比如initXXX()中，因为直接调用某方法赋值可能会因为类尚未初始化而抛空指针异常，如：public int state = this.getState()。</p><ol start="27"><li><p>在java+Oracle的应用系统开发中，java中内嵌的SQL语言应尽量使用大写形式，以减少Oracle解析器的解析负担。</p></li><li><p>在java编程过程中，进行数据库连接，I/O流操作，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销。</p></li><li><p>过分的创建对象会消耗系统的大量内存，严重时，会导致内存泄漏</p></li></ol><p>   因此，保证过期的对象的及时回收具有重要意义。JVM的GC并非十分智能，因此建议在对象使用完毕后，手动设置成null。</p><ol start="30"><li>不要在循环中使用Try/Catch语句，应把Try/Catch放在循环最外层</li></ol><p>   Error是获取系统错误的类，或者说是虚拟机错误的类。不是所有的错误Exception都能获取到的，虚拟机报错Exception就获取不到，必须用Error获取。</p><ol start="31"><li>array(数组)和ArrayList的使用</li></ol><p>   array 数组效率最高，但容量固定，无法动态改变，ArrayList容量可以动态增长，但牺牲了效率。</p><ol start="32"><li><p>单线程应尽量使用 HashMap, ArrayList,除非必要，否则不推荐使用HashTable,Vector，它们使用了同步机制，而降低了性能。</p></li><li><p>考虑使用静态方法，如果你没有必要去访问对象的外部，那么就使你的方法成为静态方法。它会被更快地调用，因为它不需要一个虚拟函数导向表。</p></li></ol><p>   这同时也是一个很好的实践，因为它告诉你如何区分方法的性质，调用这个方法不会改变对象的状态。</p><ol start="34"><li><p>避免枚举，浮点数的使用。</p></li><li><p>使用32位的无符号整数（UNSIGNED INT）来存储IP地址，而不是使用字符串 </p><p>  相对字符串存储，使用无符号整数来存储有如下的好处：</p><ul><li>节省空间，不管是数据存储空间，还是索引存储空间<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通常，在保存IPv4地址时，一个IPv4最小需要7个字符，最大需要15个字符，所以，使用VARCHAR(15)即可。MySQL在保存变长的字符串时，还需要额外的一个字节来保存此字符串的长度。而如果使用无符号整数来存储，只需要4个字节即可。</span><br></pre></td></tr></table></figure></li><li>便于使用范围查询（BETWEEN…AND），且效率更高</li></ul><p>  另外还可以使用4个字段分别存储IPv4中的各部分，但是通常这不管是存储空间和查询效率应该都不是很高（可能有的场景适合使用这种方式存储）。</p><p>  使用无符号整数来存储也有缺点：</p><ul><li>不便于阅读</li><li>需要手动转换</li></ul></li></ol>   <details><summary>对于转换来说，MySQL提供了相应的函数</summary>      <p>   把字符串格式的IP转换成整数<code>INET_ATON</code>，以及把整数格式的IP转换成字符串的<code>INET_NTOA</code>。如下所示：<br>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select inet_aton(<span class="string">&#x27;192.168.0.1&#x27;</span>);</span></span><br><span class="line">+--------------------------+</span><br><span class="line">| inet_aton(&#x27;192.168.0.1&#x27;) |</span><br><span class="line">+--------------------------+</span><br><span class="line">|               3232235521 |</span><br><span class="line">+--------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select inet_ntoa(3232235521);</span></span><br><span class="line">+-----------------------+</span><br><span class="line">| inet_ntoa(3232235521) |</span><br><span class="line">+-----------------------+</span><br><span class="line">| 192.168.0.1           |</span><br><span class="line">+-----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><br>   对于IPv6来说，使用VARBINARY同样可获得相同的好处，同时MySQL也提供了相应的转换函数，即<code>INET6_ATON</code>和<code>INET6_NTOA</code></p><p>   对于转换字符串IPv4和数值类型，可以放在应用层，下面是使用java代码来对二者转换：<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IpLongUtils</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 把字符串IP转换成long</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ipStr 字符串IP</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> IP对应的long值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">ip2Long</span><span class="params">(String ipStr)</span> </span>&#123;</span><br><span class="line">      String[] ip = ipStr.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> (Long.valueOf(ip[<span class="number">0</span>]) &lt;&lt; <span class="number">24</span>) + (Long.valueOf(ip[<span class="number">1</span>]) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">              + (Long.valueOf(ip[<span class="number">2</span>]) &lt;&lt; <span class="number">8</span>) + Long.valueOf(ip[<span class="number">3</span>]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 把IP的long值转换成字符串</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ipLong IP的long值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> long值对应的字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">long2Ip</span><span class="params">(<span class="keyword">long</span> ipLong)</span> </span>&#123;</span><br><span class="line">      StringBuilder ip = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">      ip.append(ipLong &gt;&gt;&gt; <span class="number">24</span>).append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">      ip.append((ipLong &gt;&gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>).append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">      ip.append((ipLong &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>).append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">      ip.append(ipLong &amp; <span class="number">0xFF</span>);</span><br><span class="line">      <span class="keyword">return</span> ip.toString();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      System.out.println(ip2Long(<span class="string">&quot;192.168.0.1&quot;</span>));</span><br><span class="line">      System.out.println(long2Ip(<span class="number">3232235521L</span>));</span><br><span class="line">      System.out.println(ip2Long(<span class="string">&quot;10.0.0.1&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   输出结果如下：<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3232235521</span><br><span class="line">192.168.0.1</span><br><span class="line">167772161</span><br></pre></td></tr></table></figure><br>   </p></details><p></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在JAVA程序中，性能问题的大部分原因并不在于JAVA语言，而是程序本身。养成良好的编码习惯非常重要，能够显著地提升程序性能。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;尽量在合适的场合使用单例&lt;/p&gt;
&lt;p&gt; 使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有</summary>
      
    
    
    
    <category term="代码规范" scheme="http://example.com/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="代码规范" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>代码实用小套路之Effective Java阅读笔记</title>
    <link href="http://example.com/2021/08/12/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%A5%97%E8%B7%AF%E4%B9%8BEffective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2021/08/12/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%A5%97%E8%B7%AF%E4%B9%8BEffective-Java%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-12T01:38:29.000Z</published>
    <updated>2021-08-12T02:49:57.953Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jiapengcai.gitbooks.io/effective-java/content/">《Effective Java》第三版中文版</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://jiapengcai.gitbooks.io/effective-java/content/&quot;&gt;《Effective Java》第三版中文版&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="代码规范" scheme="http://example.com/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="代码规范" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>数据库版本管理之Flyway使用指南</title>
    <link href="http://example.com/2021/08/11/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E4%B9%8BFlyway%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://example.com/2021/08/11/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E4%B9%8BFlyway%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2021-08-11T02:13:23.000Z</published>
    <updated>2021-08-12T09:57:21.109Z</updated>
    
    <content type="html"><![CDATA[<p>对于数据库版本管理，我们已经介绍过一款类似工具<a href="/2021/08/11/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E4%B9%8BLiquibase%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="数据库版本管理之Liquibase使用指南">数据库版本管理之Liquibase使用指南</a></p><p>本文将介绍另一种数据库版本管理工具flyway.</p><p>老规矩，首先上<a href="https://flywaydb.org/documentation">官网</a></p><h3 id="Flyway是如何工作的"><a href="#Flyway是如何工作的" class="headerlink" title="Flyway是如何工作的"></a>Flyway是如何工作的</h3><p>flyway 工作原理与 Liquibase 基本一致，其工作流程如下:</p><ol><li>项目启动，应用程序完成数据库连接池的建立后，Flyway自动运行。</li><li>初次使用时，Flyway会创建一个flyway_schema_history表，用于记录sql执行记录。</li><li>Flyway会扫描项目指定路径下(默认是classpath:db/migration)的所有sql脚本，与flyway_schema_history表脚本记录进行比对。如果数据库记录执行过的脚本记录，与项目中的sql脚本不一致，Flyway会报错并停止项目执行。</li><li>如果校验通过，则根据表中的sql记录最大版本号，忽略所有版本号不大于该版本的脚本。再按照版本号从小到大，逐个执行其余脚本。</li></ol><h3 id="在SpringBoot项目使用Flyway"><a href="#在SpringBoot项目使用Flyway" class="headerlink" title="在SpringBoot项目使用Flyway"></a>在SpringBoot项目使用Flyway</h3><ol><li>初始化一个SpringBoot项目，引入MySQL数据库驱动依赖等，并且需要引入Flyway依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入flyway--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.flywaydb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flyway-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>添加Flyway配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line"><span class="comment">  # 数据库连接配置</span></span><br><span class="line">  <span class="attr">datasource</span>:<span class="string"></span></span><br><span class="line">    <span class="meta">driver-class-name</span>: <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">jdbc:mysql://localhost:3306/ssm-demo?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT%2B8</span></span><br><span class="line">    <span class="attr">username</span>: <span class="string">xxx</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">xxx</span></span><br><span class="line">  <span class="attr">flyway</span>:<span class="string"></span></span><br><span class="line"><span class="comment">    # 是否启用flyway</span></span><br><span class="line">    <span class="attr">enabled</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">    # 编码格式，默认UTF-8</span></span><br><span class="line">    <span class="attr">encoding</span>: <span class="string">UTF-8</span></span><br><span class="line"><span class="comment">    # 迁移sql脚本文件存放路径，默认db/migration</span></span><br><span class="line">    <span class="attr">locations</span>: <span class="string">classpath:db/migration</span></span><br><span class="line"><span class="comment">    # 迁移sql脚本文件名称的前缀，默认V</span></span><br><span class="line">    <span class="meta">sql-migration-prefix</span>: <span class="string">V</span></span><br><span class="line"><span class="comment">    # 迁移sql脚本文件名称的分隔符，默认2个下划线__</span></span><br><span class="line">    <span class="meta">sql-migration-separator</span>: <span class="string">__</span></span><br><span class="line"><span class="comment">    # 迁移sql脚本文件名称的后缀</span></span><br><span class="line">    <span class="meta">sql-migration-suffixes</span>: <span class="string">.sql</span></span><br><span class="line"><span class="comment">    # 迁移时是否进行校验，默认true</span></span><br><span class="line">    <span class="meta">validate-on-migrate</span>: <span class="string">true</span></span><br><span class="line"><span class="comment">    # 当迁移发现数据库非空且存在没有元数据的表时，自动执行基准迁移，新建schema_version表</span></span><br><span class="line">    <span class="meta">baseline-on-migrate</span>: <span class="string">true</span></span><br></pre></td></tr></table></figure></li><li><p>根据在配置文件的脚本存放路径的配置，在resource目录下建立文件夹db/migration</p></li><li><p>添加需要运行的sql脚本。sql脚本的命名规范为：V+版本号(版本号的数字间以”.“或”_“分隔开)+双下划线(用来分隔版本号和描述)+文件描述+后缀名，例如：V20201100__create_user.sql。如图所示：<br> <img src="/2021/08/11/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E4%B9%8BFlyway%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/img.png"></p></li><li><p>启动项目。启动成功后，在数据库中可以看到已按照定义好的脚本，完成数据库变更，并在flyway_schema_history表插入了sql执行记录。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于数据库版本管理，我们已经介绍过一款类似工具&lt;a href=&quot;/2021/08/11/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E</summary>
      
    
    
    
    <category term="实用工具" scheme="http://example.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="数据库版本管理" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据库版本管理之Liquibase使用指南</title>
    <link href="http://example.com/2021/08/11/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E4%B9%8BLiquibase%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://example.com/2021/08/11/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E4%B9%8BLiquibase%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2021-08-11T02:12:37.000Z</published>
    <updated>2021-08-11T06:26:12.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么需要数据库版本管理"><a href="#为什么需要数据库版本管理" class="headerlink" title="为什么需要数据库版本管理"></a>为什么需要数据库版本管理</h3><p>研发过程中经常涉及到数据库变更，对表结构的修复及对数据的修改，为了保证各环境都能正确的进行变更我们可能需要维护一个数据库升级文档来保存这些记录，有需要升级的环境按文档进行升级。</p><p>这样手工维护有几个缺点：</p><ul><li>无法保证每个环境都按要求执行</li><li>遇到问题不一定有相对的回滚语句</li><li>无法自动化</li></ul><p>为了解决这些问题，我们进行了一些调研，主要调研对象是Liquibase和Flyway，我们希望通过数据库版本管理工具实现以下几个目标：</p><ul><li>数据库升级</li><li>数据库回滚</li><li>版本标记</li></ul><h3 id="数据库版本管理工具Liquibase简介"><a href="#数据库版本管理工具Liquibase简介" class="headerlink" title="数据库版本管理工具Liquibase简介"></a>数据库版本管理工具Liquibase简介</h3><p>首先，上<a href="https://docs.liquibase.com/home.html">官方文档</a></p><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><p>首先，Liquibase是用于管理数据库版本的，所以就会有这些概念：</p><ul><li>版本号<ul><li>它的版本号由开发人员来维护，使用 author + id(由ChangeSet定义)</li></ul></li><li>管理的数据</li><li>差异比较</li><li>版本回滚</li></ul><p>提交数据，比较差异，版本回滚 可以使用命令行 或者 maven ，ant 等构建工具来完成</p><h5 id="Changelog-文件"><a href="#Changelog-文件" class="headerlink" title="Changelog 文件"></a>Changelog 文件</h5><p>开发人员将数据库更改存储在其本地开发计算机上基于文本的文件中，并将其应用于其本地数据库。Changelog文件可以任意嵌套，以便更好地管理。</p><p>所有Liquibase更改的根源是更改日志文件, Liquibase使用更改日志按顺序列出对数据库所做的所有更改。</p><p>它是一个包含所有数据库更改记录的文件（变更集s）, Liquibase使用此更改日志记录审核您的数据库并执行尚未应用于您的数据库的任何更改。</p><p><strong>可用属性</strong></p><ul><li>logicalFilePath: 用于在创建changeSet的唯一标识符时覆盖文件名和路径。移动或重命名change logs时是必需的。</li></ul><p><strong>可用的子标签</strong></p><ul><li><p>preConditions: 执行更改日志所需的先决条件。<a href="http://www.liquibase.org/documentation/preconditions.html">read more</a></p><ul><li>记录更改日志的编写者在创建changelog时的假设。</li><li>强制使运行change log的用户不会违反这些假设</li><li>在执行不可恢复的更改（如 drop_Table）之前执行数据检查</li><li>根据数据库的状态控制哪些changeSet运行<details><summary>demo</summary><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">databaseChangeLog</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">&quot;http://www.liquibase.org/xml/ns/dbchangelog/1.8&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.liquibase.org/xml/ns/dbchangelog/1.8</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-1.8.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">preConditions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dbms</span> <span class="attr">type</span>=<span class="string">&quot;oracle&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">runningAs</span> <span class="attr">username</span>=<span class="string">&quot;SYSTEM&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">preConditions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">changeSet</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">author</span>=<span class="string">&quot;bob&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">preConditions</span> <span class="attr">onFail</span>=<span class="string">&quot;WARN&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">sqlCheck</span> <span class="attr">expectedResult</span>=<span class="string">&quot;0&quot;</span>&gt;</span>select count(*) from oldtable<span class="tag">&lt;/<span class="name">sqlCheck</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">preConditions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>Comments should go after preCondition. If they are before then liquibase usually gives error.<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dropTable</span> <span class="attr">tableName</span>=<span class="string">&quot;oldtable&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">changeSet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseChangeLog</span>&gt;</span></span><br></pre></td></tr></table></figure>仅当针对 Oracle执行的数据库和执行脚本的数据库用户为SYSTEM时，才会运行上述databasechangelog。<br>仅当”oldtable”中没有值时，它才会运行 drop_Table命令。</details></li></ul></li><li><p>property: 将属性设置为的值（如果不是通过其他方法设置）。<a href="http://www.liquibase.org/documentation/changelog_parameters.html">read more</a></p></li><li><p>changeSet: 要执行的changeSet。<a href="http://www.liquibase.org/documentation/changeset.html">read more</a></p></li><li><p>include: 包含要执行的changeSet的其他文件。<a href="http://www.liquibase.org/documentation/include.html">read more</a></p></li></ul><p>当 Liquibase 迁移器运行时，它将分析数据库 ChangeLog 标记。它首先检查指定的先决条件。如果先决条件失败，Liquibase将退出，并显示一条错误消息，解释失败的原因。先决条件对于记录和强制执行更改日志编写器的预期和假设（如要针对的 DBMS 或以用户身份运行更改）非常有用。</p><p>如果满足所有的先决条件，Liquibase将会开始运行在databaseChangeLog文件中按照顺序出现changeSet和include标签。</p><p><strong>changelog文件格式说明</strong></p><p>具体格式参考<a href="https://docs.liquibase.com/concepts/basic/changelog.html">官方文档</a></p><p>本文列举两种常见格式:</p><ul><li><p>SQL 文件格式</p><p>其实各种文件格式使用生成数据库脚本就可以看到格式了，照着写就行：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--liquibase formatted sql</span><br><span class="line"></span><br><span class="line">--changeset &lt;author&gt;:&lt;version&gt; </span><br><span class="line">sqls</span><br><span class="line"></span><br><span class="line">--rollback rollback sqls </span><br><span class="line"></span><br><span class="line">--comment: 注释都有特殊含义了，所以注释要这样加</span><br></pre></td></tr></table></figure></li><li><p>XML 文件格式</p><p>xml 比 sql 更加可控，它可以加一个预判断条件，来判断这个后面的 changeSet 要不要执行，但相应的就必须照它的语法来写语句了，没 sql 方便了，还好提供了 xsd</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;preConditions&gt;</span><br><span class="line">    &lt;runningAs username=&quot;liquibase&quot;/&gt;</span><br><span class="line">&lt;/preConditions&gt;</span><br><span class="line">&lt;!-- 版本 1 的修改--&gt;</span><br><span class="line">&lt;changeSet id=&quot;1&quot; author=&quot;sanri&quot;&gt;</span><br><span class="line">    &lt;addColumn tableName=&quot;person&quot;&gt;</span><br><span class="line">        &lt;column name=&quot;username&quot; type=&quot;varchar(8)&quot;/&gt;</span><br><span class="line">    &lt;/addColumn&gt;</span><br><span class="line">&lt;/changeSet&gt;</span><br></pre></td></tr></table></figure></li></ul><h5 id="ChangeSet"><a href="#ChangeSet" class="headerlink" title="ChangeSet"></a>ChangeSet</h5><p>changeSet由author和id属性以及changelog文件的位置唯一标识，是 Liquibase 跟踪执行的单位（管理的数据最小单元）。</p><p>changeSet 可以用 xml,yaml,json,sql 来编写</p><p>运行 Liquibase 时，它会查询标记为已执行的changSet的DATABASECHANGELOG 表，然后执行更改日志文件中尚未执行的所有changeSet。</p><h5 id="Changes"><a href="#Changes" class="headerlink" title="Changes"></a>Changes</h5><p>每个changeSet通常包含一个更改，该更改描述要应用于数据库的更改/重构。</p><p>Liquibase 支持为支持的数据库和原始 SQL 生成 SQL 的描述性更改。</p><p>通常，<strong>每个changeSet应只有一个更改</strong>，以避免可能使数据库处于意外状态的自动提交语句失败。</p><h5 id="Preconditions"><a href="#Preconditions" class="headerlink" title="Preconditions"></a>Preconditions</h5><p>先决条件可以应用于整个changelog或单个changeSet。如果先决条件失败，liquibase将停止执行。</p><h5 id="Contexts"><a href="#Contexts" class="headerlink" title="Contexts"></a>Contexts</h5><p>可以将上下文应用于changeSet，以控制在不同环境中运行的changeSet。例如，某些changeSet可以标记为production，另一些可以标记为test。如果未指定上下文，则无论执行上下文如何，changset都将运行。</p><h4 id="Liquibase是如何工作的"><a href="#Liquibase是如何工作的" class="headerlink" title="Liquibase是如何工作的"></a>Liquibase是如何工作的</h4><p>Liquibase的核心是依靠一种简单的机制来跟踪、版本和部署更改：</p><ul><li>Liquibase 使用更改日志（是更改的分类）按特定顺序显式列出数据库更改。更改日志中的每个更改都是一个change set。更改日志可以任意嵌套，以帮助组织和管理数据库迁移。<ul><li>最佳做法是确保每个change set都尽可能原子性更改，以避免失败的结果使数据库中剩下的未处理的语句处于unknown 状态;</li><li>不过，可以将大型 SQL 脚本视为单个更改集。</li></ul></li><li>Liquibase 使用跟踪表（具体称为DATABASECHANGELOG），该表位于每个数据库上，并跟踪已部署更改日志中的change set。<ul><li>如果 Liquibase所在的数据库没有跟踪表，Liquibase 将创建一个跟踪表。</li><li>为了协助处理您未从空白数据库开始的项目，Liquibase具有生成一条更改日志以表示数据库模式当前状态的功能。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它会在你的目标数据库生成一张表 DATABASECHANGELOG 来管理版本 ，另一个 lock 的是防止多人同时操作数据库加的锁。</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>使用分类和跟踪表，Liquibase 能够：</p><ul><li>跟踪和以版本控制数据库更改 – 用户确切知道已部署到数据库的更改以及尚未部署的更改。</li><li>部署更改 — 具体来说，通过将分类(ledger)中的内容与跟踪表中的内容进行比较，Liquibase 只能将以前尚未部署到数据库的更改部署到数据库中。<ul><li>Liquibase 具有上下文、标签和先决条件等高级功能，可精确控制changeSet的部署时间以及位置。</li></ul></li></ul><h4 id="liquibase使用"><a href="#liquibase使用" class="headerlink" title="liquibase使用"></a>liquibase使用</h4><h5 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h5><p>虽然使用可以集成自 springboot ，但这种数据库脚本一般公司都是运维在维护，使用命令行是最方便的方式，所以我先说下使用命令行, <a href="http://www.liquibase.org/documentation/command_line.html">官网示例</a> </p><p>为先为了不每次都要写一大堆参数，可以在 liquibase 根目录加一个 liquibase.properties，用于配置数据库 jar、url、用户名、密码等参数, <a href="http://www.liquibase.org/documentation/config_properties.html">配置详情</a> </p><p>命令格式： liquibase [options] [command] [command parameters]</p><h6 id="比较开发库和测试库的差异，并生成升级包"><a href="#比较开发库和测试库的差异，并生成升级包" class="headerlink" title="比较开发库和测试库的差异，并生成升级包"></a>比较开发库和测试库的差异，并生成升级包</h6><p>如果要升级哪个，则哪个要做为源，则配置中的 url 不是 referenceUrl，使用如下命令创建升级包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liquibase --changeLogFile=&quot;changeLogFiledevtest.postgresql.sql&quot; diffChangeLog</span><br></pre></td></tr></table></figure><p>changeLogFile 是有命名规则的，命名必须为 *.dbType.format ，如上所示</p><h6 id="为测试库打一个标签"><a href="#为测试库打一个标签" class="headerlink" title="为测试库打一个标签"></a>为测试库打一个标签</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liquibase tag v1.0</span><br></pre></td></tr></table></figure><h6 id="使用差异升级源库"><a href="#使用差异升级源库" class="headerlink" title="使用差异升级源库"></a>使用差异升级源库</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">liquibase --changeLogFile=&quot;sqls/changeLogFiledevtest.postgresql.sql&quot; update</span><br></pre></td></tr></table></figure><h6 id="升级有问题需要回滚"><a href="#升级有问题需要回滚" class="headerlink" title="升级有问题需要回滚"></a>升级有问题需要回滚</h6><p>liquibase 有几种回滚策略，一种是根据标签回滚，回滚次数，和根据日期回滚；有 9 个与之对应的命令</p><p>回滚要求对应的 changeLogFile 有回滚标签 ，这个在后面文件格式说</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 按照 changeSet 次数回滚</span></span><br><span class="line">liquibase  --changeLogFile=&quot;sqls/changeLogFiledevtest.postgresql.sql&quot; rollbackCount 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照标签回滚</span></span><br><span class="line">liquibase  --changeLogFile=&quot;sqls/changeLogFiledevtest.postgresql.sql&quot; rollback v1.0</span><br></pre></td></tr></table></figure><h6 id="生成数据库脚本-新环境"><a href="#生成数据库脚本-新环境" class="headerlink" title="生成数据库脚本(新环境)"></a>生成数据库脚本(新环境)</h6><p>liquibase –changeLogFile=”sqls/create_table.mysql.sql”  generateChangeLog</p><h5 id="使用构建工具"><a href="#使用构建工具" class="headerlink" title="使用构建工具"></a>使用构建工具</h5><p>我们也可以使用 maven 来执行这些操作，引入 maven 的一个插件就行</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.liquibase<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>liquibase-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--指定执行主文件 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;changeLogFile&gt;$&#123;basedir&#125;/src/main/resources/liquibase/master_changelog.xml&lt;/changeLogFile&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;diffChangeLogFile&gt;$&#123;basedir&#125;/src/main/resources/liquibase/changelog/$&#123;maven.build.timestamp&#125;_changelog.xml&lt;/diffChangeLogFile&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;outputChangeLogFile&gt;$&#123;basedir&#125;/src/main/resources/liquibase/changelog/changelog_original.xml&lt;/outputChangeLogFile&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">                   <span class="tag">&lt;<span class="name">propertyFile</span>&gt;</span>src/main/resources/liquibase/liquibase.properties<span class="tag">&lt;/<span class="name">propertyFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dropFirst</span>&gt;</span>false<span class="tag">&lt;/<span class="name">dropFirst</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">logging</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">logging</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 是否需要弹出确认框 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">promptOnNonLocalDatabase</span>&gt;</span>false<span class="tag">&lt;/<span class="name">promptOnNonLocalDatabase</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--输出文件的编码 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">outputFileEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">outputFileEncoding</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--执行的时候是否显示详细的参数信息 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--是否每次都重新加载properties --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">propertyFileWillOverride</span>&gt;</span>true<span class="tag">&lt;/<span class="name">propertyFileWillOverride</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">rollbackTag</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">rollbackTag</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">tag</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>相应的命令做成了目标(goal)，使用 -Dkey=value 来指定参数，如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 执行更新 sql</span> </span><br><span class="line">mvn liquibase:update -DchangeLogFile=&quot;file&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打标签，这个版本号在插件中配置成项目版本了</span></span><br><span class="line">mvn liquibase:tag </span><br><span class="line"><span class="meta">#</span><span class="bash"> 将当前库导出表结构</span></span><br><span class="line">mvn liquibase:generateChangeLog </span><br></pre></td></tr></table></figure><h5 id="集成进-springboot-在项目启动的时候执行版本管理"><a href="#集成进-springboot-在项目启动的时候执行版本管理" class="headerlink" title="集成进 springboot, 在项目启动的时候执行版本管理"></a>集成进 springboot, 在项目启动的时候执行版本管理</h5><p>具体实现方案参考文章<a href="https://blog.csdn.net/qq_39508627/article/details/89883549?utm_medium=distribute.pc_feed_404.none-task-blog-2~default~BlogCommendFromBaidu~default-3.nonecase&depth_1-utm_source=distribute.pc_feed_404.none-task-blog-2~default~BlogCommendFromBaidu~default-3.nonecas">springboot引入liquibase</a></p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h4 id="项目开发中存在的问题"><a href="#项目开发中存在的问题" class="headerlink" title="项目开发中存在的问题"></a>项目开发中存在的问题</h4><p>随着项目的发展，一个项目中的代码量会非常庞大，同时数据库表也会错综复杂。如果一个项目使用了Liquibase对数据库结构进行管理，越来越多的问题会浮现出来。</p><ul><li>ChangeSet文件同时多人在修改，自己的ChangeSet被改掉，甚至被删除掉。</li><li>开发人员将ChangeSet添加到已经执行过的文件中，导致执行顺序出问题。</li><li>开发人员擅自添加对业务数据的修改，其它环境无法执行并报错。</li><li>ChangeSet中SQL包含schema名称，导致其它环境schema名称变化时，ChangeSet报错。</li><li>开发人员不小心改动了已经执行过的ChangeSet，在启动时会报错。</li></ul><h4 id="Liquibase基本规范"><a href="#Liquibase基本规范" class="headerlink" title="Liquibase基本规范"></a>Liquibase基本规范</h4><ul><li>ChangeSet id使用[任务ID]-[日期]-[序号]，如 T100-20181009-001</li><li>ChangeSet必须填写author</li><li>Liquibase禁止对业务数据进行sql操作</li><li>使用<sql>时，禁止包含schema名称</sql></li><li>Liquibase禁止使用存储过程</li><li>所有表，列要加remarks进行注释</li><li>已经执行过的ChangeSet严禁修改。</li><li>不要随便升级项目liquibase版本，特别是大版本升级。不同版本ChangeSet MD5SUM的算法不一样。</li></ul><p>其它数据库规范不再赘述。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">databaseChangeLog</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">changeSet</span> <span class="attr">id</span>=<span class="string">&quot;T100-20181009-001&quot;</span> <span class="attr">author</span>=<span class="string">&quot;markfredchen&quot;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">createTable</span> <span class="attr">tableName</span>=<span class="string">&quot;demo_user&quot;</span> <span class="attr">remarks</span>=<span class="string">&quot;用户表&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;bigint&quot;</span> <span class="attr">remarks</span>=<span class="string">&quot;用户ID,主键&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constraints</span> <span class="attr">nullable</span>=<span class="string">&quot;false&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;true&quot;</span> <span class="attr">primaryKeyName</span>=<span class="string">&quot;pk_demo_user_id&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">column</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">type</span>=<span class="string">&quot;varchar(100)&quot;</span> <span class="attr">remarks</span>=<span class="string">&quot;用户名&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constraints</span> <span class="attr">nullable</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">column</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">createTable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">changeSet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseChangeLog</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="有效文件管理"><a href="#有效文件管理" class="headerlink" title="有效文件管理"></a>有效文件管理</h4><p>使用Liquibase中提供<include file="xxx">tag，可以将ChangeSet分布在不同文件中。同时<include>支持多级引用。</include></include></p><p>基于此功能可以对项目中的ChangeSet进行有效管理。推荐使用以下规范进行管理。</p><h5 id="根据发布进行管理"><a href="#根据发布进行管理" class="headerlink" title="根据发布进行管理"></a>根据发布进行管理</h5><ul><li>每个发布新建一个文件夹，所有发布相关的ChangeSet文件以及数据初始化文件，均放在些文件夹中。</li><li>每个发布新建一个master.xml。此master.xml中，include本次发布需要执行的ChangeSet文件</li><li>根据开发小组独立ChangeSet文件(可选)</li><li>根据功能独立ChangeSet文件。例如user.xml, company.xml  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">resources</span><br><span class="line">|-liquibase</span><br><span class="line">|-user</span><br><span class="line">| |- master.xml</span><br><span class="line">| |- release.1.0.0</span><br><span class="line">| | |- release.xml</span><br><span class="line">| | |- user.xml -- 用户相关表ChangeSet</span><br><span class="line">| | |- user.csv -- 用户初始化数据</span><br><span class="line">| | |- company.xml -- 公司相关表ChangeSet</span><br><span class="line">| |- release.1.1.0</span><br><span class="line">| | |- release.xml</span><br><span class="line">| | |- ...</span><br></pre></td></tr></table></figure></li></ul><h5 id="模块化管理"><a href="#模块化管理" class="headerlink" title="模块化管理"></a>模块化管理</h5><p>当项目变得庞大之后，一个服务可能包含的功能模块会越来越多。此时大家会想尽办法进行模块拆分，逐步进行微服务化。然而在面对错综复杂的Liquibase ChangeSet就会无从下手。</p><p>针对这种将来可能会面对的问题，项目初期就对Liquibase进行模块化管理，将在未来带来很大收益。</p><p>首先说明一下Spring Boot中Liquibase默认是如何执行以及执行结果。</p><ul><li>在启动时，LiquibaseAutoConfiguration会根据默认配置初始化SpringLiquibase</li><li>SpringLiquibase.afterPropertiesSet()中执行ChangeSet文件</li><li>第一次跑ChangeSets的时候，会在数据库中自动创建两个表databasechangelog和databasechangeloglock</li></ul><p>因此我们可以认为一个SpringLiquibase执行为一个模块。</p><p>引入多模块管理时，基于上节文件管理规范，我们基于模块管理再做下调整。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">resources</span><br><span class="line">  |-liquibase</span><br><span class="line">    |-user</span><br><span class="line">    | |- master.xml</span><br><span class="line">    | |- release.1.0.0</span><br><span class="line">    | | |- release.xml</span><br><span class="line">    | | |- user.xml -- 用户相关表ChangeSet</span><br><span class="line">    | | |- user.csv -- 用户初始化数据</span><br><span class="line">    | | |- company.xml -- 公司相关表ChangeSet</span><br><span class="line">    | |- release.1.1.0</span><br><span class="line">    | | |- release.xml</span><br><span class="line">    | | |- ...</span><br><span class="line">    |- order</span><br><span class="line">    | |- master.xml</span><br><span class="line">    | |- release.1.0.0</span><br><span class="line">    | | |- ...</span><br></pre></td></tr></table></figure><p>当有一天我们需要把订单模块拆分成独立服务时，我们只需要将模块相关的ChangeSet文件迁出来。即可完成数据结构的拆分。</p><p>那如何在一个Spring Boot运行多个SpringLiquibase呢？需要对代码进行以下调整。</p><ol><li><p>禁用Spring Boot自动运行Liquibase。</p><p> 当以下配置被启用时，Spring Boot AutoConfigure会使用默认配置初始化名为springLiquibase的Bean。然后我们不对其进行配置，Spring Boot启动时会报错。</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties</span></span><br><span class="line"><span class="comment"># spring boot 2以上</span></span><br><span class="line"><span class="meta">spring.liquibase.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># spring boot 2以下</span></span><br><span class="line"><span class="meta">liquibase.enabled</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure></li><li><p>Spring Boot配置Liquibase Bean</p><p> 配置两个SpringLiquibase Bean，Bean名称分别为userLiquibase和orderLiqubase。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">LiquibaseConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  用户模块Liquibase   </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringLiquibase <span class="title">userLiquibase</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        SpringLiquibase liquibase = <span class="keyword">new</span> SpringLiquibase();</span><br><span class="line">        <span class="comment">// 用户模块Liquibase文件路径</span></span><br><span class="line">        liquibase.setChangeLog(<span class="string">&quot;classpath:liquibase/user/master.xml&quot;</span>);</span><br><span class="line">        liquibase.setDataSource(dataSource);</span><br><span class="line">        liquibase.setShouldRun(<span class="keyword">true</span>);</span><br><span class="line">        liquibase.setResourceLoader(<span class="keyword">new</span> DefaultResourceLoader());</span><br><span class="line">        <span class="comment">// 覆盖Liquibase changelog表名</span></span><br><span class="line">        liquibase.setDatabaseChangeLogTable(<span class="string">&quot;user_changelog_table&quot;</span>);</span><br><span class="line">        liquibase.setDatabaseChangeLogLockTable(<span class="string">&quot;user_changelog_lock_table&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> liquibase;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  订单模块Liquibase   </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringLiquibase <span class="title">orderLiquibase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      SpringLiquibase liquibase = <span class="keyword">new</span> SpringLiquibase();</span><br><span class="line">      liquibase.setChangeLog(<span class="string">&quot;classpath:liquibase/order/master.xml&quot;</span>);</span><br><span class="line">      liquibase.setDataSource(dataSource);</span><br><span class="line">      liquibase.setShouldRun(<span class="keyword">true</span>);</span><br><span class="line">      liquibase.setResourceLoader(<span class="keyword">new</span> DefaultResourceLoader());</span><br><span class="line">      liquibase.setDatabaseChangeLogTable(<span class="string">&quot;order_changelog_table&quot;</span>);</span><br><span class="line">      liquibase.setDatabaseChangeLogLockTable(<span class="string">&quot;order_changelog_lock_table&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> liquibase;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://blog.csdn.net/u012934325/article/details/100652805">LiquiBase中文学习指南</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;为什么需要数据库版本管理&quot;&gt;&lt;a href=&quot;#为什么需要数据库版本管理&quot; class=&quot;headerlink&quot; title=&quot;为什么需要数据库版本管理&quot;&gt;&lt;/a&gt;为什么需要数据库版本管理&lt;/h3&gt;&lt;p&gt;研发过程中经常涉及到数据库变更，对表结构的修复及对数据的修改</summary>
      
    
    
    
    <category term="实用工具" scheme="http://example.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="数据库版本管理" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>微服务解决方案SpringCloud Alibaba系列之Sentinel初探</title>
    <link href="http://example.com/2021/08/09/SpringCloudAlibaba/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88SpringCloud%20Alibaba%E7%B3%BB%E5%88%97%E4%B9%8BSentinel%E5%88%9D%E6%8E%A2/"/>
    <id>http://example.com/2021/08/09/SpringCloudAlibaba/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88SpringCloud%20Alibaba%E7%B3%BB%E5%88%97%E4%B9%8BSentinel%E5%88%9D%E6%8E%A2/</id>
    <published>2021-08-09T08:52:34.000Z</published>
    <updated>2021-08-12T02:54:33.386Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Sentinel-是什么"><a href="#Sentinel-是什么" class="headerlink" title="Sentinel 是什么"></a>Sentinel 是什么</h3><p>新技术学习第一步，<a href="https://sentinelguard.io/zh-cn/docs/introduction.html">官方文档</a></p><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。</p><p>Sentinel 是面向分布式服务架构的流量控制组件，作为分布式系统的流量防卫兵， 以<strong>流量</strong>为切入点，从<strong>流量控制、熔断降级、系统负载保护</strong>等多个维度保护服务的稳定性。</p><h3 id="Sentinel-要做什么"><a href="#Sentinel-要做什么" class="headerlink" title="Sentinel 要做什么"></a>Sentinel 要做什么</h3><p>服务的动态注册、服务发现是 SOA、微服务架构体系中首先需要解决的基本问题，服务治理是 SOA 领域又一重要课题，而 dubbo 框架只提供了一些基本的服务治理能力，例如限制服务并发调用数、配置合适的业务线程数量等，但熔断相关的功能就涉及的较少。</p><p>Sentinel 将作为 Dubbo 生态的重要一员，将集中解决服务治理相关的课题，服务限流与熔断又是服务治理首先要解决的课题。</p><p>那什么是限流与熔断呢？</p><ul><li>限流：我们通常使用TPS对流量来进行描述，限流就是现在服务被调用的并发TPS，从而对系统进行自我保护。</li><li>熔断：就是当系统中某一个服务出现性能瓶颈是，对这个服务的调用进行快速失败，避免造成连锁反应，从而影响整个链路的调用。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Sentinel-是什么&quot;&gt;&lt;a href=&quot;#Sentinel-是什么&quot; class=&quot;headerlink&quot; title=&quot;Sentinel 是什么&quot;&gt;&lt;/a&gt;Sentinel 是什么&lt;/h3&gt;&lt;p&gt;新技术学习第一步，&lt;a href=&quot;https://sent</summary>
      
    
    
    
    <category term="JAVA开发" scheme="http://example.com/categories/JAVA%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="高并发" scheme="http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    <category term="限流" scheme="http://example.com/tags/%E9%99%90%E6%B5%81/"/>
    
    <category term="Sentinel" scheme="http://example.com/tags/Sentinel/"/>
    
    <category term="SpringCloud Alibaba" scheme="http://example.com/tags/SpringCloud-Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件Kafka系列之与Zookeeper的爱恨缠绵</title>
    <link href="http://example.com/2021/08/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Kafka/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6Kafka%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8EZookeeper%E7%9A%84%E7%88%B1%E6%81%A8%E7%BC%A0%E7%BB%B5/"/>
    <id>http://example.com/2021/08/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Kafka/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6Kafka%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8EZookeeper%E7%9A%84%E7%88%B1%E6%81%A8%E7%BC%A0%E7%BB%B5/</id>
    <published>2021-08-04T03:08:28.000Z</published>
    <updated>2021-08-12T09:57:21.103Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="/2021/02/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/Zookeeper/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E7%BB%84%E4%BB%B6%E4%B9%8BZookeeper%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%85%A5%E9%97%A8/" title="分布式协调组件之Zookeeper基础概念入门">分布式协调组件之Zookeeper基础概念入门</a> 一文中，我们简单介绍了Zookeeper的基础概念。</p><p>而Kafka作为Zookeeper分布式协调的重要案例，本文将通过Kafka与Zookeeper的合与分展示Kafka与Zookeeper的前世今生。</p><h3 id="Kafka为什么需要Zookeeper"><a href="#Kafka为什么需要Zookeeper" class="headerlink" title="Kafka为什么需要Zookeeper"></a>Kafka为什么需要Zookeeper</h3><p>Kafka中存在众多的Leader选举，熟悉Kafka的朋友应该知道，一个主题可以拥有多个分区(数据分片)，每一个数据分片可以配置多个副本，如何保证一个分区的数据在多个副本之间的一致性成为一个迫切的需求。</p><p>Kafka的实现套路就是一个分区的多个副本，从中选举出一个Leader用来承担客户端的读写请求，从节点从主节点处拷贝内容，Leader节点根据数据在副本中成功写入情况，进行抉择来确定是否写入成功。</p><p>Kafka中topic的分区分布示意图：</p><p><img src="/2021/08/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Kafka/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6Kafka%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8EZookeeper%E7%9A%84%E7%88%B1%E6%81%A8%E7%BC%A0%E7%BB%B5/img_1.png"></p><p>故此处需要进行Leader选举,而基于Zookeeper能轻松实现，从此一拍即合，开启了一段“蜜月之旅”。</p><h3 id="Zookeeper为Kafka提供了什么"><a href="#Zookeeper为Kafka提供了什么" class="headerlink" title="Zookeeper为Kafka提供了什么"></a>Zookeeper为Kafka提供了什么</h3><p>ZooKeeper 作为给分布式系统提供协调服务的工具被 kafka 所依赖。</p><p>在分布式系统中，消费者需要知道有哪些生产者是可用的，而如果每次消费者都需要和生产者建立连接并测试是否成功连接，那效率也太低了，显然是不可取的。</p><p><img src="/2021/08/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Kafka/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6Kafka%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8EZookeeper%E7%9A%84%E7%88%B1%E6%81%A8%E7%BC%A0%E7%BB%B5/img_5.png"></p><p>通过使用 ZooKeeper 协调服务，Kafka 就能将 Producer，Consumer，Broker 等结合在一起，同时借助 ZooKeeper，Kafka 就能够将所有组件在无状态的条件下建立起生产者和消费者的订阅关系，实现负载均衡。</p><p><img src="/2021/08/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Kafka/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6Kafka%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8EZookeeper%E7%9A%84%E7%88%B1%E6%81%A8%E7%BC%A0%E7%BB%B5/img.png"></p><ol><li><p>注册中心</p><ul><li><p>Broker 信息注册</p><ul><li>在 ZooKeeper 上会有一个专门用来进行 Broker 服务器列表记录的节点，节点路径为 /brokers/ids。  </li><li>Kafka 的每个 Broker 启动时，都会在 ZooKeeper 中注册，创建 /brokers/ids/[0-N] 节点，写入 IP，端口等信息，每个 Broker 都有一个 BrokerId。  </li><li>Broker 创建的是临时节点，在连接断开时节点就会自动删除，所以在 ZooKeeper 上就可以通过 Broker 中节点的变化来得到 Broker 的可用性。</li></ul></li><li><p>Topic 信息注册</p><ul><li><p>在 Kafka 中可以定义很多个 Topic，每个 Topic 又被分为很多个 Partition。一般情况下，每个 Partition 独立在存在一个 Broker 上，所有的这些 Topic 和 Broker 的对应关系都由 ZooKeeper 进行维护。</p></li><li><p>Zookeeper会为topic分配一个单独节点，每个topic都会以/brokers/topics/[topic_name]的形式记录在Zookeeper。</p></li><li><p>一个topic的消息会被保存到多个partition，这些partition跟broker的对应关系也需要保存到Zookeeper。</p></li><li><p>partition是多副本保存的，上图中红色partition是leader副本。当leader副本所在的broker发生故障时，partition需要重新选举leader，这个需要由Zookeeper主导完成。</p></li><li><p>broker启动后，会把自己的Broker ID注册到到对应topic节点的分区列表中。</p><p>我们查看一个topic是xxx，分区编号是1的信息，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master] get /brokers/topics/xxx/partitions/1/state</span><br><span class="line">&#123;&quot;controller_epoch&quot;:15,&quot;leader&quot;:11,&quot;version&quot;:1,&quot;leader_epoch&quot;:2,&quot;isr&quot;:[11,12,13]&#125;</span><br></pre></td></tr></table></figure><p><code>当broker退出后，Zookeeper会更新其对应topic的分区列表。</code></p></li></ul></li><li><p>consumer 信息注册</p><p>   消费者组也会向Zookeeper进行注册，Zookeeper会为其分配节点来保存相关数据，节点路径为/consumers/{group_id}，有3个子节点，如下图:</p><p>   <img src="/2021/08/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Kafka/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6Kafka%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8EZookeeper%E7%9A%84%E7%88%B1%E6%81%A8%E7%BC%A0%E7%BB%B5/img_6.png"></p><p>   这样Zookeeper可以记录分区跟消费者的关系，以及分区的offset。</p></li></ul></li><li><p>负载均衡</p><p> 生产者需要将消息发送给 Broker，消费者需要从 Broker 上获取消息，通过使用 ZooKeeper，就都能监听 Broker 上节点的状态信息，从而实现动态负载均衡。</p><ul><li>broker向Zookeeper进行注册后，生产者根据broker节点来感知broker服务列表变化，这样可以实现动态负载均衡。</li><li>consumer group中的消费者，可以根据topic节点信息来拉取特定分区的消息,实现负载均衡。</li></ul></li><li><p>Controller</p><p> 在 Kafka 中会有多个 Broker，其中一个 Broker 会被选举成为 Controller（控制器），在任意时刻，Kafka 集群中有且仅有一个控制器。</p><p> Controller 负责管理集群中所有分区和副本的状态，当某个分区的 leader 副本出现故障时，由 Controller 为该分区选举出一个新的 leader。</p><p> Controller具体职责如下：</p><ul><li>监听分区变化<ul><li>当某个分区的leader出现故障时，Controller会为该分区选举新的leader。</li><li>当检测到分区的ISR集合发生变化时，Controller会通知所有broker更新元数据。</li><li>当某个topic增加分区时，Controller会负责重新分配分区。</li></ul></li><li>监听topic相关的变化</li><li>监听broker相关的变化</li><li>集群元数据管理</li></ul><p> 下面这张图展示了Controller、Zookeeper和broker的交互细节：<br> <img src="/2021/08/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Kafka/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6Kafka%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8EZookeeper%E7%9A%84%E7%88%B1%E6%81%A8%E7%BC%A0%E7%BB%B5/img_7.png"></p><p> Controller选举成功后，会从Zookeeper集群中拉取一份完整的元数据初始化ControllerContext，这些元数据缓存在Controller节点。当集群发生变化时，比如增加topic分区，Controller不仅需要变更本地的缓存数据，还需要将这些变更信息同步到其他Broker。</p><p> Controller监听到Zookeeper事件、定时任务事件和其他事件后，将这些事件按照先后顺序暂存到LinkedBlockingQueue中，由事件处理线程按顺序处理，这些处理多数需要跟Zookeeper交互，Controller则需要更新自己的元数据。</p><p> Kafka 的 Controller 选举就依靠 ZooKeeper 来完成，成功竞选为 Controller 的 Broker 会在 ZooKeeper 中创建 /controller 这个临时节点，在 ZooKeeper 中使用 get 命令查看节点内容：</p><p> <img src="/2021/08/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Kafka/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6Kafka%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8EZookeeper%E7%9A%84%E7%88%B1%E6%81%A8%E7%BC%A0%E7%BB%B5/img_2.png"></p><ul><li>“version”在目前版本中固定为1</li><li>“brokerid”表示 Broker 的编号</li><li>“timestamp”表示竞选称为 Controller 时的时间戳。</li></ul><p> Kafka Controller选举流程: 当 Broker 启动时，会尝试读取 /controller 中的“brokerid”: </p><ul><li>如果读取到的值不是-1，则表示已经有节点竞选成为 Controller 了，当前节点就会放弃竞选；</li><li>而如果读取到的值为-1，ZooKeeper 就会尝试创建 /controller 节点，当该 Broker 去创建的时候，可能还有其他 Broker 一起同时创建节点，但只有一个 Broker 能够创建成功，即成为唯一的 Controller。</li></ul></li></ol><h3 id="为什么Kafka要抛弃Zookeeper"><a href="#为什么Kafka要抛弃Zookeeper" class="headerlink" title="为什么Kafka要抛弃Zookeeper"></a>为什么Kafka要抛弃Zookeeper</h3><h4 id="外部依赖带来的复杂度及系统效率影响"><a href="#外部依赖带来的复杂度及系统效率影响" class="headerlink" title="外部依赖带来的复杂度及系统效率影响"></a>外部依赖带来的复杂度及系统效率影响</h4><p>对于 Kafka 来讲，ZooKeeper 是一套外部系统，要想部署一套 Kafka 集群，就要同时部署、管理、监控 ZooKeeper，Kafka的运维人员必须要具备Zookeeper的运维能力。</p><p>ZooKeeper 有自己的配置方式、管理工具，和 Kafka 完全不一样，所以，一起搞两套分布式系统，自然就提升了<strong>复杂度</strong>，也更容易出现问题。有时工作量还会加倍，例如要开启一些安全特性，Kafka 和 ZooKeeper 中都需要配置。</p><p>除了复杂度，外部存储也会<strong>降低系统效率</strong>。</p><p>例如 Kafka 集群每次启动的时候，Controller 必须从 ZooKeeper 加载集群的状态信息。</p><p>再比如选举出一个新的 Controller 之后也会比较麻烦，Kafaka依赖一个单一Controller节点跟Zookeeper进行交互，如果这个Controller节点发生了故障，就需要从broker中选择新的Controller。如下图,新的Controller变成了broker3。</p><p><img src="/2021/08/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Kafka/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6Kafka%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8EZookeeper%E7%9A%84%E7%88%B1%E6%81%A8%E7%BC%A0%E7%BB%B5/img_4.png"></p><p>新的Controller选举成功后，会重新从Zookeeper拉取元数据进行初始化，并且需要通知其他所有的broker更新ActiveControllerId。老的Controller需要关闭监听、事件处理线程和定时任务。分区数非常多时，这个过程非常耗时，而且这个过程中Kafka集群是不能工作的。</p><p>当分区数增加时，Zookeeper保存的元数据变多，Zookeeper集群压力变大，达到一定级别后，监听延迟增加，给Kafaka的工作带来了影响。</p><p>所以，Kafka单集群承载的<strong>分区数量是一个瓶颈</strong>。而这又恰恰是一些业务场景需要的。</p><h4 id="Zookeeper的致命缺陷"><a href="#Zookeeper的致命缺陷" class="headerlink" title="Zookeeper的致命缺陷"></a>Zookeeper的致命缺陷</h4><p>Zookeeper是集群部署，只要集群中超过半数节点存活，即可提供服务，例如一个由3个节点的Zookeeper，允许1个Zookeeper节点宕机，集群仍然能提供服务；一个由５个节点的Zookeeper，允许2个节点宕机。</p><p>但Zookeeper的设计是CP模型，即要保证数据的强一致性，必然在可用性方面做出牺牲。</p><p>Zookeeper集群中也存在所谓的Leader节点和从节点，Leader节点负责写，Leader与从节点可用接受读请求，但在Zookeeper内部节点在选举时整个Zookeeper无法对外提供服务。当然正常情况下选举会非常快，但在异常情况下就不好说了，例如Zookeeper节点发生full Gc，此时造成的影响将是毁灭性的。</p><p>Zookeeper节点如果频繁发生Full Gc，此时与客户端的会话将超时，由于此时无法响应客户端的心跳请求(Stop World)，从而与会话相关联的临时节点将被删除，注意，此时是所有的临时节点会被删除，Zookeeper依赖的事件通知机制将失效，整个集群的选举服务将失效。</p><h4 id="设计优雅性"><a href="#设计优雅性" class="headerlink" title="设计优雅性"></a>设计优雅性</h4><p>站在高可用性的角度，Kafka集群的可用性不仅取决于自身，还受到了外部组件的制约，从长久来看，显然都不是一个优雅的方案。</p><h4 id="分布式领域技术完善"><a href="#分布式领域技术完善" class="headerlink" title="分布式领域技术完善"></a>分布式领域技术完善</h4><p>随着分布式领域相关技术的不断完善，<strong>去中心化</strong>的思想逐步兴起，去Zookeeper的呼声也越来越高，在这个进程中涌现了一个非常优秀的算法：<strong>Raft协议</strong>。</p><p>Raft协议的两个重要组成部分：Leader选举、日志复制，而日志复制为多个副本提供数据强一致性提供了强一致性，并且一个显著的特点是Raft节点是去中心化的架构，不依赖外部的组件，而是作为一个协议簇嵌入到应用中的，即与应用本身是融合为一体的。</p><h3 id="Kafka去掉Zookeeper后怎么实现其功能"><a href="#Kafka去掉Zookeeper后怎么实现其功能" class="headerlink" title="Kafka去掉Zookeeper后怎么实现其功能"></a>Kafka去掉Zookeeper后怎么实现其功能</h3><p>KIP-500用Quorum Controller代替之前的Controller，Quorum中每个Controller节点都会保存所有元数据，通过KRaft协议保证副本的一致性。这样即使Quorum Controller节点出故障了，新的Controller迁移也会非常快。</p><p>以Kafka Topic的分布图举例，引用Raft协议的示例图如下：</p><p><img src="/2021/08/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Kafka/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6Kafka%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%8EZookeeper%E7%9A%84%E7%88%B1%E6%81%A8%E7%BC%A0%E7%BB%B5/img_3.png"></p><p>官方介绍，升级之后，Kafka可以轻松支持百万级别的分区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kafak团队把通过Raft协议同步数据的方式Kafka Raft Metadata mode,简称KRaft</span><br></pre></td></tr></table></figure><p>关于Raft协议，本文并不打算深入进行探讨，具体参考文章<a href="https://zhuanlan.zhihu.com/p/91288179">Raft协议原理详解</a></p><p>Raft协议为选主提供了另外一种可行方案，而且还无需依赖第三方组件，何乐而不为呢？故最终Kafka在2.8版本中正式废弃了Zookeeper，拥抱Raft。</p><p>Kafaka计划在3.0版本会兼容Zookeeper Controller和Quorum Controller，这样用户可以进行灰度测试。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在大规模集群和云原生的背景下，使用Zookeeper给Kafka的运维和集群性能造成了很大的压力。去除Zookeeper是必然趋势，这也符合大道至简的架构思想。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 &lt;a href=&quot;/2021/02/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/Zookeeper/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E7%BB%84%E4%BB%B6%E4%B9%8BZook</summary>
      
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="消息中间件" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="MQ" scheme="http://example.com/tags/MQ/"/>
    
    <category term="Kafka" scheme="http://example.com/tags/Kafka/"/>
    
    <category term="ZOOKEEPER" scheme="http://example.com/tags/ZOOKEEPER/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件系列之死信、延迟、重试队列</title>
    <link href="http://example.com/2021/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%AD%BB%E4%BF%A1%E3%80%81%E5%BB%B6%E8%BF%9F%E3%80%81%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2021/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%AD%BB%E4%BF%A1%E3%80%81%E5%BB%B6%E8%BF%9F%E3%80%81%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97/</id>
    <published>2021-08-02T11:19:56.000Z</published>
    <updated>2021-08-12T03:37:01.842Z</updated>
    
    <content type="html"><![CDATA[<h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在发送延时消息的时候并不是先投递到要发送的真实主题（real_topic）中，而是先投递到一些 Kafka 内部的主题（delay_topic）中，这些内部主题对用户不可见，</span><br><span class="line"></span><br><span class="line">然后通过一个自定义的服务拉取这些内部主题中的消息，并将满足条件的消息再投递到要发送的真实的主题中，消费者所订阅的还是真实的主题。</span><br></pre></td></tr></table></figure><p>如果采用这种方案，那么一般是按照不同的延时等级来划分的，比如设定5s、10s、30s、1min、2min、5min、10min、20min、30min、45min、1hour、2hour这些按延时时间递增的延时等级，延时的消息按照延时时间投递到不同等级的主题中，投递到同一主题中的消息的延时时间会被强转为与此主题延时等级一致的延时时间，这样延时误差控制在两个延时等级的时间差范围之内（比如延时时间为17s的消息投递到30s的延时主题中，之后按照延时时间为30s进行计算，延时误差为13s）。虽然有一定的延时误差，但是误差可控，并且这样只需增加少许的主题就能实现延时队列的功能。</p><p><img src="/2021/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%AD%BB%E4%BF%A1%E3%80%81%E5%BB%B6%E8%BF%9F%E3%80%81%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97/img_2.png"></p><p>发送到内部主题（delaytopic*）中的消息会被一个独立的 DelayService 进程消费，这个 DelayService 进程和 Kafka broker 进程以一对一的配比进行同机部署（参考下图），以保证服务的可用性。</p><p><img src="/2021/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%AD%BB%E4%BF%A1%E3%80%81%E5%BB%B6%E8%BF%9F%E3%80%81%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97/img_3.png"></p><p><strong>针对不同延时级别的主题，在 DelayService 的内部都会有单独的线程来进行消息的拉取，以及单独的 DelayQueue（这里用的是 JUC 中 DelayQueue）进行消息的暂存。</strong></p><p>与此同时，在 DelayService 内部还会有专门的消息发送线程来获取 DelayQueue 的消息并转发到真实的主题中。从消费、暂存再到转发，线程之间都是一一对应的关系。如下图所示，DelayService 的设计应当尽量保持简单，避免锁机制产生的隐患。</p><p><img src="/2021/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%AD%BB%E4%BF%A1%E3%80%81%E5%BB%B6%E8%BF%9F%E3%80%81%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97/img_4.png"></p><p>为了保障内部 DelayQueue 不会因为未处理的消息过多而导致内存的占用过大，DelayService 会对主题中的每个分区进行计数，当达到一定的阈值之后，就会暂停拉取该分区中的消息。</p><p>因为一个主题中一般不止一个分区，分区之间的消息并不会按照投递时间进行排序，DelayQueue的作用是将消息按照再次投递时间进行有序排序，这样下游的消息发送线程就能够按照先后顺序获取最先满足投递条件的消息。</p><h3 id="重试队列"><a href="#重试队列" class="headerlink" title="重试队列"></a>重试队列</h3><p>重试队列其实可以看作一种回退队列，具体指消费端消费消息失败时，为了防止消息无故丢失而重新将消息回滚到 broker 中。</p><p>与回退队列不同的是，重试队列一般分成多个重试等级，每个重试等级一般也会设置重新投递延时，重试次数越多投递延时就越大。</p><p>理解了他们的概念之后我们就可以为每个主题设置重试队列，消息第一次消费失败入重试队列 Q1，Q1 的重新投递延时为5s，5s过后重新投递该消息；如果消息再次消费失败则入重试队列 Q2，Q2 的重新投递延时为10s，10s过后再次投递该消息。</p><p>然后再设置一个主题作为死信队列，重试越多次重新投递的时间就越久，并且需要设置一个上限，超过投递次数就进入死信队列。重试队列与延时队列有相同的地方，都需要设置延时级别。</p><h3 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h3><p>当一条消息初次消费失败，消息队列 MQ 会自动进行消息重试；</p><p>达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息; </p><p>此时，消息队列 MQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中，这种正常情况下无法被消费的消息称为<strong>死信消息</strong>（Dead-Letter Message），存储死信消息的特殊队列称为<strong>死信队列</strong>（Dead-Letter Queue）。</p><p>当一条消息在队列中出现以下三种情况的时候，该消息就会变成一条死信。</p><ul><li>消费者拒绝消费消息，并且不把消息重新放回原目标队列(消费者不想处理的数据)</li><li>消息TTL(time to live)过期(不符合处理要求的数据)</li><li>队列达到最大长度(消费者不能处理的数据)</li></ul><p>当消息在一个队列中变成一个死信之后，如果配置了死信队列，它将被重新publish到死信交换机，死信交换机将死信投递到一个队列上，这个队列就是死信队列。</p><p><img src="/2021/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%AD%BB%E4%BF%A1%E3%80%81%E5%BB%B6%E8%BF%9F%E3%80%81%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97/img.png"></p><h4 id="死信队列处理的方式"><a href="#死信队列处理的方式" class="headerlink" title="死信队列处理的方式"></a>死信队列处理的方式</h4><ul><li>丢弃，如果不是很重要，可以选择丢弃</li><li>记录死信入库，然后做后续的业务分析或处理</li><li>通过死信队列，由负责监听死信的应用程序进行处理</li></ul><p><img src="/2021/08/02/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%AD%BB%E4%BF%A1%E3%80%81%E5%BB%B6%E8%BF%9F%E3%80%81%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97/img_1.png"></p><h3 id="各中间件支持"><a href="#各中间件支持" class="headerlink" title="各中间件支持"></a>各中间件支持</h3><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>Kafka 没有重试机制不支持消息重试，也没有死信队列，因此使用 Kafka 做消息队列时，如果遇到了消息在业务处理时出现异常，就会很难进行下一步处理。</p><p><strong>使用KafkaConnector扩展实现死信队列</strong></p><p>Kafka连接器是Kafka的一部分，是在Kafka和其它技术之间构建流式管道的一个强有力的框架。它可用于将数据从多个地方（包括数据库、消息队列和文本文件）流式注入到Kafka，以及从Kafka将数据流式传输到目标端（如文档存储、NoSQL、数据库、对象存储等）中。</p><p>Kafka连接器可以配置为将无法处理的消息（例如上面提到的反序列化错误）发送到一个单独的Kafka主题，即死信队列。有效消息会正常处理，管道也会继续运行。然后可以从死信队列中检查无效消息，并根据需要忽略或修复并重新处理。</p><p>进行如下的配置可以启用死信队列：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">errors.tolerance</span> = <span class="string">all</span></span><br><span class="line"><span class="meta">errors.deadletterqueue.topic.name</span> =<span class="string"></span></span><br></pre></td></tr></table></figure><p>如果运行于单节点Kafka集群，还需要配置<code>errors.deadletterqueue.topic.replication.factor = 1</code>，其默认值为3。</p><p>但是只有看到消息才能知道它是无效的JSON，即便如此，也只能假设消息被拒绝的原因，要确定Kafka连接器将消息视为无效的实际原因，有两个方法：</p><ul><li>死信队列的消息头；</li><li>Kafka连接器的工作节点日志。</li></ul><p><strong>记录消息的失败原因：消息头</strong></p><p>消息头是使用Kafka消息的键、值和时间戳存储的附加元数据，是在Kafka 0.11版本中引入的。Kafka连接器可以将有关消息拒绝原因的信息写入消息本身的消息头中。这个做法比写入日志文件更好，因为它将原因直接与消息联系起来。</p><p>配置如下的参数，可以在死信队列的消息头中包含拒绝原因：</p><pre><code>errors.deadletterqueue.context.headers.enable = true</code></pre><p><strong>记录消息的失败原因：日志</strong></p><p>记录消息的拒绝原因的第二个选项是将其写入日志。根据安装方式不同，Kafka连接器会将其写入标准输出或日志文件。无论哪种方式都会为每个失败的消息生成一堆详细输出。进行如下配置可启用此功能：</p><pre><code>errors.log.enable = true</code></pre><p>通过配置<code>errors.log.include.messages = true</code>，还可以在输出中包含有关消息本身的元数据。此元数据中包括一些和上面提到的消息头中一样的项目，包括源消息的主题和偏移量。注意它不包括消息键或值本身</p><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>默认的处理机制中，如果我们只对消息做重复消费，达到最大重试次数之后消息就进入死信队列了。RocketMQ 的处理方式为将达到最大重试次数（16 次）的消息标记为死信消息，将该死信消息投递到 DLQ 死信队列中，业务需要进行人工干预。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;延迟队列&quot;&gt;&lt;a href=&quot;#延迟队列&quot; class=&quot;headerlink&quot; title=&quot;延迟队列&quot;&gt;&lt;/a&gt;延迟队列&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="消息中间件" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="MQ" scheme="http://example.com/tags/MQ/"/>
    
    <category term="Kafka" scheme="http://example.com/tags/Kafka/"/>
    
    <category term="RabbitMQ" scheme="http://example.com/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>代码规范之JAVA代码安全指南</title>
    <link href="http://example.com/2021/07/13/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B9%8BJAVA%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://example.com/2021/07/13/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E4%B9%8BJAVA%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/</id>
    <published>2021-07-13T09:37:37.000Z</published>
    <updated>2021-07-14T08:49:21.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="后台类"><a href="#后台类" class="headerlink" title="后台类"></a>后台类</h2><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><h4 id="【必须】SQL语句默认使用预编译并绑定变量"><a href="#【必须】SQL语句默认使用预编译并绑定变量" class="headerlink" title="【必须】SQL语句默认使用预编译并绑定变量"></a>【必须】SQL语句默认使用预编译并绑定变量</h4><p>Web后台系统应默认使用预编译绑定变量的形式创建sql语句，保持查询语句和数据相分离。以从本质上避免SQL注入风险。</p><p>如使用Mybatis作为持久层框架，应通过#{}语法进行参数绑定，MyBatis 会创建 <code>PreparedStatement</code> 参数占位符，并通过占位符安全地设置参数。</p><p>示例：JDBC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String custname=request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        String query=<span class="string">&quot;SELECT * FROM user_data WHERE user_name = ? &quot;</span>;</span><br><span class="line">        PreparedStatement pstmt=connection.prepareStatement(query);</span><br><span class="line">        pstmt.setString(<span class="number">1</span>,custname);</span><br><span class="line">        ResultSet results=pstmt.executeQuery();</span><br></pre></td></tr></table></figure><p>Mybatis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;queryRuleIdByApplicationId&quot;</span>parameterType=<span class="string">&quot;java.lang.String&quot;</span>resultType=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span><br><span class="line">        select rule_id from scan_rule_sqlmap_tab where application_id=#&#123;applicationId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>应避免外部输入未经过滤直接拼接到SQL语句中，或者通过Mybatis中的${}传入SQL语句（即使使用PreparedStatement，SQL语句直接拼接外部输入也同样有风险。例如Mybatis中部分参数通过${}传入SQL语句后实际执行时调用的是PreparedStatement.execute()<br>，同样存在注入风险）。</p><h4 id="【必须】白名单过滤"><a href="#【必须】白名单过滤" class="headerlink" title="【必须】白名单过滤"></a>【必须】白名单过滤</h4><p>对于表名、列名等无法进行预编译的场景，比如外部数据拼接到order by, group<br>by语句中，需通过白名单的形式对数据进行校验，例如判断传入列名是否存在、升降序仅允许输入“ASC”和“DESC”、表名列名仅允许输入字符、数字、下划线等。参考示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">someMethod</span><span class="params">(<span class="keyword">boolean</span> sortOrder)</span></span>&#123;</span><br><span class="line">        String SQLquery=<span class="string">&quot;some SQL ... order by Salary &quot;</span>+(sortOrder?<span class="string">&quot;ASC&quot;</span>:<span class="string">&quot;DESC&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="【必须】文件类型限制"><a href="#【必须】文件类型限制" class="headerlink" title="【必须】文件类型限制"></a>【必须】文件类型限制</h4><p>须在服务器端采用白名单方式对上传或下载的文件类型、大小进行严格的限制。仅允许业务所需文件类型上传，避免上传.jsp、.jspx、.class、.java等可执行文件。参考示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String file_name=file.getOriginalFilename();</span><br><span class="line">String[]parts=file_name.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">String suffix=parts[parts.length-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">switch</span>(suffix)&#123;</span><br><span class="line">    <span class="keyword">case</span><span class="string">&quot;jpeg&quot;</span>:</span><br><span class="line">        suffix=<span class="string">&quot;.jpeg&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="string">&quot;jpg&quot;</span>:</span><br><span class="line">        suffix=<span class="string">&quot;.jpg&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="string">&quot;bmp&quot;</span>:</span><br><span class="line">        suffix=<span class="string">&quot;.bmp&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span><span class="string">&quot;png&quot;</span>:</span><br><span class="line">        suffix=<span class="string">&quot;.png&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//handle error</span></span><br><span class="line">        <span class="keyword">return</span><span class="string">&quot;error&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="【必须】禁止外部文件存储于可执行目录"><a href="#【必须】禁止外部文件存储于可执行目录" class="headerlink" title="【必须】禁止外部文件存储于可执行目录"></a>【必须】禁止外部文件存储于可执行目录</h4><p>禁止外部文件存储于WEB容器的可执行目录（appBase）。建议保存在专门的文件服务器中。</p><h4 id="【建议】避免路径拼接"><a href="#【建议】避免路径拼接" class="headerlink" title="【建议】避免路径拼接"></a>【建议】避免路径拼接</h4><p>文件目录避免外部参数拼接。保存文件目录建议后台写死并对文件名进行校验（字符类型、长度）。建议文件保存时，将文件名替换为随机字符串。</p><h4 id="【必须】避免路径穿越"><a href="#【必须】避免路径穿越" class="headerlink" title="【必须】避免路径穿越"></a>【必须】避免路径穿越</h4><p>如因业务需要不能满足避免路径拼接，文件路径、文件命中拼接了不可行数据，需判断请求文件名和文件路径参数中是否存在../或..\(仅windows)， 如存在应判定路径非法并拒绝请求。</p><h3 id="网络访问"><a href="#网络访问" class="headerlink" title="网络访问"></a>网络访问</h3><h4 id="【必须】避免直接访问不可信地址"><a href="#【必须】避免直接访问不可信地址" class="headerlink" title="【必须】避免直接访问不可信地址"></a>【必须】避免直接访问不可信地址</h4><p>服务器访问不可信地址时，禁止访问私有地址段及内网域名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 以RFC定义的专有网络为例，如有自定义私有网段亦应加入禁止访问列表。</span><br><span class="line">10.0.0.0/8</span><br><span class="line">172.16.0.0/12</span><br><span class="line">192.168.0.0/16</span><br><span class="line">127.0.0.0/8</span><br></pre></td></tr></table></figure><p>建议通过URL解析函数进行解析，获取host或者domain后通过DNS获取其IP，然后和内网地址进行比较。</p><p>对已校验通过地址进行访问时，应关闭跟进跳转功能。</p><p>参考示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">httpConnection=(HttpURLConnection)Url.openConnection();</span><br><span class="line">httpConnection.setFollowRedirects(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><h3 id="XML读写"><a href="#XML读写" class="headerlink" title="XML读写"></a>XML读写</h3><h4 id="【必须】XML解析器关闭DTD解析"><a href="#【必须】XML解析器关闭DTD解析" class="headerlink" title="【必须】XML解析器关闭DTD解析"></a>【必须】XML解析器关闭DTD解析</h4><p>读取外部传入XML文件时，XML解析器初始化过程中设置关闭DTD解析。</p><p>参考示例：</p><p>javax.xml.parsers.DocumentBuilderFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DocumentBuilderFactory dbf=DocumentBuilderFactory.newInstance();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        dbf.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">        dbf.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">        dbf.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">        dbf.setFeature(<span class="string">&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">        dbf.setXIncludeAware(<span class="keyword">false</span>);</span><br><span class="line">        dbf.setExpandEntityReferences(<span class="keyword">false</span>);</span><br><span class="line">        ……</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>org.dom4j.io.SAXReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">saxReader.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">saxReader.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>,<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>org.jdom2.input.SAXBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SAXBuilder builder=<span class="keyword">new</span> SAXBuilder();</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">builder.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">Document doc=builder.build(<span class="keyword">new</span> File(fileName));</span><br></pre></td></tr></table></figure><p>org.xml.sax.XMLReader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XMLReader reader=XMLReaderFactory.createXMLReader();</span><br><span class="line">reader.setFeature(<span class="string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">reader.setFeature(<span class="string">&quot;http://apache.org/xml/features/nonvalidating/load-external-dtd&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">reader.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>,<span class="keyword">false</span>);</span><br><span class="line">reader.setFeature(<span class="string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>,<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><h3 id="响应输出"><a href="#响应输出" class="headerlink" title="响应输出"></a>响应输出</h3><h4 id="【必须】设置正确的HTTP响应包类型"><a href="#【必须】设置正确的HTTP响应包类型" class="headerlink" title="【必须】设置正确的HTTP响应包类型"></a>【必须】设置正确的HTTP响应包类型</h4><p>响应包的HTTP头“Content-Type”必须正确配置响应包的类型，禁止非HTML类型的响应包设置为“text/html”。此举会使浏览器在直接访问链接时，将非HTML格式的返回报文当做HTML解析，增加反射型XSS的触发几率。</p><h4 id="【建议】设置安全的HTTP响应头"><a href="#【建议】设置安全的HTTP响应头" class="headerlink" title="【建议】设置安全的HTTP响应头"></a>【建议】设置安全的HTTP响应头</h4><ul><li><p>X-Content-Type-Options：</p><p>建议添加“X-Content-Type-Options”响应头并将其值设置为“nosniff”，可避免部分浏览器根据其“Content-Sniff”特性，将一些非“text/html”类型的响应作为HTML解析，增加反射型XSS的触发几率。</p></li><li><p>HttpOnly：</p><p>控制用户登录鉴权的Cookie字段 应当设置HttpOnly属性以防止被XSS漏洞/JavaScript操纵泄漏。</p></li><li><p>X-Frame-Options：</p><p>设置X-Frame-Options响应头，并根据需求合理设置其允许范围。该头用于指示浏览器禁止当前页面在frame、iframe、embed等标签中展现。从而避免点击劫持问题。它有三个可选的值：<br>DENY： 浏览器会拒绝当前页面加载任何frame页面；<br>SAMEORIGIN：则frame页面的地址只能为同源域名下的页面<br>ALLOW-FROM origin：可以定义允许frame加载的页面地址。</p></li><li><p>Access-Control-Allow-Origin</p><p>当需要配置CORS跨域时，应对请求头的Origin值做严格过滤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String currentOrigin = request.getHeader(<span class="string">&quot;Origin&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (currentOrigin.equals(<span class="string">&quot;https://domain.qq.com&quot;</span>)) &#123;</span><br><span class="line">       response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, currentOrigin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="【必须】外部输入拼接到response页面前进行编码处理"><a href="#【必须】外部输入拼接到response页面前进行编码处理" class="headerlink" title="【必须】外部输入拼接到response页面前进行编码处理"></a>【必须】外部输入拼接到response页面前进行编码处理</h4><p>当响应“content-type”为“html”类型时，外部输入拼接到响应包中，需根据输出位置进行编码处理。编码规则：</p><table><thead><tr><th>场景</th><th>编码规则</th></tr></thead><tbody><tr><td>输出点在HTML标签之间</td><td>需要对以下6个特殊字符进行HTML实体编码(&amp;, &lt;, &gt;, “, ‘,/)。<br>示例：<br>&amp; –&gt; &amp;amp;<br>&lt; –&gt; &amp;lt;<br>&gt;–&gt; &amp;gt;<br>“ –&gt; &amp;quot;<br>‘ –&gt; &amp;#x27;  <br>/ –&gt; &amp;#x2F;</td></tr><tr><td>输出点在HTML标签普通属性内（如href、src、style等，on事件除外）</td><td>要对数据进行HTML属性编码。<br>编码规则：除了阿拉伯数字和字母，对其他所有的字符进行编码，只要该字符的ASCII码小于256。编码后输出的格式为&#xHH;(以&amp;#x开头，HH则是指该字符对应的十六进制数字，分号作为结束符)</td></tr><tr><td>输出点在JS内的数据中</td><td>需要进行js编码<br>编码规则：<br>除了阿拉伯数字和字母，对其他所有的字符进行编码，只要该字符的ASCII码小于256。编码后输出的格式为 \xHH （以 \x 开头，HH则是指该字符对应的十六进制数字）<br>Tips：这种场景仅限于外部数据拼接在js里被引号括起来的变量值中。除此之外禁止直接将代码拼接在js代码中。</td></tr><tr><td>输出点在CSS中（Style属性）</td><td>需要进行CSS编码<br>编码规则：<br>除了阿拉伯数字和字母，对其他所有的字符进行编码，只要该字符的ASCII码小于256。编码后输出的格式为 \HH （以 \ 开头，HH则是指该字符对应的十六进制数字）</td></tr><tr><td>输出点在URL属性中</td><td>对这些数据进行URL编码<br>Tips：除此之外，所有链接类属性应该校验其协议。禁止JavaScript、data和Vb伪协议。</td></tr></tbody></table><p>以上编码规则相对较为繁琐，可参考或直接使用业界已有成熟第三方库如ESAPI.其提供以下函数对象上表中的编码规则:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ESAPI.encoder().encodeForHTML();</span><br><span class="line">        ESAPI.encoder().encodeForHTMLAttribute();</span><br><span class="line">        ESAPI.encoder().encodeForJavaScript();</span><br><span class="line">        ESAPI.encoder().encodeForCSS();</span><br><span class="line">        ESAPI.encoder().encodeForURL();</span><br></pre></td></tr></table></figure><h4 id="【必须】外部输入拼接到HTTP响应头中需进行过滤"><a href="#【必须】外部输入拼接到HTTP响应头中需进行过滤" class="headerlink" title="【必须】外部输入拼接到HTTP响应头中需进行过滤"></a>【必须】外部输入拼接到HTTP响应头中需进行过滤</h4><p>应尽量避免外部可控参数拼接到HTTP响应头中，如业务需要则需要过滤掉“\r”、”\n”等换行符，或者拒绝携带换行符号的外部输入。</p><h4 id="【必须】避免不可信域名的302跳转"><a href="#【必须】避免不可信域名的302跳转" class="headerlink" title="【必须】避免不可信域名的302跳转"></a>【必须】避免不可信域名的302跳转</h4><p>如果对外部传入域名进行302跳转，必须设置可信域名列表并对传入域名进行校验。</p><p>为避免校验被绕过，应避免直接对URL进行字符串匹配。应通过通过URL解析函数进行解析，获取host或者domain后和白名单进行比较。</p><p>需要注意的是，由于浏览器的容错机制，域名<code>https://www.qq.com\www.bbb.com</code>中的<code>\</code>会被替换成<code>/</code>，最终跳转到<code>www.qq.com</code><br>。而Java的域名解析函数则无此特性。为避免解析不一致导致绕过，建议对host中的<code>/</code>和<code>#</code>进行替换。</p><p>参考代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String host=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  url=url.replaceAll(<span class="string">&quot;[\\\\#]&quot;</span>,<span class="string">&quot;/&quot;</span>); <span class="comment">//替换掉反斜线和井号</span></span><br><span class="line">  host=<span class="keyword">new</span> URL(url).getHost();</span><br><span class="line">&#125; <span class="keyword">catch</span>(MalformedURLException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(host.endsWith(<span class="string">&quot;.qq.com&quot;</span>))&#123;</span><br><span class="line">    <span class="comment">//跳转操作</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="【必须】避免通过Jsonp传输非公开敏感信息"><a href="#【必须】避免通过Jsonp传输非公开敏感信息" class="headerlink" title="【必须】避免通过Jsonp传输非公开敏感信息"></a>【必须】避免通过Jsonp传输非公开敏感信息</h4><p>jsonp请求再被CSRF攻击时，其响应包可被攻击方劫持导致信息泄露。应避免通过jsonp传输非公开的敏感信息，例如用户隐私信息、身份凭证等。</p><h4 id="【必须】限定JSONP接口的callback字符集范围"><a href="#【必须】限定JSONP接口的callback字符集范围" class="headerlink" title="【必须】限定JSONP接口的callback字符集范围"></a>【必须】限定JSONP接口的callback字符集范围</h4><p>JSONP接口的callback函数名为固定白名单。如callback函数名可用户自定义，应限制函数名仅包含 字母、数字和下划线。如：<code>[a-zA-Z0-9_-]+</code></p><h4 id="【必须】屏蔽异常栈"><a href="#【必须】屏蔽异常栈" class="headerlink" title="【必须】屏蔽异常栈"></a>【必须】屏蔽异常栈</h4><p>应用程序出现异常时，禁止将数据库版本、数据库结构、操作系统版本、堆栈跟踪、文件名和路径信息、SQL 查询字符串等对攻击者有用的信息返回给客户端。建议重定向到一个统一、默认的错误提示页面，进行信息过滤。</p><h4 id="【必须】模板-amp-表达式"><a href="#【必须】模板-amp-表达式" class="headerlink" title="【必须】模板&amp;表达式"></a>【必须】模板&amp;表达式</h4><p>web view层通常通过模板技术或者表达式引擎来实现界面与业务数据分离，比如jsp中的EL表达式。这些引擎通常可执行敏感操作，如果外部不可信数据未经过滤拼接到表达式中进行解析。则可能造成严重漏洞。</p><p>下列是基于EL表达式注入漏洞的演示demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@RequestMapping(&quot;/ELdemo&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ELdemo</span><span class="params">(RepeatDTO repeat)</span></span>&#123;</span><br><span class="line">    ExpressionFactory expressionFactory=<span class="keyword">new</span> ExpressionFactoryImpl();</span><br><span class="line">    SimpleContext simpleContext=<span class="keyword">new</span> SimpleContext();</span><br><span class="line">    String exp=<span class="string">&quot;$&#123;&quot;</span>+repeat.getel()+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    ValueExpression valueExpression=expressionFactory.createValueExpression(simpleContext,exp,String.class);</span><br><span class="line">    <span class="keyword">return</span> valueExpression.getValue(simpleContext).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外部可通过el参数，将不可信输入拼接到EL表达式中并解析。</p><p>此时外部访问：x.x.x.x/ELdemo?el=”’’.getClass().forName(‘java.lang.Runtime’).getMethod(‘exec’,’’.getClass()).invoke(‘’<br>.getClass().forName(‘java.lang.Runtime’).getMethod(‘getRuntime’).invoke(null),’open /Applications/Calculator.app’)“<br>可执行操作系统命令调出计算器。</p><p>基于以上风险：</p><ul><li>应避免外部输入的内容拼接到EL表达式或其他表达式引起、模板引擎进行解析。</li><li>白名单过滤外部输入，仅允许字符、数字、下划线等。</li></ul><h3 id="OS命令执行"><a href="#OS命令执行" class="headerlink" title="OS命令执行"></a>OS命令执行</h3><h4 id="【建议】避免不可信数据拼接操作系统命令"><a href="#【建议】避免不可信数据拼接操作系统命令" class="headerlink" title="【建议】避免不可信数据拼接操作系统命令"></a>【建议】避免不可信数据拼接操作系统命令</h4><p>当不可信数据存在时，应尽量避免外部数据拼接到操作系统命令使用 <code>Runtime</code> 和 <code>ProcessBuilder</code> 来执行。优先使用其他同类操作进行代替，比如通过文件系统API进行文件操作而非直接调用操作系统命令。</p><h4 id="【必须】避免创建SHELL操作"><a href="#【必须】避免创建SHELL操作" class="headerlink" title="【必须】避免创建SHELL操作"></a>【必须】避免创建SHELL操作</h4><p>如无法避免直接访问操作系统命令，需要严格管理外部传入参数，使不可信数据仅作为执行命令的参数而非命令。</p><ul><li><p>禁止外部数据直接直接作为操作系统命令执行。</p></li><li><p>避免通过”cmd”、“bash”、“sh”等命令创建shell后拼接外部数据来执行操作系统命令。</p></li><li><p>对外部传入数据进行过滤。可通过白名单限制字符类型，仅允许字符、数字、下划线；或过滤转义以下符号：|;&amp;$&gt;&lt;`（反引号）!</p><p>白名单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern FILTER_PATTERN = Pattern.compile(<span class="string">&quot;[0-9A-Za-z_]+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!FILTER_PATTERN.matcher(input).matches()) &#123;</span><br><span class="line">  <span class="comment">// 终止当前请求的处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h3><h4 id="【必须】非一次有效身份凭证禁止在URL中传输"><a href="#【必须】非一次有效身份凭证禁止在URL中传输" class="headerlink" title="【必须】非一次有效身份凭证禁止在URL中传输"></a>【必须】非一次有效身份凭证禁止在URL中传输</h4><p>身份凭证禁止在URL中传输，一次有效的身份凭证除外（如CAS中的st）。</p><h4 id="【必须】避免未经校验的数据直接给会话赋值"><a href="#【必须】避免未经校验的数据直接给会话赋值" class="headerlink" title="【必须】避免未经校验的数据直接给会话赋值"></a>【必须】避免未经校验的数据直接给会话赋值</h4><p>防止会话信息被篡改，如恶意用户通过URL篡改手机号码等。</p><h3 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h3><h4 id="【建议】对称加密"><a href="#【建议】对称加密" class="headerlink" title="【建议】对称加密"></a>【建议】对称加密</h4><p>建议使用AES，秘钥长度128位以上。禁止使用DES算法，由于秘钥太短，其为目前已知不安全加密算法。使用AES加密算法请参考以下注意事项：</p><ul><li>AES算法如果采用CBC模式：每次加密时IV必须采用密码学安全的伪随机发生器（如/dev/urandom）,禁止填充全0等固定值。</li><li>AES算法如采用GCM模式，nonce须采用密码学安全的伪随机数</li><li>AES算法避免使用ECB模式，推荐使用GCM模式。</li></ul><h4 id="【建议】非对称加密"><a href="#【建议】非对称加密" class="headerlink" title="【建议】非对称加密"></a>【建议】非对称加密</h4><p>建议使用RSA算法，秘钥2048及以上。</p><h4 id="【建议】哈希算法"><a href="#【建议】哈希算法" class="headerlink" title="【建议】哈希算法"></a>【建议】哈希算法</h4><p>哈希算法推荐使用SHA-2及以上。对于签名场景，应使用HMAC算法。如果采用字符串拼接盐值后哈希的方式，禁止将盐值置于字符串开头，以避免哈希长度拓展攻击。</p><h4 id="【建议】密码存储策略"><a href="#【建议】密码存储策略" class="headerlink" title="【建议】密码存储策略"></a>【建议】密码存储策略</h4><p>建议采用随机盐+明文密码进行多轮哈希后存储密码。</p><h3 id="查询业务"><a href="#查询业务" class="headerlink" title="查询业务"></a>查询业务</h3><h4 id="【必须】返回信息最小化"><a href="#【必须】返回信息最小化" class="headerlink" title="【必须】返回信息最小化"></a>【必须】返回信息最小化</h4><p>返回用户信息应遵循最小化原则，避免将业务需求之外的用户信息返回到前端。</p><h4 id="【必须】个人敏感信息脱敏展示"><a href="#【必须】个人敏感信息脱敏展示" class="headerlink" title="【必须】个人敏感信息脱敏展示"></a>【必须】个人敏感信息脱敏展示</h4><p>在满足业务需求的情况下，个人敏感信息需脱敏展示,如：</p><ul><li>鉴权信息（如口令、密保答案、生理标识等）不允许展示</li><li>身份证只显示第一位和最后一位字符，如3****************1。</li><li>移动电话号码隐藏中间6位字符，如134******48。</li><li>工作地址/家庭地址最多显示到“区”一级。</li><li>银行卡号仅显示最后4位字符，如************8639</li></ul><h4 id="【必须】数据权限校验"><a href="#【必须】数据权限校验" class="headerlink" title="【必须】数据权限校验"></a>【必须】数据权限校验</h4><p>查询个人非公开信息时，需要对当前访问账号进行数据权限校验。</p><ol><li>验证当前用户的登录态</li><li>从可信结构中获取经过校验的当前请求账号的身份信息（如：session）。禁止从用户请求参数或Cookie中获取外部传入不可信用户身份直接进行查询。</li><li>验当前用户是否具备访问数据的权限</li></ol><h3 id="操作业务"><a href="#操作业务" class="headerlink" title="操作业务"></a>操作业务</h3><h4 id="【必须】部署CSRF防御机制"><a href="#【必须】部署CSRF防御机制" class="headerlink" title="【必须】部署CSRF防御机制"></a>【必须】部署CSRF防御机制</h4><p>CSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。对于可重放的敏感操作请求，需部署CSRF防御机制。可参考以下两种常见的CSRF防御方式</p><ul><li><p>设置CSRF Token</p><p>服务端给合法的客户颁发CSRF<br>Token，客户端在发送请求时携带该token供服务端校验，服务端拒绝token验证不通过的请求。以此来防止第三方构造合法的恶意操作链接。Token的作用域可以是Request级或者Session级。下面以Session级CSRF<br>Token进行示例</p><ol><li><p>登录成功后颁发Token，并同时存储在服务端Session中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String uuidToken = UUID.randomUUID().toString();</span><br><span class="line">map.put(<span class="string">&quot;token&quot;</span>, uuidToken);</span><br><span class="line">request.getSession().setAttribute(<span class="string">&quot;token&quot;</span>,uuidToken );</span><br><span class="line"><span class="keyword">return</span> map;</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>创建Filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CsrfFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;  </span><br><span class="line">   HttpSession session = req.getSession();</span><br><span class="line">   Object token = session.getAttribute(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">   String requestToken = req.getParameter(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">   <span class="keyword">if</span>(StringUtils.isBlank(requestToken) || !requestToken.equals(token))&#123;</span><br><span class="line">         AjaxResponseWriter.write(req, resp, ServiceStatusEnum.ILLEGAL_TOKEN, <span class="string">&quot;非法的token&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><p>CSRF Token应具备随机性，保证其不可预测和枚举。另外由于浏览器会自动对表单所访问的域名添加相应的cookie信息，所以CSRF Token不应该通过Cookie传输。</p><ul><li><p>校验Referer头</p><p>通过检查HTTP请求的Referer字段是否属于本站域名，非本站域名的请求进行拒绝。</p><p>这种校验方式需要注意两点：</p><ol><li>要需要处理Referer为空的情况，当Referer为空则拒绝请求</li><li>注意避免例如qq.com.evil.com 部分匹配的情况。</li></ol></li></ul><h4 id="【必须】权限校验"><a href="#【必须】权限校验" class="headerlink" title="【必须】权限校验"></a>【必须】权限校验</h4><p>对于非公共操作，应当校验当前访问账号进行操作权限（常见于CMS）和数据权限校验。</p><ol><li>验证当前用户的登录态</li><li>从可信结构中获取经过校验的当前请求账号的身份信息（如：session）。禁止从用户请求参数或Cookie中获取外部传入不可信用户身份直接进行查询。</li><li>校验当前用户是否具备该操作权限</li><li>校验当前用户是否具备所操作数据的权限。避免越权。</li></ol><h4 id="【建议】加锁操作"><a href="#【建议】加锁操作" class="headerlink" title="【建议】加锁操作"></a>【建议】加锁操作</h4><p>对于有次数限制的操作，比如抽奖。如果操作的过程中资源访问未正确加锁。在高并发的情况下可能造成条件竞争，导致实际操作成功次数多于用户实际操作资格次数。此类操作应加锁处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;后台类&quot;&gt;&lt;a href=&quot;#后台类&quot; class=&quot;headerlink&quot; title=&quot;后台类&quot;&gt;&lt;/a&gt;后台类&lt;/h2&gt;&lt;h3 id=&quot;数据持久化&quot;&gt;&lt;a href=&quot;#数据持久化&quot; class=&quot;headerlink&quot; title=&quot;数据持久化&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="代码规范" scheme="http://example.com/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
    <category term="代码规范" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
</feed>
