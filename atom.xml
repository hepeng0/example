<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沉默者</title>
  
  <subtitle>编码是一门技术，更加是一门艺术</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-19T07:29:08.852Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>何鹏 [smile.hepeng@qq.com]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/"/>
    <id>http://example.com/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/</id>
    <published>2022-05-18T06:35:42.730Z</published>
    <updated>2022-05-19T07:29:08.852Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 操作系统第二步之大战前期的初始化工作<br>date: 2022-05-18 14:35:41<br>tags: [‘操作系统’]  </p><h2 id="categories-操作系统"><a href="#categories-操作系统" class="headerlink" title="categories: 操作系统"></a>categories: 操作系统</h2><h3 id="大道至简-二十几行代码完成操作系统"><a href="#大道至简-二十几行代码完成操作系统" class="headerlink" title="大道至简 二十几行代码完成操作系统"></a>大道至简 二十几行代码完成操作系统</h3><p>在第一部分，我们完成了进入 main 方法前的苦力工作，我们的程序终于跳到第一个由 c 语言写的，也是操作系统的全部代码骨架的地方，就是 main.c 文件里的 main 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line">    drive_info = DRIVE_INFO;</span><br><span class="line">    memory_end = (1&lt;&lt;20) + (EXT_MEM_K&lt;&lt;10);</span><br><span class="line">    memory_end &amp;= 0xfffff000;</span><br><span class="line">    if (memory_end &gt; 16*1024*1024)</span><br><span class="line">    memory_end = 16*1024*1024;</span><br><span class="line">    if (memory_end &gt; 12*1024*1024)</span><br><span class="line">    buffer_memory_end = 4*1024*1024;</span><br><span class="line">    else if (memory_end &gt; 6*1024*1024)</span><br><span class="line">    buffer_memory_end = 2*1024*1024;</span><br><span class="line">    else</span><br><span class="line">    buffer_memory_end = 1*1024*1024;</span><br><span class="line">    main_memory_start = buffer_memory_end;</span><br><span class="line"></span><br><span class="line">    mem_init(main_memory_start,memory_end);</span><br><span class="line">    trap_init();</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    sched_init();</span><br><span class="line">    buffer_init(buffer_memory_end);</span><br><span class="line">    hd_init();</span><br><span class="line">    floppy_init();</span><br><span class="line"></span><br><span class="line">    sti();</span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    if (!fork()) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数一数看，总共也就 20 几行代码。</p><p>但这的确是操作系统启动流程的全部秘密了，我用空格将这个代码分成了几个部分。</p><h4 id="第一部分-一些参数的取值和计算。"><a href="#第一部分-一些参数的取值和计算。" class="headerlink" title="第一部分 一些参数的取值和计算。"></a>第一部分 一些参数的取值和计算。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line">    drive_info = DRIVE_INFO;</span><br><span class="line">    memory_end = (1&lt;&lt;20) + (EXT_MEM_K&lt;&lt;10);</span><br><span class="line">    memory_end &amp;= 0xfffff000;</span><br><span class="line">    if (memory_end &gt; 16*1024*1024)</span><br><span class="line">        memory_end = 16*1024*1024;</span><br><span class="line">    if (memory_end &gt; 12*1024*1024)</span><br><span class="line">        buffer_memory_end = 4*1024*1024;</span><br><span class="line">    else if (memory_end &gt; 6*1024*1024)</span><br><span class="line">        buffer_memory_end = 2*1024*1024;</span><br><span class="line">    else</span><br><span class="line">        buffer_memory_end = 1*1024*1024;</span><br><span class="line">    main_memory_start = buffer_memory_end;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括<strong>根设备 ROOT_DEV</strong>，之前在汇编语言中获取的各个设备的<strong>参数信息 drive_info</strong>，以及通过计算得到的<strong>内存边界</strong></p><ul><li>main_memory_start</li><li>main_memory_end</li><li>buffer_memory_start</li><li>buffer_memory_end</li></ul><p>从哪获得之前的设备参数信息呢？</p><p>如果你前面看了，那一定还记得这个表，都是由 setup.s 这个汇编程序调用 BIOS 中断获取的各个设备的信息，并保存在约定好的内存地址 0x90000 处，现在这不就来取了么。</p><div class="table-container"><table><thead><tr><th>内存地址</th><th>长度(字节)</th><th>名称</th></tr></thead><tbody><tr><td>0x90000</td><td>2</td><td>光标位置</td></tr><tr><td>0x90002</td><td>2</td><td>扩展内存数</td></tr><tr><td>0x90004</td><td>2</td><td>显示页面</td></tr><tr><td>0x90006</td><td>1</td><td>显示模式</td></tr><tr><td>0x90007</td><td>1</td><td>字符列数</td></tr><tr><td>0x90008</td><td>2</td><td>未知</td></tr><tr><td>0x9000A</td><td>1</td><td>显示内存</td></tr><tr><td>0x9000B</td><td>1</td><td>显示状态</td></tr><tr><td>0x9000C</td><td>2</td><td>显卡特性参数</td></tr><tr><td>0x9000E</td><td>1</td><td>屏幕行数</td></tr><tr><td>0x9000F</td><td>1</td><td>屏幕列数</td></tr><tr><td>0x90080</td><td>16</td><td>硬盘1参数表</td></tr><tr><td>0x90090</td><td>16</td><td>硬盘2参数表</td></tr><tr><td>0x901FC</td><td>2</td><td>根设备号</td></tr></tbody></table></div><h4 id="第二部分-各种初始化-init-操作。"><a href="#第二部分-各种初始化-init-操作。" class="headerlink" title="第二部分 各种初始化 init 操作。"></a>第二部分 各种初始化 init 操作。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mem_init(main_memory_start,memory_end);</span><br><span class="line">    trap_init();</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    sched_init();</span><br><span class="line">    buffer_init(buffer_memory_end);</span><br><span class="line">    hd_init();</span><br><span class="line">    floppy_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括<strong>内存初始化 mem_init</strong>，<strong>中断初始化 trap_init</strong>、<strong>进程调度初始化 sched_init</strong> 等等。</p><p>我们知道学操作系统知识的时候，其实就分成这么几块来学的，看来在操作系统源码上看，也确实是这么划分的，那我们之后照着源码慢慢品，就好了。</p><h4 id="第三部分-切换到用户态模式，并在一个新的进程中做一个最终的初始化-init。"><a href="#第三部分-切换到用户态模式，并在一个新的进程中做一个最终的初始化-init。" class="headerlink" title="第三部分 切换到用户态模式，并在一个新的进程中做一个最终的初始化 init。"></a>第三部分 切换到用户态模式，并在一个新的进程中做一个最终的初始化 init。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    sti();</span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    if (!fork()) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 init 函数里会创建出一个进程，设置终端的标准 IO，并且再创建出一个执行 shell 程序的进程用来接受用户的命令，到这里其实就出现了我们熟悉的画面（下面是 bochs 启动 Linux 0.11 后的画面）。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img.png" alt></p><h4 id="第四部分-死循环"><a href="#第四部分-死循环" class="headerlink" title="第四部分 死循环"></a>第四部分 死循环</h4><p>如果没有任何任务可以运行，操作系统会一直陷入这个死循环无法自拔。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    for(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，不要细品每一句话，我们本回就是要你有个整体印象，之后会细细讲这里的每一个部分。</p><h4 id="回顾-已完成工作"><a href="#回顾-已完成工作" class="headerlink" title="回顾 已完成工作"></a>回顾 已完成工作</h4><p>这里再放上目前的内存布局图。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_1.png" alt></p><p>这个图大家一定要牢记在心，操作系统说白了就是在内存中放置各种的数据结构，来实现“管理”的功能。</p><p>所以之后我们的学习过程，主心骨其实就是看看，操作系统在经过一番折腾后，又在内存中建立了什么数据结构，而这些数据结构后面又是如何用到的。</p><p>比如进程管理，就是在内存中建立好多复杂的数据结构用来记录进程的信息，再配合上进程调度的小算法，完成了进程这个强大的功能。</p><p>为了让大家目前心里有个底，我们把前面的工作再再再再在这里做一个回顾，用一张图表示就是：</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_2.png" alt></p><p>看到了吧，我们已经把 boot 文件夹下的三个汇编文件的全部代码都一行一行品读过了，其主要功能就是三张表的设置：</p><ul><li>全局描述符表</li><li>中断描述符表</li><li>页表</li></ul><p>同时还设置了各种段寄存器，栈顶指针。</p><p>并且，还为后续的程序提供了设备信息，保存在 0x90000 处往后的几个位置上。</p><p>最后，一个华丽的跳转，将程序跳转到了 main.c 文件里的 main 函数中。</p><h3 id="管理内存前先划分出三个边界值"><a href="#管理内存前先划分出三个边界值" class="headerlink" title="管理内存前先划分出三个边界值"></a>管理内存前先划分出三个边界值</h3><p>还是把 main 的全部代码都先写出来，很少</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line"></span><br><span class="line">    ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line">    drive_info = DRIVE_INFO;</span><br><span class="line">    memory_end = (1&lt;&lt;20) + (EXT_MEM_K&lt;&lt;10);</span><br><span class="line">    memory_end &amp;= 0xfffff000;</span><br><span class="line">    if (memory_end &gt; 16*1024*1024)</span><br><span class="line">        memory_end = 16*1024*1024;</span><br><span class="line">    if (memory_end &gt; 12*1024*1024) </span><br><span class="line">        buffer_memory_end = 4*1024*1024;</span><br><span class="line">    else if (memory_end &gt; 6*1024*1024)</span><br><span class="line">        buffer_memory_end = 2*1024*1024;</span><br><span class="line">    else</span><br><span class="line">        buffer_memory_end = 1*1024*1024;</span><br><span class="line">    main_memory_start = buffer_memory_end;</span><br><span class="line"></span><br><span class="line">    mem_init(main_memory_start,memory_end);</span><br><span class="line">    trap_init();</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    sched_init();</span><br><span class="line">    buffer_init(buffer_memory_end);</span><br><span class="line">    hd_init();</span><br><span class="line">    floppy_init();</span><br><span class="line"></span><br><span class="line">    sti();</span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    if (!fork()) &#123;      /* we count on this going ok */</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们今天就看这第一小段。</p><p>首先，ROOT_DEV 为系统的根文件设备号，drive_info 为之前 setup.s 程序获取并存储在内存 0x90000 处的设备信息，我们先不管这俩，等之后用到了再说。</p><p>我们看后面这一坨很影响整体画风的一段代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    memory_end = (1&lt;&lt;20) + (EXT_MEM_K&lt;&lt;10);</span><br><span class="line">    memory_end &amp;= 0xfffff000;</span><br><span class="line">    if (memory_end &gt; 16*1024*1024)</span><br><span class="line">        memory_end = 16*1024*1024;</span><br><span class="line">    if (memory_end &gt; 12*1024*1024) </span><br><span class="line">        buffer_memory_end = 4*1024*1024;</span><br><span class="line">    else if (memory_end &gt; 6*1024*1024)</span><br><span class="line">        buffer_memory_end = 2*1024*1024;</span><br><span class="line">    else</span><br><span class="line">        buffer_memory_end = 1*1024*1024;</span><br><span class="line">    main_memory_start = buffer_memory_end;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一坨代码和后面规规整整的 xxx_init 平级的位置，要是我们这么写代码，肯定被老板批评，被同事鄙视了。但 Linus 写的，就是经典，学就完事了。</p><p>这一坨代码虽然很乱，但仔细看就知道它只是为了计算出三个变量罢了。</p><ul><li>main_memory_start</li><li>memory_end</li><li>buffer_memory_end</li></ul><p>而观察最后一行代码发现，其实两个变量是相等的，所以其实仅仅计算出了两个变量。</p><ul><li>main_memory_start</li><li>memory_end</li></ul><p>然后再具体分析这个逻辑，其实就是一堆 if else 判断而已，判断的标准都是 memory_end 也就是内存最大值的大小，而这个内存最大值由第一行代码可以看出，是等于 1M + 扩展内存大小。</p><p>那 ok 了，其实就只是<strong>针对不同的内存大小，设置不同的边界值</strong>罢了，为了理解它，我们完全没必要考虑这么周全，就假设总内存一共就 8M 大小吧。</p><p>那么如果内存为 8M 大小，memory_end 就是 8 <em> 1024 </em> 1024，也就只会走倒数第二个分支，那么 buffer_memory_end 就为 2 <em> 1024 </em> 1024， 那么 main_memory_start<br>也为 2 <em> 1024 </em> 1024</p><p>那这些值有什么用呢？一张图就给你说明白了。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_3.png" alt></p><p>你看，其实就是定了三个箭头所指向的地址的三个边界变量。</p><h3 id="主内存区初始化-用一张大表管理内存-mem-init"><a href="#主内存区初始化-用一张大表管理内存-mem-init" class="headerlink" title="主内存区初始化 - 用一张大表管理内存 - mem_init"></a>主内存区初始化 - 用一张大表管理内存 - mem_init</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mem_init(main_memory_start, memory_end);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入 mem_init 函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#define LOW_MEM 0x100000</span><br><span class="line">#define PAGING_MEMORY (15*1024*1024)</span><br><span class="line">#define PAGING_PAGES (PAGING_MEMORY&gt;&gt;12)</span><br><span class="line">#define MAP_NR(addr) (((addr)-LOW_MEM)&gt;&gt;12)</span><br><span class="line">#define USED 100</span><br><span class="line"></span><br><span class="line">static long HIGH_MEMORY = 0;</span><br><span class="line">static unsigned char mem_map[PAGING_PAGES] = &#123; 0, &#125;;</span><br><span class="line"></span><br><span class="line">// start_mem = 2 * 1024 * 1024</span><br><span class="line">// end_mem = 8 * 1024 * 1024</span><br><span class="line">void mem_init(long start_mem, long end_mem)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    HIGH_MEMORY = end_mem;</span><br><span class="line">    for (i=0 ; i&lt;PAGING_PAGES ; i++)</span><br><span class="line">        mem_map[i] = USED;</span><br><span class="line">    i = MAP_NR(start_mem);</span><br><span class="line">    end_mem -= start_mem;</span><br><span class="line">    end_mem &gt;&gt;= 12;</span><br><span class="line">    while (end_mem--&gt;0)</span><br><span class="line">        mem_map[i++]=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现也没几行，而且并没有更深的方法调用，看来是个好欺负的方法。</p><p>仔细一看这个方法，其实折腾来折腾去，就是给一个 <strong>mem_map</strong> 数组的各个位置上赋了值，而且显示全部赋值为 USED 也就是 100，然后对其中一部分又赋值为了 0。</p><p>是不是很简单？就是<strong>准备了一个表，记录了哪些内存被占用了，哪些内存没被占用</strong>。这就是所谓的“管理”，并没有那么神乎其神。</p><p>那接下来自然有两个问题，每个元素表示占用和未占用，这个表示的范围是多大？初始化时哪些地方是占用的，哪些地方又是未占用的？</p><p>还是一张图就看明白了，我们仍然假设内存总共只有 8M。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_4.png" alt></p><p>可以看出，初始化完成后，其实就是 mem_map 这个数组的每个元素都代表一个 4K 内存是否空闲（准确说是使用次数）。</p><p>4K 内存通常叫做 1 页内存，而这种管理方式叫<strong>分页管理</strong>，就是把内存分成一页一页（4K）的单位去管理。</p><p>1M 以下的内存这个数组干脆没有记录，这里的内存是无需管理的，或者换个说法是无权管理的，也就是没有权利申请和释放，因为这个区域是内核代码所在的地方，不能被“污染”。</p><p>1M 到 2M 这个区间是<strong>缓冲区</strong>，2M 是缓冲区的末端，缓冲区的开始在哪里之后再说，这些地方不是主内存区域，因此直接标记为 USED，产生的效果就是无法再被分配了。</p><p>2M 以上的空间是<strong>主内存区域</strong>，而主内存目前没有任何程序申请，所以初始化时统统都是零，未来等着应用程序去申请和释放这里的内存资源。</p><h4 id="通过-get-free-page-申请空闲内存页"><a href="#通过-get-free-page-申请空闲内存页" class="headerlink" title="通过 get_free_page() 申请空闲内存页"></a>通过 get_free_page() 申请空闲内存页</h4><p>在 memory.c 文件中有个函数 get_free_page()，用于在主内存区中申请一页空闲内存页，并返回物理内存页的起始地址</p><p>比如我们在 fork 子进程的时候，会调用 <strong>copy_process</strong> 函数来复制进程的结构信息，其中有一个步骤就是要<strong>申请一页内存</strong>，用于存放进程结构信息 task_struct。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int copy_process(...) &#123;</span><br><span class="line">    struct task_struct *p;</span><br><span class="line">    ...</span><br><span class="line">    p = (struct task_struct *) get_free_page();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看 get_free_page 的具体实现，是内联汇编代码，看不懂不要紧，注意它里面就有 mem_map 结构的使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">unsigned long get_free_page(void) &#123;</span><br><span class="line">    register unsigned long __res asm(&quot;ax&quot;);</span><br><span class="line">    __asm__(</span><br><span class="line">        &quot;std ; repne ; scasb\n\t&quot;</span><br><span class="line">        &quot;jne 1f\n\t&quot;</span><br><span class="line">        &quot;movb $1,1(%%edi)\n\t&quot;</span><br><span class="line">        &quot;sall $12,%%ecx\n\t&quot;</span><br><span class="line">        &quot;addl %2,%%ecx\n\t&quot;</span><br><span class="line">        &quot;movl %%ecx,%%edx\n\t&quot;</span><br><span class="line">        &quot;movl $1024,%%ecx\n\t&quot;</span><br><span class="line">        &quot;leal 4092(%%edx),%%edi\n\t&quot;</span><br><span class="line">        &quot;rep ; stosl\n\t&quot;</span><br><span class="line">        &quot;movl %%edx,%%eax\n&quot;</span><br><span class="line">        &quot;1:&quot;</span><br><span class="line">        :&quot;=a&quot; (__res)</span><br><span class="line">        :&quot;0&quot; (0),&quot;i&quot; (LOW_MEM),&quot;c&quot; (PAGING_PAGES),</span><br><span class="line">        &quot;D&quot; (mem_map + PAGING_PAGES-1)</span><br><span class="line">        :&quot;di&quot;,&quot;cx&quot;,&quot;dx&quot;);</span><br><span class="line">    return __res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是选择 mem_map 中首个空闲页面，并标记为已使用。</p><p>之后的内存申请与释放等骚操作，统统是跟着张大表 mem_map 打交道而已。</p><h3 id="中断初始化-键盘是什么时候开始生效的-trap-init"><a href="#中断初始化-键盘是什么时候开始生效的-trap-init" class="headerlink" title="中断初始化 - 键盘是什么时候开始生效的 - trap_init"></a>中断初始化 - 键盘是什么时候开始生效的 - trap_init</h3><p>当你的计算机刚刚启动时，你按下键盘是不生效的，但是过了一段时间后，再按下键盘就有效果了。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/_posts/操作系统/操作系统第二步之大战前期的初始化工作/img_5.png" alt="img_5.png"></p><p>那我们今天就来刨根问底一下，<strong>到底过了多久之后，按下键盘才有效果呢</strong>？</p><p>当然首先你得知道，按下键盘后会触发中断，CPU 收到你的键盘中断后，根据中断号，寻找由操作系统写好的键盘中断处理程序。</p><p>这个中断处理程序会把你的键盘码放入一个队列中，由相应的用户程序或内核程序读取，并显示在控制台，或者其他用途，这就代表你的键盘生效了。</p><p>不过放宽心，我们不展开讲这个中断处理程序以及用户程序读取键盘码后的处理细节，我们把关注点放在，究竟是“<strong>什么时候</strong>”，按下键盘才会有这个效果。</p><h4 id="trap-init"><a href="#trap-init" class="headerlink" title="trap_init()"></a>trap_init()</h4><p>进入内核的 main 函数后不久，有这样一行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    trap_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个方法的全部代码后，你可能会会心一笑，也可能一脸懵逼。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void trap_init(void) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    set_trap_gate(0,&amp;divide_error);</span><br><span class="line">    set_trap_gate(1,&amp;debug);</span><br><span class="line">    set_trap_gate(2,&amp;nmi);</span><br><span class="line">    set_system_gate(3,&amp;int3);   /* int3-5 can be called from all */</span><br><span class="line">    set_system_gate(4,&amp;overflow);</span><br><span class="line">    set_system_gate(5,&amp;bounds);</span><br><span class="line">    set_trap_gate(6,&amp;invalid_op);</span><br><span class="line">    set_trap_gate(7,&amp;device_not_available);</span><br><span class="line">    set_trap_gate(8,&amp;double_fault);</span><br><span class="line">    set_trap_gate(9,&amp;coprocessor_segment_overrun);</span><br><span class="line">    set_trap_gate(10,&amp;invalid_TSS);</span><br><span class="line">    set_trap_gate(11,&amp;segment_not_present);</span><br><span class="line">    set_trap_gate(12,&amp;stack_segment);</span><br><span class="line">    set_trap_gate(13,&amp;general_protection);</span><br><span class="line">    set_trap_gate(14,&amp;page_fault);</span><br><span class="line">    set_trap_gate(15,&amp;reserved);</span><br><span class="line">    set_trap_gate(16,&amp;coprocessor_error);</span><br><span class="line">    for (i=17;i&lt;48;i++)</span><br><span class="line">        set_trap_gate(i,&amp;reserved);</span><br><span class="line">    set_trap_gate(45,&amp;irq13);</span><br><span class="line">    set_trap_gate(39,&amp;parallel_interrupt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给他简化一下, 把相同功能的去掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void trap_init(void) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    // set 了一堆 trap_gate</span><br><span class="line">    set_trap_gate(0, &amp;divide_error);</span><br><span class="line">    ... </span><br><span class="line">    // 又 set 了一堆 system_gate</span><br><span class="line">    set_system_gate(45, &amp;bounds);</span><br><span class="line">    ...</span><br><span class="line">    // 又又批量 set 了一堆 trap_gate</span><br><span class="line">    for (i=17;i&lt;48;i++)</span><br><span class="line">        set_trap_gate(i, &amp;reserved);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set-trap-gate-amp-set-system-gate"><a href="#set-trap-gate-amp-set-system-gate" class="headerlink" title="set_trap_gate &amp; set_system_gate"></a>set_trap_gate &amp; set_system_gate</h4><p>首先我们看 set_trap_gate 和 set_system_gate 这俩货，发现了这么几个宏定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define _set_gate(gate_addr,type,dpl,addr) \</span><br><span class="line">__asm__ (&quot;movw %%dx,%%ax\n\t&quot; \</span><br><span class="line">    &quot;movw %0,%%dx\n\t&quot; \</span><br><span class="line">    &quot;movl %%eax,%1\n\t&quot; \</span><br><span class="line">    &quot;movl %%edx,%2&quot; \</span><br><span class="line">    : \</span><br><span class="line">    : &quot;i&quot; ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \</span><br><span class="line">    &quot;o&quot; (*((char *) (gate_addr))), \</span><br><span class="line">    &quot;o&quot; (*(4+(char *) (gate_addr))), \</span><br><span class="line">    &quot;d&quot; ((char *) (addr)),&quot;a&quot; (0x00080000))</span><br><span class="line"></span><br><span class="line">#define set_trap_gate(n,addr) \</span><br><span class="line">    _set_gate(&amp;idt[n],15,0,addr)</span><br><span class="line"></span><br><span class="line">#define set_system_gate(n,addr) \</span><br><span class="line">    _set_gate(&amp;idt[n],15,3,addr)</span><br></pre></td></tr></table></figure><p>不过这俩都是最终指向了相同的另一个宏定义 _set_gate，说明是有共性的。</p><p>啥共性呢？我直接说吧，那段你完全看不懂的代码，是将汇编语言嵌入到 c 语言了，最终的效果就是</p><p><strong>在中断描述符表中插入了一个中断描述符</strong>。</p><p>中断描述符表还记得吧，英文叫 idt。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_6.png" alt></p><p>这段代码就是往这个 idt 表里一项一项地写东西，其对应的中断号就是第一个参数，中断处理程序就是第二个参数。</p><p>产生的效果就是，之后如果来一个中断后，CPU 根据其中断号，就可以到这个中断描述符表 idt 中找到对应的中断处理程序了。</p><p>比如这个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_trap_gate(0,&amp;divide_error);</span><br></pre></td></tr></table></figure><p>就是设置 0 号中断，对应的中断处理程序是 divide_error。</p><p>等 CPU 执行了一条除零指令的时候，会从硬件层面发起一个 0 号异常中断，然后执行由我们操作系统定义的 divide_error 也就是除法异常处理程序，执行完之后再返回。</p><p>再比如这个。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_system_gate(5,&amp;overflow);</span><br></pre></td></tr></table></figure><p>就是设置 5 号中断，对应的中断处理程序是 overflow，是边界出错中断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIPS：这个 system 与 trap 的区别仅仅在于，设置的中断描述符的特权级不同，前者是 0（内核态），后者是 3（用户态），这块展开将会是非常严谨的、绕口的、复杂的特权级相关的知识，不明白的话先不用管，就理解为都是设置一个中断号和中断处理程序的对应关系就好了。</span><br></pre></td></tr></table></figure><p>再往后看，批量操作这里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void trap_init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    for (i=17;i&lt;48;i++)</span><br><span class="line">        set_trap_gate(i,&amp;reserved);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>17 到 48 号中断都批量设置为了 reserved 函数，这是暂时的，后面各个硬件初始化时要重新设置好这些中断，把暂时的这个给覆盖掉，此时你留个印象。</p><p>所以整段代码执行下来，内存中那个 idt 的位置会变成如下的样子。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_7.png" alt></p><p>好了，我们看到了设置中断号与中断处理程序对应的地方，那这行代码过去后，键盘好使了么？</p><p><strong>NO</strong></p><p>键盘产生的中断的中断号是 0x21，此时这个中断号还仅仅对应着一个临时的中断处理程序 &amp;reserved，我们接着往后看。</p><h4 id="键盘中断设置"><a href="#键盘中断设置" class="headerlink" title="键盘中断设置"></a>键盘中断设置</h4><p>在这行代码往后几行，还有这么一行代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    trap_init();</span><br><span class="line">    ...</span><br><span class="line">    tty_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tty_init(void) &#123;</span><br><span class="line">    rs_init();</span><br><span class="line">    con_init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void con_init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    set_trap_gate(0x21,&amp;keyboard_interrupt);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到 trap_init 后有个 tty_init，最后根据调用链，会调用到一行添加 0x21 号中断处理程序的代码，就是刚刚熟悉的 set_trap_gate。</p><p>而后面的 keyboard_interrupt 根据名字也可以猜出，就是键盘的中断处理程序嘛！</p><p>就是从这一行代码开始，我们的键盘生效了！</p><h4 id="启用中断"><a href="#启用中断" class="headerlink" title="启用中断"></a>启用中断</h4><p>不过还有点小问题，不过不重要，就是我们现在的中断处于<strong>禁用状态</strong>，不论是键盘中断还是其他中断，通通都不好使。</p><p>而 main 方法继续往下读，还有一行这个东西。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    trap_init();</span><br><span class="line">    ...</span><br><span class="line">    tty_init();</span><br><span class="line">    ...</span><br><span class="line">    sti();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sti 最终会对应一个同名的汇编指令 sti，表示允许中断。所以这行代码之后，键盘才真正开始生效！</p><h3 id="块设备请求项的初始化-读取块设备与内存缓冲区之间的桥梁-blk-dev-init"><a href="#块设备请求项的初始化-读取块设备与内存缓冲区之间的桥梁-blk-dev-init" class="headerlink" title="块设备请求项的初始化 - 读取块设备与内存缓冲区之间的桥梁 - blk_dev_init"></a>块设备请求项的初始化 - 读取块设备与内存缓冲区之间的桥梁 - blk_dev_init</h3><p>读取硬盘数据到内存中，是操作系统的一个基础功能。</p><p>读取硬盘需要有块设备驱动程序，而以文件的方式来读取则还有要再上面包一层文件系统。</p><p>把读出来的数据放到内存，就涉及到内存中缓冲区的管理。</p><p>上面说的每一件事，都是一个十分庞大的体系，先不展开叙述，先梳理读取块设备与内存缓冲区之间的桥梁，<strong>块设备请求项</strong>的初始化工作。</p><h4 id="初始化-request-32"><a href="#初始化-request-32" class="headerlink" title="初始化 request[32]"></a>初始化 request[32]</h4><p>进入内核的 main 函数后不久，有这样一行代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个方法的全部代码后，你可能会会心一笑，也可能一脸懵逼。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void blk_dev_init(void) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i=0; i&lt;32; i++) &#123;</span><br><span class="line">        request[i].dev = -1;</span><br><span class="line">        request[i].next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是给 request 这个数组的前 32 个元素的两个变量 dev 和 next 附上值，看这俩值 -1 和 NULL 也可以大概猜出，这是没有任何作用时的初始化值。</p><h4 id="request-32-结构"><a href="#request-32-结构" class="headerlink" title="request[32] 结构"></a>request[32] 结构</h4><p>我们看下 request 结构体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Ok, this is an expanded form so that we can use the same</span><br><span class="line"> * request for paging requests when that is implemented. In</span><br><span class="line"> * paging, &#x27;bh&#x27; is NULL, and &#x27;waiting&#x27; is used to wait for</span><br><span class="line"> * read/write completion.</span><br><span class="line"> */</span><br><span class="line">struct request &#123;</span><br><span class="line">    int dev;        /* -1 if no request */</span><br><span class="line">    int cmd;        /* READ or WRITE */</span><br><span class="line">    int errors;</span><br><span class="line">    unsigned long sector;</span><br><span class="line">    unsigned long nr_sectors;</span><br><span class="line">    char * buffer;</span><br><span class="line">    struct task_struct * waiting;</span><br><span class="line">    struct buffer_head * bh;</span><br><span class="line">    struct request * next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>哎哟，这就有点头大了，刚刚的函数虽然很短，但看到这个结构体我们知道了，重点在这呢。</p><p>这也侧面说明了，学习操作系统，其实把遇到的重要数据结构牢记心中，就已经成功一半了。比如主内存管理结构 mem_map，知道它的数据结构是什么样子，其功能也基本就懂了。</p><p>收，继续说这个 request 结构，这个结构就代表了一次读盘请求，其中：</p><ul><li>dev 表示设备号，-1 就表示空闲。</li><li>cmd 表示命令，其实就是 READ 还是 WRITE，也就表示本次操作是读还是写。</li><li>errors 表示操作时产生的错误次数。</li><li>sector 表示起始扇区。</li><li>nr_sectors 表示扇区数。</li><li>buffer 表示数据缓冲区，也就是读盘之后的数据放在内存中的什么位置。</li><li>waiting 是个 task_struct 结构，这可以表示一个进程，也就表示是哪个进程发起了这个请求。</li><li>bh 是缓冲区头指针，这个后面讲完缓冲区就懂了，因为这个 request 是需要与缓冲区挂钩的。</li><li>next 指向了下一个请求项。</li></ul><p>这里有的变量看不懂没关系，不过我们倒是可以基于现有的重点参数猜测一下，比如读请求时，cmd 就是 READ，sector 和 nr_sectors 这俩就定位了所要读取的块设备（可以简单先理解为硬盘）的哪几个扇区，buffer<br>就定位了这些数据读完之后放在内存的什么位置。</p><p>这就够啦，想想看，这四个参数是不是就能完整描述了一个读取硬盘的需求了？而且完全没有歧义，就像下面这样。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_8.png" alt></p><p>而其他的参数，肯定是为了更好地配合操作系统进行读写块设备操作嘛，为了把多个读写块设备请求很好地组织起来。</p><p>这个组织不但要有这个数据结构中 hb 和 next 等变量的配合，还要有后面的电梯调度算法的配合，仅此而已，先点到为止。</p><p>总之，我们这里就先明白，这个 request 结构可以完整描述一个读盘操作。然后那个 request 数组就是把它们都放在一起，并且它们又通过 next 指针串成链表。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_9.png" alt></p><h4 id="如何使用-request-32-结构-数据读盘"><a href="#如何使用-request-32-结构-数据读盘" class="headerlink" title="如何使用 request[32] 结构 - 数据读盘"></a>如何使用 request[32] 结构 - 数据读盘</h4><p>简单展望一下，后面读盘的全流程中，是怎么用到刚刚初始化的这个 request[32] 结构的。</p><p>读操作的系统调用函数是 sys_read，源代码很长，简化一下，仅仅保留读取普通文件的分支，就是如下的样子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int sys_read(unsigned int fd,char * buf,int count) &#123;</span><br><span class="line">    struct file * file = current-&gt;filp[fd];</span><br><span class="line">    struct m_inode * inode = file-&gt;f_inode;</span><br><span class="line">    // 校验 buf 区域的内存限制</span><br><span class="line">    verify_area(buf,count);</span><br><span class="line">    // 仅关注目录文件或普通文件</span><br><span class="line">    return file_read(inode,file,buf,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看，入参 fd 是文件描述符，通过它可以找到一个文件的 inode，进而找到这个文件在硬盘中的位置。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_10.png" alt></p><p>另两个入参 buf 就是要复制到的内存中的位置，count 就是要复制多少个字节，很好理解。</p><p>钻到 file_read 函数里继续看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int file_read(struct m_inode * inode, struct file * filp, char * buf, int count) &#123;</span><br><span class="line">    int left,chars,nr;</span><br><span class="line">    struct buffer_head * bh;</span><br><span class="line">    left = count;</span><br><span class="line">    while (left) &#123;</span><br><span class="line">        if (nr = bmap(inode,(filp-&gt;f_pos)/BLOCK_SIZE)) &#123;</span><br><span class="line">            if (!(bh=bread(inode-&gt;i_dev,nr)))</span><br><span class="line">                break;</span><br><span class="line">        &#125; else</span><br><span class="line">            bh = NULL;</span><br><span class="line">        nr = filp-&gt;f_pos % BLOCK_SIZE;</span><br><span class="line">        chars = MIN( BLOCK_SIZE-nr , left );</span><br><span class="line">        filp-&gt;f_pos += chars;</span><br><span class="line">        left -= chars;</span><br><span class="line">        if (bh) &#123;</span><br><span class="line">            char * p = nr + bh-&gt;b_data;</span><br><span class="line">            while (chars--&gt;0)</span><br><span class="line">                put_fs_byte(*(p++),buf++);</span><br><span class="line">            brelse(bh);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            while (chars--&gt;0)</span><br><span class="line">                put_fs_byte(0,buf++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    inode-&gt;i_atime = CURRENT_TIME;</span><br><span class="line">    return (count-left)?(count-left):-ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体看，就是一个 while 循环，每次读入一个块的数据，直到入参所要求的大小全部读完为止。</p><p>直接看 bread 那一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int file_read(struct m_inode * inode, struct file * filp, char * buf, int count) &#123;</span><br><span class="line">    ...</span><br><span class="line">    while (left) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (!(bh=bread(inode-&gt;i_dev,nr)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数就是去读某一个设备的某一个数据块号的内容，展开进去看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct buffer_head * bread(int dev,int block) &#123;</span><br><span class="line">    struct buffer_head * bh = getblk(dev,block);</span><br><span class="line">    if (bh-&gt;b_uptodate)</span><br><span class="line">        return bh;</span><br><span class="line">    ll_rw_block(READ,bh);</span><br><span class="line">    wait_on_buffer(bh);</span><br><span class="line">    if (bh-&gt;b_uptodate)</span><br><span class="line">        return bh;</span><br><span class="line">    brelse(bh);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 getblk 先申请了一个内存中的缓冲块，然后 ll_rw_block 负责把数据读入这个缓冲块，进去继续看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void ll_rw_block(int rw, struct buffer_head * bh) &#123;</span><br><span class="line">    ...</span><br><span class="line">    make_request(major,rw,bh);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void make_request(int major,int rw, struct buffer_head * bh) &#123;</span><br><span class="line">    ...</span><br><span class="line">if (rw == READ)</span><br><span class="line">        req = request+NR_REQUEST;</span><br><span class="line">    else</span><br><span class="line">        req = request+((NR_REQUEST*2)/3);</span><br><span class="line">/* find an empty request */</span><br><span class="line">    while (--req &gt;= request)</span><br><span class="line">        if (req-&gt;dev&lt;0)</span><br><span class="line">            break;</span><br><span class="line">    ...</span><br><span class="line">/* fill up the request-info, and add it to the queue */</span><br><span class="line">    req-&gt;dev = bh-&gt;b_dev;</span><br><span class="line">    req-&gt;cmd = rw;</span><br><span class="line">    req-&gt;errors=0;</span><br><span class="line">    req-&gt;sector = bh-&gt;b_blocknr&lt;&lt;1;</span><br><span class="line">    req-&gt;nr_sectors = 2;</span><br><span class="line">    req-&gt;buffer = bh-&gt;b_data;</span><br><span class="line">    req-&gt;waiting = NULL;</span><br><span class="line">    req-&gt;bh = bh;</span><br><span class="line">    req-&gt;next = NULL;</span><br><span class="line">    add_request(major+blk_dev,req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看，这里就用到了刚刚说的结构咯。</p><p>具体说来，就是该函数会往刚刚的设备的请求项链表 request[32] 中添加一个请求项，只要 request[32] 中有未处理的请求项存在，都会陆续地被处理，直到设备的请求项链表是空为止。</p><p>具体怎么读盘，就是与硬盘 IO 端口进行交互的过程了，可以继续往里跟，直到看到一个 hd_out 函数为止，本讲不展开了。</p><p>具体读盘操作，后面会有详细的章节展开讲解，目前你只需要知道，我们在 main 函数的 init 系列函数中，通过 blk_dev_init 为后面的块设备访问，提前建立了一个数据结构，作为访问块设备和内存缓冲区之间的桥梁，就可以了。</p><h3 id="控制台初始化-为什么屏幕上就会有输出-tty-init"><a href="#控制台初始化-为什么屏幕上就会有输出-tty-init" class="headerlink" title="控制台初始化 - 为什么屏幕上就会有输出 - tty_init"></a>控制台初始化 - 为什么屏幕上就会有输出 - tty_init</h3><p>继内存管理结构 mem_map 和中断描述符表 idt 建立好之后，我们又在内存中倒腾出一个新的数据结构 request。</p><p>这是块<strong>设备驱动程序</strong>与<strong>内存缓冲区</strong>的桥梁，通过它可以完整地表示一个块设备读写操作要做的事。</p><h4 id="串口中断与显示模式"><a href="#串口中断与显示模式" class="headerlink" title="串口中断与显示模式"></a>串口中断与显示模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法执行完成之后，我们将会具备键盘输入到显示器输出字符这个最常用的功能。</p><p>打开这个函数后我有点慌。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void tty_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    rs_init();</span><br><span class="line">    con_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来这个方法已经多到需要拆成两个子方法了。</p><p>打开第一个方法，还好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void rs_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    set_intr_gate(0x24,rs1_interrupt);</span><br><span class="line">    set_intr_gate(0x23,rs2_interrupt);</span><br><span class="line">    init(tty_table[1].read_q.data);</span><br><span class="line">    init(tty_table[2].read_q.data);</span><br><span class="line">    outb(inb_p(0x21)&amp;0xE7,0x21);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是串口中断的开启，以及设置对应的中断处理程序，串口在我们现在的 PC 机上已经很少用到了，所以这个直接忽略。</p><p>看第二个方法，这是重点。代码非常长，有点吓人，我先把大体框架写出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void con_init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (ORIG_VIDEO_MODE == 7) &#123;</span><br><span class="line">        ...</span><br><span class="line">        if ((ORIG_VIDEO_EGA_BX &amp; 0xff) != 0x10) &#123;...&#125;</span><br><span class="line">        else &#123;...&#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">        if ((ORIG_VIDEO_EGA_BX &amp; 0xff) != 0x10) &#123;...&#125;</span><br><span class="line">        else &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，非常多的 if else。</p><p>这是为了应对不同的显示模式，来分配不同的变量值，那如果我们仅仅找出一个显示模式，这些分支就可以只看一个了。</p><h4 id="一个字符是如何显示在屏幕上的呢"><a href="#一个字符是如何显示在屏幕上的呢" class="headerlink" title="一个字符是如何显示在屏幕上的呢"></a>一个字符是如何显示在屏幕上的呢</h4><p>如果你可以随意操作内存和 CPU 等设备，你如何操作才能使得你的显示器上，显示一个字符‘a’呢？</p><p>我们先看一张图。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_11.png" alt></p><p>内存中有这样一部分区域，是和显存映射的。啥意思，就是你往上图的这些内存区域中写数据，相当于写在了显存中。而往显存中写数据，就相当于在屏幕上输出文本了。</p><p>没错，就是这么简单。</p><p>如果我们写这一行汇编语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [0xB8000],&#x27;h&#x27;</span><br></pre></td></tr></table></figure><p>后面那个 h 相当于汇编编辑器帮我们转换成 ASCII 码的二进制数值，当然我们也可以直接写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov [0xB8000],0x68</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实就是往内存中 0xB8000 这个位置写了一个值，只要一写，屏幕上就会是这样。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_12.png" alt></p><p>简单吧，具体说来，这片内存是<strong>每两个字节表示一个显示在屏幕上的字符，第一个是字符的编码，第二个是字符的颜色</strong>，那我们先不管颜色，如果多写几个字符就像这样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov [0xB8000],&#x27;h&#x27;</span><br><span class="line">mov [0xB8002],&#x27;e&#x27;</span><br><span class="line">mov [0xB8004],&#x27;l&#x27;</span><br><span class="line">mov [0xB8006],&#x27;l&#x27;</span><br><span class="line">mov [0xB8008],&#x27;o&#x27;</span><br></pre></td></tr></table></figure><p>此时屏幕上就会是这样。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_13.png" alt></p><p>是不是贼简单？那我们回过头看刚刚的代码，我们就假设显示模式是我们现在的这种文本模式，那条件分支就可以去掉好多。</p><p>代码可以简化成这个样子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#define ORIG_X          (*(unsigned char *)0x90000)</span><br><span class="line">#define ORIG_Y          (*(unsigned char *)0x90001)</span><br><span class="line">void con_init(void) &#123;</span><br><span class="line">    register unsigned char a;</span><br><span class="line">    // 第一部分 获取显示模式相关信息</span><br><span class="line">    video_num_columns = (((*(unsigned short *)0x90006) &amp; 0xff00) &gt;&gt; 8);</span><br><span class="line">    video_size_row = video_num_columns * 2;</span><br><span class="line">    video_num_lines = 25;</span><br><span class="line">    video_page = (*(unsigned short *)0x90004);</span><br><span class="line">    video_erase_char = 0x0720;</span><br><span class="line">    // 第二部分 显存映射的内存区域 </span><br><span class="line">    video_mem_start = 0xb8000;</span><br><span class="line">    video_port_reg  = 0x3d4;</span><br><span class="line">    video_port_val  = 0x3d5;</span><br><span class="line">    video_mem_end = 0xba000;</span><br><span class="line">    // 第三部分 滚动屏幕操作时的信息</span><br><span class="line">    origin  = video_mem_start;</span><br><span class="line">    scr_end = video_mem_start + video_num_lines * video_size_row;</span><br><span class="line">    top = 0;</span><br><span class="line">    bottom  = video_num_lines;</span><br><span class="line">    // 第四部分 定位光标并开启键盘中断</span><br><span class="line">    gotoxy(ORIG_X, ORIG_Y);</span><br><span class="line">    set_trap_gate(0x21,&amp;keyboard_interrupt);</span><br><span class="line">    outb_p(inb_p(0x21)&amp;0xfd,0x21);</span><br><span class="line">    a=inb_p(0x61);</span><br><span class="line">    outb_p(a|0x80,0x61);</span><br><span class="line">    outb(a,0x61);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先还记不记得之前汇编语言的时候做的工作，存了好多以后要用的数据在内存中。</p><div class="table-container"><table><thead><tr><th>内存地址</th><th>长度(字节)</th><th>名称</th></tr></thead><tbody><tr><td>0x90000</td><td>2</td><td>光标位置</td></tr><tr><td>0x90002</td><td>2</td><td>扩展内存数</td></tr><tr><td>0x90004</td><td>2</td><td>显示页面</td></tr><tr><td>0x90006</td><td>1</td><td>显示模式</td></tr><tr><td>0x90007</td><td>1</td><td>字符列数</td></tr><tr><td>0x90008</td><td>2</td><td>未知</td></tr><tr><td>0x9000A</td><td>1</td><td>显示内存</td></tr><tr><td>0x9000B</td><td>1</td><td>显示状态</td></tr><tr><td>0x9000C</td><td>2</td><td>显卡特性参数</td></tr><tr><td>0x9000E</td><td>1</td><td>屏幕行数</td></tr><tr><td>0x9000F</td><td>1</td><td>屏幕列数</td></tr><tr><td>0x90080</td><td>16</td><td>硬盘1参数表</td></tr><tr><td>0x90090</td><td>16</td><td>硬盘2参数表</td></tr><tr><td>0x901FC</td><td>2</td><td>根设备号</td></tr></tbody></table></div><p>所以：</p><ol><li>第一部分获取 0x90006 地址处的数据，就是获取显示模式等相关信息。</li><li>第二部分就是显存映射的内存地址范围，我们现在假设是 CGA 类型的文本模式，所以映射的内存是从 0xB8000 到 0xBA000。</li><li>第三部分是设置一些滚动屏幕时需要的参数，定义顶行和底行是哪里，这里顶行就是第一行，底行就是最后一行，很合理。</li><li>第四部分是把光标定位到之前保存的光标位置处（取内存地址 0x90000 处的数据），然后设置并开启键盘中断。</li></ol><h4 id="键盘敲击如何显示在屏幕上"><a href="#键盘敲击如何显示在屏幕上" class="headerlink" title="键盘敲击如何显示在屏幕上"></a>键盘敲击如何显示在屏幕上</h4><p>开启键盘中断后，键盘上敲击一个按键后就会触发中断，中断程序就会读键盘码转换成 ASCII 码，然后写到光标处的内存地址，也就相当于往显存写，于是这个键盘敲击的字符就显示在了屏幕上。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_14.png" alt></p><p>这一切具体是怎么做到的呢？我们先看看我们干了什么。</p><ol><li>我们现在根据已有信息已经可以实现往屏幕上的任意位置写字符了，而且还能指定颜色。</li><li>并且，我们也能接受键盘中断，根据键盘码中断处理程序就可以得知哪个键按下了。</li></ol><p>有了这俩功能，那我们想干嘛还不是为所欲为？</p><p>好，接下来我们看看代码是怎么处理的，很简单。一切的起点，就是第四步的 gotoxy 函数，定位当前光标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define ORIG_X          (*(unsigned char *)0x90000)</span><br><span class="line">#define ORIG_Y          (*(unsigned char *)0x90001)</span><br><span class="line">void con_init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 第四部分 定位光标并开启键盘中断</span><br><span class="line">    gotoxy(ORIG_X, ORIG_Y);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面干嘛了呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static inline void gotoxy(unsigned int new_x,unsigned int new_y) &#123;</span><br><span class="line">   ...</span><br><span class="line">   x = new_x;</span><br><span class="line">   y = new_y;</span><br><span class="line">   pos = origin + y*video_size_row + (x&lt;&lt;1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是给 x y pos 这三个参数附上了值。</p><p>其中 x 表示光标在哪一列，y 表示光标在哪一行，pos 表示根据列号和行号计算出来的内存指针，也就是往这个 pos 指向的地址处写数据，就相当于往控制台的 x 列 y 行处写入字符了，简单吧？</p><p>然后，当你按下键盘后，触发键盘中断，之后的程序调用链是这样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_keyboard_interrupt:</span><br><span class="line">    ...</span><br><span class="line">    call _do_tty_interrupt</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">void do_tty_interrupt(int tty) &#123;</span><br><span class="line">   copy_to_cooked(tty_table+tty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void copy_to_cooked(struct tty_struct * tty) &#123;</span><br><span class="line">    ...</span><br><span class="line">    tty-&gt;write(tty);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 控制台时 tty 的 write 为 con_write 函数</span><br><span class="line">void con_write(struct tty_struct * tty) &#123;</span><br><span class="line">    ...</span><br><span class="line">    __asm__(&quot;movb _attr,%%ah\n\t&quot;</span><br><span class="line">      &quot;movw %%ax,%1\n\t&quot;</span><br><span class="line">      ::&quot;a&quot; (c),&quot;m&quot; (*(short *)pos)</span><br><span class="line">      :&quot;ax&quot;);</span><br><span class="line">     pos += 2;</span><br><span class="line">     x++;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面的过程不用管，我们看最后一个函数 con_write 中的关键代码。</p><p><strong>asm</strong> 内联汇编，就是把键盘输入的字符 c 写入 pos 指针指向的内存，相当于往屏幕输出了。</p><p>之后两行 pos+=2 和 x++，就是调整所谓的光标。</p><p>你看，写入一个字符，最底层，其实就是往内存的某处写个数据，然后顺便调整一下光标。</p><p>由此我们也可以看出，<strong>光标的本质，其实就是这里的 x y pos 这仨变量</strong>而已。</p><h5 id="换行效果"><a href="#换行效果" class="headerlink" title="换行效果"></a>换行效果</h5><p>当发现光标位置处于某一行的结尾时（这个应该很好算吧，我们都知道屏幕上一共有几行几列了），就把光标计算出一个新值，让其处于下一行的开头。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_15.png" alt></p><p>就一个小计算公式即可搞定，仍然在 con_write 源码处有体现，就是判断列号 x 是否大于了总列数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void con_write(struct tty_struct * tty) &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (x&gt;=video_num_columns) &#123;</span><br><span class="line">        x -= video_num_columns;</span><br><span class="line">        pos -= video_size_row;</span><br><span class="line">        lf();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void lf(void) &#123;</span><br><span class="line">   if (y+1&lt;bottom) &#123;</span><br><span class="line">      y++;</span><br><span class="line">      pos += video_size_row;</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="滚屏"><a href="#滚屏" class="headerlink" title="滚屏"></a>滚屏</h5><p>无非就是当检测到光标已经出现在最后一行最后一列了，那就把每一行的字符，都复制到它上一行，其实就是算好哪些内存地址上的值，拷贝到哪些内存地址，就好了。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>所以，有了这个初始化工作，我们就可以利用这些信息，弄几个小算法，实现各种我们常见控制台的操作。</p><p>或者换句话说，我们见惯不怪的控制台，回车、换行、删除、滚屏、清屏等操作，其实底层都要实现相应的代码的。</p><p>所以 console.c 中的其他方法就是做这个事的，我们就不展开每一个功能的方法体了，简单看看有哪些方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 定位光标的</span><br><span class="line">static inline void gotoxy(unsigned int new_x, unsigned int new_y)&#123;&#125;</span><br><span class="line">// 滚屏，即内容向上滚动一行</span><br><span class="line">static void scrup(void)&#123;&#125;</span><br><span class="line">// 光标同列位置下移一行</span><br><span class="line">static void lf(int currcons)&#123;&#125;</span><br><span class="line">// 光标回到第一列</span><br><span class="line">static void cr(void)&#123;&#125;</span><br><span class="line">...</span><br><span class="line">// 删除一行</span><br><span class="line">static void delete_line(void)&#123;&#125;</span><br></pre></td></tr></table></figure><p>整个 console.c 就讲完了，要知道这个文件可是整个内核中代码量最大的文件，可是功能特别单一，也都很简单，主要是处理键盘各种不同的按键，需要写好多 switch case 等语句，十分麻烦，我们这里就完全没必要去展开了，就是个苦力活。</p><p>到这里，我们就正式讲完了 tty_init 的作用。</p><p>在此之后，内核代码就可以用它来方便地在控制台输出字符啦！这在之后内核想要在启动过程中告诉用户一些信息，以及后面内核完全建立起来之后，由用户用 shell 进行操作时手动输入命令，都是可以用到这里的代码的！</p><h3 id="时间初始化-操作系统如何获取当前时间"><a href="#时间初始化-操作系统如何获取当前时间" class="headerlink" title="时间初始化 操作系统如何获取当前时间"></a>时间初始化 操作系统如何获取当前时间</h3><p>过初始化控制台的 tty_init 操作，内核代码可以很方便地在控制台输出字符啦，同时支持用户键盘操作和换行和滚屏等友好设计。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续往下看下一个初始化的倒霉鬼，time_init。</p><p>为什么操作系统在启动之后，可以显示出当前时间呢？难道操作系统在电脑关机后，依然不停地在某处运行着，勤勤恳恳数着秒表么？</p><p>当然不是，那我们今天就打开这个 time_init 函数一探究竟。</p><p>打开这个函数后我又是很开心，因为很短，且没有更深入的方法调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#define CMOS_READ(addr) (&#123; \</span><br><span class="line">    outb_p(0x80|addr,0x70); \</span><br><span class="line">    inb_p(0x71); \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">#define BCD_TO_BIN(val) ((val)=((val)&amp;15) + ((val)&gt;&gt;4)*10)</span><br><span class="line"></span><br><span class="line">static void time_init(void) &#123;</span><br><span class="line">    struct tm time;</span><br><span class="line">    do &#123;</span><br><span class="line">        time.tm_sec = CMOS_READ(0);</span><br><span class="line">        time.tm_min = CMOS_READ(2);</span><br><span class="line">        time.tm_hour = CMOS_READ(4);</span><br><span class="line">        time.tm_mday = CMOS_READ(7);</span><br><span class="line">        time.tm_mon = CMOS_READ(8);</span><br><span class="line">        time.tm_year = CMOS_READ(9);</span><br><span class="line">    &#125; while (time.tm_sec != CMOS_READ(0));</span><br><span class="line">    BCD_TO_BIN(time.tm_sec);</span><br><span class="line">    BCD_TO_BIN(time.tm_min);</span><br><span class="line">    BCD_TO_BIN(time.tm_hour);</span><br><span class="line">    BCD_TO_BIN(time.tm_mday);</span><br><span class="line">    BCD_TO_BIN(time.tm_mon);</span><br><span class="line">    BCD_TO_BIN(time.tm_year);</span><br><span class="line">    time.tm_mon--;</span><br><span class="line">    startup_time = kernel_mktime(&amp;time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>梦想的代码呀！ 那主要就是对 CMOS_READ 和 BCD_TO_BIN 都是啥意思展开讲一下就明白了了。</p><h4 id="CMOS-READ"><a href="#CMOS-READ" class="headerlink" title="CMOS_READ"></a>CMOS_READ</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define CMOS_READ(addr) (&#123; \</span><br><span class="line">    outb_p(0x80|addr,0x70); \</span><br><span class="line">    inb_p(0x71); \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>就是对一个端口先 out 写一下，再 in 读一下。</p><p>这是 CPU 与外设交互的一个基本玩法，CPU 与外设打交道基本是通过端口，往某些端口写值来表示要这个外设干嘛，然后从另一些端口读值来接受外设的反馈。</p><p>至于这个外设内部是怎么实现的，对使用它的操作系统而言，是个黑盒，无需关心。那对于我们程序员来说，就更不用关心了。</p><p>对 CMOS 这个外设的交互讲起来可能没感觉，我们看看与硬盘的交互。</p><p>最常见的就是读硬盘了，我们看硬盘的端口表。</p><div class="table-container"><table><thead><tr><th>端口</th><th>读</th><th>写</th></tr></thead><tbody><tr><td>0x1F0</td><td>数据寄存器</td><td>数据寄存器</td></tr><tr><td>0x1F1</td><td>错误寄存器</td><td>特征寄存器</td></tr><tr><td>0x1F2</td><td>扇区计数寄存器</td><td>扇区计数寄存器</td></tr><tr><td>0x1F3</td><td>扇区号寄存器或 LBA 块地址 0~7</td><td>扇区号或 LBA 块地址 0~7</td></tr><tr><td>0x1F4</td><td>磁道数低 8 位或 LBA 块地址 8~15</td><td>磁道数低 8 位或 LBA 块地址 8~15</td></tr><tr><td>0x1F5</td><td>磁道数高 8 位或 LBA 块地址 16~23</td><td>磁道数高 8 位或 LBA 块地址 16~23</td></tr><tr><td>0x1F6</td><td>驱动器/磁头或 LBA 块地址 24~27</td><td>驱动器/磁头或 LBA 块地址 24~27</td></tr><tr><td>0x1F7</td><td>命令寄存器或状态寄存器</td><td>命令寄存器</td></tr></tbody></table></div><p>那读硬盘就是，往除了第一个以外的后面几个端口写数据，告诉要读硬盘的哪个扇区，读多少。然后再从 0x1F0 端口一个字节一个字节的读数据。这就完成了一次硬盘读操作。</p><p>如果觉得不够具体，那来个具体的版本。</p><ol><li>在 0x1F2 写入要读取的扇区数</li><li>在 0x1F3 ~ 0x1F6 这四个端口写入计算好的起始 LBA 地址</li><li>在 0x1F7 处写入读命令的指令号</li><li>不断检测 0x1F7 （此时已成为状态寄存器的含义）的忙位</li><li>如果第四步骤为不忙，则开始不断从 0x1F0 处读取数据到内存指定位置，直到读完</li></ol><p>看，是不是对 CPU 最底层是如何与外设打交道有点感觉了？是不是也不难？就是按照人家的操作手册，然后无脑按照要求读写端口就行了。</p><p>当然，读取硬盘的这个无脑循环，可以 <strong>CPU</strong> 直接读取并做写入内存的操作，这样就会占用 CPU 的计算资源。</p><p>也可以交给 <strong>DMA</strong> 设备去读，解放 CPU，但和硬盘的交互，通通都是按照硬件手册上的端口说明，来操作的，实际上也是做了一层封装。</p><p>好了，我们已经学会了和一个外设打交道的基本玩法了。</p><p>那我们代码中要打交道的是哪个外设呢？就是 <strong>CMOS</strong>。</p><p>它是主板上的一个可读写的 RAM 芯片，你在开机时长按某个键就可以进入设置它的页面。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_16.png" alt></p><p>那我们的代码，其实就是与它打交道，获取它的一些数据而已。</p><p>我们回过头看代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void time_init(void) &#123;</span><br><span class="line">    struct tm time;</span><br><span class="line">    do &#123;</span><br><span class="line">        time.tm_sec = CMOS_READ(0);</span><br><span class="line">        time.tm_min = CMOS_READ(2);</span><br><span class="line">        time.tm_hour = CMOS_READ(4);</span><br><span class="line">        time.tm_mday = CMOS_READ(7);</span><br><span class="line">        time.tm_mon = CMOS_READ(8);</span><br><span class="line">        time.tm_year = CMOS_READ(9);</span><br><span class="line">    &#125; while (time.tm_sec != CMOS_READ(0));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面几个赋值语句 CMOS_READ 就是<strong>通过读写 CMOS 上的指定端口，依次获取年月日时分秒</strong>等信息。具体咋操作代码上也写了，也是按照 CMOS 手册要求的读写指定端口就行了，我们就不展开了。</p><p>所以你看，其实操作系统程序，也是要依靠与一个外部设备打交道，来获取这些信息的，并不是它自己有什么魔力。操作系统最大的魅力，就在于它借力完成了一项伟大的事，借 CPU 的力，借硬盘的力，借内存的力，以及现在借 CMOS 的力。</p><p>至于 CMOS 又是如何知道时间的，这个就不在我们讨论范围了。</p><h4 id="BCD-TO-BIN"><a href="#BCD-TO-BIN" class="headerlink" title="BCD_TO_BIN"></a>BCD_TO_BIN</h4><p>就是 BCD 转换成 BIN，因为从 CMOS 上获取的这些年月日都是 BCD 码值，需要转换成存储在我们变量上的二进制数值，所以需要一个小算法来转换一下，没什么意思。</p><h4 id="kernel-mktime"><a href="#kernel-mktime" class="headerlink" title="kernel_mktime"></a>kernel_mktime</h4><p>就是根据刚刚的那些时分秒数据，计算从 <strong>1970 年 1 月 1 日 0 时</strong>起到开机当时经过的秒数，作为开机时间，存储在 <strong>startup_time</strong> 这个变量里。</p><p>想研究可以仔细看看这段代码，不过我觉得这种细节不必看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">startup_time = kernel_mktime(&amp;time);</span><br><span class="line"></span><br><span class="line">// kernel/mktime.c</span><br><span class="line">long kernel_mktime(struct tm * tm)</span><br><span class="line">&#123;</span><br><span class="line">    long res;</span><br><span class="line">    int year;</span><br><span class="line">    year = tm-&gt;tm_year - 70;</span><br><span class="line">    res = YEAR*year + DAY*((year+1)/4);</span><br><span class="line">    res += month[tm-&gt;tm_mon];</span><br><span class="line">    if (tm-&gt;tm_mon&gt;1 &amp;&amp; ((year+2)%4))</span><br><span class="line">        res -= DAY;</span><br><span class="line">    res += DAY*(tm-&gt;tm_mday-1);</span><br><span class="line">    res += HOUR*tm-&gt;tm_hour;</span><br><span class="line">    res += MINUTE*tm-&gt;tm_min;</span><br><span class="line">    res += tm-&gt;tm_sec;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>所以今天其实就是，计算出了一个 startup_time 变量而已，至于这个变量今后会被谁用，怎么用，那就是后话了。</p><p>相信你逐渐也体会到了，此时操作系统好多地方都是用外设要求的方式去询问，比如硬盘信息、显示模式，以及今天的开机时间的获取等。</p><p>所以至少到目前来说，你还不应该感觉操作系统有多么的“高端”，很多时候都是繁琐地，读人家的硬件手册，获取到想要的的信息，拿来给自己用，或者对其进行各种设置。</p><p>但你一定要耐得住寂寞，真正体现操作系统的强大设计之处，还得接着往下读。</p><h3 id="进程调度初始化"><a href="#进程调度初始化" class="headerlink" title="进程调度初始化"></a>进程调度初始化</h3><p>我们继续往下看，大名鼎鼎的进程调度初始化，shed_init，这方法可了不起，因为它就是多进程的基石！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    sched_init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于来到了兴奋的时刻，是不是很激动？不过先别激动，这里只是进程调度的初始化，也就是为进程调度所需要用到的数据结构做个准备，真正的进程调度还需要调度算法、时钟中断等机制的配合。</p><p>当然，对于理解操作系统，流程和数据结构最为重要了，而这一段作为整个流程的起点，以及建立数据结构的地方，就显得格外重要了。</p><p>我们进入这个方法，一点点往后看。</p><h4 id="初始化了下-TSS-和-LDT-线程0"><a href="#初始化了下-TSS-和-LDT-线程0" class="headerlink" title="初始化了下 TSS 和 LDT (线程0)"></a>初始化了下 TSS 和 LDT (线程0)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void sched_init(void) &#123;</span><br><span class="line">    set_tss_desc(gdt+4, &amp;(init_task.task.tss));</span><br><span class="line">    set_ldt_desc(gdt+5, &amp;(init_task.task.ldt));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两行代码初始化了下 TSS 和 LDT。</p><p>先别急问这俩结构是啥。还记得之前讲的全局描述符表 gdt 么？它在内存的这个位置，并且被设置成了这个样子。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_17.png" alt></p><p>说回这两行代码，其实就是往后又加了两项，分别是 TSS 和 LDT。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_18.png" alt></p><p>好，那再说说这俩结构是干嘛的，不过本篇先简单理解，后面会详细讲到。</p><p><strong>TSS 叫任务状态段，就是保存和恢复进程的上下文的</strong>，所谓上下文，其实就是各个寄存器的信息而已，这样进程切换的时候，才能做到保存和恢复上下文，继续执行。</p><p>由它的数据结构你应该可以看出点意思。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct tss_struct&#123;</span><br><span class="line">    long back_link;</span><br><span class="line">    long esp0;</span><br><span class="line">    long ss0;</span><br><span class="line">    long esp1;</span><br><span class="line">    long ss1;</span><br><span class="line">    long esp2;</span><br><span class="line">    long ss2;</span><br><span class="line">    long cr3;</span><br><span class="line">    long eip;</span><br><span class="line">    long eflags;</span><br><span class="line">    long eax, ecx, edx, ebx;</span><br><span class="line">    long esp;</span><br><span class="line">    long ebp;</span><br><span class="line">    long esi;</span><br><span class="line">    long edi;</span><br><span class="line">    long es;</span><br><span class="line">    long cs;</span><br><span class="line">    long ss;</span><br><span class="line">    long ds;</span><br><span class="line">    long fs;</span><br><span class="line">    long gs;</span><br><span class="line">    long ldt;</span><br><span class="line">    long trace_bitmap;</span><br><span class="line">    struct i387_struct i387;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 <strong>LDT 叫局部描述符表，是与 GDT 全局描述符表相对应的</strong>，内核态的代码用 GDT 里的数据段和代码段，而用户进程的代码用每个用户进程自己的 LDT 里得数据段和代码段。</p><p>先不管它，我这里放一张超纲的图，你先找找感觉。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_19.png" alt></p><p>我们接着往下看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct desc_struct &#123;</span><br><span class="line">    unsigned long a,b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct task_struct * task[64] = &#123;&amp;(init_task.task), &#125;;</span><br><span class="line"></span><br><span class="line">void sched_init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    int i;</span><br><span class="line">    struct desc_struct * p;</span><br><span class="line">        p = gdt+6;</span><br><span class="line">    for(i=1;i&lt;64;i++) &#123;</span><br><span class="line">        task[i] = NULL;</span><br><span class="line">        p-&gt;a=p-&gt;b=0;</span><br><span class="line">        p++;</span><br><span class="line">        p-&gt;a=p-&gt;b=0;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有个循环，干了两件事。</p><p>一个是给一个长度为 64，结构为 task_struct 的数组 task 附上初始值。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_20.png" alt></p><p>这个 task_struct 结构就是代表<strong>每一个进程的信息</strong>，这可是个<strong>相当相当重要</strong>的结构了，把它放在心里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">/* these are hardcoded - don&#x27;t touch */</span><br><span class="line">    long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><span class="line">    long counter;</span><br><span class="line">    long priority;</span><br><span class="line">    long signal;</span><br><span class="line">    struct sigaction sigaction[32];</span><br><span class="line">    long blocked; /* bitmap of masked signals */</span><br><span class="line">  /* various fields */</span><br><span class="line">    int exit_code;</span><br><span class="line">    unsigned long start_code,end_code,end_data,brk,start_stack;</span><br><span class="line">    long pid,father,pgrp,session,leader;</span><br><span class="line">    unsigned short uid,euid,suid;</span><br><span class="line">    unsigned short gid,egid,sgid;</span><br><span class="line">    long alarm;</span><br><span class="line">    long utime,stime,cutime,cstime,start_time;</span><br><span class="line">    unsigned short used_math;</span><br><span class="line">  /* file system info */</span><br><span class="line">    int tty;  /* -1 if no tty, so it must be signed */</span><br><span class="line">    unsigned short umask;</span><br><span class="line">    struct m_inode * pwd;</span><br><span class="line">    struct m_inode * root;</span><br><span class="line">    struct m_inode * executable;</span><br><span class="line">    unsigned long close_on_exec;</span><br><span class="line">    struct file * filp[NR_OPEN];</span><br><span class="line">  /* ldt for this task 0 - zero 1 - cs 2 - ds&amp;ss */</span><br><span class="line">    struct desc_struct ldt[3];</span><br><span class="line">  /* tss for this task */</span><br><span class="line">    struct tss_struct tss;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个循环做的另一件事，是给 gdt 剩下的位置填充上 0，也就是把剩下留给 TSS 和 LDT 的描述符都先附上空值。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_21.png" alt></p><p>往后展望一下的话，就是以后每创建一个新进程，就会在后面添加一组 TSS 和 LDT 表示这个进程的任务状态段以及局部描述符表信息。</p><p>还记得刚刚的超纲图吧，未来整个内存的规划就是这样的，不过你先不用理解得很细。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_22.png" alt></p><p>那为什么一开始就先有了一组 TSS 和 LDT 呢？现在也没创建进程呀。错了，现在虽然我们还没有建立起进程调度的机制，但我们正在运行的代码就是会作为<strong>未来的一个进程的指令流</strong>。</p><p>也就是当未来进程调度机制一建立起来，正在执行的代码就会化身成为<strong>进程 0</strong> 的代码。所以我们需要提前把这些未来会作为进程 0 的信息写好。</p><p>如果你觉得很疑惑，别急，等后面整个进程调度机制建立起来，并且让你亲眼看到进程 0 以及进程 1 的创建，以及它们后面因为进程调度机制而切换，你就明白这一切的意义了。</p><h4 id="ltr-amp-lldt"><a href="#ltr-amp-lldt" class="headerlink" title="ltr &amp; lldt"></a>ltr &amp; lldt</h4><p>好，收回来，初始化了一组 TSS 和 LDT 后，再往下看两行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define ltr(n) __asm__(&quot;ltr %%ax&quot;::&quot;a&quot; (_TSS(n)))</span><br><span class="line">#define lldt(n) __asm__(&quot;lldt %%ax&quot;::&quot;a&quot; (_LDT(n)))</span><br><span class="line"></span><br><span class="line">void sched_init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ltr(0);</span><br><span class="line">    lldt(0);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这又涉及到之前的知识咯。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还记得 lidt 和 lgdt 指令么？一个是给 idtr 寄存器赋值，以告诉 CPU 中断描述符表 idt 在内存的位置；一个是给 gdtr 寄存器赋值，以告诉 CPU 全局描述符表 gdt 在内存的位置。</span><br></pre></td></tr></table></figure><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_23.png" alt></p><p>那这两行和刚刚的类似:</p><ul><li>ltr 是给 tr 寄存器赋值，以告诉 CPU 任务状态段 TSS 在内存的位置；</li><li>lldt 一个是给 ldt 寄存器赋值，以告诉 CPU 局部描述符 LDT 在内存的位置。</li></ul><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_24.png" alt></p><p>这样，CPU 之后就能通过 tr 寄存器找到当前进程的任务状态段信息，也就是上下文信息，以及通过 ldt 寄存器找到当前进程在用的局部描述符表信息。</p><h4 id="可编程定时器与中断"><a href="#可编程定时器与中断" class="headerlink" title="可编程定时器与中断"></a>可编程定时器与中断</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void sched_init(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    outb_p(0x36,0x43);      /* binary, mode 3, LSB/MSB, ch 0 */</span><br><span class="line">    outb_p(LATCH &amp; 0xff , 0x40);    /* LSB */</span><br><span class="line">    outb(LATCH &gt;&gt; 8 , 0x40);    /* MSB */</span><br><span class="line">    set_intr_gate(0x20,&amp;timer_interrupt);</span><br><span class="line">    outb(inb_p(0x21)&amp;~0x01,0x21);</span><br><span class="line">    set_system_gate(0x80,&amp;system_call);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四行端口读写代码，两行设置中断代码。</p><p>端口读写我们已经很熟悉了，就是 CPU 与外设交互的一种方式，之前讲硬盘读写以及 CMOS 读写时，已经接触过了。</p><p>而这次交互的外设是一个<strong>可编程定时器的芯片</strong>，这四行代码就开启了这个定时器，之后这个定时器变会<strong>持续的、以一定频率的向 CPU 发出中断信号</strong>。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_25.png" alt></p><p>而这段代码中设置的两个中断:</p><ul><li>第一个就是<strong>时钟中断，中断号为 0x20，中断处理程序为 timer_interrupt</strong>。那么每次定时器向 CPU 发出中断后，便会执行这个函数。<ul><li>这个定时器的触发，以及时钟中断函数的设置，是操作系统主导进程调度的一个关键！没有他们这样的外部信号不断触发中断，操作系统就没有办法作为进程管理的主人，通过强制的手段收回进程的 CPU 执行权限。</li></ul></li><li>第二个设置的中断叫<strong>系统调用 system_call，中断号是 0x80</strong>，这个中断又是个<strong>非常非常非常非常非常非常非常重要</strong>的中断，所有用户态程序想要调用内核提供的方法，都需要基于这个系统调用来进行。<ul><li>比如 Java 程序员写一个 read，底层会执行汇编指令 int 0x80，这就会触发系统调用这个中断，最终调用到 Linux 里的 sys_read 方法。</li></ul></li></ul><p>所以你看这一章的内容，偷偷设置了影响进程和影响用户程序调用系统方法的两个重量级中断处理函数，不简单呀~</p><p>到目前为止，中断已经设置了不少了，我们现在看看所设置好的中断有哪些。</p><div class="table-container"><table><thead><tr><th>中断号</th><th>中断处理函数</th></tr></thead><tbody><tr><td>0 ~ 0x10</td><td>trap_init 里设置的一堆</td></tr><tr><td>0x20</td><td>timer_interrupt</td></tr><tr><td>0x21</td><td>keyboard_interrupt</td></tr><tr><td>0x80</td><td>system_call</td></tr></tbody></table></div><ul><li>其中 0-0x10 这 17 个中断是 trap_init 里初始化设置的，是一些基本的中断，比如除零异常等。</li><li>在控制台初始化 con_init 里设置了 0x21 键盘中断， 这样按下键盘就有反应了。</li><li>0x20 时钟中断，并且开启定时器。</li><li>最后又偷偷设置了一个极为重要的 0x80 系统调用中断。</li></ul><p>找到些感觉没，有没有越来越发现，操作系统有点靠中断驱动的意思，各个模块不断初始化各种中断处理函数，并且开启指定的外设开关，让操作系统自己慢慢“活”了起来，逐渐通过中断忙碌于各种事情中，无法自拔。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>回顾一下我们今天，就三件事。</p><ul><li>第一，我们往全局描述符表写了两个结构，TSS 和 LDT，作为未来进程 0 的任务状态段和局部描述符表信息。</li></ul><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_26.png" alt></p><ul><li>第二，我们初始化了一个结构为 task_struct  的数组，未来这里会存放所有进程的信息，并且我们给数组的第一个位置附上了 init_task.init 这个具体值，也是作为未来进程 0 的信息。</li></ul><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_27.png" alt></p><ul><li>第三，设置了时钟中断 0x20 和系统调用 0x80，一个作为进程调度的起点，一个作为用户程序调用操作系统功能的桥梁，非常之重要。</li></ul><p>后面，我们将会逐渐看到，这些重要的事情，是如何紧密且精妙地结合在一起，发挥出奇妙的作用。</p><h3 id="缓冲区初始化-主内存外的另一个内存管理神器"><a href="#缓冲区初始化-主内存外的另一个内存管理神器" class="headerlink" title="缓冲区初始化 主内存外的另一个内存管理神器"></a>缓冲区初始化 主内存外的另一个内存管理神器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ...</span><br><span class="line">    mem_init(main_memory_start, memory_end);</span><br><span class="line">    ...</span><br><span class="line">    buffer_init(buffer_memory_end);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在管理内存之初，我们划分出了三个边界值，对主内存和缓冲区进行了区分</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_28.png" alt></p><p>并通过 mem_init 完成了主内存区初始化， 设置好了内存管理结构 mam_map</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_29.png" alt></p><p>至此，我们完成了主内存区的管理，而缓冲区是如何管理和分配的，就要看 buffer_init 了。</p><p>我们还是采用之前的方式，就假设内存只有 8M，把一些不相干的分支去掉，方便理解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">extern int end;</span><br><span class="line">struct buffer_head * start_buffer = (struct buffer_head *) &amp;end;</span><br><span class="line"></span><br><span class="line">void buffer_init(long buffer_end) &#123;</span><br><span class="line">    struct buffer_head * h = start_buffer;</span><br><span class="line">    void * b = (void *) buffer_end;</span><br><span class="line">    while ( (b -= 1024) &gt;= ((void *) (h+1)) ) &#123;</span><br><span class="line">        h-&gt;b_dev = 0;</span><br><span class="line">        h-&gt;b_dirt = 0;</span><br><span class="line">        h-&gt;b_count = 0;</span><br><span class="line">        h-&gt;b_lock = 0;</span><br><span class="line">        h-&gt;b_uptodate = 0;</span><br><span class="line">        h-&gt;b_wait = NULL;</span><br><span class="line">        h-&gt;b_next = NULL;</span><br><span class="line">        h-&gt;b_prev = NULL;</span><br><span class="line">        h-&gt;b_data = (char *) b;</span><br><span class="line">        h-&gt;b_prev_free = h-1;</span><br><span class="line">        h-&gt;b_next_free = h+1;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    h--;</span><br><span class="line">    free_list = start_buffer;</span><br><span class="line">    free_list-&gt;b_prev_free = h;</span><br><span class="line">    h-&gt;b_next_free = free_list;</span><br><span class="line">    for (int i=0;i&lt;307;i++)</span><br><span class="line">        hash_table[i]=NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然很长，但其实就造了<strong>两个数据结构</strong>而已。</p><h4 id="通过链接器-ld-获取缓冲区开始位置"><a href="#通过链接器-ld-获取缓冲区开始位置" class="headerlink" title="通过链接器 ld 获取缓冲区开始位置"></a>通过链接器 ld 获取缓冲区开始位置</h4><p>不过别急，我们先看这一行代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern int end;</span><br><span class="line">void buffer_init(long buffer_end) &#123;</span><br><span class="line">    struct buffer_head * start_buffer = (struct buffer_head *) &amp;end;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个外部变量 <strong>end</strong>，而我们的缓冲区开始位置 <strong>start_buffer</strong> 就等于这个变量的内存地址。</p><p>这个外部变量 end 并不是操作系统代码写就的，而是由<strong>链接器 ld</strong> 在链接整个程序时设置的一个外部变量，帮我们计算好了整个内核代码的末尾地址。</p><p>那在这之前的是内核代码区域肯定不能用，在这之后的，就给 buffer 用了。所以我们的内存分布图可以更精确一点了。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_30.png" alt></p><p>你看，之前的疑惑解决了吧？很好理解嘛，内核程序和缓冲区的划分，肯定有个分界线，这个分界线就是 end 变量的值。</p><p>这个值定多少合适呢？</p><p>像主内存和缓冲区的分界线，就直接代码里写死了，就是上图中的 2M。</p><p>可是内核程序占多大内存在写的时候完全不知道，就算知道了如果改动一点代码也会变化，所以就由程序编译链接时由链接器程序帮我们把这个内核代码末端的地址计算出来，作为一个外部变量 end 我们拿来即用，就方便多了。</p><h4 id="两个内存管理结构"><a href="#两个内存管理结构" class="headerlink" title="两个内存管理结构"></a>两个内存管理结构</h4><p>好，回过头我们再看看，<strong>整段代码创造了哪两个管理结构</strong>？</p><p>我们先看这段结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void buffer_init(long buffer_end) &#123;</span><br><span class="line">    struct buffer_head * h = start_buffer;</span><br><span class="line">    void * b = (void *) buffer_end;</span><br><span class="line">    while ( (b -= 1024) &gt;= ((void *) (h+1)) ) &#123;</span><br><span class="line">        ...</span><br><span class="line">        h-&gt;b_data = (char *) b;</span><br><span class="line">        h-&gt;b_prev_free = h-1;</span><br><span class="line">        h-&gt;b_next_free = h+1;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就俩变量。</p><ul><li>一个是 buffer_head 结构的 h，代表缓冲头，其指针值是 start_buffer，刚刚我们计算过了，就是图中的内核代码末端地址 end，也就是缓冲区开头。</li><li>一个是 b，代表缓冲块，指针值是 buffer_end，也就是图中的 2M，就是缓冲区结尾。</li></ul><p>缓冲区结尾的 b 每次循环 -1024，也就是一页的值，缓冲区结尾的 h 每次循环 +1（一个 buffer_head 大小的内存），直到碰一块为止。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_31.png" alt></p><p>可以看到，其实这个 b 就代表缓冲块，h 代表缓冲头，一个从上往下，一个从下往上。</p><p>而且这个过程中，h 被附上了属性值，其中比较关键的是这个 buffer 所表示的数据部分 b_data，也就是指向了上面的缓冲块 b。</p><p>还有这个 buffer 的前后空闲 buffer 的指针 b_prev_free 和 b_next_free。</p><p>那画成图就是如下这样。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_32.png" alt></p><p>当缓冲头 h 的所有 next 和 prev 指针都指向彼此时，就构成了一个双向链表。继续看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void buffer_init(long buffer_end) &#123;</span><br><span class="line">...</span><br><span class="line">free_list = start_buffer;</span><br><span class="line">free_list-&gt;b_prev_free = h;</span><br><span class="line">h-&gt;b_next_free = free_list;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三行代码，结合刚刚的双向链表 h，我画出图，你就懂了。</p><p><img src="/2022/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AD%A5%E4%B9%8B%E5%A4%A7%E6%88%98%E5%89%8D%E6%9C%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E4%BD%9C/img_33.png" alt></p><p>看，free_list 指向了缓冲头双向链表的第一个结构，然后就可以顺着这个结构，从双向链表中遍历到任何一个缓冲头结构了，而通过缓冲头又可以找到这个缓冲头对应的缓冲块。</p><p>简单说，<strong>缓冲头就是具体缓冲块的管理结构，而 free_list 开头的双向链表又是缓冲头的管理结构</strong>，整个管理体系就这样建立起来了。</p><p>现在，从 free_list 开始遍历，就可以找到这里的所有内容了。</p><h4 id="通过-哈希表-双向链表-进一步优化查询"><a href="#通过-哈希表-双向链表-进一步优化查询" class="headerlink" title="通过 哈希表 + 双向链表 进一步优化查询"></a>通过 哈希表 + 双向链表 进一步优化查询</h4><p>不过，还有最后一个事，能帮助更好管理，往下看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void buffer_init(long buffer_end) &#123;</span><br><span class="line">    ...</span><br><span class="line">    for (i=0;i&lt;307;i++)</span><br><span class="line">        hash_table[i]=NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 307 大小的 <strong>hash_table</strong> 数组，这是干嘛的呢？</p><p>其实这段代码在 <strong>buffer.c</strong> 中，而 buffer.c 是在 <strong>fs</strong> 包下的，也就是<strong>文件系统</strong>包下的。所以它今后是为文件系统而服务，具体是内核程序如果需要访问块设备中的数据，就都需要经过缓冲区来间接地操作。</p><p>也就是说，读取块设备的数据（硬盘中的数据），需要先读到缓冲区中，如果缓冲区已有了，就不用从块设备读取了，直接取走。</p><p>那怎么知道缓冲区已经有了要读取的块设备中的数据呢？从双向链表从头遍历当然可以，但是这效率可太低了。所以需要一个 hashmap 的结构方便快速查找，这就是 hash_table 这个数组的作用。</p><p>现在只是初始化这个 hash_table，还并没有哪个地方用到了它，所以我就先简单剧透下。</p><p>之后当要读取某个块设备上的数据时，首先要搜索相应的缓冲块，是下面这个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#define _hashfn(dev,block) (((unsigned)(dev^block))%307)</span><br><span class="line">#define hash(dev,block) hash_table[_hashfn(dev,block)]</span><br><span class="line"></span><br><span class="line">// 搜索合适的缓冲块 </span><br><span class="line">struct buffer_head * getblk(int dev,int block) &#123;</span><br><span class="line">    ...</span><br><span class="line">    struct buffer_head bh = get_hash_table(dev,block)；</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct buffer_head * get_hash_table(int dev, int block) &#123;</span><br><span class="line">    ...    </span><br><span class="line">    find_buffer(dev,block);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct buffer_head * find_buffer(int dev, int block) &#123; </span><br><span class="line">    ...     </span><br><span class="line">    hash(dev,block);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一路跟下来发现，就是通过</p><figure class="highlight plaintext"><figcaption><span>% 307``` 即 ```(设备号^逻辑块号) Mod 307``` 找到在 hash_table 里的索引下标，接下来就和 Java 里的 HashMap 类似，如果哈希冲突就形成链表，画成图就是这样。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](./操作系统第二步之大战前期的初始化工作/img_34.png)</span><br><span class="line"></span><br><span class="line">**哈希表 + 双向链表**，如果刷算法题多了，很容易想到这可以实现 **LRU 算法**，没错，之后的缓冲区使用和弃用，正是这个算法发挥了作用。</span><br><span class="line"></span><br><span class="line">也就是之后在讲通过文件系统来读取硬盘文件时，都需要使用和弃用这个缓冲区里的内容，缓冲区即是用户进程的内存和硬盘之间的桥梁。</span><br><span class="line"></span><br><span class="line">### 硬盘初始化 - hd_init</span><br><span class="line"></span><br><span class="line">至此，我们只剩下了最后两个初始化函数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>void main(void) {<br>    …<br>    mem_init(main_memory_start,memory_end);<br>    trap_init();<br>    blk_dev_init();<br>    chr_dev_init();<br>    tty_init();<br>    time_init();<br>    sched_init();<br>    buffer_init(buffer_memory_end);<br>    hd_init(); //本节重点<br>    floppy_init();</p><pre><code>sti();move_to_user_mode();if (!fork()) &#123;init();&#125;for(;;) pause();</code></pre><p>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">floppy_init 是软盘初始化，现在软盘几乎都被淘汰了，计算机中也没有软盘驱动器了，所以这个我们完全可以不看。</span><br><span class="line"></span><br><span class="line">我们直接看 hd_init 硬盘初始化干了什么？</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>void hd_init(void) {<br>    blk_dev[3].request_fn = do_hd_request;<br>    set_intr_gate(0x2E,&amp;hd_interrupt);<br>    outb_p(inb_p(0x21)&amp;0xfb,0x21);<br>    outb(inb_p(0xA1)&amp;0xbf,0xA1);<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">就这？一共就四行代码。</span><br><span class="line"></span><br><span class="line">没错，初始化嘛，往往都比较简单，尤其是对硬件设备的初始化，大体都是：</span><br><span class="line">1. 往某些 IO 端口上读写一些数据，表示开启它；</span><br><span class="line">2. 然后再向中断向量表中添加一个中断，使得 CPU 能够响应这个硬件设备的动作；</span><br><span class="line">3. 最后再初始化一些数据结构来管理。不过像是内存管理可能结构复杂些，外设的管理，相对就简单很多了。</span><br><span class="line"></span><br><span class="line">#### blk_dev[3]</span><br><span class="line"></span><br><span class="line">看第一行代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>void hd_init(void) {<br>    blk_dev[3].request_fn = do_hd_request;<br>    …<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们把 blk_dev 数组索引 3 位置处的块设备管理结构 blk_dev_struct 的 request_fn 赋值为了 do_hd_request，这是啥意思呢？</span><br><span class="line"></span><br><span class="line">因为有很多块设备，所以 Linux 0.11 内核用了一个 blk_dev[] 来进行管理，每一个索引表示一个块设备。</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>struct blk_dev_struct blk_dev[NR_BLK_DEV] = {<br>    { NULL, NULL },     /<em> no_dev </em>/<br>    { NULL, NULL },     /<em> dev mem </em>/<br>    { NULL, NULL },     /<em> dev fd </em>/<br>    { NULL, NULL },     /<em> dev hd </em>/<br>    { NULL, NULL },     /<em> dev ttyx </em>/<br>    { NULL, NULL },     /<em> dev tty </em>/<br>    { NULL, NULL }      /<em> dev lp </em>/<br>};<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">你看，索引为 3 这个位置，就表示给硬盘 hd 这个块设备留的位置。</span><br><span class="line"></span><br><span class="line">那么每个块设备执行读写请求都有自己的函数实现，在上层看来都是一个统一函数 request_fn 即可，具体实现各有不同，对于硬盘来说，这个实现就是 do_hd_request 函数。</span><br><span class="line"></span><br><span class="line">是不是有点像接口？这其实就是**多态**思想在 C 语言的体现嘛~ 用 Java 程序员熟悉的话就是，父类引用 request_fn 指向子类对象 do_hd_request 的感觉咯。</span><br><span class="line"></span><br><span class="line">#### 设置中断 </span><br><span class="line"></span><br></pre></td></tr></table></figure><br>void hd_init(void) {<br>    …<br>    set_intr_gate(0x2E,&amp;hd_interrupt);<br>    …<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对于中断我们已经很熟悉了，这里就是又设置了一个新的中断，中断号是 0x2E，中断处理函数是 hd_interrupt，也就是说硬盘发生读写时，硬盘会发出中断信号给 CPU，之后 CPU 便会陷入中断处理程序，也就是执行 hd_interrupt 函数。</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>_hd_interrupt:<br>    …<br>    xchgl _do_hd,%edx<br>    …</p><p>// 如果是读盘操作，这个 do_hd 是 read_intr<br>static void read_intr(void) {<br>    …<br>    do_hd_request();<br>    …<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">好了，又多了一个中断，那我们再次梳理下目前开启的中断都有哪些。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 中断号 | 中断处理函数           |</span><br><span class="line">| ---- |------------------|</span><br><span class="line">| 0 ~ 0x10 | trap_init 里设置的一堆 |</span><br><span class="line">| 0x20 | timer_interrupt  |</span><br><span class="line">| 0x21 | keyboard_interrupt |</span><br><span class="line">| 0x2E | hd_interrupt |</span><br><span class="line">| 0x80 | system_call | </span><br><span class="line"></span><br></pre></td></tr></table></figure><br>看到最后，你会发现操作系统就是一个靠中断驱动的死循环而已，如果不发生任何中断，操作系统会一直在一个死循环里等待。换句话说，让操作系统工作的唯一方式，就是触发中断。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 允许硬盘控制器发送中断请求信号</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>void hd_init(void) {<br>    …<br>    outb_p(inb_p(0x21)&amp;0xfb,0x21);<br>    outb(inb_p(0xA1)&amp;0xbf,0xA1);<br>}<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">就是往几个 IO 端口上读写，其作用是**允许硬盘控制器发送中断请求信号**，仅此而已。我们向来是不深入硬件细节，知道往这个端口里写上这些数据，导致硬盘开启了中断，即可。</span><br><span class="line"></span><br><span class="line">#### 拓展</span><br><span class="line"></span><br><span class="line">hd.c 里还有很多读写硬盘的方法，这个在之后文件系统用到他们时，自然会讲起，这里就抛个引子，看看读硬盘最最底层的操作流程，是怎样的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">| 端口     | 读                        | 写      |</span><br><span class="line">|--------|--------------------------|--------|</span><br><span class="line">| 0x1F0  | 数据寄存器                   | 数据寄存器  |</span><br><span class="line">| 0x1F1  | 错误寄存器                   | 特征寄存器 |</span><br><span class="line">| 0x1F2  | 扇区计数寄存器                 | 扇区计数寄存器 | </span><br><span class="line">| 0x1F3  | 扇区号寄存器或 LBA 块地址 0~7      | 扇区号或 LBA 块地址 0~7 |</span><br><span class="line">| 0x1F4  | 磁道数低 8 位或 LBA 块地址 8~15   | 磁道数低 8 位或 LBA 块地址 8~15 |</span><br><span class="line">| 0x1F5  | 磁道数高 8 位或 LBA 块地址 16~23 | 磁道数高 8 位或 LBA 块地址 16~23 |</span><br><span class="line">| 0x1F6  | 驱动器/磁头或 LBA 块地址 24~27    | 驱动器/磁头或 LBA 块地址 24~27 |</span><br><span class="line">| 0x1F7  | 命令寄存器或状态寄存器              | 命令寄存器 |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">那读硬盘就是，往除了第一个以外的后面几个端口写数据，告诉要读硬盘的哪个扇区，读多少。然后再从 0x1F0 端口一个字节一个字节的读数据。这就完成了一次硬盘读操作。</span><br><span class="line"></span><br><span class="line">如果觉得不够具体，那来个具体的版本。</span><br><span class="line"></span><br><span class="line">1. 在 0x1F2 写入要读取的扇区数</span><br><span class="line">2. 在 0x1F3 ~ 0x1F6 这四个端口写入计算好的起始 LBA 地址</span><br><span class="line">3. 在 0x1F7 处写入读命令的指令号</span><br><span class="line">4. 不断检测 0x1F7 （此时已成为状态寄存器的含义）的忙位</span><br><span class="line">5. 如果第四步骤为不忙，则开始不断从 0x1F0 处读取数据到内存指定位置，直到读完</span><br><span class="line"></span><br><span class="line">而操作系统的代码，也是这样写的，我们一睹为快一下，不用理解细节。</span><br></pre></td></tr></table></figure><br>static void hd_out(unsigned int drive,unsigned int nsect,unsigned int sect,<br>        unsigned int head,unsigned int cyl,unsigned int cmd,<br>        void (*intr_addr)(void)) {<br>    …<br>    do_hd = intr_addr;<br>    outb_p(hd_info[drive].ctl,HD_CMD);<br>    port = 0x1f0;<br>    outb_p(hd_info[drive].wpcom&gt;&gt;2,++port);<br>    outb_p(nsect,++port);<br>    outb_p(sect,++port);<br>    outb_p(cyl,++port);<br>    outb_p(cyl&gt;&gt;8,++port);<br>    outb_p(0xA0|(drive&lt;&lt;4)|head,++port);<br>    outb(cmd,++port);<br>}<br>```</p><p>看，那些 outb_p 方法，转换成汇编语言，就是 out 指令，往指定的硬盘 IO 端口上写数据，达到我们想要的读或者写的目的。</p><p>是不是很 low？</p><p>但我们由用户层写的各种 read\write 函数，即便是经过系统调用、文件系统、缓冲区管理等等过程，但只要是读写硬盘，最终都要调用到这个最底层的函数，殊途同归，逃不掉的！</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><a href="https://mp.weixin.qq.com/s/Hf9B1ww1wFxiUDkWb0obeQ">大战前期的初始化工作</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;title: 操作系统第二步之大战前期的初始化工作&lt;br&gt;date: 2022-05-18 14:35:41&lt;br&gt;tags: [‘操作系统’]  &lt;/p&gt;
&lt;h2 id=&quot;categories-操作系统&quot;&gt;&lt;a href=&quot;#categories-操作系统&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统初始化之进入内核前的苦力活</title>
    <link href="http://example.com/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/"/>
    <id>http://example.com/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/</id>
    <published>2022-04-19T12:55:24.000Z</published>
    <updated>2022-04-24T07:15:57.036Z</updated>
    
    <content type="html"><![CDATA[<p>本系列转自<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzk0MjE3NDE0Ng==&action=getalbum&album_id=2123743679373688834&scene=173&from_msgid=2247499734&from_itemidx=1&count=3&nolastread=1#wechat_redirect">操作系统源码系列</a></p><p>会以一个读小说的心态，从开机启动后的代码执行顺序，阅读和赏析 Linux 0.11 全部核心代码，了解操作系统的技术细节和设计思想。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_0.png"></p><h3 id="最开始的两行代码-加载启动区"><a href="#最开始的两行代码-加载启动区" class="headerlink" title="最开始的两行代码-加载启动区"></a>最开始的两行代码-加载启动区</h3><p>在<a href="/2022/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E6%8C%89%E4%B8%8B%E5%BC%80%E6%9C%BA%E9%94%AE/" title="操作系统第一步之按下开机键">操作系统第一步之按下开机键</a> 一文中， 我们简单介绍了操作系统启动区加载的过程，回顾一下：</p><ul><li>按下开机键，CPU 将 PC 寄存器的值强制初始化为 0xffff0，这个位置是 BIOS 程序的入口地址（一跳）</li><li>该入口地址处是一个跳转指令，跳转到 0xfe05b 位置，开始执行（二跳）</li><li>执行了一些硬件检测工作后，最后一步将启动区内容加载到内存 0x7c00，并跳转到这里（三跳）</li><li>启动区代码主要是加载操作系统内核，并跳转到加载处（四跳）</li></ul><p>当你按下开机键的那一刻，在主板上提前写死的固件程序 BIOS 会将硬盘中启动区的 512 字节的数据，原封不动复制到内存中的 0x7c00 这个位置，并跳转到那个位置进行执行。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img.png"></p><p>启动区的定义非常简单，只要硬盘中的 0 盘 0 道 1 扇区的 512 个字节的最后两个字节分别是 0x55 和 0xaa，那么 BIOS 就会认为它是个启动区。</p><p>所以对于我们理解操作系统而言，此时的 BIOS 仅仅就是个代码搬运工，把 512 字节的二进制数据从硬盘搬运到了内存中而已。</p><p><strong>所以作为操作系统的开发人员，仅仅需要把操作系统最开始的那段代码，编译并存储在硬盘的 0 盘 0 道 1 扇区即可</strong>。</p><p>之后 BIOS 会帮我们把它放到内存里，并且跳过去执行。</p><p>而 Linux-0.11 的最开始的代码，就是这个用汇编语言写的 bootsect.s，位于 boot 文件夹下。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_1.png"></p><p>通过编译，这个 bootsect.s 会被编译成二进制文件，存放在启动区的第一扇区。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_2.png"></p><p>随后就会如刚刚所说，由 BIOS 搬运到内存的 0x7c00 这个位置，而 CPU 也会从这个位置开始，不断往后一条一条语句无脑地执行下去。</p><p>那我们的梦幻之旅，就从这个文件的第一行代码开始啦！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0x07c0</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure><p>这段代码是用汇编语言写的，含义是<strong>把 0x07c0 这个值复制到 ax 寄存器里，再将 ax 寄存器里的值复制到 ds 寄存器</strong>里。</p><details><summary>立即数不能直接赋给段寄存器</summary><p>因为CPU的设计里面一次指令只能读写内存一次的流程设计。</p><p>立即数直接赋值给段寄存器的话，相当于读一次内存，一次内存流程了，再写一次内存，二次内存流程了。</p></details><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_3.png"></p><p>那其实这一番折腾的结果就是:</p><details><summary>让 ds 这个寄存器里的值变成了 0x07c0</summary><p>ds 是一个 16 位的段寄存器，具体表示数据段寄存器，在内存寻址时充当段基址的作用。</p><p>啥意思呢？就是当我们之后用汇编语言写一个内存地址时，实际上仅仅是写了偏移地址，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [0x0001]</span><br></pre></td></tr></table></figure><p>实际上相当于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [ds:0x0001]</span><br></pre></td></tr></table></figure><p>ds 是默认加上的，表示在 ds 这个段基址处，往后再偏移 0x0001 单位，将这个位置的内存数据，复制到 ax 寄存器中。</p><p>这个 ds 被赋值为了 0x07c0，由于 x86 为了让自己在 16 位这个实模式下能访问到 20 位的地址线这个历史因素（不了解这个的就先别纠结为啥了），所以段基址要先左移四位。</p><p>那 0x07c0 左移四位就是 0x7c00，那这就刚好和这段代码被 BIOS 加载到的内存地址 0x7c00 一样了。</p></details><p>也就是说，之后再写的代码，里面访问的数据的内存地址，都先默认加上 0x7c00，再去内存中寻址。</p><p>为啥统一加上 0x7c00 这个数呢？这很好解释，BIOS 规定死了把操作系统代码加载到内存 0x7c00，那么里面的各种数据自然就全都被偏移了这么多，所以把数据段寄存器 ds<br>设置为这个值，方便了以后通过这种基址的方式访问内存里的数据。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_4.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>BIOS 将操作系统代码（启动区）加载到内存 0x7c00，然后通过 mov 指令将默认的数据段寄存器（ds 寄存器）的值改为 0x07c0 方便以后的基址寻址方式。</p><h3 id="自己给自己挪个地儿-移动启动区代码段"><a href="#自己给自己挪个地儿-移动启动区代码段" class="headerlink" title="自己给自己挪个地儿-移动启动区代码段"></a>自己给自己挪个地儿-移动启动区代码段</h3><h4 id="寄存器赋值"><a href="#寄存器赋值" class="headerlink" title="寄存器赋值"></a>寄存器赋值</h4><p>接下来我们带着这两行代码，继续往下看几行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0x07c0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,0x9000</span><br><span class="line">mov es,ax</span><br><span class="line">mov cx,#256</span><br><span class="line">sub si,si</span><br><span class="line">sub di,di</span><br><span class="line">rep movw</span><br></pre></td></tr></table></figure><p>此时 ds 寄存器的值已经是 0x07c0 了，然后又通过同样的方式将 es 寄存器的值变成 0x9000，接着又把 cx 寄存器的值变成<br>256（代码里确实是用十进制表示的，与其他地方有些不一致，不过无所谓）。</p><figure class="highlight plaintext"><figcaption><span>si,si```表示```si</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">经过这些指令后，以下几个寄存器分别被附上了指定的值，我们梳理一下</span><br><span class="line"></span><br><span class="line">* 数据段寄存器： ds = 0x07c0</span><br><span class="line">* 附加段寄存器： es = 0x9000</span><br><span class="line">* 普通寄存器： cx = 256</span><br><span class="line">* 源变址： si = 0</span><br><span class="line">* 目的变址： di = 0</span><br><span class="line"></span><br><span class="line">![](./操作系统初始化之进入内核前的苦力活/img_5.png)</span><br><span class="line"></span><br><span class="line">#### 复制启动区</span><br><span class="line"></span><br><span class="line">干嘛要给这些毫不相干的寄存器附上值呢？其实就是为下一条指令服务的，就是</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rep movw</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中 **rep 表示重复执行后面的指令**。</span><br><span class="line"></span><br><span class="line">而后面的指令 **movw 表示复制一个字**（word 16位），那其实就是不断重复地复制一个字。</span><br><span class="line"></span><br><span class="line">那下面自然就有三连问：</span><br><span class="line"></span><br><span class="line">**重复执行多少次呢？** 是 cx 寄存器中的值，也就是 256 次。</span><br><span class="line"></span><br><span class="line">**从哪复制到哪呢？** 是从 ds:si 处复制到 es:di 处。</span><br><span class="line"></span><br><span class="line">**一次复制多少呢？** 刚刚说过了，复制一个字，16 位，也就是两个字节。</span><br><span class="line"></span><br><span class="line">上面是直译，那把这段话翻译成更人话的方式讲出来就是，**将内存地址 0x7c00 处开始往后的 512 字节的数据，原封不动复制到 0x90000 处**。</span><br><span class="line"></span><br><span class="line">![](./操作系统初始化之进入内核前的苦力活/img_6.png)</span><br><span class="line"></span><br><span class="line">没错，就是这么折腾了一下。现在，操作系统最开头的代码，已经被挪到了 **0x90000** 这个位置了。</span><br><span class="line"></span><br><span class="line">#### 跳转到新的地址</span><br><span class="line"></span><br><span class="line">再往后是一个**跳转**指令。</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">jmpi go,0x9000</span><br><span class="line">go: </span><br><span class="line">  mov ax,cs</span><br><span class="line">  mov ds,ax</span><br></pre></td></tr></table></figure><p><strong>jmpi 是一个段间跳转指令，表示跳转到 0x9000:go 处执行</strong>。</p><p>还记得上一讲说的 <strong>段基址 : 偏移地址</strong> 这种格式的内存地址要如何计算吧？段基址仍然要先左移四位，因此结论就是跳转到 <strong>0x90000 + go</strong> 这个内存地址处执行。</p><p>再说 go，go 就是一个<strong>标签</strong>，最终编译成机器码的时候会被翻译成一个值，这个值就是 go 这个<strong>标签在文件内的偏移地址</strong>。</p><p>这个偏移地址再加上 0x90000，就刚好是 go 标签后面那段代码 <code>mov ax,cs</code> 此时所在的内存地址了。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_7.png"></p><p>那假如 mov ax,cx 这行代码位于最终编译好后的二进制文件的 0x08 处，那 go 就等于 0x08，而最终 CPU 跳转到的地址就是 0x90008 处。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>到此为止，其实就是<strong>一段 512 字节的代码和数据，从硬盘的启动区先是被移动到了内存 0x7c00 处，然后又立刻被移动到 0x90000 处，并且跳转到此处往后再稍稍偏移 go<br>这个标签所代表的偏移地址处</strong>，也就是 mov ax,cs 这行指令的位置。</p><h3 id="做好最最基础的准备工作-内存规划"><a href="#做好最最基础的准备工作-内存规划" class="headerlink" title="做好最最基础的准备工作-内存规划"></a>做好最最基础的准备工作-内存规划</h3><h4 id="寄存器赋值-1"><a href="#寄存器赋值-1" class="headerlink" title="寄存器赋值"></a>寄存器赋值</h4><p>操作系统的代码最开头的 512 字节的数据，从硬盘的启动区先是被移动到了内存 0x7c00 处，然后又立刻被移动到 0x90000 处，并且跳转到此处往后再稍稍偏移 go 这个标签所代表的偏移地址处。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_8.png"></p><p>那我们接下来，就继续把我们的目光放在 go 这个标签的位置，跟着 CPU 的步伐往后看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go: mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,#0xFF00</span><br></pre></td></tr></table></figure><p>这段代码的直接意思很容易理解，就是</p><ul><li>cs 寄存器的值分别复制给 ds、es 和 ss 寄存器，</li><li>把 0xFF00 给了 sp 寄存器。</li></ul><details><summary>CPU寄存器图</summary><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_9.png"></p></details><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cs 寄存器表示代码段寄存器，CPU 当前正在执行的代码在内存中的位置，就是由 cs:ip 这组寄存器配合指向的，其中 cs 是基址，ip 是偏移地址。</span><br></pre></td></tr></table></figure><ul><li><p>之前执行过一个段间跳转指令<code>jmpi go,0x9000</code>, 所以现在<strong>cs寄存器里的值就是0x9000，ip 寄存器里的值是 go 这个标签的偏移地址</strong>。</p></li><li><p>ds 为数据段寄存器，之前我们说过了，当时它被复制为 0x07c0，是因为之前的代码在 0x7c00 处，现在代码已经被挪到了 0x90000 处，所以现在自然又改赋值为 0x9000 了。</p></li><li><p>es 是扩展段寄存器，仅仅是个扩展，不是主角，先不用理它。</p></li><li><p>ss 为<strong>栈段寄存器</strong>，后面要配合栈基址寄存器 sp 来表示此时的栈顶地址。而此时 sp 寄存器被赋值为了 0xFF00 了，所以<strong>目前的栈顶地址就是 ss:sp 所指向的地址<br>0x9FF00 处</strong>。</p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_11.png" class title="实模式下的内存分布图"><ul><li>回顾一下实模式下的内存分布图，栈顶位置被赋值为了0x9FF00，几乎是基本内存距离代码段最远的位置，所以栈向下发展就很难撞见代码，也就比较安全。<br><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_10.png"></li><li>这也是为什么给栈顶地址设置为这个值的原因，其实只需要离代码的位置远远的即可。</li></ul></li></ul><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>其实到这里，操作系统的一些最最最最基础的准备工作，就做好了。都做了些啥事呢？</p><ol><li>代码从硬盘移到内存，又从内存挪了个地方，放在了 0x90000 处</li><li>数据段寄存器 ds 和代码段寄存器 cs 此时都被设置为了 0x9000，也就为跳转代码和访问内存数据，奠定了同一个内存的基址地址，方便了跳转和内存访问，因为仅仅需要指定偏移地址即可了。</li><li>栈顶地址被设置为了 0x9FF00，具体表现为栈段寄存器 ss 为 0x9000，栈基址寄存器 sp 为 0xFF00。栈是向下发展的，这个栈顶地址 0x9FF00 要远远大于此时代码所在的位置<br>0x90000，也就比较安全。</li></ol><p>拔高一下，这一部分其实就是把<strong>代码段寄存器 cs，数据段寄存器 ds，栈段寄存器 ss 和栈基址寄存器 sp</strong> 分别设置好了值，方便后续使用。</p><p>再拔高一下，其实操作系统在做的事情，就是给如何访问代码，如何访问数据，如何访问栈进行了一下<strong>内存的初步规划</strong>。其中访问代码和访问数据的规划方式就是设置了一个<strong>基址</strong>而已，访问栈就是把**<br>栈顶指针**指向了一个远离代码位置的地方而已。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_12.png"></p><h4 id="扩展阅读-三种段寄存器的作用"><a href="#扩展阅读-三种段寄存器的作用" class="headerlink" title="扩展阅读-三种段寄存器的作用"></a>扩展阅读-三种段寄存器的作用</h4><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_13.png"></p><ul><li>CS 是代码段寄存器，就是执行代码的时候带着这里存的基地址。</li><li>DS 是数据段寄存器，就是访问数据的时候带着这里的基地址。</li><li>SS 是栈段寄存器，就是访问栈时带着这里的基地址。</li></ul><h3 id="把自己在硬盘里的其他部分也放到内存来"><a href="#把自己在硬盘里的其他部分也放到内存来" class="headerlink" title="把自己在硬盘里的其他部分也放到内存来"></a>把自己在硬盘里的其他部分也放到内存来</h3><p>至此，短短几句代码，操作系统已经完成了最最基础的准备工作，也即初步做了一次内存规划， 从 CPU 的角度看，访问内存其实也就是三块地方而已</p><ul><li>数据段</li><li>代码段</li><li>栈</li></ul><p>内存规划中：</p><ul><li>将数据段寄存器 ds 和代码段寄存器 cs 设置为了 0x9000，方便代码的跳转与数据的访问。</li><li>将栈顶地址 ss:sp 设置在了离代码的位置 0x90000 足够遥远的 0x9FF00，保证栈向下发展不会轻易撞见代码的位置。</li></ul><h4 id="读取操作系统的全部代码"><a href="#读取操作系统的全部代码" class="headerlink" title="读取操作系统的全部代码"></a>读取操作系统的全部代码</h4><p>做好这些基础工作后，接下来就又该新的一翻折腾了，我们接着往下看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">load_setup:</span><br><span class="line">mov dx,#0x0000      ; drive 0, head 0</span><br><span class="line">mov cx,#0x0002      ; sector 2, track 0</span><br><span class="line">mov bx,#0x0200      ; address = 512, in 0x9000</span><br><span class="line">mov ax,#0x0200+4    ; service 2, nr of sectors</span><br><span class="line">int 0x13            ; read it</span><br><span class="line">jnc ok_load_setup       ; ok - continue</span><br><span class="line">mov dx,#0x0000</span><br><span class="line">mov ax,#0x0000      ; reset the diskette</span><br><span class="line">int 0x13</span><br><span class="line">jmp load_setup</span><br><span class="line"></span><br><span class="line">ok_load_setup:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里有两个 int<br>指令我们还没见过，<a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&mid=2247498208&idx=1&sn=b784f8b4e627ebd1bfb9810d194fdb80&chksm=c2c5834df5b20a5bdee331002bfc61c90eb468da325bf67abeef780c303a9f51c8543e1a5981&scene=21#wechat_redirect">这个 int 是汇编指令，可不是高级语言的整型变量哟</a></p><p>int 0x13 表示<strong>发起 0x13 号中断</strong>，这条指令上面给 dx、cx、bx、ax 赋值都是作为这个中断程序的参数。</p><p>这个中断发起后，CPU 会<strong>通过这个中断号，去寻找对应的中断处理程序的入口地址，并跳转过去执行</strong>，逻辑上就相当于执行了一个函数。</p><p>而 0x13 号中断的处理程序是 BIOS 提前给我们写好的，是<strong>读取磁盘</strong>的相关功能的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之后真正进入操作系统内核后，中断处理程序是需要我们自己去重新写的</span><br></pre></td></tr></table></figure><p>本段代码的注释已经写的很明确了，直接说最终的作用吧，就是<strong>将硬盘的第 2 个扇区开始，把数据加载到内存 0x90200 处，共加载 4 个扇区</strong>，图示其实就是这样。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_14.png"></p><p>如果复制成功，就跳转到 ok_load_setup 这个标签，如果失败，则会不断重复执行这段代码，也就是重试。</p><p>直接看成功后跳转的 ok_load_setup 这个标签后的代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ok_load_setup:</span><br><span class="line">    ...</span><br><span class="line">    mov ax,#0x1000</span><br><span class="line">    mov es,ax       ; segment of 0x10000</span><br><span class="line">    call read_it</span><br><span class="line">    ...</span><br><span class="line">    jmpi 0,0x9020</span><br></pre></td></tr></table></figure><p>这段代码省略了很多非主逻辑的代码，比如在屏幕上输出 Loading system … 这个字符串等。</p><p>剩下的主要代码就都写在这里了，就这么几行，其作用是<strong>把从硬盘第 6 个扇区开始往后的 240 个扇区，加载到内存 0x10000 处</strong>，和之前的从硬盘捣腾到内存是一个道理。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_15.png"></p><p>至此，整个操作系统的<strong>全部代码</strong>，就已经全部从硬盘中，被搬迁到内存来了。</p><p>然后又通过一个熟悉的段间跳转指令 jmpi 0,0x9020，跳转到 <strong>0x90200</strong> 处，就是硬盘第二个扇区开始处的内容。</p><h4 id="整个操作系统的编译过程"><a href="#整个操作系统的编译过程" class="headerlink" title="整个操作系统的编译过程"></a>整个操作系统的编译过程</h4><p>在分析硬盘第二个分区前，我们先简单看下炒作系统整个编译过程，就是通过 Makefile 和 build.c 配合完成的，最终会：</p><ol><li>把 bootsect.s 编译成 bootsect 放在硬盘的 1 扇区。</li><li>把 setup.s 编译成 setup 放在硬盘的 2~5 扇区。</li><li>把剩下的全部代码（head.s 作为开头）编译成 system 放在硬盘的随后 240 个扇区。</li></ol><p>所以整个路径就是这样的：</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_16.png"></p><p>所以，我们即将跳转到的内存中的 0x90200 处的代码，就是从硬盘第二个扇区开始处加载到内存的。</p><p>第二个扇区的最开始处，那也就是 setup.s 文件的第一行代码咯。</p><p>在<strong>操作系统刚刚开始建立的时候，那是完全自己安排前前后后的关系</strong><br>，一个字节都不能偏，就是这么强耦合，需要小心翼翼，需要大脑时刻保持清醒，规划好自己写的代码被编译并存储在硬盘的哪个位置，而随后又会被加载到内存的哪个位置，不能错乱。</p><h3 id="Setup加载-进入保护模式前的内存重规划"><a href="#Setup加载-进入保护模式前的内存重规划" class="headerlink" title="Setup加载-进入保护模式前的内存重规划"></a>Setup加载-进入保护模式前的内存重规划</h3><p>至此，操作系统已经完成了各种从硬盘到内存的加载，以及内存到内存的复制， 整个 bootsect.s 的使命就完成了，也是我们品读完的第一个操作系统源码文件。</p><h4 id="内存、硬盘、显卡等临时数据覆盖bootsect内容"><a href="#内存、硬盘、显卡等临时数据覆盖bootsect内容" class="headerlink" title="内存、硬盘、显卡等临时数据覆盖bootsect内容"></a>内存、硬盘、显卡等临时数据覆盖bootsect内容</h4><p>之后便跳转到了 0x90200 这个位置开始执行，这个位置处的代码就是位于 setup.s 的开头，我们接着来看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    mov ax,#0x9000  ; this is done in bootsect already, but...</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ah,#0x03    ; read cursor pos</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10        ; save it in known place, con_init fetches</span><br><span class="line">    mov [0],dx      ; it from 0x90000.</span><br></pre></td></tr></table></figure><p>又有个 int 0x10 指令, 它也是触发 BIOS 提供的<strong>显示服务中断</strong>处理程序，而 <strong>ah</strong> 寄存器被赋值为 0x03 表示显示服务里具体的<strong>读取光标位置功能</strong></p><p>这个 int 0x10 中断程序执行完毕并返回时，<strong>dx 寄存器里的值表示光标的位置</strong>，具体说来其高八位 dh 存储了行号，低八位 dl 存储了列号。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_17.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机在加电自检后会自动初始化到文字模式，在这种模式下，一屏幕可以显示 25 行，每行 80 个字符，也就是 80 列。</span><br></pre></td></tr></table></figure><p>那下一步 mov [0],dx 就是把这个光标位置存储在 [0] 这个内存地址处。</p><p>注意，前面我们说过，这个内存地址仅仅是偏移地址，还需要加上 ds 这个寄存器里存储的段基址，最终的内存地址是在 0x90000 处，这里存放着光标的位置，以便之后在初始化控制台的时候用到。</p><p>所以从这里也可以看出，这和我们平时调用一个方法没什么区别，只不过这里的寄存器的用法相当于入参和返回值，这里的 0x10 中断号相当于方法名。</p><details><summary>再接下来的几行代码，也是调用一个 BIOS 中断获取点什么信息，然后存储在内存中某个位置</summary><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">比如获取内存信息。</span><br><span class="line">; Get memory size (extended mem, kB)</span><br><span class="line">    mov ah,#0x88</span><br><span class="line">    int 0x15</span><br><span class="line">    mov [2],ax</span><br><span class="line">获取显卡显示模式。</span><br><span class="line">; Get video-card data:</span><br><span class="line">    mov ah,#0x0f</span><br><span class="line">    int 0x10</span><br><span class="line">    mov [4],bx      ; bh = display page</span><br><span class="line">    mov [6],ax      ; al = video mode, ah = window width</span><br><span class="line">检查显示方式并取参数</span><br><span class="line">; check for EGA/VGA and some config parameters</span><br><span class="line">    mov ah,#0x12</span><br><span class="line">    mov bl,#0x10</span><br><span class="line">    int 0x10</span><br><span class="line">    mov [8],ax</span><br><span class="line">    mov [10],bx</span><br><span class="line">    mov [12],cx</span><br><span class="line">获取第一块硬盘的信息。</span><br><span class="line">; Get hd0 data</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    mov ds,ax</span><br><span class="line">    lds si,[4*0x41]</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,#0x0080</span><br><span class="line">    mov cx,#0x10</span><br><span class="line">    rep</span><br><span class="line">    movsb</span><br><span class="line">获取第二块硬盘的信息。</span><br><span class="line">; Get hd1 data</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    mov ds,ax</span><br><span class="line">    lds si,[4*0x46]</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,#0x0090</span><br><span class="line">    mov cx,#0x10</span><br><span class="line">    rep</span><br><span class="line">    movsb</span><br></pre></td></tr></table></figure></details><p>我们就没必要细琢磨了，对操作系统的理解作用不大，只需要知道最终存储在内存中的信息是什么，在什么位置，就好了，之后会用到他们的</p><table><thead><tr><th>内存地址</th><th>长度(字节)</th><th>名称</th></tr></thead><tbody><tr><td>0x90000</td><td>2</td><td>光标位置</td></tr><tr><td>0x90002</td><td>2</td><td>扩展内存数</td></tr><tr><td>0x90004</td><td>2</td><td>显示页面</td></tr><tr><td>0x90006</td><td>1</td><td>显示模式</td></tr><tr><td>0x90007</td><td>1</td><td>字符列数</td></tr><tr><td>0x90008</td><td>2</td><td>未知</td></tr><tr><td>0x9000A</td><td>1</td><td>显示内存</td></tr><tr><td>0x9000B</td><td>1</td><td>显示状态</td></tr><tr><td>0x9000C</td><td>2</td><td>显卡特性参数</td></tr><tr><td>0x9000E</td><td>1</td><td>屏幕行数</td></tr><tr><td>0x9000F</td><td>1</td><td>屏幕列数</td></tr><tr><td>0x90080</td><td>16</td><td>硬盘1参数表</td></tr><tr><td>0x90090</td><td>16</td><td>硬盘2参数表</td></tr><tr><td>0x901FC</td><td>2</td><td>根设备号</td></tr></tbody></table><p>由于之后很快就会用 c 语言进行编程，虽然汇编和 c 语言也可以用变量的形式进行传递数据，但这需要编译器在链接时做一些额外的工作，所以这么多数据更方便的还是<strong>双方共同约定一个内存地址</strong><br>，我往这里存，你从这里取，就完事了。这恐怕是最最原始和直观的变量传递的方式了。</p><h4 id="关闭中断"><a href="#关闭中断" class="headerlink" title="关闭中断"></a>关闭中断</h4><p>把这些信息存储好之后，操作系统又要做什么呢？我们继续往下看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli         ; no interrupts allowed ;</span><br></pre></td></tr></table></figure><p>就一行 cli，表示关闭中断的意思。</p><p>因为后面我们要把原本是 BIOS 写好的中断向量表给覆盖掉，也就是给破坏掉了，写上我们自己的中断向量表，所以这个时候是不允许中断进来的。</p><h4 id="System模块移动"><a href="#System模块移动" class="headerlink" title="System模块移动"></a>System模块移动</h4><p>继续看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; first we move the system to it&#x27;s rightful place</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    cld         ; &#x27;direction&#x27;=0, movs moves forward</span><br><span class="line">do_move:</span><br><span class="line">    mov es,ax       ; destination segment</span><br><span class="line">    add ax,#0x1000</span><br><span class="line">    cmp ax,#0x9000</span><br><span class="line">    jz  end_move</span><br><span class="line">    mov ds,ax       ; source segment</span><br><span class="line">    sub di,di</span><br><span class="line">    sub si,si</span><br><span class="line">    mov cx,#0x8000</span><br><span class="line">    rep movsw</span><br><span class="line">    jmp do_move</span><br><span class="line">; then we load the segment descriptors</span><br><span class="line">end_move:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>看到后面那个 rep movsw 熟不熟悉, 同前面的原理一样，也是做了个内存复制操作，最终的结果是，把内存地址 0x10000 处开始往后一直到 0x90000 的内容，统统复制到内存的最开始的 0<br>位置，大概就是这么个效果。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_18.png"></p><h4 id="Setup加载总结-新的内存布局"><a href="#Setup加载总结-新的内存布局" class="headerlink" title="Setup加载总结-新的内存布局"></a>Setup加载总结-新的内存布局</h4><p>由于之前的各种加载和复制，导致内存看起来很乱，是时候进行一波取舍和整理了，我们重新梳理一下此时的内存布局。</p><ul><li>栈顶地址仍然是 0x9FF00 没有改变。</li><li>0x90000 开始往上的位置，原来是 bootsect 和 setup 程序的代码，现 bootsect 的一部分代码在已经被操作系统为了记录内存、硬盘、显卡等一些临时存放的数据给覆盖了一部分。</li><li>内存最开始的 <strong>0 到 0x80000 这 512K 被 system 模块给占用</strong>了，之前讲过，这个 system 模块就是除了 bootsect 和 setup<br>之外的全部程序链接在一起的结果，可以理解为<strong>操作系统的全部</strong>。</li></ul><p>那么现在的内存布局就是这个样子。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_19.png"></p><p>好了，记住上面的图就好了，这回是不是又重新清晰起来了？<strong>之前的什么 0x7c00，已经是过去式了</strong>，赶紧忘掉它，向前看！</p><p>接下来，就要进行有点技术含量的工作了，那就是<strong>模式的转换</strong>，需要<strong>从现在的 16 位的实模式转变为之后 32 位的保护模式</strong>，这是一项大工程！</p><h3 id="先解决段寄存器的历史包袱问题-进入保护模式前的新寻址方式准备"><a href="#先解决段寄存器的历史包袱问题-进入保护模式前的新寻址方式准备" class="headerlink" title="先解决段寄存器的历史包袱问题-进入保护模式前的新寻址方式准备"></a>先解决段寄存器的历史包袱问题-进入保护模式前的新寻址方式准备</h3><h4 id="当前内存地址回顾"><a href="#当前内存地址回顾" class="headerlink" title="当前内存地址回顾"></a>当前内存地址回顾</h4><p>经过Setup模块执行，操作系统内存被重新划分，并且之后的很长一段时间内存布局相对稳定，目前它长这样：</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_20.png"></p><p>0 地址开始处存放着操作系统的全部代码吗，也就是 system 模块，0x90000 位置处往后的几十个字节存放着一些设备的信息，方便以后使用。</p><table><thead><tr><th>内存地址</th><th>长度(字节)</th><th>名称</th></tr></thead><tbody><tr><td>0x90000</td><td>2</td><td>光标位置</td></tr><tr><td>0x90002</td><td>2</td><td>扩展内存数</td></tr><tr><td>0x90004</td><td>2</td><td>显示页面</td></tr><tr><td>0x90006</td><td>1</td><td>显示模式</td></tr><tr><td>0x90007</td><td>1</td><td>字符列数</td></tr><tr><td>0x90008</td><td>2</td><td>未知</td></tr><tr><td>0x9000A</td><td>1</td><td>显示内存</td></tr><tr><td>0x9000B</td><td>1</td><td>显示状态</td></tr><tr><td>0x9000C</td><td>2</td><td>显卡特性参数</td></tr><tr><td>0x9000E</td><td>1</td><td>屏幕行数</td></tr><tr><td>0x9000F</td><td>1</td><td>屏幕列数</td></tr><tr><td>0x90080</td><td>16</td><td>硬盘1参数表</td></tr><tr><td>0x90090</td><td>16</td><td>硬盘2参数表</td></tr><tr><td>0x901FC</td><td>2</td><td>根设备号</td></tr></tbody></table><p>是不是十分清晰？不过别高兴得太早，清爽的内存布局，是方便后续操作系统的大显身手！</p><p>接下来就要进行真正的第一项大工程了，那就是模式的转换，需要从现在的 16 位的实模式转变为之后 32 位的保护模式。</p><h4 id="保护模式下的物理地址"><a href="#保护模式下的物理地址" class="headerlink" title="保护模式下的物理地址"></a>保护模式下的物理地址</h4><p>每次讲这里都十分的麻烦，因为这是 <strong>x86 的历史包袱</strong>问题，现在的 CPU 几乎都是支持 32 位模式甚至 64 位模式了，很少有还仅仅停留在 16 位的实模式下的 CPU。</p><p>所以我们要<strong>为了这个历史包袱，写一段模式转换的代码</strong>，如果 Intel CPU 被重新设计而不用考虑兼容性，那么今天的代码将会减少很多甚至不复存在。</p><p>关于实模式和保护模式的区别，可以参考文档<a href="https://zhuanlan.zhihu.com/p/352843177">实模式和保护模式区别及寻址方式</a></p><p>继续看 setup.s 文件中的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lidt  idt_48      ; load idt with 0,0</span><br><span class="line">lgdt  gdt_48      ; load gdt with whatever appropriate</span><br><span class="line"></span><br><span class="line">idt_48:</span><br><span class="line">    .word   0     ; idt limit=0</span><br><span class="line">    .word   0,0   ; idt base=0L</span><br></pre></td></tr></table></figure><p>上来就是两行看不懂的指令，要理解这两条指令，就涉及到实模式和保护模式的第一个区别了。</p><p>目前，我们还处于实模式下，这个模式的CPU计算物理地址的方式为： <strong>段基址左移四位，再加上偏移地址</strong>。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_21.png"></p><p>当 CPU 切换到保护模式后，同样的代码，内存地址的计算方式还<strong>不一样</strong>。</p><p>刚刚那个 ds 寄存器里存储的值，在实模式下叫做<strong>段基址</strong>，在保护模式下叫<strong>段选择子</strong>。</p><p><strong>段选择子里存储着段描述符的索引</strong>。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_22.png"></p><p>通过段描述符索引，可以从 <strong>全局描述符表 gdt</strong> 中找到一个段描述符，段描述符里存储着段基址。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_23.png"></p><p>段基址取出来，再和偏移地址相加，就得到了物理地址，整个过程如下。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_24.png"></p><p>总结一下就是： <strong>段寄存器（比如 ds、ss、cs）里存储的是段选择子，段选择子去全局描述符表中寻找段描述符，从中取出段基址</strong>。</p><h4 id="全局描述符gdt-amp-gdtr-寄存器"><a href="#全局描述符gdt-amp-gdtr-寄存器" class="headerlink" title="全局描述符gdt &amp; gdtr 寄存器"></a>全局描述符gdt &amp; gdtr 寄存器</h4><p>那问题自然就出来了，全局描述符表（gdt）长什么样？它在哪？怎么让 CPU 知道它在哪？</p><p>先说说它在哪？ 在内存中呗。</p><p>那么怎么告诉 CPU 全局描述符表（gdt）在内存中的什么位置呢？</p><p>答案是由操作系统把这个位置信息存储在一个叫 gdtr 的寄存器中。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_25.png"></p><p>怎么存呢？就是刚刚那条指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt    gdt_48</span><br></pre></td></tr></table></figure><p>其中 <strong>lgdt</strong> 就表示把<strong>后面的值（gdt_48）放在 gdtr 寄存器</strong>中，gdt_48 标签，我们看看它长什么样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdt_48:</span><br><span class="line">    .word   0x800       ; gdt limit=2048, 256 GDT entries</span><br><span class="line">    .word   512+gdt,0x9 ; gdt base = 0X9xxxx</span><br></pre></td></tr></table></figure><p>可以看到这个标签位置处表示一个 48 位的数据，其中高 32 位存储着的正是全局描述符表 gdt 的内存地址</p><p><strong>0x90200 + gdt</strong></p><p>gdt 是个标签，表示在本文件内的偏移量，而本文件是 setup.s，编译后是放在 0x90200 这个内存地址的，还记得吧？所以要加上 0x90200 这个值。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_26.png"></p><p>那 gdt 这个标签处，就是全局描述符表在内存中的真正数据了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gdt:</span><br><span class="line">    .word   0,0,0,0     ; dummy</span><br><span class="line"></span><br><span class="line">    .word   0x07FF      ; 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">    .word   0x0000      ; base address=0</span><br><span class="line">    .word   0x9A00      ; code read/exec</span><br><span class="line">    .word   0x00C0      ; granularity=4096, 386</span><br><span class="line"></span><br><span class="line">    .word   0x07FF      ; 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">    .word   0x0000      ; base address=0</span><br><span class="line">    .word   0x9200      ; data read/write</span><br><span class="line">    .word   0x00C0      ; granularity=4096, 386</span><br></pre></td></tr></table></figure><p>具体细节不用关心，跟我看重点。</p><p>根据刚刚的段描述符格式。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_27.png"></p><p>可以看出目前全局描述符表有三个段描述符，第一个为空，第二个是代码段描述符（type=code），第三个是数据段描述符（type=data）。</p><p>第二个和第三个段描述符的段基址都是 0，也就是之后在逻辑地址转换物理地址的时候，通过段选择子查找到无论是代码段还是数据段，取出的段基址都是<br>0，那么物理地址将直接等于程序员给出的逻辑地址（准确说是逻辑地址中的偏移地址）。先记住这点就好。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_28.png"></p><p>具体段描述符的细节还有很多，就不展开了，比如这里的高 22 位就表示它是代码段还是数据段。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_29.png"></p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>整体而言，操作系统设置了个全局描述符表 gdt，为后面切换到保护模式后，能去那里寻找到段描述符，然后拼凑成最终的物理地址，就这个作用。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_31.png"></p><p>我们看看目前的内存布局:</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_30.png"></p><p>这里我把 idtr 寄存器也画出来了，这个是中断描述符表，其原理和全局描述符表一样。</p><ul><li>全局描述符表是让段选择子去里面寻找段描述符用的，</li><li>而中断描述符表是用来在发生中断时，CPU 拿着中断号去中断描述符表中寻找中断处理程序的地址，找到后就跳到相应的中断程序中去执行，具体我们后面遇到了再说。</li></ul><p>当然，还有很多段描述符，作用不仅仅是转换成最终的物理地址，不过这是后话了。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>段描述符结构和详细说明如下(Intel 手册)</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_34.png"></p><p>保护模式下逻辑地址到线性地址（不开启分页时就是物理地址）的转化</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_35.png"></p><h3 id="六行代码进入保护模式"><a href="#六行代码进入保护模式" class="headerlink" title="六行代码进入保护模式"></a>六行代码进入保护模式</h3><p>自此，我们解决了向前兼容(X86)实模式寻址的历史包袱问题, 但这知识进入保护模式前准备工作中的其中一个。</p><h4 id="打开A20地址线"><a href="#打开A20地址线" class="headerlink" title="打开A20地址线"></a>打开A20地址线</h4><p>我们接着往下看，代码仍然是 setup.s 中的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,#0xD1        ; command write</span><br><span class="line">out #0x64,al</span><br><span class="line">mov al,#0xDF        ; A20 on</span><br><span class="line">out #0x60,al</span><br></pre></td></tr></table></figure><p>这段代码的意思是，<strong>打开 A20 地址线</strong>。</p><details><summary>到底什么是 A20 地址线呢</summary><p>简单理解，这一步就是为了突破地址信号线 20 位的宽度，变成 32 位可用。这是由于 8086 CPU 只有 20 位的地址线，所以如果程序给出 21<br>位的内存地址数据，那多出的一位就被忽略了，比如如果经过计算得出一个内存地址为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 0000 00000000 00000000</span><br></pre></td></tr></table></figure><p>那实际上内存地址相当于 0，因为高位的那个 1 被忽略了，地方不够。</p><p>当 CPU 到了 32 位时代之后，由于要考虑<strong>兼容性</strong>，还必须保持一个只能用 20 位地址线的模式，所以如果你不手动开启的话，即使地址线已经有 32 位了，仍然会限制只能使用其中的 20 位。</p><p>具体可参考文档<a href="http://www.techbulo.com/703.html">A20 地址线问题全面解析</a></p></details><h4 id="中断重定义"><a href="#中断重定义" class="headerlink" title="中断重定义"></a>中断重定义</h4><p>接下来的一段代码，你完全完全不用看，但为了防止你一直记挂在心上，我给你截出来说道说道，这样以后我说完全不用看的代码时，你就真的可以放宽心完全不看了。</p><details><summary>就是这一大坨，还有 Linus 自己的注释</summary><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">; well, that went ok, I hope. Now we have to reprogram the interrupts :-(</span><br><span class="line">; we put them right after the intel-reserved hardware interrupts, at</span><br><span class="line">; int 0x20-0x2F. There they won&#x27;t mess up anything. Sadly IBM really</span><br><span class="line">; messed this up with the original PC, and they haven&#x27;t been able to</span><br><span class="line">; rectify it afterwards. Thus the bios puts interrupts at 0x08-0x0f,</span><br><span class="line">; which is used for the internal hardware interrupts as well. We just</span><br><span class="line">; have to reprogram the 8259&#x27;s, and it isn&#x27;t fun.</span><br><span class="line"></span><br><span class="line">    mov al,#0x11        ; initialization sequence</span><br><span class="line">    out #0x20,al        ; send it to 8259A-1</span><br><span class="line">    .word   0x00eb,0x00eb       ; jmp $+2, jmp $+2</span><br><span class="line">    out #0xA0,al        ; and to 8259A-2</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x20        ; start of hardware int&#x27;s (0x20)</span><br><span class="line">    out #0x21,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x28        ; start of hardware int&#x27;s 2 (0x28)</span><br><span class="line">    out #0xA1,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x04        ; 8259-1 is master</span><br><span class="line">    out #0x21,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x02        ; 8259-2 is slave</span><br><span class="line">    out #0xA1,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x01        ; 8086 mode for both</span><br><span class="line">    out #0x21,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    out #0xA1,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0xFF        ; mask off all interrupts for now</span><br><span class="line">    out #0x21,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    out #0xA1,al</span><br></pre></td></tr></table></figure></details><p>这里是对<strong>可编程中断控制器 8259 芯片</strong>进行的编程。</p><p>因为中断号是不能冲突的， Intel 把 0 到 0x19 号中断都作为<strong>保留中断</strong>，比如 0 号中断就规定为<strong>除零异常</strong>，软件自定义的中断都应该放在这之后，但是 IBM 在原 PC<br>机中搞砸了，跟保留中断号发生了冲突，以后也没有纠正过来，所以我们得重新对其进行编程，不得不做，却又一点意思也没有。</p><p>所以我们也不必在意，只要知道重新编程之后，8259 这个芯片的引脚与中断号的对应关系，变成了如下的样子就好。</p><table><thead><tr><th>PIC请求号</th><th>中断号</th><th>用途</th></tr></thead><tbody><tr><td>IRQ0</td><td>0x20</td><td>时钟中断</td></tr><tr><td>IRQ1</td><td>0x21</td><td>键盘中断</td></tr><tr><td>IRQ2</td><td>0x22</td><td>接连从芯片</td></tr><tr><td>IRQ3</td><td>0x23</td><td>串口2</td></tr><tr><td>IRQ4</td><td>0x24</td><td>串口1</td></tr><tr><td>IRQ5</td><td>0x25</td><td>并口2</td></tr><tr><td>IRQ6</td><td>0x26</td><td>软盘驱动器</td></tr><tr><td>IRQ7</td><td>0x27</td><td>并口1</td></tr><tr><td>IRQ8</td><td>0x28</td><td>实时钟中断</td></tr><tr><td>IRQ9</td><td>0x29</td><td>保留</td></tr><tr><td>IRQ10</td><td>0x2a</td><td>保留</td></tr><tr><td>IRQ11</td><td>0x2b</td><td>保留</td></tr><tr><td>IRQ12</td><td>0x2c</td><td>鼠标中断</td></tr><tr><td>IRQ13</td><td>0x2d</td><td>数学协处理器</td></tr><tr><td>IRQ14</td><td>0x2e</td><td>硬盘中断</td></tr><tr><td>IRQ15</td><td>0x2f</td><td>保留</td></tr></tbody></table><h4 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h4><p>好了，接下来的一步，就是真正切换模式的一步了，从代码上看就两行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,#0x0001  ; protected mode (PE) bit</span><br><span class="line">lmsw ax      ; This is it;</span><br><span class="line">jmpi 0,8     ; jmp offset 0 of segment 8 (cs)</span><br></pre></td></tr></table></figure><p>前两行，将 cr0 这个寄存器的位 0 置 1，模式就从实模式切换到保护模式了。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_32.png"></p><p>所以真正的模式切换十分简单，重要的是之前做的准备工作。</p><h4 id="跳转到System"><a href="#跳转到System" class="headerlink" title="跳转到System"></a>跳转到System</h4><p>再往后，又是一个段间跳转指令 jmpi，后面的 8 表示 cs（代码段寄存器）的值，0 表示偏移地址。</p><p>请注意，此时已经是保护模式了，之前也说过，保护模式下内存寻址方式变了，段寄存器里的值被当做段选择子。</p><p>回顾下段选择子的模样。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_33.png"></p><p>8 用二进制表示就是<code>00000,0000,0000,1000</code></p><p>对照上面段选择子的结构，可以知道<strong>描述符索引值是 1，也就是要去全局描述符表（gdt）中找第一项段描述符</strong>。</p><p>还记得全局描述符的具体内容吗？</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_28.png"></p><ul><li>第 0 项是空值，</li><li>第一项被表示为代码段描述符，是个可读可执行的段，</li><li>第二项为数据段描述符，是个可读可写段</li></ul><p>不过他们的段基址都是 0。</p><p>这里取的就是这个代码段描述符，段基址是 0，偏移也是 0，那加一块就还是 0 咯，所以最终这个跳转指令，就是跳转到内存地址的 0 地址处，开始执行。</p><p>零地址处是什么呢？还是回顾之前的内存布局图。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_30.png"></p><p>就是操作系统全部代码的 system 这个大模块，system 模块怎么生成的呢？</p><p>由 Makefile 文件可知，是由 head.s 和 main.c 以及其余各模块的操作系统代码合并来的，可以理解为操作系统的全部核心代码编译后的结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tools/system: boot/head.o init/main.o \</span><br><span class="line">    $(ARCHIVES) $(DRIVERS) $(MATH) $(LIBS)</span><br><span class="line">    $(LD) $(LDFLAGS) boot/head.o init/main.o \</span><br><span class="line">    $(ARCHIVES) \</span><br><span class="line">    $(DRIVERS) \</span><br><span class="line">    $(MATH) \</span><br><span class="line">    $(LIBS) \</span><br><span class="line">    -o tools/system &gt; System.map</span><br></pre></td></tr></table></figure><p>所以，接下来，我们就要重点阅读 head.s 了。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_36.png"></p><p>这也是 boot 文件夹下的最后一个由汇编写就的源代码文件，而且是汇编写的令人头疼的代码。</p><p>head.s 这个文件仅仅是为了顺利进入由后面的 c 语言写就的 main.c 做的准备，所以咬咬牙看完这个之后，我们就终于可以进入 c 语言的世界了！也终于可以看到我们熟悉的 main 函数了！</p><p>在那里，操作系统真正秀操作的地方，才刚刚开始！</p><h3 id="重新设置一遍-idt-和-gdt-给描述符表挪个地儿"><a href="#重新设置一遍-idt-和-gdt-给描述符表挪个地儿" class="headerlink" title="重新设置一遍 idt 和 gdt - 给描述符表挪个地儿"></a>重新设置一遍 idt 和 gdt - 给描述符表挪个地儿</h3><p>至此，CPU 进入了 32 位保护模式，并且跳转到了 system 模块。</p><p>那接下来，我们就品品，正式进入 c 语言写的 main.c 之前的 head.s 究竟写了点啥？</p><p>head.s 文件很短，我们一点点品。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_pg_dir:</span><br><span class="line">_startup_32:</span><br><span class="line">    mov eax,0x10</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov fs,ax</span><br><span class="line">    mov gs,ax</span><br><span class="line">    lss esp,_stack_start</span><br></pre></td></tr></table></figure><p>注意到开头有个标号 <strong>_pg_dir</strong>。先留个心眼，这个表示<strong>页目录</strong>，之后在设置<strong>分页机制</strong>时，页目录会存放在这里，也会覆盖这里的代码。</p><p>再往下连续五个 mov 操作，分别给 <strong>ds、es、fs、gs 这几个段寄存器赋值为 0x10</strong>，根据段描述符结构解析，表示<strong>这几个段寄存器的值为指向全局描述符表中的第二个段描述符（数据段描述符）</strong>。</p><p>最后 lss 指令相当于让 ss:esp 这个<strong>栈顶指针指向了 _stack_start 这个标号的位置</strong>。还记得图里的那个原来的栈顶指针在哪里吧？往上翻一下，<strong>0x9FF00，现在要变咯</strong>。</p><p>这个 stack_start 标号定义在了很久之后才会讲到的 sched.c 里，我们这里拿出来分析一波。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long user_stack[4096 &gt;&gt; 2];</span><br><span class="line"></span><br><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">  long *a;</span><br><span class="line">  short b;</span><br><span class="line">&#125;</span><br><span class="line">stack_start = &#123;&amp;user_stack[4096 &gt;&gt; 2], 0x10&#125;;</span><br></pre></td></tr></table></figure><p>这啥意思呢？</p><p>首先，stack_start 结构中的高位 8 字节是 0x10，将会赋值给 ss 栈段寄存器，低位 16 字节是 user_stack 这个数组的最后一个元素的地址值，将其赋值给 esp 寄存器。</p><p>赋值给 ss 的 0x10 仍然按照保护模式下的段选择子去解读，其指向的是全局描述符表中的第二个段描述符（数据段描述符），段基址是 0。</p><p>赋值给 esp 寄存器的就是 user_stack 数组的最后一个元素的内存地址值，那最终的栈顶地址，也指向了这里（user_stack + 0），后面的压栈操作，就是往这个新的栈顶地址处压咯。</p><p>继续往下看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">call setup_idt ;设置中断描述符表</span><br><span class="line">call setup_gdt ;设置全局描述符表</span><br><span class="line">mov eax,10h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">mov gs,ax</span><br><span class="line">lss esp,_stack_start</span><br></pre></td></tr></table></figure><p>先设置了 idt 和 gdt，然后又重新执行了一遍刚刚执行过的代码。</p><p>为什么要重新设置这些段寄存器呢？ 因为上面修改了 gdt，所以要重新设置一遍以刷新才能生效。</p><p>那我们接下来就把目光放到设置 idt 和 gdt 上。</p><h4 id="设置中断描述符表"><a href="#设置中断描述符表" class="headerlink" title="设置中断描述符表"></a>设置中断描述符表</h4><details><summary>中断描述符表 idt 我们之前没设置过，所以这里设置具体的值，理所应当</summary><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">setup_idt:</span><br><span class="line">    lea edx,ignore_int</span><br><span class="line">    mov eax,00080000h</span><br><span class="line">    mov ax,dx</span><br><span class="line">    mov dx,8E00h</span><br><span class="line">    lea edi,_idt</span><br><span class="line">    mov ecx,256</span><br><span class="line">rp_sidt:</span><br><span class="line">    mov [edi],eax</span><br><span class="line">    mov [edi+4],edx</span><br><span class="line">    add edi,8</span><br><span class="line">    dec ecx</span><br><span class="line">    jne rp_sidt</span><br><span class="line">    lidt fword ptr idt_descr</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">idt_descr:</span><br><span class="line">    dw 256*8-1</span><br><span class="line">    dd _idt</span><br><span class="line"></span><br><span class="line">_idt:</span><br><span class="line">    DQ 256 dup(0)</span><br></pre></td></tr></table></figure></details><p>中断描述符表 idt 里面存储着一个个中断描述符，每一个中断号就对应着一个中断描述符，而中断描述符里面存储着主要是中断程序的地址，这样一个中断号过来后，CPU 就会自动寻找相应的中断程序，然后去执行它。</p><p>那这段程序的作用就是:</p><ul><li><strong>设置了 256 个中断描述符</strong>，</li><li>并且让每一个中断描述符中的中断程序例程都指向一个 <strong>ignore_int</strong> 的函数地址<ul><li>这个是个<strong>默认的中断处理程序</strong>，之后会逐渐被各个具体的中断程序所覆盖。</li><li>比如之后键盘模块会将自己的键盘中断处理程序，覆盖过去。</li></ul></li></ul><p>那现在，产生任何中断都会指向这个默认的函数 ignore_int，也就是说<strong>现在这个阶段你按键盘还不好使</strong>。</p><h4 id="设置全局描述符表"><a href="#设置全局描述符表" class="headerlink" title="设置全局描述符表"></a>设置全局描述符表</h4><p>设置中断描述符表 setup_idt 说完了，那接下来 setup_gdt 就同理了。</p><p>我们就直接看设置好后的新的全局描述符表长什么样吧？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_gdt:</span><br><span class="line">    DQ 0000000000000000h    ;/* NULL descriptor */</span><br><span class="line">    DQ 00c09a0000000fffh    ;/* 16Mb */</span><br><span class="line">    DQ 00c0920000000fffh    ;/* 16Mb */</span><br><span class="line">    DQ 0000000000000000h    ;/* TEMPORARY - don&#x27;t use */</span><br><span class="line">    DQ 252 dup(0)</span><br></pre></td></tr></table></figure><p>其实和我们原先设置好的 gdt 一模一样。</p><p>也是有<strong>代码段描述符和数据段描述符</strong>，然后第四项系统段描述符并没有用到，不用管。</p><p>最后还留了 252 项的空间，这些空间后面会用来放置<strong>任务状态段描述符 TSS 和局部描述符 LDT</strong>，这个后面再说。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_37.png"></p><p>为什么原来已经设置过一遍了，这里又要重新设置一遍?</p><p>你可千万别想有什么复杂的原因，就是因为原来设置的 gdt 是在 setup 程序中，之后这个地方要被缓冲区覆盖掉，所以这里重新设置在 head 程序中，这块内存区域之后就不会被其他程序用到并且覆盖了，就这么个事。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_38.png"></p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>总体而言，header.s 目前就是完成了寄存器位置的一个指向转换，并且给所有中断设置了一个默认的中断处理程序 ignore_int，然后全局描述符表仍然只有代码段描述符和数据段描述符。</p><h3 id="Intel-内存管理两板斧-分段和分页"><a href="#Intel-内存管理两板斧-分段和分页" class="headerlink" title="Intel 内存管理两板斧-分段和分页"></a>Intel 内存管理两板斧-分段和分页</h3><p>header.s 代码在重新设置gdt和idt后， 来到了这样一段代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jmp after_page_tables</span><br><span class="line">...</span><br><span class="line">after_page_tables:</span><br><span class="line">    push 0</span><br><span class="line">    push 0</span><br><span class="line">    push 0</span><br><span class="line">    push L6</span><br><span class="line">    push _main</span><br><span class="line">    jmp setup_paging</span><br><span class="line">L6:</span><br><span class="line">    jmp L6</span><br></pre></td></tr></table></figure><p>那就是开启分页机制，并且跳转到 main 函数！</p><p>这可太令人兴奋了！开启分页后，配合着分段，就构成了内存管理的最最底层的机制。</p><p>而跳转到 main 函数，标志着我们正式进入 c 语言写的操作系统核心代码！如何跳转到之后用 c 语言写的 main.c 里的 main 函数，是个有趣的事，也包含在这段代码里。</p><p>不过我们先瞧瞧这<strong>分页机制</strong>是如何开启的，也就是 setup_paging 这个标签处的代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">setup_paging:</span><br><span class="line">    mov ecx,1024*5</span><br><span class="line">    xor eax,eax</span><br><span class="line">    xor edi,edi</span><br><span class="line">    pushf</span><br><span class="line">    cld</span><br><span class="line">    rep stosd</span><br><span class="line">    mov eax,_pg_dir</span><br><span class="line">    mov [eax],pg0+7</span><br><span class="line">    mov [eax+4],pg1+7</span><br><span class="line">    mov [eax+8],pg2+7</span><br><span class="line">    mov [eax+12],pg3+7</span><br><span class="line">    mov edi,pg3+4092</span><br><span class="line">    mov eax,00fff007h</span><br><span class="line">    std</span><br><span class="line">L3: stosd</span><br><span class="line">    sub eax,00001000h</span><br><span class="line">    jge L3</span><br><span class="line">    popf</span><br><span class="line">    xor eax,eax</span><br><span class="line">    mov cr3,eax</span><br><span class="line">    mov eax,cr0</span><br><span class="line">    or  eax,80000000h</span><br><span class="line">    mov cr0,eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h4 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h4><p>首先要了解的就是，啥是分页机制？</p><p>还记不记得之前我们在代码中给出一个内存地址，在保护模式下要先经过分段机制的转换，才能最终变成物理地址，就是这样。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_39.png"></p><p>这是在没有开启分页机制的时候，只需要经过这一步转换即可得到最终的物理地址了，但是在开启了分页机制后，又会<strong>多一步转换</strong>。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_40.png"></p><p>也就是说：</p><ul><li>在没有开启分页机制时，由程序员给出的逻辑地址，需要先通过分段机制转换成物理地址。</li><li>但在开启分页机制后，逻辑地址仍然要先通过分段机制进行转换，只不过转换后不再是最终的物理地址，而是线性地址，然后再通过一次分页机制转换，得到最终的物理地址。</li></ul><p>分段机制我们已经清楚如何对地址进行变换了，那分页机制又是如何变换的呢？我们直接以一个例子来学习过程。</p><p>比如我们的线性地址（已经经过了分段机制的转换）是 <code>15M</code>, 二进制表示就是 <code>0000000011_0100000000_000000000000</code></p><p>我们看一下它的转换过程</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_41.png"></p><p>也就是说，CPU 在看到我们给出的内存地址后，首先把线性地址被拆分成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">高 10 位：中间 10 位：后 12 位</span><br></pre></td></tr></table></figure><p>高 10 位负责在<strong>页目录表</strong>中找到一个<strong>页目录项</strong>，这个页目录项的值加上中间 10 位拼接后的地址去<strong>页表</strong>中去寻找一个<strong>页表项</strong>，这个页表项的值，再加上后 12 位偏移地址，就是最终的物理地址。</p><p>而这一切的操作，都由计算机的一个硬件叫 <strong>MMU</strong>，中文名字叫<strong>内存管理单元</strong>，有时也叫 PMMU，分页内存管理单元。由这个部件来负责将虚拟地址转换为物理地址。</p><p>所以整个过程我们不用操心，作为操作系统这个软件层，只需要提供好页目录表和页表即可，这种页表方案叫做<strong>二级页表</strong>，第一级叫<strong>页目录表 PDE</strong>，第二级叫<strong>页表 PTE</strong>。</p><p>他们的结构如下:</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_42.png"></p><p>之后再开启分页机制的开关。其实就是更改 cr0 寄存器中的一位即可（31 位），还记得我们开启保护模式么，也是改这个寄存器中的一位的值。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_43.png"></p><p>然后，MMU 就可以帮我们进行分页的转换了。此后指令中的内存地址（就是程序员提供的逻辑地址），就统统要先经过分段机制的转换，再通过分页机制的转换，才能最终变成物理地址。</p><p>所以这段代码，就是帮我们<strong>把页表和页目录表在内存中写好，之后开启 cr0 寄存器的分页开关</strong>，仅此而已，我们再把代码贴上来。</p><h4 id="分页内存结构"><a href="#分页内存结构" class="headerlink" title="分页内存结构"></a>分页内存结构</h4><p>我们先说这段代码最终产生的效果吧。</p><p>当时 linux-0.11 认为，总共可以使用的内存不会超过 <strong>16M</strong>，也即最大地址空间为 <strong>0xFFFFFF</strong>。</p><p>而按照当前的页目录表和页表这种机制:</p><ul><li>1 个页目录表最多包含 1024 个页目录项（也就是 1024 个页表），</li><li>1 个页表最多包含 1024 个页表项（也就是 1024 个页），</li><li>1 页为 4KB（因为有 12 位偏移地址）</li></ul><p>因此，16M 的地址空间可以用 1 个页目录表 + 4 个页表搞定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4（页表数）* 1024（页表项数） * 4KB（一页大小）= 16MB</span><br></pre></td></tr></table></figure><p>所以，上面这段代码就是，<strong>将页目录表放在内存地址的最开头</strong>，还记得上一讲开头让你留意的 _pg_dir 这个标签吧？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_pg_dir:</span><br><span class="line">_startup_32:</span><br><span class="line">    mov eax,0x10</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>之后紧挨着这个页目录表，放置 4 个页表</strong>，代码里也有这四个页表的标签项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.org 0x1000 pg0:</span><br><span class="line">.org 0x2000 pg1:</span><br><span class="line">.org 0x3000 pg2:</span><br><span class="line">.org 0x4000 pg3:</span><br><span class="line">.org 0x5000</span><br></pre></td></tr></table></figure><p>最终将页目录表和页表填写好数值，来覆盖整个 16MB 的内存。随后，开启分页机制。</p><p>此时内存中的页表相关的布局如下。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_44.png"></p><p>这些页目录表和页表放到了整个内存布局中最开头的位置，就是覆盖了开头的 system 代码了，不过被覆盖的 system 代码已经执行过了，所以无所谓。</p><p>同时，如 idt 和 gdt 一样，我们也需要通过一个寄存器告诉 CPU 我们把这些页表放在了哪里，就是这段代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xor eax,eax</span><br><span class="line">mov cr3,eax</span><br></pre></td></tr></table></figure><p>你看，我们相当于告诉 <strong>cr3 寄存器</strong>，<strong>0 地址处就是页目录表，再通过页目录表可以找到所有的页表</strong>，也就相当于 CPU 知道了分页机制的全貌了。</p><p>至此后，整个内存布局如下:</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_45.png"></p><h4 id="页表具体映射内存"><a href="#页表具体映射内存" class="headerlink" title="页表具体映射内存"></a>页表具体映射内存</h4><p>那么具体页表设置好后，映射的内存是怎样的情况呢？那就要看页表的具体数据了，就是这一坨代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setup_paging:</span><br><span class="line">    ...</span><br><span class="line">    mov eax,_pg_dir</span><br><span class="line">    mov [eax],pg0+7</span><br><span class="line">    mov [eax+4],pg1+7</span><br><span class="line">    mov [eax+8],pg2+7</span><br><span class="line">    mov [eax+12],pg3+7</span><br><span class="line">    mov edi,pg3+4092</span><br><span class="line">    mov eax,00fff007h</span><br><span class="line">    std</span><br><span class="line">L3: stosd</span><br><span class="line">    sub eax, 1000h</span><br><span class="line">    jpe L3</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>很简单，对照刚刚的页目录表与页表结构看。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_42.png"></p><p>前五行表示，页目录表的前 4 个页目录项，分别指向 4 个页表。比如页目录项中的第一项 [eax] 被赋值为 pg0+7，也就是 0x00001007，根据页目录项的格式，表示页表地址为 0x1000，页属性为 0x07 表示改页存在、用户可读写。</p><p>后面几行表示，填充 4 个页表的每一项，一共 4*1024=4096 项，依次映射到内存的前 16MB 空间。</p><p>画出图就是这个样子，其实刚刚的图就是:</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_46.png"></p><p>看，最终的效果就是，经过这套分页机制，<strong>线性地址将恰好和最终转换的物理地址一样</strong>。</p><p>现在只有四个页目录项，也就是将前 16M 的线性地址空间，与 16M 的物理地址空间一一对应起来了。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_47.png"></p><p>好了，我们终于把这些杂七杂八的idt、gdt、页表都设置好了，并且也开启了保护模式，之后我们就要做好进入 main.c 的准备了，那里是个新世界！</p><h4 id="拓展-名词梳理"><a href="#拓展-名词梳理" class="headerlink" title="拓展 - 名词梳理"></a>拓展 - 名词梳理</h4><p>关于地址，我们已经出现了好多词了，包括<strong>逻辑地址</strong>、<strong>线性地址</strong>、<strong>物理地址</strong>，以及本文中没出现的，你可能在很多地方看到过的<strong>虚拟地址</strong>。</p><p>而这些地址后面加上空间两个字，似乎又成为了一个新词，比如<strong>线性地址空间</strong>、<strong>物理地址空间</strong>、<strong>虚拟地址空间</strong>等。</p><p>那就是时候展开一波讨论，将这块的内容梳理一番了，且听我说。</p><p>Intel 体系结构的内存管理可以分成两大部分，也就是标题中的两板斧，<strong>分段和分页</strong>。</p><ul><li><p><strong>分段机制</strong>： 在之前已经讨论过多次了，其目的是为了为每个程序或任务提供单独的代码段（cs）、数据段（ds）、栈段（ss），使其不会相互干扰。</p></li><li><p><strong>分页机制</strong>： 开机后分页机制默认是关闭状态，需要我们手动开启，并且设置好页目录表（PDE）和页表（PTE）。</p><ul><li>其目的在于可以按需使用物理内存，同时也可以在多任务时起到隔离的作用，这个在后面将多任务时将会有所体会。</li></ul></li></ul><p>在 Intel 的保护模式下，分段机制是没有开启和关闭一说的，它必须存在，而分页机制是可以选择开启或关闭的。所以如果有人和你说，它实现了一个没有分段机制的操作系统，那一定是个外行。</p><p>再说说那些地址：</p><ul><li><p>逻辑地址：我们程序员写代码时给出的地址叫逻辑地址，其中包含段选择子和偏移地址两部分。</p></li><li><p>线性地址：通过分段机制，将逻辑地址转换后的地址，叫做线性地址。而这个线性地址是有个范围的，这个范围就叫做线性地址空间，32 位模式下，线性地址空间就是 4G。</p></li><li><p>物理地址：就是真正在内存中的地址，它也是有范围的，叫做物理地址空间。那这个范围的大小，就取决于你的内存有多大了。</p></li><li><p>虚拟地址：如果没有开启分页机制，那么线性地址就和物理地址是一一对应的，可以理解为相等。如果开启了分页机制，那么线性地址将被视为虚拟地址，这个虚拟地址将会通过分页机制的转换，最终转换成物理地址。</p></li></ul><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_48.png"></p><h3 id="进入-main-c-之前的最后一哆嗦"><a href="#进入-main-c-之前的最后一哆嗦" class="headerlink" title="进入 main.c 之前的最后一哆嗦"></a>进入 main.c 之前的最后一哆嗦</h3><p>回到上节中开启分页机制的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jmp after_page_tables</span><br><span class="line">...</span><br><span class="line">after_page_tables:</span><br><span class="line">    push 0</span><br><span class="line">    push 0</span><br><span class="line">    push 0</span><br><span class="line">    push L6</span><br><span class="line">    push _main</span><br><span class="line">    jmp setup_paging</span><br><span class="line">L6:</span><br><span class="line">    jmp L6</span><br></pre></td></tr></table></figure><p>这里有个 push _main，把 main 函数的地址压栈了，那最终跳转到这个 main.c 里的 main 函数，一定和这个压栈有关。</p><p>压栈为什么和跳转到这里还能联系上呢？</p><p>五个 push 指令过去后，栈会变成这个样子。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_49.png"></p><p>然后注意，setup_paging 最后一个指令是 ret，也就是设置分页的代码的最后一个指令，形象地说它叫<strong>返回指令</strong>，但 CPU 可没有那么聪明，它并不知道该返回到哪里执行，只是很<strong>机械地把栈顶的元素值当做返回地址</strong>，跳转去那里执行。</p><p>再具体说是，把 esp 寄存器（栈顶地址）所指向的内存处的值，赋值给 eip 寄存器，而 cs:eip 就是 CPU 要执行的下一条指令的地址。而此时栈顶刚好是 main.c 里写的 main 函数的内存地址，是我们刚刚特意压入栈的，所以 CPU 就理所应当跳过来了。</p><details><summary>当然 Intel CPU 是设计了 call 和 ret 这一配对儿的指令，意为调用函数和返回</summary><p>关于 ret 指令，其实 Intel CPU 是配合 call 设计的，有关 call 和 ret 指令，即调用和返回指令，可以参考 Intel 手册。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intel 1 Chapter 6.4 CALLING PROCEDURES USING CALL AND RET</span><br></pre></td></tr></table></figure><p>同时，可以看到系统还分为不改变段基址的 near call &amp; near ret, 以及改变段基址的 far call 和 far ret。</p><p>压栈和出栈的具体过程，上面文字写的清清楚楚，下面 Intel 手册还非常友好地放了张图。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_52.png"></p><p>可以看到，我们本文就是左边的那一套，把 main 函数地址值当做 Calling EIP 压入栈，仿佛是执行了 call 指令调用了一个函数一样，但实际上这是我们通过骚操作代码伪造的假象，骗了 CPU。</p><p>然后 ret 的时候就把栈顶的那个 Calling EIP 也就是 main 函数地址弹出栈，存入 EIP 寄存器，这样 CPU 就相当于“返回”到了 main 函数开始执行。</p></details><p>至于其他压入栈的 L6 是用作当 main 函数返回时的跳转地址，但由于在操作系统层面的设计上，main 是绝对不会返回的，所以也就没用了。而其他的三个压栈的 0，本意是作为 main 函数的参数，但实际上似乎也没有用到，所以也不必关心。</p><p>总之，经过这一个小小的骚操作，程序终于跳转到 main.c 这个由 c 语言写就的主函数 main 里了！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line">    drive_info = DRIVE_INFO;</span><br><span class="line">    memory_end = (1&lt;&lt;20) + (EXT_MEM_K&lt;&lt;10);</span><br><span class="line">    memory_end &amp;= 0xfffff000;</span><br><span class="line">    if (memory_end &gt; 16*1024*1024)</span><br><span class="line">        memory_end = 16*1024*1024;</span><br><span class="line">    if (memory_end &gt; 12*1024*1024) </span><br><span class="line">        buffer_memory_end = 4*1024*1024;</span><br><span class="line">    else if (memory_end &gt; 6*1024*1024)</span><br><span class="line">        buffer_memory_end = 2*1024*1024;</span><br><span class="line">    else</span><br><span class="line">        buffer_memory_end = 1*1024*1024;</span><br><span class="line">    main_memory_start = buffer_memory_end;</span><br><span class="line">    mem_init(main_memory_start,memory_end);</span><br><span class="line">    trap_init();</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    sched_init();</span><br><span class="line">    buffer_init(buffer_memory_end);</span><br><span class="line">    hd_init();</span><br><span class="line">    floppy_init();</span><br><span class="line">    sti();</span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    if (!fork()) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    for(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，这就是这个 main 函数的全部了。</p><p>而整个操作系统也会最终停留在最后一行死循环中，永不返回，直到关机。</p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>至此，系统正式完成了 main 函数的所有准备工作，并跳转到了 main 函数地址。</p><p>来看看系统都经历了什么？</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_50.png"></p><p>而经过这样的流程，内存被搞成了这个样子</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_51.png"></p><p>之后，main 方法就开始执行了，靠着我们辛辛苦苦建立起来的内存布局，向崭新的未来前进！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列转自&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzk0MjE3NDE0Ng==&amp;action=getalbum&amp;album_id=2123743679373688834&amp;scene=173&amp;from_</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统第一步之进入内核前的苦力活</title>
    <link href="http://example.com/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/"/>
    <id>http://example.com/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/</id>
    <published>2022-04-19T12:55:24.000Z</published>
    <updated>2022-05-19T07:29:08.867Z</updated>
    
    <content type="html"><![CDATA[<p>本系列转自<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzk0MjE3NDE0Ng==&amp;action=getalbum&amp;album_id=2123743679373688834&amp;scene=173&amp;from_msgid=2247499734&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect">操作系统源码系列</a></p><p>会以一个读小说的心态，从开机启动后的代码执行顺序，阅读和赏析 Linux 0.11 全部核心代码，了解操作系统的技术细节和设计思想。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_0.png" alt></p><h3 id="最开始的两行代码-加载启动区"><a href="#最开始的两行代码-加载启动区" class="headerlink" title="最开始的两行代码-加载启动区"></a>最开始的两行代码-加载启动区</h3><p>在<a href="#">Post not found: 操作系统/操作系统第一步之按下开机键</a> 一文中， 我们简单介绍了操作系统启动区加载的过程，回顾一下：</p><ul><li>按下开机键，CPU 将 PC 寄存器的值强制初始化为 0xffff0，这个位置是 BIOS 程序的入口地址（一跳）</li><li>该入口地址处是一个跳转指令，跳转到 0xfe05b 位置，开始执行（二跳）</li><li>执行了一些硬件检测工作后，最后一步将启动区内容加载到内存 0x7c00，并跳转到这里（三跳）</li><li>启动区代码主要是加载操作系统内核，并跳转到加载处（四跳）</li></ul><p>当你按下开机键的那一刻，在主板上提前写死的固件程序 BIOS 会将硬盘中启动区的 512 字节的数据，原封不动复制到内存中的 0x7c00 这个位置，并跳转到那个位置进行执行。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img.png" alt></p><p>启动区的定义非常简单，只要硬盘中的 0 盘 0 道 1 扇区的 512 个字节的最后两个字节分别是 0x55 和 0xaa，那么 BIOS 就会认为它是个启动区。</p><p>所以对于我们理解操作系统而言，此时的 BIOS 仅仅就是个代码搬运工，把 512 字节的二进制数据从硬盘搬运到了内存中而已。</p><p><strong>所以作为操作系统的开发人员，仅仅需要把操作系统最开始的那段代码，编译并存储在硬盘的 0 盘 0 道 1 扇区即可</strong>。</p><p>之后 BIOS 会帮我们把它放到内存里，并且跳过去执行。</p><p>而 Linux-0.11 的最开始的代码，就是这个用汇编语言写的 bootsect.s，位于 boot 文件夹下。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_1.png" alt></p><p>通过编译，这个 bootsect.s 会被编译成二进制文件，存放在启动区的第一扇区。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_2.png" alt></p><p>随后就会如刚刚所说，由 BIOS 搬运到内存的 0x7c00 这个位置，而 CPU 也会从这个位置开始，不断往后一条一条语句无脑地执行下去。</p><p>那我们的梦幻之旅，就从这个文件的第一行代码开始啦！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0x07c0</span><br><span class="line">mov ds,ax</span><br></pre></td></tr></table></figure><p>这段代码是用汇编语言写的，含义是<strong>把 0x07c0 这个值复制到 ax 寄存器里，再将 ax 寄存器里的值复制到 ds 寄存器</strong>里。</p><details><summary>立即数不能直接赋给段寄存器</summary>因为CPU的设计里面一次指令只能读写内存一次的流程设计。立即数直接赋值给段寄存器的话，相当于读一次内存，一次内存流程了，再写一次内存，二次内存流程了。</details><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_3.png" alt></p><p>那其实这一番折腾的结果就是:</p><details><summary>让 ds 这个寄存器里的值变成了 0x07c0</summary>ds 是一个 16 位的段寄存器，具体表示数据段寄存器，在内存寻址时充当段基址的作用。啥意思呢？就是当我们之后用汇编语言写一个内存地址时，实际上仅仅是写了偏移地址，比如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [0x0001]</span><br></pre></td></tr></table></figure>实际上相当于<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax, [ds:0x0001]</span><br></pre></td></tr></table></figure>ds 是默认加上的，表示在 ds 这个段基址处，往后再偏移 0x0001 单位，将这个位置的内存数据，复制到 ax 寄存器中。这个 ds 被赋值为了 0x07c0，由于 x86 为了让自己在 16 位这个实模式下能访问到 20 位的地址线这个历史因素（不了解这个的就先别纠结为啥了），所以段基址要先左移四位。那 0x07c0 左移四位就是 0x7c00，那这就刚好和这段代码被 BIOS 加载到的内存地址 0x7c00 一样了。</details><p>也就是说，之后再写的代码，里面访问的数据的内存地址，都先默认加上 0x7c00，再去内存中寻址。</p><p>为啥统一加上 0x7c00 这个数呢？这很好解释，BIOS 规定死了把操作系统代码加载到内存 0x7c00，那么里面的各种数据自然就全都被偏移了这么多，所以把数据段寄存器 ds<br>设置为这个值，方便了以后通过这种基址的方式访问内存里的数据。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_4.png" alt></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>BIOS 将操作系统代码（启动区）加载到内存 0x7c00，然后通过 mov 指令将默认的数据段寄存器（ds 寄存器）的值改为 0x07c0 方便以后的基址寻址方式。</p><h3 id="自己给自己挪个地儿-移动启动区代码段"><a href="#自己给自己挪个地儿-移动启动区代码段" class="headerlink" title="自己给自己挪个地儿-移动启动区代码段"></a>自己给自己挪个地儿-移动启动区代码段</h3><h4 id="寄存器赋值"><a href="#寄存器赋值" class="headerlink" title="寄存器赋值"></a>寄存器赋值</h4><p>接下来我们带着这两行代码，继续往下看几行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0x07c0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,0x9000</span><br><span class="line">mov es,ax</span><br><span class="line">mov cx,#256</span><br><span class="line">sub si,si</span><br><span class="line">sub di,di</span><br><span class="line">rep movw</span><br></pre></td></tr></table></figure><p>此时 ds 寄存器的值已经是 0x07c0 了，然后又通过同样的方式将 es 寄存器的值变成 0x9000，接着又把 cx 寄存器的值变成<br>256（代码里确实是用十进制表示的，与其他地方有些不一致，不过无所谓）。</p><figure class="highlight plaintext"><figcaption><span>si,si```表示```si</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">经过这些指令后，以下几个寄存器分别被附上了指定的值，我们梳理一下</span><br><span class="line"></span><br><span class="line">* 数据段寄存器： ds = 0x07c0</span><br><span class="line">* 附加段寄存器： es = 0x9000</span><br><span class="line">* 普通寄存器： cx = 256</span><br><span class="line">* 源变址： si = 0</span><br><span class="line">* 目的变址： di = 0</span><br><span class="line"></span><br><span class="line">![](./操作系统第一步之进入内核前的苦力活/img_5.png)</span><br><span class="line"></span><br><span class="line">#### 复制启动区</span><br><span class="line"></span><br><span class="line">干嘛要给这些毫不相干的寄存器附上值呢？其实就是为下一条指令服务的，就是</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rep movw<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中 **rep 表示重复执行后面的指令**。</span><br><span class="line"></span><br><span class="line">而后面的指令 **movw 表示复制一个字**（word 16位），那其实就是不断重复地复制一个字。</span><br><span class="line"></span><br><span class="line">那下面自然就有三连问：</span><br><span class="line"></span><br><span class="line">**重复执行多少次呢？** 是 cx 寄存器中的值，也就是 256 次。</span><br><span class="line"></span><br><span class="line">**从哪复制到哪呢？** 是从 ds:si 处复制到 es:di 处。</span><br><span class="line"></span><br><span class="line">**一次复制多少呢？** 刚刚说过了，复制一个字，16 位，也就是两个字节。</span><br><span class="line"></span><br><span class="line">上面是直译，那把这段话翻译成更人话的方式讲出来就是，**将内存地址 0x7c00 处开始往后的 512 字节的数据，原封不动复制到 0x90000 处**。</span><br><span class="line"></span><br><span class="line">![](./操作系统第一步之进入内核前的苦力活/img_6.png)</span><br><span class="line"></span><br><span class="line">没错，就是这么折腾了一下。现在，操作系统最开头的代码，已经被挪到了 **0x90000** 这个位置了。</span><br><span class="line"></span><br><span class="line">#### 跳转到新的地址</span><br><span class="line"></span><br><span class="line">再往后是一个**跳转**指令。</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">jmpi go,0x9000</span><br><span class="line">go: </span><br><span class="line">  mov ax,cs</span><br><span class="line">  mov ds,ax</span><br></pre></td></tr></table></figure></p><p><strong>jmpi 是一个段间跳转指令，表示跳转到 0x9000:go 处执行</strong>。</p><p>还记得上一讲说的 <strong>段基址 : 偏移地址</strong> 这种格式的内存地址要如何计算吧？段基址仍然要先左移四位，因此结论就是跳转到 <strong>0x90000 + go</strong> 这个内存地址处执行。</p><p>再说 go，go 就是一个<strong>标签</strong>，最终编译成机器码的时候会被翻译成一个值，这个值就是 go 这个<strong>标签在文件内的偏移地址</strong>。</p><p>这个偏移地址再加上 0x90000，就刚好是 go 标签后面那段代码 <code>mov ax,cs</code> 此时所在的内存地址了。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_7.png" alt></p><p>那假如 mov ax,cx 这行代码位于最终编译好后的二进制文件的 0x08 处，那 go 就等于 0x08，而最终 CPU 跳转到的地址就是 0x90008 处。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>到此为止，其实就是<strong>一段 512 字节的代码和数据，从硬盘的启动区先是被移动到了内存 0x7c00 处，然后又立刻被移动到 0x90000 处，并且跳转到此处往后再稍稍偏移 go<br>这个标签所代表的偏移地址处</strong>，也就是 mov ax,cs 这行指令的位置。</p><h3 id="做好最最基础的准备工作-内存规划"><a href="#做好最最基础的准备工作-内存规划" class="headerlink" title="做好最最基础的准备工作-内存规划"></a>做好最最基础的准备工作-内存规划</h3><h4 id="寄存器赋值-1"><a href="#寄存器赋值-1" class="headerlink" title="寄存器赋值"></a>寄存器赋值</h4><p>操作系统的代码最开头的 512 字节的数据，从硬盘的启动区先是被移动到了内存 0x7c00 处，然后又立刻被移动到 0x90000 处，并且跳转到此处往后再稍稍偏移 go 这个标签所代表的偏移地址处。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_8.png" alt></p><p>那我们接下来，就继续把我们的目光放在 go 这个标签的位置，跟着 CPU 的步伐往后看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go: mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,#0xFF00</span><br></pre></td></tr></table></figure><p>这段代码的直接意思很容易理解，就是</p><ul><li>cs 寄存器的值分别复制给 ds、es 和 ss 寄存器，</li><li>把 0xFF00 给了 sp 寄存器。</li></ul><details><summary>CPU寄存器图</summary>![](./操作系统第一步之进入内核前的苦力活/img_9.png)</details><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cs 寄存器表示代码段寄存器，CPU 当前正在执行的代码在内存中的位置，就是由 cs:ip 这组寄存器配合指向的，其中 cs 是基址，ip 是偏移地址。</span><br></pre></td></tr></table></figure><ul><li><p>之前执行过一个段间跳转指令<code>jmpi go,0x9000</code>, 所以现在<strong>cs寄存器里的值就是0x9000，ip 寄存器里的值是 go 这个标签的偏移地址</strong>。</p></li><li><p>ds 为数据段寄存器，之前我们说过了，当时它被复制为 0x07c0，是因为之前的代码在 0x7c00 处，现在代码已经被挪到了 0x90000 处，所以现在自然又改赋值为 0x9000 了。</p></li><li><p>es 是扩展段寄存器，仅仅是个扩展，不是主角，先不用理它。</p></li><li><p>ss 为<strong>栈段寄存器</strong>，后面要配合栈基址寄存器 sp 来表示此时的栈顶地址。而此时 sp 寄存器被赋值为了 0xFF00 了，所以<strong>目前的栈顶地址就是 ss:sp 所指向的地址<br>0x9FF00 处</strong>。<br><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/_posts/操作系统/操作系统第一步之进入内核前的苦力活/img_11.png" alt="实模式下的内存分布图"></p><ul><li>回顾一下实模式下的内存分布图，栈顶位置被赋值为了0x9FF00，几乎是基本内存距离代码段最远的位置，所以栈向下发展就很难撞见代码，也就比较安全。<br><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_10.png" alt></li><li>这也是为什么给栈顶地址设置为这个值的原因，其实只需要离代码的位置远远的即可。</li></ul></li></ul><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>其实到这里，操作系统的一些最最最最基础的准备工作，就做好了。都做了些啥事呢？</p><ol><li>代码从硬盘移到内存，又从内存挪了个地方，放在了 0x90000 处</li><li>数据段寄存器 ds 和代码段寄存器 cs 此时都被设置为了 0x9000，也就为跳转代码和访问内存数据，奠定了同一个内存的基址地址，方便了跳转和内存访问，因为仅仅需要指定偏移地址即可了。</li><li>栈顶地址被设置为了 0x9FF00，具体表现为栈段寄存器 ss 为 0x9000，栈基址寄存器 sp 为 0xFF00。栈是向下发展的，这个栈顶地址 0x9FF00 要远远大于此时代码所在的位置<br>0x90000，也就比较安全。</li></ol><p>拔高一下，这一部分其实就是把<strong>代码段寄存器 cs，数据段寄存器 ds，栈段寄存器 ss 和栈基址寄存器 sp</strong> 分别设置好了值，方便后续使用。</p><p>再拔高一下，其实操作系统在做的事情，就是给如何访问代码，如何访问数据，如何访问栈进行了一下<strong>内存的初步规划</strong>。其中访问代码和访问数据的规划方式就是设置了一个<strong>基址</strong>而已，访问栈就是把<strong><br>栈顶指针</strong>指向了一个远离代码位置的地方而已。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_12.png" alt></p><h4 id="扩展阅读-三种段寄存器的作用"><a href="#扩展阅读-三种段寄存器的作用" class="headerlink" title="扩展阅读-三种段寄存器的作用"></a>扩展阅读-三种段寄存器的作用</h4><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_13.png" alt></p><ul><li>CS 是代码段寄存器，就是执行代码的时候带着这里存的基地址。</li><li>DS 是数据段寄存器，就是访问数据的时候带着这里的基地址。</li><li>SS 是栈段寄存器，就是访问栈时带着这里的基地址。</li></ul><h3 id="把自己在硬盘里的其他部分也放到内存来"><a href="#把自己在硬盘里的其他部分也放到内存来" class="headerlink" title="把自己在硬盘里的其他部分也放到内存来"></a>把自己在硬盘里的其他部分也放到内存来</h3><p>至此，短短几句代码，操作系统已经完成了最最基础的准备工作，也即初步做了一次内存规划， 从 CPU 的角度看，访问内存其实也就是三块地方而已</p><ul><li>数据段</li><li>代码段</li><li>栈</li></ul><p>内存规划中：</p><ul><li>将数据段寄存器 ds 和代码段寄存器 cs 设置为了 0x9000，方便代码的跳转与数据的访问。</li><li>将栈顶地址 ss:sp 设置在了离代码的位置 0x90000 足够遥远的 0x9FF00，保证栈向下发展不会轻易撞见代码的位置。</li></ul><h4 id="读取操作系统的全部代码"><a href="#读取操作系统的全部代码" class="headerlink" title="读取操作系统的全部代码"></a>读取操作系统的全部代码</h4><p>做好这些基础工作后，接下来就又该新的一翻折腾了，我们接着往下看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">load_setup:</span><br><span class="line">mov dx,#0x0000      ; drive 0, head 0</span><br><span class="line">mov cx,#0x0002      ; sector 2, track 0</span><br><span class="line">mov bx,#0x0200      ; address = 512, in 0x9000</span><br><span class="line">mov ax,#0x0200+4    ; service 2, nr of sectors</span><br><span class="line">int 0x13            ; read it</span><br><span class="line">jnc ok_load_setup       ; ok - continue</span><br><span class="line">mov dx,#0x0000</span><br><span class="line">mov ax,#0x0000      ; reset the diskette</span><br><span class="line">int 0x13</span><br><span class="line">jmp load_setup</span><br><span class="line"></span><br><span class="line">ok_load_setup:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里有两个 int<br>指令我们还没见过，<a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247498208&amp;idx=1&amp;sn=b784f8b4e627ebd1bfb9810d194fdb80&amp;chksm=c2c5834df5b20a5bdee331002bfc61c90eb468da325bf67abeef780c303a9f51c8543e1a5981&amp;scene=21#wechat_redirect">这个 int 是汇编指令，可不是高级语言的整型变量哟</a></p><p>int 0x13 表示<strong>发起 0x13 号中断</strong>，这条指令上面给 dx、cx、bx、ax 赋值都是作为这个中断程序的参数。</p><p>这个中断发起后，CPU 会<strong>通过这个中断号，去寻找对应的中断处理程序的入口地址，并跳转过去执行</strong>，逻辑上就相当于执行了一个函数。</p><p>而 0x13 号中断的处理程序是 BIOS 提前给我们写好的，是<strong>读取磁盘</strong>的相关功能的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之后真正进入操作系统内核后，中断处理程序是需要我们自己去重新写的</span><br></pre></td></tr></table></figure><p>本段代码的注释已经写的很明确了，直接说最终的作用吧，就是<strong>将硬盘的第 2 个扇区开始，把数据加载到内存 0x90200 处，共加载 4 个扇区</strong>，图示其实就是这样。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_14.png" alt></p><p>如果复制成功，就跳转到 ok_load_setup 这个标签，如果失败，则会不断重复执行这段代码，也就是重试。</p><p>直接看成功后跳转的 ok_load_setup 这个标签后的代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ok_load_setup:</span><br><span class="line">    ...</span><br><span class="line">    mov ax,#0x1000</span><br><span class="line">    mov es,ax       ; segment of 0x10000</span><br><span class="line">    call read_it</span><br><span class="line">    ...</span><br><span class="line">    jmpi 0,0x9020</span><br></pre></td></tr></table></figure><p>这段代码省略了很多非主逻辑的代码，比如在屏幕上输出 Loading system … 这个字符串等。</p><p>剩下的主要代码就都写在这里了，就这么几行，其作用是<strong>把从硬盘第 6 个扇区开始往后的 240 个扇区，加载到内存 0x10000 处</strong>，和之前的从硬盘捣腾到内存是一个道理。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_15.png" alt></p><p>至此，整个操作系统的<strong>全部代码</strong>，就已经全部从硬盘中，被搬迁到内存来了。</p><p>然后又通过一个熟悉的段间跳转指令 jmpi 0,0x9020，跳转到 <strong>0x90200</strong> 处，就是硬盘第二个扇区开始处的内容。</p><h4 id="整个操作系统的编译过程"><a href="#整个操作系统的编译过程" class="headerlink" title="整个操作系统的编译过程"></a>整个操作系统的编译过程</h4><p>在分析硬盘第二个分区前，我们先简单看下炒作系统整个编译过程，就是通过 Makefile 和 build.c 配合完成的，最终会：</p><ol><li>把 bootsect.s 编译成 bootsect 放在硬盘的 1 扇区。</li><li>把 setup.s 编译成 setup 放在硬盘的 2~5 扇区。</li><li>把剩下的全部代码（head.s 作为开头）编译成 system 放在硬盘的随后 240 个扇区。</li></ol><p>所以整个路径就是这样的：</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_16.png" alt></p><p>所以，我们即将跳转到的内存中的 0x90200 处的代码，就是从硬盘第二个扇区开始处加载到内存的。</p><p>第二个扇区的最开始处，那也就是 setup.s 文件的第一行代码咯。</p><p>在<strong>操作系统刚刚开始建立的时候，那是完全自己安排前前后后的关系</strong><br>，一个字节都不能偏，就是这么强耦合，需要小心翼翼，需要大脑时刻保持清醒，规划好自己写的代码被编译并存储在硬盘的哪个位置，而随后又会被加载到内存的哪个位置，不能错乱。</p><h3 id="Setup加载-进入保护模式前的内存重规划"><a href="#Setup加载-进入保护模式前的内存重规划" class="headerlink" title="Setup加载-进入保护模式前的内存重规划"></a>Setup加载-进入保护模式前的内存重规划</h3><p>至此，操作系统已经完成了各种从硬盘到内存的加载，以及内存到内存的复制， 整个 bootsect.s 的使命就完成了，也是我们品读完的第一个操作系统源码文件。</p><h4 id="内存、硬盘、显卡等临时数据覆盖bootsect内容"><a href="#内存、硬盘、显卡等临时数据覆盖bootsect内容" class="headerlink" title="内存、硬盘、显卡等临时数据覆盖bootsect内容"></a>内存、硬盘、显卡等临时数据覆盖bootsect内容</h4><p>之后便跳转到了 0x90200 这个位置开始执行，这个位置处的代码就是位于 setup.s 的开头，我们接着来看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">start:</span><br><span class="line">    mov ax,#0x9000  ; this is done in bootsect already, but...</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ah,#0x03    ; read cursor pos</span><br><span class="line">    xor bh,bh</span><br><span class="line">    int 0x10        ; save it in known place, con_init fetches</span><br><span class="line">    mov [0],dx      ; it from 0x90000.</span><br></pre></td></tr></table></figure><p>又有个 int 0x10 指令, 它也是触发 BIOS 提供的<strong>显示服务中断</strong>处理程序，而 <strong>ah</strong> 寄存器被赋值为 0x03 表示显示服务里具体的<strong>读取光标位置功能</strong></p><p>这个 int 0x10 中断程序执行完毕并返回时，<strong>dx 寄存器里的值表示光标的位置</strong>，具体说来其高八位 dh 存储了行号，低八位 dl 存储了列号。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_17.png" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机在加电自检后会自动初始化到文字模式，在这种模式下，一屏幕可以显示 25 行，每行 80 个字符，也就是 80 列。</span><br></pre></td></tr></table></figure><p>那下一步 mov [0],dx 就是把这个光标位置存储在 [0] 这个内存地址处。</p><p>注意，前面我们说过，这个内存地址仅仅是偏移地址，还需要加上 ds 这个寄存器里存储的段基址，最终的内存地址是在 0x90000 处，这里存放着光标的位置，以便之后在初始化控制台的时候用到。</p><p>所以从这里也可以看出，这和我们平时调用一个方法没什么区别，只不过这里的寄存器的用法相当于入参和返回值，这里的 0x10 中断号相当于方法名。</p><details><summary>再接下来的几行代码，也是调用一个 BIOS 中断获取点什么信息，然后存储在内存中某个位置</summary><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">比如获取内存信息。</span><br><span class="line">; Get memory size (extended mem, kB)</span><br><span class="line">    mov ah,#0x88</span><br><span class="line">    int 0x15</span><br><span class="line">    mov [2],ax</span><br><span class="line">获取显卡显示模式。</span><br><span class="line">; Get video-card data:</span><br><span class="line">    mov ah,#0x0f</span><br><span class="line">    int 0x10</span><br><span class="line">    mov [4],bx      ; bh = display page</span><br><span class="line">    mov [6],ax      ; al = video mode, ah = window width</span><br><span class="line">检查显示方式并取参数</span><br><span class="line">; check for EGA/VGA and some config parameters</span><br><span class="line">    mov ah,#0x12</span><br><span class="line">    mov bl,#0x10</span><br><span class="line">    int 0x10</span><br><span class="line">    mov [8],ax</span><br><span class="line">    mov [10],bx</span><br><span class="line">    mov [12],cx</span><br><span class="line">获取第一块硬盘的信息。</span><br><span class="line">; Get hd0 data</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    mov ds,ax</span><br><span class="line">    lds si,[4*0x41]</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,#0x0080</span><br><span class="line">    mov cx,#0x10</span><br><span class="line">    rep</span><br><span class="line">    movsb</span><br><span class="line">获取第二块硬盘的信息。</span><br><span class="line">; Get hd1 data</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    mov ds,ax</span><br><span class="line">    lds si,[4*0x46]</span><br><span class="line">    mov ax,#INITSEG</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,#0x0090</span><br><span class="line">    mov cx,#0x10</span><br><span class="line">    rep</span><br><span class="line">    movsb</span><br></pre></td></tr></table></figure></details><p>我们就没必要细琢磨了，对操作系统的理解作用不大，只需要知道最终存储在内存中的信息是什么，在什么位置，就好了，之后会用到他们的</p><div class="table-container"><table><thead><tr><th>内存地址</th><th>长度(字节)</th><th>名称</th></tr></thead><tbody><tr><td>0x90000</td><td>2</td><td>光标位置</td></tr><tr><td>0x90002</td><td>2</td><td>扩展内存数</td></tr><tr><td>0x90004</td><td>2</td><td>显示页面</td></tr><tr><td>0x90006</td><td>1</td><td>显示模式</td></tr><tr><td>0x90007</td><td>1</td><td>字符列数</td></tr><tr><td>0x90008</td><td>2</td><td>未知</td></tr><tr><td>0x9000A</td><td>1</td><td>显示内存</td></tr><tr><td>0x9000B</td><td>1</td><td>显示状态</td></tr><tr><td>0x9000C</td><td>2</td><td>显卡特性参数</td></tr><tr><td>0x9000E</td><td>1</td><td>屏幕行数</td></tr><tr><td>0x9000F</td><td>1</td><td>屏幕列数</td></tr><tr><td>0x90080</td><td>16</td><td>硬盘1参数表</td></tr><tr><td>0x90090</td><td>16</td><td>硬盘2参数表</td></tr><tr><td>0x901FC</td><td>2</td><td>根设备号</td></tr></tbody></table></div><p>由于之后很快就会用 c 语言进行编程，虽然汇编和 c 语言也可以用变量的形式进行传递数据，但这需要编译器在链接时做一些额外的工作，所以这么多数据更方便的还是<strong>双方共同约定一个内存地址</strong><br>，我往这里存，你从这里取，就完事了。这恐怕是最最原始和直观的变量传递的方式了。</p><h4 id="关闭中断"><a href="#关闭中断" class="headerlink" title="关闭中断"></a>关闭中断</h4><p>把这些信息存储好之后，操作系统又要做什么呢？我们继续往下看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli         ; no interrupts allowed ;</span><br></pre></td></tr></table></figure><p>就一行 cli，表示关闭中断的意思。</p><p>因为后面我们要把原本是 BIOS 写好的中断向量表给覆盖掉，也就是给破坏掉了，写上我们自己的中断向量表，所以这个时候是不允许中断进来的。</p><h4 id="System模块移动"><a href="#System模块移动" class="headerlink" title="System模块移动"></a>System模块移动</h4><p>继续看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">; first we move the system to it&#x27;s rightful place</span><br><span class="line">    mov ax,#0x0000</span><br><span class="line">    cld         ; &#x27;direction&#x27;=0, movs moves forward</span><br><span class="line">do_move:</span><br><span class="line">    mov es,ax       ; destination segment</span><br><span class="line">    add ax,#0x1000</span><br><span class="line">    cmp ax,#0x9000</span><br><span class="line">    jz  end_move</span><br><span class="line">    mov ds,ax       ; source segment</span><br><span class="line">    sub di,di</span><br><span class="line">    sub si,si</span><br><span class="line">    mov cx,#0x8000</span><br><span class="line">    rep movsw</span><br><span class="line">    jmp do_move</span><br><span class="line">; then we load the segment descriptors</span><br><span class="line">end_move:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>看到后面那个 rep movsw 熟不熟悉, 同前面的原理一样，也是做了个内存复制操作，最终的结果是，把内存地址 0x10000 处开始往后一直到 0x90000 的内容，统统复制到内存的最开始的 0<br>位置，大概就是这么个效果。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_18.png" alt></p><h4 id="Setup加载总结-新的内存布局"><a href="#Setup加载总结-新的内存布局" class="headerlink" title="Setup加载总结-新的内存布局"></a>Setup加载总结-新的内存布局</h4><p>由于之前的各种加载和复制，导致内存看起来很乱，是时候进行一波取舍和整理了，我们重新梳理一下此时的内存布局。</p><ul><li>栈顶地址仍然是 0x9FF00 没有改变。</li><li>0x90000 开始往上的位置，原来是 bootsect 和 setup 程序的代码，现 bootsect 的一部分代码在已经被操作系统为了记录内存、硬盘、显卡等一些临时存放的数据给覆盖了一部分。</li><li>内存最开始的 <strong>0 到 0x80000 这 512K 被 system 模块给占用</strong>了，之前讲过，这个 system 模块就是除了 bootsect 和 setup<br>之外的全部程序链接在一起的结果，可以理解为<strong>操作系统的全部</strong>。</li></ul><p>那么现在的内存布局就是这个样子。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_19.png" alt></p><p>好了，记住上面的图就好了，这回是不是又重新清晰起来了？<strong>之前的什么 0x7c00，已经是过去式了</strong>，赶紧忘掉它，向前看！</p><p>接下来，就要进行有点技术含量的工作了，那就是<strong>模式的转换</strong>，需要<strong>从现在的 16 位的实模式转变为之后 32 位的保护模式</strong>，这是一项大工程！</p><h3 id="先解决段寄存器的历史包袱问题-进入保护模式前的新寻址方式准备"><a href="#先解决段寄存器的历史包袱问题-进入保护模式前的新寻址方式准备" class="headerlink" title="先解决段寄存器的历史包袱问题-进入保护模式前的新寻址方式准备"></a>先解决段寄存器的历史包袱问题-进入保护模式前的新寻址方式准备</h3><h4 id="当前内存地址回顾"><a href="#当前内存地址回顾" class="headerlink" title="当前内存地址回顾"></a>当前内存地址回顾</h4><p>经过Setup模块执行，操作系统内存被重新划分，并且之后的很长一段时间内存布局相对稳定，目前它长这样：</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_20.png" alt></p><p>0 地址开始处存放着操作系统的全部代码吗，也就是 system 模块，0x90000 位置处往后的几十个字节存放着一些设备的信息，方便以后使用。</p><div class="table-container"><table><thead><tr><th>内存地址</th><th>长度(字节)</th><th>名称</th></tr></thead><tbody><tr><td>0x90000</td><td>2</td><td>光标位置</td></tr><tr><td>0x90002</td><td>2</td><td>扩展内存数</td></tr><tr><td>0x90004</td><td>2</td><td>显示页面</td></tr><tr><td>0x90006</td><td>1</td><td>显示模式</td></tr><tr><td>0x90007</td><td>1</td><td>字符列数</td></tr><tr><td>0x90008</td><td>2</td><td>未知</td></tr><tr><td>0x9000A</td><td>1</td><td>显示内存</td></tr><tr><td>0x9000B</td><td>1</td><td>显示状态</td></tr><tr><td>0x9000C</td><td>2</td><td>显卡特性参数</td></tr><tr><td>0x9000E</td><td>1</td><td>屏幕行数</td></tr><tr><td>0x9000F</td><td>1</td><td>屏幕列数</td></tr><tr><td>0x90080</td><td>16</td><td>硬盘1参数表</td></tr><tr><td>0x90090</td><td>16</td><td>硬盘2参数表</td></tr><tr><td>0x901FC</td><td>2</td><td>根设备号</td></tr></tbody></table></div><p>是不是十分清晰？不过别高兴得太早，清爽的内存布局，是方便后续操作系统的大显身手！</p><p>接下来就要进行真正的第一项大工程了，那就是模式的转换，需要从现在的 16 位的实模式转变为之后 32 位的保护模式。</p><h4 id="保护模式下的物理地址"><a href="#保护模式下的物理地址" class="headerlink" title="保护模式下的物理地址"></a>保护模式下的物理地址</h4><p>每次讲这里都十分的麻烦，因为这是 <strong>x86 的历史包袱</strong>问题，现在的 CPU 几乎都是支持 32 位模式甚至 64 位模式了，很少有还仅仅停留在 16 位的实模式下的 CPU。</p><p>所以我们要<strong>为了这个历史包袱，写一段模式转换的代码</strong>，如果 Intel CPU 被重新设计而不用考虑兼容性，那么今天的代码将会减少很多甚至不复存在。</p><p>关于实模式和保护模式的区别，可以参考文档<a href="https://zhuanlan.zhihu.com/p/352843177">实模式和保护模式区别及寻址方式</a></p><p>继续看 setup.s 文件中的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lidt  idt_48      ; load idt with 0,0</span><br><span class="line">lgdt  gdt_48      ; load gdt with whatever appropriate</span><br><span class="line"></span><br><span class="line">idt_48:</span><br><span class="line">    .word   0     ; idt limit=0</span><br><span class="line">    .word   0,0   ; idt base=0L</span><br></pre></td></tr></table></figure><p>上来就是两行看不懂的指令，要理解这两条指令，就涉及到实模式和保护模式的第一个区别了。</p><p>目前，我们还处于实模式下，这个模式的CPU计算物理地址的方式为： <strong>段基址左移四位，再加上偏移地址</strong>。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_21.png" alt></p><p>当 CPU 切换到保护模式后，同样的代码，内存地址的计算方式还<strong>不一样</strong>。</p><p>刚刚那个 ds 寄存器里存储的值，在实模式下叫做<strong>段基址</strong>，在保护模式下叫<strong>段选择子</strong>。</p><p><strong>段选择子里存储着段描述符的索引</strong>。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_22.png" alt></p><p>通过段描述符索引，可以从 <strong>全局描述符表 gdt</strong> 中找到一个段描述符，段描述符里存储着段基址。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_23.png" alt></p><p>段基址取出来，再和偏移地址相加，就得到了物理地址，整个过程如下。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_24.png" alt></p><p>总结一下就是： <strong>段寄存器（比如 ds、ss、cs）里存储的是段选择子，段选择子去全局描述符表中寻找段描述符，从中取出段基址</strong>。</p><h4 id="全局描述符gdt-amp-gdtr-寄存器"><a href="#全局描述符gdt-amp-gdtr-寄存器" class="headerlink" title="全局描述符gdt &amp; gdtr 寄存器"></a>全局描述符gdt &amp; gdtr 寄存器</h4><p>那问题自然就出来了，全局描述符表（gdt）长什么样？它在哪？怎么让 CPU 知道它在哪？</p><p>先说说它在哪？ 在内存中呗。</p><p>那么怎么告诉 CPU 全局描述符表（gdt）在内存中的什么位置呢？</p><p>答案是由操作系统把这个位置信息存储在一个叫 gdtr 的寄存器中。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_25.png" alt></p><p>怎么存呢？就是刚刚那条指令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lgdt    gdt_48</span><br></pre></td></tr></table></figure><p>其中 <strong>lgdt</strong> 就表示把<strong>后面的值（gdt_48）放在 gdtr 寄存器</strong>中，gdt_48 标签，我们看看它长什么样。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdt_48:</span><br><span class="line">    .word   0x800       ; gdt limit=2048, 256 GDT entries</span><br><span class="line">    .word   512+gdt,0x9 ; gdt base = 0X9xxxx</span><br></pre></td></tr></table></figure><p>可以看到这个标签位置处表示一个 48 位的数据，其中高 32 位存储着的正是全局描述符表 gdt 的内存地址</p><p><strong>0x90200 + gdt</strong></p><p>gdt 是个标签，表示在本文件内的偏移量，而本文件是 setup.s，编译后是放在 0x90200 这个内存地址的，还记得吧？所以要加上 0x90200 这个值。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_26.png" alt></p><p>那 gdt 这个标签处，就是全局描述符表在内存中的真正数据了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gdt:</span><br><span class="line">    .word   0,0,0,0     ; dummy</span><br><span class="line"></span><br><span class="line">    .word   0x07FF      ; 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">    .word   0x0000      ; base address=0</span><br><span class="line">    .word   0x9A00      ; code read/exec</span><br><span class="line">    .word   0x00C0      ; granularity=4096, 386</span><br><span class="line"></span><br><span class="line">    .word   0x07FF      ; 8Mb - limit=2047 (2048*4096=8Mb)</span><br><span class="line">    .word   0x0000      ; base address=0</span><br><span class="line">    .word   0x9200      ; data read/write</span><br><span class="line">    .word   0x00C0      ; granularity=4096, 386</span><br></pre></td></tr></table></figure><p>具体细节不用关心，跟我看重点。</p><p>根据刚刚的段描述符格式。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_27.png" alt></p><p>可以看出目前全局描述符表有三个段描述符，第一个为空，第二个是代码段描述符（type=code），第三个是数据段描述符（type=data）。</p><p>第二个和第三个段描述符的段基址都是 0，也就是之后在逻辑地址转换物理地址的时候，通过段选择子查找到无论是代码段还是数据段，取出的段基址都是<br>0，那么物理地址将直接等于程序员给出的逻辑地址（准确说是逻辑地址中的偏移地址）。先记住这点就好。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_28.png" alt></p><p>具体段描述符的细节还有很多，就不展开了，比如这里的高 22 位就表示它是代码段还是数据段。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_29.png" alt></p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>整体而言，操作系统设置了个全局描述符表 gdt，为后面切换到保护模式后，能去那里寻找到段描述符，然后拼凑成最终的物理地址，就这个作用。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_31.png" alt></p><p>我们看看目前的内存布局:</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_30.png" alt></p><p>这里我把 idtr 寄存器也画出来了，这个是中断描述符表，其原理和全局描述符表一样。</p><ul><li>全局描述符表是让段选择子去里面寻找段描述符用的，</li><li>而中断描述符表是用来在发生中断时，CPU 拿着中断号去中断描述符表中寻找中断处理程序的地址，找到后就跳到相应的中断程序中去执行，具体我们后面遇到了再说。</li></ul><p>当然，还有很多段描述符，作用不仅仅是转换成最终的物理地址，不过这是后话了。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>段描述符结构和详细说明如下(Intel 手册)</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_34.png" alt></p><p>保护模式下逻辑地址到线性地址（不开启分页时就是物理地址）的转化</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_35.png" alt></p><h3 id="六行代码进入保护模式"><a href="#六行代码进入保护模式" class="headerlink" title="六行代码进入保护模式"></a>六行代码进入保护模式</h3><p>自此，我们解决了向前兼容(X86)实模式寻址的历史包袱问题, 但这知识进入保护模式前准备工作中的其中一个。</p><h4 id="打开A20地址线"><a href="#打开A20地址线" class="headerlink" title="打开A20地址线"></a>打开A20地址线</h4><p>我们接着往下看，代码仍然是 setup.s 中的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,#0xD1        ; command write</span><br><span class="line">out #0x64,al</span><br><span class="line">mov al,#0xDF        ; A20 on</span><br><span class="line">out #0x60,al</span><br></pre></td></tr></table></figure><p>这段代码的意思是，<strong>打开 A20 地址线</strong>。</p><details><summary>到底什么是 A20 地址线呢</summary>简单理解，这一步就是为了突破地址信号线 20 位的宽度，变成 32 位可用。这是由于 8086 CPU 只有 20 位的地址线，所以如果程序给出 21位的内存地址数据，那多出的一位就被忽略了，比如如果经过计算得出一个内存地址为<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 0000 00000000 00000000</span><br></pre></td></tr></table></figure>那实际上内存地址相当于 0，因为高位的那个 1 被忽略了，地方不够。当 CPU 到了 32 位时代之后，由于要考虑**兼容性**，还必须保持一个只能用 20 位地址线的模式，所以如果你不手动开启的话，即使地址线已经有 32 位了，仍然会限制只能使用其中的 20 位。具体可参考文档[A20 地址线问题全面解析](http://www.techbulo.com/703.html)</details><h4 id="中断重定义"><a href="#中断重定义" class="headerlink" title="中断重定义"></a>中断重定义</h4><p>接下来的一段代码，你完全完全不用看，但为了防止你一直记挂在心上，我给你截出来说道说道，这样以后我说完全不用看的代码时，你就真的可以放宽心完全不看了。</p><details><summary>就是这一大坨，还有 Linus 自己的注释</summary><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">; well, that went ok, I hope. Now we have to reprogram the interrupts :-(</span><br><span class="line">; we put them right after the intel-reserved hardware interrupts, at</span><br><span class="line">; int 0x20-0x2F. There they won&#x27;t mess up anything. Sadly IBM really</span><br><span class="line">; messed this up with the original PC, and they haven&#x27;t been able to</span><br><span class="line">; rectify it afterwards. Thus the bios puts interrupts at 0x08-0x0f,</span><br><span class="line">; which is used for the internal hardware interrupts as well. We just</span><br><span class="line">; have to reprogram the 8259&#x27;s, and it isn&#x27;t fun.</span><br><span class="line"></span><br><span class="line">    mov al,#0x11        ; initialization sequence</span><br><span class="line">    out #0x20,al        ; send it to 8259A-1</span><br><span class="line">    .word   0x00eb,0x00eb       ; jmp $+2, jmp $+2</span><br><span class="line">    out #0xA0,al        ; and to 8259A-2</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x20        ; start of hardware int&#x27;s (0x20)</span><br><span class="line">    out #0x21,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x28        ; start of hardware int&#x27;s 2 (0x28)</span><br><span class="line">    out #0xA1,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x04        ; 8259-1 is master</span><br><span class="line">    out #0x21,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x02        ; 8259-2 is slave</span><br><span class="line">    out #0xA1,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0x01        ; 8086 mode for both</span><br><span class="line">    out #0x21,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    out #0xA1,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    mov al,#0xFF        ; mask off all interrupts for now</span><br><span class="line">    out #0x21,al</span><br><span class="line">    .word   0x00eb,0x00eb</span><br><span class="line">    out #0xA1,al</span><br></pre></td></tr></table></figure></details><p>这里是对<strong>可编程中断控制器 8259 芯片</strong>进行的编程。</p><p>因为中断号是不能冲突的， Intel 把 0 到 0x19 号中断都作为<strong>保留中断</strong>，比如 0 号中断就规定为<strong>除零异常</strong>，软件自定义的中断都应该放在这之后，但是 IBM 在原 PC<br>机中搞砸了，跟保留中断号发生了冲突，以后也没有纠正过来，所以我们得重新对其进行编程，不得不做，却又一点意思也没有。</p><p>所以我们也不必在意，只要知道重新编程之后，8259 这个芯片的引脚与中断号的对应关系，变成了如下的样子就好。</p><div class="table-container"><table><thead><tr><th>PIC请求号</th><th>中断号</th><th>用途</th></tr></thead><tbody><tr><td>IRQ0</td><td>0x20</td><td>时钟中断</td></tr><tr><td>IRQ1</td><td>0x21</td><td>键盘中断</td></tr><tr><td>IRQ2</td><td>0x22</td><td>接连从芯片</td></tr><tr><td>IRQ3</td><td>0x23</td><td>串口2</td></tr><tr><td>IRQ4</td><td>0x24</td><td>串口1</td></tr><tr><td>IRQ5</td><td>0x25</td><td>并口2</td></tr><tr><td>IRQ6</td><td>0x26</td><td>软盘驱动器</td></tr><tr><td>IRQ7</td><td>0x27</td><td>并口1</td></tr><tr><td>IRQ8</td><td>0x28</td><td>实时钟中断</td></tr><tr><td>IRQ9</td><td>0x29</td><td>保留</td></tr><tr><td>IRQ10</td><td>0x2a</td><td>保留</td></tr><tr><td>IRQ11</td><td>0x2b</td><td>保留</td></tr><tr><td>IRQ12</td><td>0x2c</td><td>鼠标中断</td></tr><tr><td>IRQ13</td><td>0x2d</td><td>数学协处理器</td></tr><tr><td>IRQ14</td><td>0x2e</td><td>硬盘中断</td></tr><tr><td>IRQ15</td><td>0x2f</td><td>保留</td></tr></tbody></table></div><h4 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h4><p>好了，接下来的一步，就是真正切换模式的一步了，从代码上看就两行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,#0x0001  ; protected mode (PE) bit</span><br><span class="line">lmsw ax      ; This is it;</span><br><span class="line">jmpi 0,8     ; jmp offset 0 of segment 8 (cs)</span><br></pre></td></tr></table></figure><p>前两行，将 cr0 这个寄存器的位 0 置 1，模式就从实模式切换到保护模式了。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_32.png" alt></p><p>所以真正的模式切换十分简单，重要的是之前做的准备工作。</p><h4 id="跳转到System"><a href="#跳转到System" class="headerlink" title="跳转到System"></a>跳转到System</h4><p>再往后，又是一个段间跳转指令 jmpi，后面的 8 表示 cs（代码段寄存器）的值，0 表示偏移地址。</p><p>请注意，此时已经是保护模式了，之前也说过，保护模式下内存寻址方式变了，段寄存器里的值被当做段选择子。</p><p>回顾下段选择子的模样。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_33.png" alt></p><p>8 用二进制表示就是<code>00000,0000,0000,1000</code></p><p>对照上面段选择子的结构，可以知道<strong>描述符索引值是 1，也就是要去全局描述符表（gdt）中找第一项段描述符</strong>。</p><p>还记得全局描述符的具体内容吗？</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_28.png" alt></p><ul><li>第 0 项是空值，</li><li>第一项被表示为代码段描述符，是个可读可执行的段，</li><li>第二项为数据段描述符，是个可读可写段</li></ul><p>不过他们的段基址都是 0。</p><p>这里取的就是这个代码段描述符，段基址是 0，偏移也是 0，那加一块就还是 0 咯，所以最终这个跳转指令，就是跳转到内存地址的 0 地址处，开始执行。</p><p>零地址处是什么呢？还是回顾之前的内存布局图。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_30.png" alt></p><p>就是操作系统全部代码的 system 这个大模块，system 模块怎么生成的呢？</p><p>由 Makefile 文件可知，是由 head.s 和 main.c 以及其余各模块的操作系统代码合并来的，可以理解为操作系统的全部核心代码编译后的结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tools/system: boot/head.o init/main.o \</span><br><span class="line">    $(ARCHIVES) $(DRIVERS) $(MATH) $(LIBS)</span><br><span class="line">    $(LD) $(LDFLAGS) boot/head.o init/main.o \</span><br><span class="line">    $(ARCHIVES) \</span><br><span class="line">    $(DRIVERS) \</span><br><span class="line">    $(MATH) \</span><br><span class="line">    $(LIBS) \</span><br><span class="line">    -o tools/system &gt; System.map</span><br></pre></td></tr></table></figure><p>所以，接下来，我们就要重点阅读 head.s 了。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_36.png" alt></p><p>这也是 boot 文件夹下的最后一个由汇编写就的源代码文件，而且是汇编写的令人头疼的代码。</p><p>head.s 这个文件仅仅是为了顺利进入由后面的 c 语言写就的 main.c 做的准备，所以咬咬牙看完这个之后，我们就终于可以进入 c 语言的世界了！也终于可以看到我们熟悉的 main 函数了！</p><p>在那里，操作系统真正秀操作的地方，才刚刚开始！</p><h3 id="重新设置一遍-idt-和-gdt-给描述符表挪个地儿"><a href="#重新设置一遍-idt-和-gdt-给描述符表挪个地儿" class="headerlink" title="重新设置一遍 idt 和 gdt - 给描述符表挪个地儿"></a>重新设置一遍 idt 和 gdt - 给描述符表挪个地儿</h3><p>至此，CPU 进入了 32 位保护模式，并且跳转到了 system 模块。</p><p>那接下来，我们就品品，正式进入 c 语言写的 main.c 之前的 head.s 究竟写了点啥？</p><p>head.s 文件很短，我们一点点品。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_pg_dir:</span><br><span class="line">_startup_32:</span><br><span class="line">    mov eax,0x10</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov fs,ax</span><br><span class="line">    mov gs,ax</span><br><span class="line">    lss esp,_stack_start</span><br></pre></td></tr></table></figure><p>注意到开头有个标号 <strong>_pg_dir</strong>。先留个心眼，这个表示<strong>页目录</strong>，之后在设置<strong>分页机制</strong>时，页目录会存放在这里，也会覆盖这里的代码。</p><p>再往下连续五个 mov 操作，分别给 <strong>ds、es、fs、gs 这几个段寄存器赋值为 0x10</strong>，根据段描述符结构解析，表示<strong>这几个段寄存器的值为指向全局描述符表中的第二个段描述符（数据段描述符）</strong>。</p><p>最后 lss 指令相当于让 ss:esp 这个<strong>栈顶指针指向了 _stack_start 这个标号的位置</strong>。还记得图里的那个原来的栈顶指针在哪里吧？往上翻一下，<strong>0x9FF00，现在要变咯</strong>。</p><p>这个 stack_start 标号定义在了很久之后才会讲到的 sched.c 里，我们这里拿出来分析一波。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long user_stack[4096 &gt;&gt; 2];</span><br><span class="line"></span><br><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">  long *a;</span><br><span class="line">  short b;</span><br><span class="line">&#125;</span><br><span class="line">stack_start = &#123;&amp;user_stack[4096 &gt;&gt; 2], 0x10&#125;;</span><br></pre></td></tr></table></figure><p>这啥意思呢？</p><p>首先，stack_start 结构中的高位 8 字节是 0x10，将会赋值给 ss 栈段寄存器，低位 16 字节是 user_stack 这个数组的最后一个元素的地址值，将其赋值给 esp 寄存器。</p><p>赋值给 ss 的 0x10 仍然按照保护模式下的段选择子去解读，其指向的是全局描述符表中的第二个段描述符（数据段描述符），段基址是 0。</p><p>赋值给 esp 寄存器的就是 user_stack 数组的最后一个元素的内存地址值，那最终的栈顶地址，也指向了这里（user_stack + 0），后面的压栈操作，就是往这个新的栈顶地址处压咯。</p><p>继续往下看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">call setup_idt ;设置中断描述符表</span><br><span class="line">call setup_gdt ;设置全局描述符表</span><br><span class="line">mov eax,10h</span><br><span class="line">mov ds,ax</span><br><span class="line">mov es,ax</span><br><span class="line">mov fs,ax</span><br><span class="line">mov gs,ax</span><br><span class="line">lss esp,_stack_start</span><br></pre></td></tr></table></figure><p>先设置了 idt 和 gdt，然后又重新执行了一遍刚刚执行过的代码。</p><p>为什么要重新设置这些段寄存器呢？ 因为上面修改了 gdt，所以要重新设置一遍以刷新才能生效。</p><p>那我们接下来就把目光放到设置 idt 和 gdt 上。</p><h4 id="设置中断描述符表"><a href="#设置中断描述符表" class="headerlink" title="设置中断描述符表"></a>设置中断描述符表</h4><details><summary>中断描述符表 idt 我们之前没设置过，所以这里设置具体的值，理所应当</summary><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">setup_idt:</span><br><span class="line">    lea edx,ignore_int</span><br><span class="line">    mov eax,00080000h</span><br><span class="line">    mov ax,dx</span><br><span class="line">    mov dx,8E00h</span><br><span class="line">    lea edi,_idt</span><br><span class="line">    mov ecx,256</span><br><span class="line">rp_sidt:</span><br><span class="line">    mov [edi],eax</span><br><span class="line">    mov [edi+4],edx</span><br><span class="line">    add edi,8</span><br><span class="line">    dec ecx</span><br><span class="line">    jne rp_sidt</span><br><span class="line">    lidt fword ptr idt_descr</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">idt_descr:</span><br><span class="line">    dw 256*8-1</span><br><span class="line">    dd _idt</span><br><span class="line"></span><br><span class="line">_idt:</span><br><span class="line">    DQ 256 dup(0)</span><br></pre></td></tr></table></figure></details><p>中断描述符表 idt 里面存储着一个个中断描述符，每一个中断号就对应着一个中断描述符，而中断描述符里面存储着主要是中断程序的地址，这样一个中断号过来后，CPU 就会自动寻找相应的中断程序，然后去执行它。</p><p>那这段程序的作用就是:</p><ul><li><strong>设置了 256 个中断描述符</strong>，</li><li>并且让每一个中断描述符中的中断程序例程都指向一个 <strong>ignore_int</strong> 的函数地址<ul><li>这个是个<strong>默认的中断处理程序</strong>，之后会逐渐被各个具体的中断程序所覆盖。</li><li>比如之后键盘模块会将自己的键盘中断处理程序，覆盖过去。</li></ul></li></ul><p>那现在，产生任何中断都会指向这个默认的函数 ignore_int，也就是说<strong>现在这个阶段你按键盘还不好使</strong>。</p><h4 id="设置全局描述符表"><a href="#设置全局描述符表" class="headerlink" title="设置全局描述符表"></a>设置全局描述符表</h4><p>设置中断描述符表 setup_idt 说完了，那接下来 setup_gdt 就同理了。</p><p>我们就直接看设置好后的新的全局描述符表长什么样吧？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_gdt:</span><br><span class="line">    DQ 0000000000000000h    ;/* NULL descriptor */</span><br><span class="line">    DQ 00c09a0000000fffh    ;/* 16Mb */</span><br><span class="line">    DQ 00c0920000000fffh    ;/* 16Mb */</span><br><span class="line">    DQ 0000000000000000h    ;/* TEMPORARY - don&#x27;t use */</span><br><span class="line">    DQ 252 dup(0)</span><br></pre></td></tr></table></figure><p>其实和我们原先设置好的 gdt 一模一样。</p><p>也是有<strong>代码段描述符和数据段描述符</strong>，然后第四项系统段描述符并没有用到，不用管。</p><p>最后还留了 252 项的空间，这些空间后面会用来放置<strong>任务状态段描述符 TSS 和局部描述符 LDT</strong>，这个后面再说。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_37.png" alt></p><p>为什么原来已经设置过一遍了，这里又要重新设置一遍?</p><p>你可千万别想有什么复杂的原因，就是因为原来设置的 gdt 是在 setup 程序中，之后这个地方要被缓冲区覆盖掉，所以这里重新设置在 head 程序中，这块内存区域之后就不会被其他程序用到并且覆盖了，就这么个事。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_38.png" alt></p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>总体而言，header.s 目前就是完成了寄存器位置的一个指向转换，并且给所有中断设置了一个默认的中断处理程序 ignore_int，然后全局描述符表仍然只有代码段描述符和数据段描述符。</p><h3 id="Intel-内存管理两板斧-分段和分页"><a href="#Intel-内存管理两板斧-分段和分页" class="headerlink" title="Intel 内存管理两板斧-分段和分页"></a>Intel 内存管理两板斧-分段和分页</h3><p>header.s 代码在重新设置gdt和idt后， 来到了这样一段代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jmp after_page_tables</span><br><span class="line">...</span><br><span class="line">after_page_tables:</span><br><span class="line">    push 0</span><br><span class="line">    push 0</span><br><span class="line">    push 0</span><br><span class="line">    push L6</span><br><span class="line">    push _main</span><br><span class="line">    jmp setup_paging</span><br><span class="line">L6:</span><br><span class="line">    jmp L6</span><br></pre></td></tr></table></figure><p>那就是开启分页机制，并且跳转到 main 函数！</p><p>这可太令人兴奋了！开启分页后，配合着分段，就构成了内存管理的最最底层的机制。</p><p>而跳转到 main 函数，标志着我们正式进入 c 语言写的操作系统核心代码！如何跳转到之后用 c 语言写的 main.c 里的 main 函数，是个有趣的事，也包含在这段代码里。</p><p>不过我们先瞧瞧这<strong>分页机制</strong>是如何开启的，也就是 setup_paging 这个标签处的代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">setup_paging:</span><br><span class="line">    mov ecx,1024*5</span><br><span class="line">    xor eax,eax</span><br><span class="line">    xor edi,edi</span><br><span class="line">    pushf</span><br><span class="line">    cld</span><br><span class="line">    rep stosd</span><br><span class="line">    mov eax,_pg_dir</span><br><span class="line">    mov [eax],pg0+7</span><br><span class="line">    mov [eax+4],pg1+7</span><br><span class="line">    mov [eax+8],pg2+7</span><br><span class="line">    mov [eax+12],pg3+7</span><br><span class="line">    mov edi,pg3+4092</span><br><span class="line">    mov eax,00fff007h</span><br><span class="line">    std</span><br><span class="line">L3: stosd</span><br><span class="line">    sub eax,00001000h</span><br><span class="line">    jge L3</span><br><span class="line">    popf</span><br><span class="line">    xor eax,eax</span><br><span class="line">    mov cr3,eax</span><br><span class="line">    mov eax,cr0</span><br><span class="line">    or  eax,80000000h</span><br><span class="line">    mov cr0,eax</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h4 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h4><p>首先要了解的就是，啥是分页机制？</p><p>还记不记得之前我们在代码中给出一个内存地址，在保护模式下要先经过分段机制的转换，才能最终变成物理地址，就是这样。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_39.png" alt></p><p>这是在没有开启分页机制的时候，只需要经过这一步转换即可得到最终的物理地址了，但是在开启了分页机制后，又会<strong>多一步转换</strong>。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_40.png" alt></p><p>也就是说：</p><ul><li>在没有开启分页机制时，由程序员给出的逻辑地址，需要先通过分段机制转换成物理地址。</li><li>但在开启分页机制后，逻辑地址仍然要先通过分段机制进行转换，只不过转换后不再是最终的物理地址，而是线性地址，然后再通过一次分页机制转换，得到最终的物理地址。</li></ul><p>分段机制我们已经清楚如何对地址进行变换了，那分页机制又是如何变换的呢？我们直接以一个例子来学习过程。</p><p>比如我们的线性地址（已经经过了分段机制的转换）是 <code>15M</code>, 二进制表示就是 <code>0000000011_0100000000_000000000000</code></p><p>我们看一下它的转换过程</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_41.png" alt></p><p>也就是说，CPU 在看到我们给出的内存地址后，首先把线性地址被拆分成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">高 10 位：中间 10 位：后 12 位</span><br></pre></td></tr></table></figure><p>高 10 位负责在<strong>页目录表</strong>中找到一个<strong>页目录项</strong>，这个页目录项的值加上中间 10 位拼接后的地址去<strong>页表</strong>中去寻找一个<strong>页表项</strong>，这个页表项的值，再加上后 12 位偏移地址，就是最终的物理地址。</p><p>而这一切的操作，都由计算机的一个硬件叫 <strong>MMU</strong>，中文名字叫<strong>内存管理单元</strong>，有时也叫 PMMU，分页内存管理单元。由这个部件来负责将虚拟地址转换为物理地址。</p><p>所以整个过程我们不用操心，作为操作系统这个软件层，只需要提供好页目录表和页表即可，这种页表方案叫做<strong>二级页表</strong>，第一级叫<strong>页目录表 PDE</strong>，第二级叫<strong>页表 PTE</strong>。</p><p>他们的结构如下:</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_42.png" alt></p><p>之后再开启分页机制的开关。其实就是更改 cr0 寄存器中的一位即可（31 位），还记得我们开启保护模式么，也是改这个寄存器中的一位的值。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_43.png" alt></p><p>然后，MMU 就可以帮我们进行分页的转换了。此后指令中的内存地址（就是程序员提供的逻辑地址），就统统要先经过分段机制的转换，再通过分页机制的转换，才能最终变成物理地址。</p><p>所以这段代码，就是帮我们<strong>把页表和页目录表在内存中写好，之后开启 cr0 寄存器的分页开关</strong>，仅此而已，我们再把代码贴上来。</p><h4 id="分页内存结构"><a href="#分页内存结构" class="headerlink" title="分页内存结构"></a>分页内存结构</h4><p>我们先说这段代码最终产生的效果吧。</p><p>当时 linux-0.11 认为，总共可以使用的内存不会超过 <strong>16M</strong>，也即最大地址空间为 <strong>0xFFFFFF</strong>。</p><p>而按照当前的页目录表和页表这种机制:</p><ul><li>1 个页目录表最多包含 1024 个页目录项（也就是 1024 个页表），</li><li>1 个页表最多包含 1024 个页表项（也就是 1024 个页），</li><li>1 页为 4KB（因为有 12 位偏移地址）</li></ul><p>因此，16M 的地址空间可以用 1 个页目录表 + 4 个页表搞定。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4（页表数）* 1024（页表项数） * 4KB（一页大小）= 16MB</span><br></pre></td></tr></table></figure></p><p>所以，上面这段代码就是，<strong>将页目录表放在内存地址的最开头</strong>，还记得上一讲开头让你留意的 _pg_dir 这个标签吧？<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_pg_dir:</span><br><span class="line">_startup_32:</span><br><span class="line">    mov eax,0x10</span><br><span class="line">    mov ds,ax</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><p><strong>之后紧挨着这个页目录表，放置 4 个页表</strong>，代码里也有这四个页表的标签项。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.org 0x1000 pg0:</span><br><span class="line">.org 0x2000 pg1:</span><br><span class="line">.org 0x3000 pg2:</span><br><span class="line">.org 0x4000 pg3:</span><br><span class="line">.org 0x5000</span><br></pre></td></tr></table></figure></p><p>最终将页目录表和页表填写好数值，来覆盖整个 16MB 的内存。随后，开启分页机制。</p><p>此时内存中的页表相关的布局如下。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_44.png" alt></p><p>这些页目录表和页表放到了整个内存布局中最开头的位置，就是覆盖了开头的 system 代码了，不过被覆盖的 system 代码已经执行过了，所以无所谓。</p><p>同时，如 idt 和 gdt 一样，我们也需要通过一个寄存器告诉 CPU 我们把这些页表放在了哪里，就是这段代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xor eax,eax</span><br><span class="line">mov cr3,eax</span><br></pre></td></tr></table></figure><p>你看，我们相当于告诉 <strong>cr3 寄存器</strong>，<strong>0 地址处就是页目录表，再通过页目录表可以找到所有的页表</strong>，也就相当于 CPU 知道了分页机制的全貌了。</p><p>至此后，整个内存布局如下:</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_45.png" alt></p><h4 id="页表具体映射内存"><a href="#页表具体映射内存" class="headerlink" title="页表具体映射内存"></a>页表具体映射内存</h4><p>那么具体页表设置好后，映射的内存是怎样的情况呢？那就要看页表的具体数据了，就是这一坨代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">setup_paging:</span><br><span class="line">    ...</span><br><span class="line">    mov eax,_pg_dir</span><br><span class="line">    mov [eax],pg0+7</span><br><span class="line">    mov [eax+4],pg1+7</span><br><span class="line">    mov [eax+8],pg2+7</span><br><span class="line">    mov [eax+12],pg3+7</span><br><span class="line">    mov edi,pg3+4092</span><br><span class="line">    mov eax,00fff007h</span><br><span class="line">    std</span><br><span class="line">L3: stosd</span><br><span class="line">    sub eax, 1000h</span><br><span class="line">    jpe L3</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>很简单，对照刚刚的页目录表与页表结构看。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_42.png" alt></p><p>前五行表示，页目录表的前 4 个页目录项，分别指向 4 个页表。比如页目录项中的第一项 [eax] 被赋值为 pg0+7，也就是 0x00001007，根据页目录项的格式，表示页表地址为 0x1000，页属性为 0x07 表示改页存在、用户可读写。</p><p>后面几行表示，填充 4 个页表的每一项，一共 4*1024=4096 项，依次映射到内存的前 16MB 空间。</p><p>画出图就是这个样子，其实刚刚的图就是:</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_46.png" alt></p><p>看，最终的效果就是，经过这套分页机制，<strong>线性地址将恰好和最终转换的物理地址一样</strong>。</p><p>现在只有四个页目录项，也就是将前 16M 的线性地址空间，与 16M 的物理地址空间一一对应起来了。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_47.png" alt></p><p>好了，我们终于把这些杂七杂八的idt、gdt、页表都设置好了，并且也开启了保护模式，之后我们就要做好进入 main.c 的准备了，那里是个新世界！</p><h4 id="拓展-名词梳理"><a href="#拓展-名词梳理" class="headerlink" title="拓展 - 名词梳理"></a>拓展 - 名词梳理</h4><p>关于地址，我们已经出现了好多词了，包括<strong>逻辑地址</strong>、<strong>线性地址</strong>、<strong>物理地址</strong>，以及本文中没出现的，你可能在很多地方看到过的<strong>虚拟地址</strong>。</p><p>而这些地址后面加上空间两个字，似乎又成为了一个新词，比如<strong>线性地址空间</strong>、<strong>物理地址空间</strong>、<strong>虚拟地址空间</strong>等。</p><p>那就是时候展开一波讨论，将这块的内容梳理一番了，且听我说。</p><p>Intel 体系结构的内存管理可以分成两大部分，也就是标题中的两板斧，<strong>分段和分页</strong>。</p><ul><li><p><strong>分段机制</strong>： 在之前已经讨论过多次了，其目的是为了为每个程序或任务提供单独的代码段（cs）、数据段（ds）、栈段（ss），使其不会相互干扰。</p></li><li><p><strong>分页机制</strong>： 开机后分页机制默认是关闭状态，需要我们手动开启，并且设置好页目录表（PDE）和页表（PTE）。</p><ul><li>其目的在于可以按需使用物理内存，同时也可以在多任务时起到隔离的作用，这个在后面将多任务时将会有所体会。</li></ul></li></ul><p>在 Intel 的保护模式下，分段机制是没有开启和关闭一说的，它必须存在，而分页机制是可以选择开启或关闭的。所以如果有人和你说，它实现了一个没有分段机制的操作系统，那一定是个外行。</p><p>再说说那些地址：</p><ul><li><p>逻辑地址：我们程序员写代码时给出的地址叫逻辑地址，其中包含段选择子和偏移地址两部分。</p></li><li><p>线性地址：通过分段机制，将逻辑地址转换后的地址，叫做线性地址。而这个线性地址是有个范围的，这个范围就叫做线性地址空间，32 位模式下，线性地址空间就是 4G。</p></li><li><p>物理地址：就是真正在内存中的地址，它也是有范围的，叫做物理地址空间。那这个范围的大小，就取决于你的内存有多大了。</p></li><li><p>虚拟地址：如果没有开启分页机制，那么线性地址就和物理地址是一一对应的，可以理解为相等。如果开启了分页机制，那么线性地址将被视为虚拟地址，这个虚拟地址将会通过分页机制的转换，最终转换成物理地址。</p></li></ul><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_48.png" alt></p><h3 id="进入-main-c-之前的最后一哆嗦"><a href="#进入-main-c-之前的最后一哆嗦" class="headerlink" title="进入 main.c 之前的最后一哆嗦"></a>进入 main.c 之前的最后一哆嗦</h3><p>回到上节中开启分页机制的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jmp after_page_tables</span><br><span class="line">...</span><br><span class="line">after_page_tables:</span><br><span class="line">    push 0</span><br><span class="line">    push 0</span><br><span class="line">    push 0</span><br><span class="line">    push L6</span><br><span class="line">    push _main</span><br><span class="line">    jmp setup_paging</span><br><span class="line">L6:</span><br><span class="line">    jmp L6</span><br></pre></td></tr></table></figure><p>这里有个 push _main，把 main 函数的地址压栈了，那最终跳转到这个 main.c 里的 main 函数，一定和这个压栈有关。</p><p>压栈为什么和跳转到这里还能联系上呢？</p><p>五个 push 指令过去后，栈会变成这个样子。</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_49.png" alt></p><p>然后注意，setup_paging 最后一个指令是 ret，也就是设置分页的代码的最后一个指令，形象地说它叫<strong>返回指令</strong>，但 CPU 可没有那么聪明，它并不知道该返回到哪里执行，只是很<strong>机械地把栈顶的元素值当做返回地址</strong>，跳转去那里执行。</p><p>再具体说是，把 esp 寄存器（栈顶地址）所指向的内存处的值，赋值给 eip 寄存器，而 cs:eip 就是 CPU 要执行的下一条指令的地址。而此时栈顶刚好是 main.c 里写的 main 函数的内存地址，是我们刚刚特意压入栈的，所以 CPU 就理所应当跳过来了。</p><details><summary>当然 Intel CPU 是设计了 call 和 ret 这一配对儿的指令，意为调用函数和返回</summary>关于 ret 指令，其实 Intel CPU 是配合 call 设计的，有关 call 和 ret 指令，即调用和返回指令，可以参考 Intel 手册。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intel 1 Chapter 6.4 CALLING PROCEDURES USING CALL AND RET</span><br></pre></td></tr></table></figure>同时，可以看到系统还分为不改变段基址的 near call & near ret, 以及改变段基址的 far call 和 far ret。压栈和出栈的具体过程，上面文字写的清清楚楚，下面 Intel 手册还非常友好地放了张图。![](./操作系统第一步之进入内核前的苦力活/img_52.png)可以看到，我们本文就是左边的那一套，把 main 函数地址值当做 Calling EIP 压入栈，仿佛是执行了 call 指令调用了一个函数一样，但实际上这是我们通过骚操作代码伪造的假象，骗了 CPU。然后 ret 的时候就把栈顶的那个 Calling EIP 也就是 main 函数地址弹出栈，存入 EIP 寄存器，这样 CPU 就相当于“返回”到了 main 函数开始执行。</details><p>至于其他压入栈的 L6 是用作当 main 函数返回时的跳转地址，但由于在操作系统层面的设计上，main 是绝对不会返回的，所以也就没用了。而其他的三个压栈的 0，本意是作为 main 函数的参数，但实际上似乎也没有用到，所以也不必关心。</p><p>总之，经过这一个小小的骚操作，程序终于跳转到 main.c 这个由 c 语言写就的主函数 main 里了！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void main(void) &#123;</span><br><span class="line">    ROOT_DEV = ORIG_ROOT_DEV;</span><br><span class="line">    drive_info = DRIVE_INFO;</span><br><span class="line">    memory_end = (1&lt;&lt;20) + (EXT_MEM_K&lt;&lt;10);</span><br><span class="line">    memory_end &amp;= 0xfffff000;</span><br><span class="line">    if (memory_end &gt; 16*1024*1024)</span><br><span class="line">        memory_end = 16*1024*1024;</span><br><span class="line">    if (memory_end &gt; 12*1024*1024) </span><br><span class="line">        buffer_memory_end = 4*1024*1024;</span><br><span class="line">    else if (memory_end &gt; 6*1024*1024)</span><br><span class="line">        buffer_memory_end = 2*1024*1024;</span><br><span class="line">    else</span><br><span class="line">        buffer_memory_end = 1*1024*1024;</span><br><span class="line">    main_memory_start = buffer_memory_end;</span><br><span class="line">    mem_init(main_memory_start,memory_end);</span><br><span class="line">    trap_init();</span><br><span class="line">    blk_dev_init();</span><br><span class="line">    chr_dev_init();</span><br><span class="line">    tty_init();</span><br><span class="line">    time_init();</span><br><span class="line">    sched_init();</span><br><span class="line">    buffer_init(buffer_memory_end);</span><br><span class="line">    hd_init();</span><br><span class="line">    floppy_init();</span><br><span class="line">    sti();</span><br><span class="line">    move_to_user_mode();</span><br><span class="line">    if (!fork()) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line">    for(;;) pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没错，这就是这个 main 函数的全部了。</p><p>而整个操作系统也会最终停留在最后一行死循环中，永不返回，直到关机。</p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>至此，系统正式完成了 main 函数的所有准备工作，并跳转到了 main 函数地址。</p><p>来看看系统都经历了什么？</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_50.png" alt></p><p>而经过这样的流程，内存被搞成了这个样子</p><p><img src="/2022/04/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%B9%8B%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E5%89%8D%E7%9A%84%E8%8B%A6%E5%8A%9B%E6%B4%BB/img_51.png" alt></p><p>之后，main 方法就开始执行了，靠着我们辛辛苦苦建立起来的内存布局，向崭新的未来前进！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本系列转自&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzk0MjE3NDE0Ng==&amp;amp;action=getalbum&amp;amp;album_id=2123743679373688834&amp;amp;sce</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统第一步之按下开机键</title>
    <link href="http://example.com/2022/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%8C%89%E4%B8%8B%E5%BC%80%E6%9C%BA%E9%94%AE/"/>
    <id>http://example.com/2022/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%8C%89%E4%B8%8B%E5%BC%80%E6%9C%BA%E9%94%AE/</id>
    <published>2022-04-18T11:15:41.000Z</published>
    <updated>2022-05-19T07:29:08.825Z</updated>
    
    <content type="html"><![CDATA[<p>文档说明：转自<a href="https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;mid=2247483867&amp;idx=1&amp;sn=76ece31324d32922a7cb9db129decd3f&amp;chksm=c2c67b76f5b1f260bb459e12c029f8e6a7a813055811ab8ed794a3f36d0d7d50e66df27f4f0a&amp;scene=21#wechat_redirect">全网最硬核讲解计算机的启动过程</a></p><p>我们按下开机键后究竟发生了什么？</p><p>当我们探寻这个问题的答案时，搜到的大多数是这样的描述：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BIOS 按照“启动顺序”，把控制权转交给排在第一位的存储设备：硬盘。</span><br><span class="line"></span><br><span class="line">然后在硬盘里寻找主引导记录的分区，这个分区告诉电脑操作系统在哪里，并把操作系统被加载到内存中，然后你就能看到经典的启动界面了，这个开机过程也就完成了。</span><br></pre></td></tr></table></figure></p><p>这种描述简直太魔幻了</p><ul><li>为什么是 BIOS 主导这一切？</li><li>怎么叫按照启动顺序？</li><li>这个分区咋就被加载到内存了?</li><li>又咋告诉电脑操作系统在哪里了？</li></ul><p><strong>前置知识</strong></p><ul><li>内存是存储数据的地方，给出一个地址信号，内存可以返回该地址所对应的数据。</li><li>CPU 的工作方式就是不断从内存中取出指令，并执行。</li><li>CPU 从内存的哪个地址取出指令，是由一个寄存器中的值决定的，这个值会不断进行 +1 操作，或者由某条跳转指令指定其值是多少。</li></ul><h3 id="为什么是BIOS主导"><a href="#为什么是BIOS主导" class="headerlink" title="为什么是BIOS主导"></a>为什么是BIOS主导</h3><p>都说开机后，BIOS 就开始运行自己的程序了，又硬件自检，又加载启动区的。</p><p>我就不服了，为什么开机后是执行 BIOS 里的程序？<br>为啥不是内存里的？<br>为啥不是硬盘里的？</p><p>好的，不要怀疑前置知识，CPU 的工作方式，就是不断从内存中取指令并执行，那为什么会说是执行 BIOS 里的程序呢？这就不得不说说内存映射了。</p><h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p><strong>CPU 地址总线的宽度决定了可访问的内存空间的大小</strong></p><p>比如 16 位的 CPU 地址总线宽度为 20 位，地址范围是 1M。32 位的 CPU 地址总线宽度为 32 位，地址范围是 4G。你可以算算我们现在的 64 位机的地址范围。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">地址总线用来定位，数据总线用来传输。</span><br><span class="line">cpu的位宽 = 数据总线的位宽 = cpu内部通用寄存器的位宽 = 机器字长， 与地址总线位宽无关。</span><br></pre></td></tr></table></figure><p>可是，可访问的内存空间这么大，并不等于说全都给内存使用，也就是说寻址的对象不只有内存，还有一些外设也要通过地址总线的方式去访问，那怎么去访问这些外设呢？就是在地址范围中划出一片片的区域，这块给显存使用，那块给硬盘控制器使用，等等 。</p><p>这样说，其实就不符合我们的前置知识了，所以可以有一种不太正确的理解方式，那就是内存中的这块位置就是显存，那块位置就是硬盘控制器。我们在相应的位置上读取或者写入，就相当于在显存等外设的相应位置上读取或者写入，就好像这些外设的存储区域，被映射到了内存中的某一片区域一样。</p><p>这样我们就不用管那些外设啦，关注点仍然是一个简简单单的内存。 </p><p>这就是所谓的内存映射。</p><h3 id="实模式下的内存分布"><a href="#实模式下的内存分布" class="headerlink" title="实模式下的内存分布"></a>实模式下的内存分布</h3><p>刚刚说到内存中划分出了一片一片区域给各种外设，那么问题自然就来了，哪块区域，分给了哪块外设了呢？如果是规定，那应该有一张表比较好吧。</p><p>嗯没错，还真有，它就是实模式下的内存分布，笔者给它画了一张图：</p><p><img src="/2022/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%8C%89%E4%B8%8B%E5%BC%80%E6%9C%BA%E9%94%AE/img_1.png" alt></p><p>实模式之后再解释，现在简单理解就是计算机刚开机的时候只有 1M 的内存可用。</p><p>我们看到，内存被各种外设瓜分了，即映射在了内存中。</p><p>BIOS 更狠，不但其空间被映射到了内存 0xC0000 - 0xFFFFF 位置，其里面的程序还占用了开头的一些区域，比如把中断向量表写在了内存开始的位置，真所谓先到先得啊。</p><h3 id="为什么从BIOS的程序开始执行"><a href="#为什么从BIOS的程序开始执行" class="headerlink" title="为什么从BIOS的程序开始执行"></a>为什么从BIOS的程序开始执行</h3><p>现在我们知道 BIOS 里的信息被映射到了内存 0xC0000 - 0xFFFFF 位置，其中最为关键的系统 BIOS 被映射到了 0xF0000 - 0xFFFFF 位置。</p><p>CPU 开机就是执行了这块区域的代码，然后巴拉巴拉一顿操作就开机了，那咋不从头开始执行？</p><p>就是 CPU 从内存的哪个位置取出执行并执行呢？</p><p><strong>是 PC 寄存器中的地址值</strong></p><p>BIOS 程序的入口地址也就是开始地址是 0xFFFF0（人家就那么写的），也就是开机键一按下，一定有一个神奇的力量，将 pc 寄存器中的值变成 0xFFFF0，然后 CPU 就开始马不停蹄地跑了起来。</p><p><strong>在你开机的一瞬间，CPU 的 PC 寄存器被强制初始化为 0xFFFF0。</strong></p><p>如果再说具体些，CPU 将段基址寄存器 cs 初始化为 0xF000，将偏移地址寄存器 IP 初始化为 0xFFF0，根据<strong>实模式下的最终地址计算规则</strong>，将段基址左移 4 位，加上偏移地址，得到最终的物理地址也就是抽象出来的 PC 寄存器地址为 0xFFFF0。</p><p>至于怎么强制初始化的，我觉得就越过了前置知识的边界了，况且各个厂商的硬件实现也不一定相同，有很多办法，也很简单。讨论起来意义就不大了。</p><h3 id="BIOS里到底写了什么？"><a href="#BIOS里到底写了什么？" class="headerlink" title="BIOS里到底写了什么？"></a>BIOS里到底写了什么？</h3><p>我们现在知道了 BIOS 被映射到了内存的某个位置，并且开机一瞬间 CPU 强制将自己的 pc 寄存器初始化为 BIOS 程序的入口地址，从这里开始 CPU 马不停蹄地向前跑了起来。</p><p>那接下来的问题似乎也非常自然地就问出来了，那就是 BIOS 程序里到底写了啥？ 把 BIOS 程序里的二进制信息全贴出来也不合适，我们分析一些主要的。</p><p>我们首先还是来猜测，你看入口地址是 0xFFFF0，说明程序是从这执行的。</p><p>实模式下内存的下边界就是 0xFFFFF，也就是只剩下 16 个字节的空间可以写代码了，这够干啥的呢？</p><p>如果你有心的话应该能猜出，入口地址处可能是个跳转指令，跳到一个更大范围的空间去执行自己的任务。</p><p>没错就是这样，0xFFFF0 处存储的机器指令，翻译成汇编语言是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp far f000:e05b</span><br></pre></td></tr></table></figure></p><p>意思是跳转到物理地址 0xfe05b 处开始执行（回忆下前面说的实模式下的地址计算方式）。</p><p>地址 0xfe05b 处开始，便是 BIOS 真正发挥作用的代码了，这块代码会检测一些外设信息，并初始化好硬件，建立中断向量表并填写中断例程。</p><p>这里的部分不要展开，这只是一段写死的程序而已，而且对理解开机启动过程无帮助，我们看后面精彩的部分，也就是 BIOS 的最后一项工作：<strong>加载启动区</strong>。</p><h3 id="0x7c00-是啥"><a href="#0x7c00-是啥" class="headerlink" title="0x7c00 是啥"></a>0x7c00 是啥</h3><p>该较真的地方就是要较真，我绝对不会让<strong>加载</strong>这种魔幻的词出现在这里，我们现在就来把它拆解成人话。</p><p>其实这个词也并不魔幻，加载在计算机领域就是指，<strong>把某设备上（比如硬盘）的程序复制到内存中的过程</strong>。</p><p>那加载启动区这个过程，翻译过来就是，<strong>BIOS 程序把启动区的内容复制到了内存中的某个区域</strong>。</p><p>好了，问题又自然出来了，启动区是哪里？被复制到了内存的哪个位置？然后呢？我们一个个来回答。</p><h4 id="什么是启动区呢"><a href="#什么是启动区呢" class="headerlink" title="什么是启动区呢"></a>什么是启动区呢</h4><p>即使你不知道，你也应该能够猜到，一定是符合某种特征的一块区域，于是人们把它就叫做启动区了，那要符合什么特征呢？</p><p>先不急，不知道你有没有过设置 BIOS 启动顺序的经历，通常有 U 盘启动、硬盘启动、软盘启动、光盘启动等等。</p><p>BIOS 会按照顺序，读取这些启动盘中位于<strong>0 盘 0 道 1 扇区</strong>的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">至于磁盘格式的划分，本篇就不做讲解了，总之对于内存，我们给出一个数字地址就能获取到该地址的数据，而对于磁盘，我们需要给出磁头、柱面、扇区这三个信息才能定位某个位置的数据，都是描述位置的一种方式而已。</span><br></pre></td></tr></table></figure><p>接着说， 这 0 盘 0 道 1 扇区的内容一共有 512 个字节，<strong>如果末尾的两个字节分别是 0x55 和 0xaa，那么 BIOS 就会认为它是个启动区</strong>。 如果不是，那么按顺序继续向下个设备中寻找位于 0 盘 0 道 1 扇区的内容。如果最后发现都没找到符合条件的，那直接报出一个无启动区的错误。</p><h4 id="BIOS找到启动区后做什么？"><a href="#BIOS找到启动区后做什么？" class="headerlink" title="BIOS找到启动区后做什么？"></a>BIOS找到启动区后做什么？</h4><p>前面说过了是加载，<strong>就是把这 512 个字节的内容，一个比特都不少的全部复制到内存的 0x7c00 这个位置</strong>。</p><p>怎么复制的？ 当然是指令啦。</p><p>哪些指令呢？这里我只能简单说指令集中是有 in 和 out 的，用来将外设中的数据复制到内存，或者将内存中的数据复制到外设，用这两个指令，以及外设给我们提供的读取方式，就能做到这一点啦。</p><p>启动区内容此时已经被 BIOS 程序复制到了内存的 0x7c00 这个位置，然后呢？这个其实也不难猜测，启动区的内容就是我们自己写的代码了，复制到这里之后，就开始执行呗，之后我们的程序就接管了接下来的流程，BIOS 的使命也就结束啦。</p><p>所以复制完之后，接下来应该是一个跳转指令吧！没错，正是这样，PC 寄存器的值变为 0x7c00，指令开始从这里执行。</p><p>这样，我们就可以理解这句魔法语言了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BIOS 把控制权转交给排在第一位的存储设备。</span><br><span class="line"></span><br><span class="line">就是 BIOS 把启动区的 512 字节复制到内存的 0x7c00 位置，并且用一条跳转指令将 pc 寄存器的值指向 0x7c00。</span><br></pre></td></tr></table></figure></p><h4 id="为什么是-ox7c00"><a href="#为什么是-ox7c00" class="headerlink" title="为什么是 ox7c00"></a>为什么是 ox7c00</h4><p>现在似乎就剩下一个问题了，为什么非要是 0x7c00 呢？好问题，当然答案也很简单，那就是人家 BIOS 开发团队就是这样定的，之后也不好改了，不然不兼容。为什么不好改？</p><details><summary>我们看一个简单的启动区 512 字节的代码</summary><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">; hello-os</span><br><span class="line">; TAB=4</span><br><span class="line"></span><br><span class="line">  ORG  0x7c00   ;程序加载到内存的 0x7c00 这个位置</span><br><span class="line"></span><br><span class="line">;程序主体</span><br><span class="line"></span><br><span class="line">entry:</span><br><span class="line">  MOV  AX,0   ;初始化寄存器</span><br><span class="line">  MOV  SS,AX</span><br><span class="line">  MOV  SP,0x7c00</span><br><span class="line">  MOV  DS,AX   ;段寄存器初始化为 0</span><br><span class="line">  MOV  ES,AX</span><br><span class="line">  MOV  SI,msg</span><br><span class="line">putloop:</span><br><span class="line">  MOV  AL,[SI]</span><br><span class="line">  ADD  SI,1</span><br><span class="line">  CMP  AL,0   ;如果遇到 0 结尾的，就跳出循环不再打印新字符</span><br><span class="line">  JE  fin</span><br><span class="line">  MOV  AH,0x0e   ;指定文字</span><br><span class="line">  MOV  BX,15   ;指定颜色</span><br><span class="line">  INT  0x10   ;调用 BIOS 显示字符函数</span><br><span class="line">  JMP  putloop</span><br><span class="line">fin:</span><br><span class="line">  HLT</span><br><span class="line">  JMP  fin</span><br><span class="line">msg:</span><br><span class="line">  DB  0x0a,0x0a  ;换行、换行</span><br><span class="line">  DB  &quot;hello-os&quot;</span><br><span class="line">  DB  0x0a   ;换行</span><br><span class="line">  DB  0    ;0 结尾</span><br><span class="line"></span><br><span class="line">  RESB 0x7dfe-$   ;填充0到512字节</span><br><span class="line">  DB 0x55, 0xaa   ;可启动设备标识</span><br></pre></td></tr></table></figure></details><p>我们看第一行：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ORG  0x7c00</span><br></pre></td></tr></table></figure></p><p>这个数字就是刚刚说的启动区加载位置，这行汇编代码简单说就表示把下面的地址统统加上 0x7c00。正因为 BIOS 将启动区的代码加载到了这里，因此有了一个偏移量，所以所有写启动区代码的人就需要在开头写死一个这样的代码，不然全都串位了。</p><p>然后正因为所有写操作系统的，启动区的第一行汇编代码都写死了这个数字，那 BIOS 开发者最初定的这个数字就不好改了，否则它得挨个联系各个操作系统的开发厂商，说唉我这个地址改一下哈，你们跟着改改。在公司推动另一个团队改个代码都得大费周折，想想看这样的推动得耗费多大人力。况且即使改了，之前的代码也都不兼容了，这不得被人们骂死啊。</p><p>再看最后一行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DB 0x55, 0xaa</span><br></pre></td></tr></table></figure></p><p>这也验证了我们之前说的这 512 字节的最后两个字节得是 0x55 0xaa，BIOS 才会认为它是一个启动区，才会去加载它，仅此而已。</p><p>回过头来说 0x7c00 这个值，它其实就是一个规定死的值，但还是会有人问，那必然有它的合理性吧。其实，我的解释也只能说是人家规定了这个值，后人们替他们解释这个合理性，并不是说当初人家就一定是这样想的，就好比我们做语文的阅读理解题一样。</p><p>第一个 BIOS 开发团队是 IBM PC 5150 BIOS，当时被认为的第一个操作系统是 DOS 1.0 操作系统，BIOS 团队就假设是为它服务的。但操作系统还没出，BIOS 团队假设其操作系统需要的最小内存为 32 KB。BIOS 希望自己所加载的启动区代码尽量靠后，这样比较“安全”，不至于过早的被其他程序覆盖掉。可是如果仅仅留 512 字节又感觉太悬了，还有一些栈空间需要预留，那扩大到 1 KB 吧。这样 32 KB 的末尾是 0x8000，减去 1KB(0x400) ，刚好等于 0x7c00。哇塞，太精准了，这可以是一种解释方式。</p><h3 id="启动区里的代码写了啥"><a href="#启动区里的代码写了啥" class="headerlink" title="启动区里的代码写了啥"></a>启动区里的代码写了啥</h3><p>启动区里的代码写了啥？就 512 字节就是全部操作系统内容了？</p><p>这是一个好问题，512 个字节确实干不了啥，现在的操作系统怎么也得按 M 为单位算吧，512 个字节远远不够呢，那是怎么回事呢？</p><p>其实我们可以按照之前的思路猜测，BIOS 用很少的代码就把 512 字节的启动区内容加载到了内存，并跳转过去开始执行。那按照这个套路，这 512 字节的启动区代码，是不是也可以把更多磁盘中存储的操作系统程序，加载到内存的某个位置，然后跳转过去呢？</p><p>没错，就是这个套路。<strong>所以 BIOS 负责加载了启动区，而启动区又负责加载真正的操作系统内核</strong>，这配合默契吧？</p><p>由于用于启动盘的磁盘是人家写操作系统的厂商制作的，俗称制作启动盘，所以他也肯定知道操作系统的核心代码存储在磁盘的哪个扇区，因此启动区就把这个扇区，以及之后的好多好多扇区（具体取决于操作系统有多大）都读到内存中，然后跳转到开始的程序开始的位置。跳转到哪里呢？这个就不像 0x7c00 这个数那么经典了，不同的操作系统肯定也不一样，也不用事先规定好，反正写操作系统的人给自己定一个就好了，别覆盖其他关键设备用到的区域就好。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>好了现在经过好几轮跳跳跳，终于跳到内核代码啦，我们来一起回顾一下：</p><ul><li>按下开机键，CPU 将 PC 寄存器的值强制初始化为 0xffff0，这个位置是 BIOS 程序的入口地址（一跳）</li><li>该入口地址处是一个跳转指令，跳转到 0xfe05b 位置，开始执行（二跳）</li><li>执行了一些硬件检测工作后，最后一步将启动区内容加载到内存 0x7c00，并跳转到这里（三跳）</li><li>启动区代码主要是加载操作系统内核，并跳转到加载处（四跳）</li></ul><p>经过这连续的四次跳跃，终于来到了操作系统的世界了。</p><p>剩下的内容，可以说是整个操作系统课程所讲述的原理： 分段、分页、建立中断、设备驱动、内存管理、进程管理、文件系统、用户态接口等等。</p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://blog.csdn.net/wwwlyj123321/article/details/99940786">cpu的位宽、操作系统的位宽和寻址能力的关系</a></p><p><img src="/2022/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%8C%89%E4%B8%8B%E5%BC%80%E6%9C%BA%E9%94%AE/img.png" alt></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文档说明：转自&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzk0MjE3NDE0Ng==&amp;amp;mid=2247483867&amp;amp;idx=1&amp;amp;sn=76ece31324d32922a7cb9db129decd3f&amp;am</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>PPT与超级汽车系列之UML类图</title>
    <link href="http://example.com/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/"/>
    <id>http://example.com/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/</id>
    <published>2022-04-12T10:23:12.000Z</published>
    <updated>2022-04-14T08:04:38.119Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是类图"><a href="#什么是类图" class="headerlink" title="什么是类图"></a>什么是类图</h3><p>类图(Class diagram)主要用于描述系统的结构化设计。类图也是最常用的UML图，用类图可以显示出类、接口以及它们之间的静态结构和关系。</p><h3 id="UML类图图示样例"><a href="#UML类图图示样例" class="headerlink" title="UML类图图示样例"></a>UML类图图示样例</h3><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img.png"></p><h3 id="UML类图模型元素"><a href="#UML类图模型元素" class="headerlink" title="UML类图模型元素"></a>UML类图模型元素</h3><p>在类图中一共包含了以下几种模型元素，分别是：类（Class）、接口（Interface）以及类之间的关系。</p><p>各种关系的强弱顺序：</p><p><strong>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</strong></p><h4 id="类-Class"><a href="#类-Class" class="headerlink" title="类(Class)"></a>类(Class)</h4><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img_2.png"></p><p>类图分三层: </p><ul><li>第一层显示类的名称，如果是抽象类，则就用斜体显示。</li><li>第二层是类的特性，通常就是字段和属性。</li><li>第三层是类的操作，通常是方法或行为。<ul><li>注意前面的符号，‘+’表示public，‘-’表示private，‘#’表示protected。”</li></ul></li></ul><p>示例如下：</p><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img_1.png"></p><h4 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口(Interface)"></a>接口(Interface)</h4><p>与类图的区别主要是顶端有&lt;<interface>&gt;显示。第一行是接口名称，第二行是接口方法。</interface></p><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img_4.png"></p><p>接口还有另一种表示方法，俗称棒棒糖表示法，比如图中的唐老鸭类就是实现了‘讲人话’的接口。”</p><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img_5.png"></p><h4 id="类图中关系"><a href="#类图中关系" class="headerlink" title="类图中关系"></a>类图中关系</h4><p>在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)</p><h5 id="泛化-继承"><a href="#泛化-继承" class="headerlink" title="泛化-继承"></a>泛化-继承</h5><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img_6.png"></p><p>【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。</p><p>例如：鸟是动物的一种，即有鸟的特性也有动物的共性。</p><p>【箭头指向】：带空心三角箭头的实线，箭头指向父类</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img_7.png"></p><p>【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.</p><p>【箭头指向】：带空心三角箭头的虚线，箭头指向接口</p><h5 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h5><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img_8.png"></p><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img_9.png"></p><p>【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，</p><p>丈夫与妻子关联可以是双向的，也可以是单向的。</p><p>双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</p><p>【代码体现】：成员变量</p><p>【箭头及指向】：带普通箭头的实心线，指向被拥有者</p><h5 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h5><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img_10.png"></p><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img_11.png"></p><p>【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。</p><p>聚合表示一种弱的‘拥有’关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。</p><p>如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。</p><p>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。</p><p>【代码体现】：成员变量</p><p>【箭头及指向】：带空心菱形的实心线，菱形指向整体</p><h5 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h5><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img_12.png"></p><p>【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。</p><p>一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。是关联关系的一种，是比聚合关系还要强的关系，部分和整体的生命周期一样。</p><p>如公司和部门是整体和部分的关系，没有公司就不存在部门。</p><p>它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。</p><p>【代码体现】：成员变量</p><p>【箭头及指向】：带实心菱形的实线，菱形指向整体</p><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img_13.png"></p><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img_14.png"></p><p>【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，</p><p>所以要尽量不使用双向的互相依赖.</p><p>【代码表现】：局部变量、方法的参数或者对静态方法的调用</p><p>【箭头及指向】：带箭头的虚线，指向被使用者</p><h3 id="类图绘制要点"><a href="#类图绘制要点" class="headerlink" title="类图绘制要点"></a>类图绘制要点</h3><ol><li><p>类的操作是针对类自身的操作，而不是它去操作人家。比如书这个类有上架下架的操作，是书自己被上架下架，不能因为上架下架是管理员的动作而把它放在管理员的操作里。</p></li><li><p>两个相关联的类，需要在关联的类中加上被关联类的ID，并且箭头指向被关联类。可以理解为数据表中的外键。比如借书和书，借书需要用到书的信息，因此借书类需包含书的ID，箭头指向书。</p></li><li><p>由于业务复杂性，一个显示中的实体可能会被分为多个类，这是很正常的，类不是越少越好。类的设计取决于怎样让后台程序的操作更加简单。比如单看逻辑，借书类可以不存在，它的信息可以放在书这个类里。然而借还书和书的上架下架完全不是一回事，借书类对借书的操作更加方便，不需要去重复改动书这个类中的内容。此外，如果书和借书是1对多的关系，那就必须分为两个类。</p></li><li><p>类图中的规范问题，比如不同关系需要不同的箭头，可见性符号等。</p></li></ol><h3 id="类图分类"><a href="#类图分类" class="headerlink" title="类图分类"></a>类图分类</h3><p>软件在分析与设计两个阶段各自会绘制一套UML类图，而且是由分析师和设计师两个不同的角色绘制的。</p><p>一般情况下，分析师绘制的UML类图叫做“领域UML类图”，而设计师绘制的UML类图叫做“实现UML类图”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里要声明，这两个名词是并不是大家都认同的通用叫法。</span><br></pre></td></tr></table></figure><h4 id="领域UML类图"><a href="#领域UML类图" class="headerlink" title="领域UML类图"></a>领域UML类图</h4><p>产生于分析阶段，由系统分析师绘制，主要作用是描述业务实体的静态结构，包括业务实体、各个业务实体所具有的业务属性及业务操作、业务实体之间具有的关系。</p><p>虽然这个UML类图也叫“UML类图”，但是说实话，它和编程中的“类”实在是没啥关系，因为最后的系统中可能根本没有类和它们对应，而且很多最后系统中的类如控制类和界面类这套UML类图中也没有。也就是说这套图和具体技术无关，也不是画给程序员看的，它只是表达业务领域中的一个静态结构。</p><p><img src="/2022/04/12/%E6%9D%82%E9%A1%B9%E7%AC%94%E8%AE%B0/PPT%E4%B8%8E%E8%B6%85%E7%BA%A7%E6%B1%BD%E8%BD%A6%E7%B3%BB%E5%88%97%E4%B9%8BUML%E7%B1%BB%E5%9B%BE/img_15.png"></p><p>这是一个选课系统的简单领域分析UML类图。可以看到，主要实体有教师、学生、课程和开课安排。每个实体标注了其在业务上具有的属性和方法。而且图中还标明了实体间的关系。</p><p>但是，最终系统中可能没有一个学生类和其对应。 因为最终系统中有哪些类、各个类有什么属性、方法依赖于所选择的平台和架构。例如，如果使用了Struts2，则会存在很多Action类，而使用了ASP.NETMVC，则会有很多Controller类等，所以，领域UML类图只于业务有关，和具体实现及编码等计算机技术无关。</p><h4 id="实现UML类图"><a href="#实现UML类图" class="headerlink" title="实现UML类图"></a>实现UML类图</h4><p>产生于设计阶段，由系统设计师绘制，其作用是描述系统的架构结构、指导程序员编码。它包括系统中所有有必要指明的实体类、控制类、界面类及与具体平台有关的所有技术性信息。</p><p>就像上面的领域UML类图，如果你把它交给程序员编码，我想程序员会疯掉，因为它没有提供任何编码的依据。假如我们使用的是.NET平台分层架构，并使用ASP.NETMVC，则设计师应该在实现UML类图中绘制出所有的实体类、数据访问类、业务逻辑类和界面类，界面类又分为视图类、控制器类等等，还要表示出IoC和Aop等信息，并明确指出各个类的属性、方法，不能有遗漏，因为最终程序员实现程序的依据就是实现UML类图。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>最后，我们总结一下要点：</p><ul><li>软件分析与设计是编码前的两个阶段，其中分析仅与业务有关，而与技术无关。设计以分析为基础，主要与具体技术有关。</li><li>分析阶段由分析师绘制领域UML类图，设计阶段由设计师绘制实现UML类图。</li><li>领域UML类图表示系统的静态领域结构，其中的类不与最终程序中的类对应；设计UML类图表示系统的技术架构，是程序员的编码依据，其中的类与系统中的类对应。</li><li>领域UML类图中类的属性与操作仅关注与业务相关的部分，实现UML类图中的属性与操作要包括最终需要实现的全部方法与操作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是类图&quot;&gt;&lt;a href=&quot;#什么是类图&quot; class=&quot;headerlink&quot; title=&quot;什么是类图&quot;&gt;&lt;/a&gt;什么是类图&lt;/h3&gt;&lt;p&gt;类图(Class diagram)主要用于描述系统的结构化设计。类图也是最常用的UML图，用类图可以显示出类、接口以</summary>
      
    
    
    
    <category term="实用工具" scheme="http://example.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="UML" scheme="http://example.com/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>一个注解搞定重试机制之spring-retry框架</title>
    <link href="http://example.com/2022/04/11/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E4%B8%80%E4%B8%AA%E6%B3%A8%E8%A7%A3%E6%90%9E%E5%AE%9A%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%E4%B9%8Bspring-retry%E6%A1%86%E6%9E%B6/"/>
    <id>http://example.com/2022/04/11/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E4%B8%80%E4%B8%AA%E6%B3%A8%E8%A7%A3%E6%90%9E%E5%AE%9A%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6%E4%B9%8Bspring-retry%E6%A1%86%E6%9E%B6/</id>
    <published>2022-04-11T11:52:05.000Z</published>
    <updated>2022-04-13T08:22:34.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在实际工作中，重处理是一个非常常见的场景，比如:</p><ul><li>发送消息失败。</li><li>调用远程服务失败。</li><li>争抢锁失败。</li></ul><p>这些错误可能是因为网络波动造成的，等待过后重处理就能成功。</p><p>通常来说，会用try/catch，while循环之类的语法来进行重处理，但是这样的做法缺乏统一性，并且不是很方便，要多写很多代码。</p><p>然而spring-retry却可以通过注解，在不入侵原有业务逻辑代码的方式下，优雅的实现重处理功能。</p><h3 id="Retryable是什么？"><a href="#Retryable是什么？" class="headerlink" title="@Retryable是什么？"></a>@Retryable是什么？</h3><p>spring系列的spring-retry是另一个实用程序模块，可以帮助我们以标准方式处理任何特定操作的重试。</p><p>在spring-retry中，所有配置都是基于简单注释的。</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="POM依赖"><a href="#POM依赖" class="headerlink" title="POM依赖"></a>POM依赖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2.5.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="启用-Retryable"><a href="#启用-Retryable" class="headerlink" title="启用@Retryable"></a>启用@Retryable</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@EnableRetry</span><br><span class="line">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span><br><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext ctx = SpringApplication.run(Application.class, args);</span><br><span class="line">        // 针对404错误，抛出异常</span><br><span class="line">        DispatcherServlet dispatcherServlet = (DispatcherServlet) ctx.getBean(&quot;dispatcherServlet&quot;);</span><br><span class="line">        dispatcherServlet.setThrowExceptionIfNoHandlerFound(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在方法上添加-Retryable"><a href="#在方法上添加-Retryable" class="headerlink" title="在方法上添加@Retryable"></a>在方法上添加@Retryable</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class RetryServiceImpl implements IRetryService &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * value：抛出指定异常才会重试</span><br><span class="line">     * include：和value一样，默认为空，当exclude也为空时，默认所有异常</span><br><span class="line">     * exclude：指定不处理的异常</span><br><span class="line">     * maxAttempts：最大重试次数，默认3次</span><br><span class="line">     * backoff：重试等待策略，默认使用@Backoff，@Backoff的value默认为1000L，我们设置为2000L；multiplier（指定延迟倍数）默认为0，表示固定暂停1秒后进行重试，如果把multiplier设置为1.5，则第一次重试为2秒，第二次为3秒，第三次为4.5秒。</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    @Retryable(value = IllegalStateException.class, maxAttempts = 3, backoff = @Backoff(delay = 2000, multiplier = 1.5))</span><br><span class="line">    public int retryTest(int code) throws Exception &#123;</span><br><span class="line">        log.info(&quot;请求方法执行，时间: &#123;&#125;&quot;, System.currentTimeMillis());</span><br><span class="line">        if (code == 0) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;情况不对头！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;情况对头了！&quot;);</span><br><span class="line">        return 200;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单解释一下注解种几个参数的含义：</p><ul><li>value：抛出指定异常才会重试</li><li>include：和value一样，默认为空，当exclude也为空时，默认所有异常</li><li>exclude：指定不处理的异常</li><li>maxAttempts：最大重试次数，默认3次</li><li>backoff：重试等待策略，默认使用@Backoff，@Backoff的value默认为1000L，我们设置为2000L；multiplier（指定延迟倍数）默认为0，表示固定暂停1秒后进行重试，如果把multiplier设置为1.5，则第一次重试为2秒，第二次为3秒，第三次为4.5秒。</li></ul><p>当重试耗尽还是失败时，会出现什么情况呢？</p><p>当重试耗尽时，RetryOperations可以将控制传递给另一个回调，即RecoveryCallback。</p><p>Spring-Retry还提供了@Recover注解，用于@Retryable重试失败后处理方法。</p><p>如果不需要回调方法，可以直接不写回调方法，那么实现的效果是，重试次数完了后，如果还是没成功没符合业务判断，就抛出异常。</p><h4 id="Recover"><a href="#Recover" class="headerlink" title="@Recover"></a>@Recover</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Recover</span><br><span class="line">public int recover(IllegalStateException e, int code) &#123;</span><br><span class="line">    log.info(&quot;回调方法执行&quot;);</span><br><span class="line">    return 400;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到传参里面写的是 Exception e，这个是作为回调的接头暗号（重试次数用完了，还是失败，我们抛出这个Exception e通知触发这个回调方法）。</p><p>对于@Recover注解的方法，需要特别注意的是：</p><ul><li>方法的返回值必须与@Retryable方法一致</li><li>方法的第一个参数，必须是Throwable类型的，建议是与@Retryable配置的异常一致，其他的参数，需要哪个参数，写进去就可以了（@Recover方法中有的）</li><li>该回调方法与重试方法写在同一个实现类里面</li></ul><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>由于是基于AOP实现，所以不支持类里自调用方法</li><li>如果重试失败需要给@Recover注解的方法做后续处理，那这个重试的方法不能有返回值，只能是void</li><li>方法内不能使用try catch，只能往外抛异常</li><li>@Recover注解来开启重试失败后调用的方法(注意,需跟重处理方法在同一个类中)，此注解注释的方法参数一定要是@Retryable抛出的异常，否则无法识别，可以在该方法中进行日志处理。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在实际工作中，重处理是一个非常常见的场景，比如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送消息失败。&lt;/li&gt;
&lt;li&gt;调用远程服务失败。&lt;/li&gt;
</summary>
      
    
    
    
    <category term="实用工具" scheme="http://example.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
    <category term="重试" scheme="http://example.com/tags/%E9%87%8D%E8%AF%95/"/>
    
    <category term="工具" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Redis消息队列发展历程</title>
    <link href="http://example.com/2022/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Redis/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/"/>
    <id>http://example.com/2022/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Redis/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</id>
    <published>2022-04-08T11:20:43.000Z</published>
    <updated>2022-04-19T08:45:17.464Z</updated>
    
    <content type="html"><![CDATA[<p>文档说明： 转自<a href="https://mp.weixin.qq.com/s/gCUT5TcCQRAxYkTJfTRjJw">阿里开发者-阿里巴巴官方技术号</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis是目前最受欢迎的kv类数据库，当然它的功能越来越多，早已不限定在kv场景，消息队列就是Redis中一个重要的功能。</p><p>Redis从2010年发布1.0版本就具备一个消息队列的雏形，随着10多年的迭代，其消息队列的功能也越来越完善，作为一个全内存的消息队列，适合应用与要求高吞吐、低延时的场景。</p><p>我们来盘一下Redis消息队列功能的发展历程，历史版本有哪些不足，后续版本是如何来解决这些问题的。</p><p><img src="/2022/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Redis/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/img.png"></p><h2 id="Redis1-0-List"><a href="#Redis1-0-List" class="headerlink" title="Redis1.0 - List"></a>Redis1.0 - List</h2><p>从广义上来讲消息队列就是一个队列的数据结构。</p><p>生产者从队列一端放入消息，消费者从另一端读取消息，消息保证先入先出的顺序。</p><p>一个本地的list数据结构就是一个进程维度的消息队列，它可以让模块A写入消息，模块B消费消息，做到模块A/B的解耦与异步化。</p><p>但想要做到应用级别的解耦和异步还需要一个消息队列的服务。</p><h3 id="List的特性"><a href="#List的特性" class="headerlink" title="List的特性"></a>List的特性</h3><p>Redis 1.0发布时就具备了list数据结构，应用A可以通过lpush写入消息，应用B通过rpop从队列中读取消息，每个消息只会被读取一次，而且是按照lpush写入的顺序读到。同时Redis的接口是并发安全的，可以同时有多个生产者向一个list中生产消息，多个消费者从list中读取消息。</p><p>这里还有个问题，消费者要如何知道list中有消息了，需要不断轮询去查询吗。</p><p>轮询无法保证消息被及时的处理，会增加延时，而且当list为空时，大部分轮询的请求都是无效请求，这种方式大量浪费了系统资源。</p><p>好在Redis有<strong>brpop接口</strong>，该接口有一个参数是超时时间，如果list为空，那么Redis服务端不会立刻返回结果，它会等待list中有新数据后在返回或是等待最多一个超时时间后返回空。</p><p>通过brpop接口实现了<strong>长轮询</strong>，该效果等同于服务端推送，消费者能立刻感知到新的消息，而且通过设置合理的超时时间，使系统资源的消耗降到很低。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">基于list完成消息的生产和消费</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">生产者生产消息msg1</span></span><br><span class="line">lpush listA msg1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">消费者读取到消息msg1</span></span><br><span class="line">rpop listA</span><br><span class="line">&quot;msg1&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">消费者阻塞式读取listA，如果有数据立刻返回，否则最多等待10秒</span></span><br><span class="line">brpop listA 10 </span><br><span class="line">1) &quot;listA&quot;</span><br><span class="line">2) &quot;msg1&quot;</span><br></pre></td></tr></table></figure><p><img src="/2022/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Redis/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/img_1.png"></p><p>使用rpop或brpop这样接口消费消息会先从队列中删除消息，然后再由应用消费，如果应用应用在处理消息前异常宕机了，<strong>消息就丢失了</strong>。</p><p>但如果使用lindex这样的只读命令先读取消息处理完毕后在删除，又需要额外的机制来<strong>保证一条消息不会被其他消费者重复读到</strong>。</p><p>好在list有<strong>rpoplpush或brpoplpush</strong>这样的接口，可以原子性的从一个list中移除一个消息并加入另一个list。</p><p>应用程序可以<strong>通过2个list组和来完成消息的消费和确认功能</strong>，使用rpoplpush从list A中消费消息并移入list B，等消息处理完毕后在从list B中删除消息，如果在处理消息过程中应用异常宕机，恢复后应用可以重新从list B中读取未处理的消息并处理。</p><p><strong>这种方式为消息的消费增加了ack机制</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">基于2个list完成消息消费和确认</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">从listA中读取消息并写入listB</span></span><br><span class="line">rpoplpush listA listB</span><br><span class="line">&quot;msg1&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">业务逻辑处理msg1完毕后，从listB中删除msg1，完成消息的确认</span></span><br><span class="line">lrem listB 1 msg1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><img src="/2022/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Redis/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/img_2.png"></p><h3 id="List的不足之处"><a href="#List的不足之处" class="headerlink" title="List的不足之处"></a>List的不足之处</h3><p>通过Redis 1.0就引入的list结构我们就能实现一个分布式的消息队列，满足一些简单的业务需求。</p><p>但list结构作为消息队列服务有一个很致命的问题，它<strong>没有广播功能，一个消息只能被消费一次</strong>。</p><p>而在大型系统中，通常一个消息会被下游多个应用同时订阅和消费，例如当用户完成一个订单的支付操作时，需要通知商家发货，要更新物流状态，可能还会提高用户的积分和等级，这些都是不同的下游子系统，他们全部会订阅支付完成的操作，而list一个消息只能被消费一次在这样复杂的大型系统面前就捉襟见肘了。</p><p>可能你会说那弄多个list，生产者向每个list中都投递消息，每个消费者处理自己的list不就行了吗。这样第一是性能不会太好，因为同一个消息需要被重复的投递，第二是这样的设计违反了生产者和消费者解耦的原则，这个设计下生产者需要知道下游有哪些消费者，如果业务发生变化，需要额外增加一个消费者，生产者的代码也需要修改。</p><h3 id="List总结"><a href="#List总结" class="headerlink" title="List总结"></a>List总结</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul><li>模型简单，和使用本地list基本相同，适配容易</li><li>通过brpop做到消息处理的实时性 </li><li>通过rpoplpush来联动2个list，可以做到消息先消费后确认，避免消费者应用异常情况下消息丢失</li></ul><h4 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h4><ul><li>消息只能被消费一次，缺乏广播机制</li></ul><h2 id="Redis2-0-Pub-Sub"><a href="#Redis2-0-Pub-Sub" class="headerlink" title="Redis2.0 - Pub/Sub"></a>Redis2.0 - Pub/Sub</h2><p>list作为消息队列应用场景受到限制很重要的原因在于没有广播，所以Redis 2.0中引入了一个新的数据结构 pubsub 。</p><p>pubsub虽然不能算作是list的替代品，但它确实能解决一些list不能解决的问题。</p><h3 id="pubsub特性"><a href="#pubsub特性" class="headerlink" title="pubsub特性"></a>pubsub特性</h3><p>pubsub引入一个概念叫channel，生产者通过publish接口投递消息时会指定channel，消费者通过subscribe接口订阅它关心的channel，调用subscribe后这条连接会进入一个特殊的状态，通常不能在发送其他请求，当有消息投递到这个channel时Redis服务端会立刻通过该连接将消息推送到消费者。</p><p>这里一个channel可以被多个应用订阅，消息会同时投递到每个订阅者，做到了消息的广播。</p><p>另一方面，消费者可以会订阅一批channel，例如一个用户订阅了浙江的新闻的推送，但浙江新闻还会进行细分，例如“浙江杭州xx”、“浙江温州xx”，这里订阅者不需要获取浙江的所有子类在挨个订阅，只需要调用psubscribe“浙江*”就能订阅所有以浙江开头的新闻推送了，这里psubscribe传入一个通配符表达的channel，Redis服务端按照规则推送所有匹配channel的消息给对应的客户端。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">基于pubsub完成channel的匹配和消息的广播</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">消费者1订阅channel1</span></span><br><span class="line">subscribe channel1</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel1&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash">收到消息推送</span></span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;channel1&quot;</span><br><span class="line">3) &quot;msg1&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">消费者2订阅channel*</span></span><br><span class="line">psubscribe channel*</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;channel*&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash">收到消息推送</span></span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;channel*&quot;</span><br><span class="line">3) &quot;channel1&quot;</span><br><span class="line">4) &quot;msg1&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;channel*&quot;</span><br><span class="line">3) &quot;channel2&quot;</span><br><span class="line">4) &quot;msg2&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">生产者发布消息msg1和msg2</span></span><br><span class="line">publish channel1 msg1</span><br><span class="line">(integer) 2</span><br><span class="line">publish channel2 msg2</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><img src="/2022/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Redis/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/img_3.png"></p><p>在Redfis 2.8时加入了<a href="https://blog.51cto.com/u_15346415/5188764">keyspace notifications功能</a></p><p>此时pubsub除了通知用户自定义消息，也可以通知系统内部消息。</p><p>keyspace notifications引入了2个特殊的channel分别是 <code>__keyevent@&lt;db&gt;__:&lt;event&gt;</code> 和 <code>__keyspace@&lt;db&gt;__:&lt;key&gt;</code>, 可以通过开启配置notify-keyspace-events使用</p><details><summary>notify-keyspace-events</summary>服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型：<p>可以设置的类型如下：</p><ul><li>想让服务器发送所有类型的键空间通知和键事件通知，可以将选项的值设置为AKE</li><li>想让服务器发送所有类型的键空间通知，可以将选项的值设置为AK</li><li>想让服务器发送所有类型的键事件通知，可以将选项的值设置为AE</li><li>想让服务器只发送和字符串键有关的键空间通知，可以将选项的值设置为K$</li><li>想让服务器只发送和列表键有关的键事件通知，可以将选项的值设置为El<br>备注：notify-keyspace-events选项的默认值为空，所以如果不设置上面的值，SUBSCRIBE命令不会有任何效果</li></ul></details><p><strong>键空间通知</strong></p><p>某个键执行了什么命令, 通过订阅__keyspace客户端可以收到目标key的增删改操作以及过期事件。</p><details><summary>键空间通知演示案例</summary><ol><li><p>先将notify-keyspace-events选项设置为“AKE”，表示服务器可以发送所有类型的键空间通知和键事件通知</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG SET notify-keyspace-events AKE</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET notify-keyspace-events</span><br><span class="line">1) &quot;notify-keyspace-events&quot;</span><br><span class="line">2) &quot;AKE&quot;</span><br></pre></td></tr></table></figure></li><li><p>使用下面命令开启对0号数据库中的message键的监视，可以获取其通知消息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE __keyspace@0__:message</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;__keyspace@0__:message&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure></li><li><p>我们在另一个客户端命令行先后用SET、EXPIRE、DEL三个命令对键message进行了操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```shell</span><br><span class="line">127.0.0.1:6379&gt; set message HellowWorld</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; expire message 500</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; del message</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p>可以看到监听一端接收到了服务端发来的message键更改的通知</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE __keyspace@0__:message</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;__keyspace@0__:message&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line"></span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;__keyspace@0__:message&quot;</span><br><span class="line">3) &quot;set&quot;</span><br><span class="line">4) &quot;message&quot;</span><br><span class="line">5) &quot;__keyspace@0__:message&quot;</span><br><span class="line">6) &quot;expire&quot;</span><br><span class="line">7) &quot;message&quot;</span><br><span class="line">8) &quot;__keyspace@0__:message&quot;</span><br><span class="line">9) &quot;del&quot;</span><br></pre></td></tr></table></figure></li></ol></details><p><strong>键事件通知</strong></p><p>某个命令被什么键执行了, 通过订阅__keyevent客户端可以收到某个具体命令调用的回调通知，</p><details><summary>键事件通知演示案例</summary>  <ol><li><p>先将notify-keyspace-events选项设置为“AKE”，表示服务器可以发送所有类型的键空间通知和键事件通知</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CONFIG SET notify-keyspace-events AKE</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; CONFIG GET notify-keyspace-events</span><br><span class="line">1) &quot;notify-keyspace-events&quot;</span><br><span class="line">2) &quot;AKE&quot;</span><br></pre></td></tr></table></figure></li><li><p>下面代码展示了客户端如何获取0号数据库中所有执行DEL命令的键</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE __keyevent@0__:del</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;__keyevent@0__:del&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure></li><li><p>我们在另一个客户端命令行执行2次del命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del key</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; del message</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure></li><li><p>可以看到监听一端接收到了服务端发来的del通知</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE __keyevent@0__:del</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;__keyevent@0__:del&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line"></span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;__keyevent@0__:del&quot;</span><br><span class="line">3) &quot;key&quot;</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;__keyevent@0__:del&quot;</span><br><span class="line">3) &quot;message&quot;</span><br></pre></td></tr></table></figure></li></ol></details><h3 id="pubsub的不足之处"><a href="#pubsub的不足之处" class="headerlink" title="pubsub的不足之处"></a>pubsub的不足之处</h3><p>pubsub既能单播又能广播，还支持channel的简单正则匹配，功能上已经能满足大部分业务的需求，而且这个接口发布的时间很早，在2011年Redis 2.0发布时就已经具备，用户基础很广泛，所以现在很多业务都有用到这个功能。</p><p>但你要深入了解pubsub的原理后，是肯定不敢把它作为一个一致性要求较高，数据量较大系统的消息服务的。</p><p>首先，pubsub的消息数据是瞬时的，它在Redis服务端不做保存，publish发送到Redis的消息会立刻推送到所有当时subscribe连接的客户端，如果当时客户端因为网络问题断连，那么就会错过这条消息，当客户端重连后，它没法重新获取之前那条消息，甚至无法判断是否有消息丢失。</p><p>其次，pubsub中消费者获取消息是一个推送模型，这意味着Redis会按消息生产的速度给所有的消费者推送消息，不管消费者处理能力如何，如果消费者应用处理能力不足，消息就会在Redis的client buf中堆积，当堆积数据超过一个阈值后会断开这条连接，这意味着这些消息全部丢失了，在也找不回来了。如果同时有多个消费者的client buf堆积数据但又还没达到断开连接的阈值，那么Redis服务端的内存会膨胀，进程可能因为oom而被杀掉，这导致了整个服务中断。</p><h3 id="pubsub总结"><a href="#pubsub总结" class="headerlink" title="pubsub总结"></a>pubsub总结</h3><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ul><li>消息具备广播能力</li><li>psubscribe能按字符串通配符匹配，给予了业务逻辑的灵活性</li><li>能订阅特定key或特定命令的系统消息<h4 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h4></li><li>Redis异常、客户端断连都会导致消息丢失</li><li>消息缺乏堆积能力，不能削峰填谷。推送的方式缺乏背压机制，没有考虑消费者处理能力，推送的消息超过消费者处理能力后可能导致消息丢失或服务异常。</li></ul><h2 id="Redis5-0-stream"><a href="#Redis5-0-stream" class="headerlink" title="Redis5.0 - stream"></a>Redis5.0 - stream</h2><p>消息丢失、消息服务不稳定的问题严重限制了pubsub的应用场景，所以Redis需要重新设计一套机制，来解决这些问题，这就有了后来的stream结构。</p><h3 id="stream特性"><a href="#stream特性" class="headerlink" title="stream特性"></a>stream特性</h3><p>一个稳定的消息服务需要具备几个要点：</p><ul><li>要保证消息不会丢失</li><li>至少被消费一次，</li><li>要具备削峰填谷的能力，来匹配生产者和消费者吞吐的差异。</li></ul><p>在2018年Redis 5.0加入了stream结构，这次考虑了list、pubsub在应用场景下的缺陷，对标kafka的模型重新设计全内存消息队列结构，从这时开始Redis消息队列功能算是能和主流消息队列产品pk一把了。</p><p><img src="/2022/04/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/MQ/Redis/Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/img_4.png"></p><p>stream的改进分为多个方面</p><p><strong>成本</strong>：</p><ul><li>存储message数据使用了listpack结构，这是一个紧凑型的数据结构，不同于list的双向链表每个节点都要额外占用2个指针的存储空间，这使得小msg情况下stream的空间利用率更高。</li></ul><p><strong>功能</strong>：</p><ul><li>stream引入了消费者组的概念，一个消费者组内可以有多个消费者，同一个组内的消费者共享一个消息位点（last_delivered_id），这使得消费者能够水平的扩容，可以在一个组内加入多个消费者来线性的提升吞吐，对于一个消费者组，每条msg只会被其中一个消费者获取和处理，这是pubsub的广播模型不具备的。</li><li>不同消费者组之前是相互隔离的，他们各自维护自己的位点，这使得一条msg能被多个不同的消费者组重复消费，做到了消息广播的能力。</li><li>stream中消费者采用拉取的方式，并能设置timeout在没有消息时阻塞，通过这种长轮询机制保证了消息的实时性，而且消费速率是和消费者自身吞吐相匹配。</li></ul><p><strong>消息不丢失</strong>：</p><ul><li>stream的数据会存储在aof和rdb文件中，这使Redis重启后能够恢复stream的数据。而pubsub的数据是瞬时的，Redis重启意味着消息全部丢失。</li><li>stream中每个消费者组会存储一个last_delivered_id来标识已经读取到的位点，客户端连接断开后重连还是能从该位点继续读取，消息不会丢失。</li><li>stream引入了ack机制保证消息至少被处理一次。<ul><li>考虑一种场景，如果消费者应用已经读取了消息，但还没来得及处理应用就宕机了，对于这种已经读取但没有ack的消息，stream会标示这条消息的状态为pending，等客户端重连后通过xpending命令可以重新读取到pengind状态的消息，继续处理。</li><li>如果这个应用永久宕机了，那么该消费者组内的其他消费者应用也能读取到这条消息，并通过xclaim命令将它归属到自己下面继续处理。</li></ul></li></ul><details><summary>基于stream完成消息的生产和消费，并确保异常状态下消息至少被消费一次</summary><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建mystream，并且创建一个consumergroup为mygroup</span></span><br><span class="line">XGROUP CREATE mystream mygroup $ MKSTREAM</span><br><span class="line">OK</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">写入一条消息，由redis自动生成消息id，消息的内容是一个kv数组，这里包含field1 value1 field2 value2</span></span><br><span class="line">XADD mystream * field1 value1 field2 value2</span><br><span class="line">&quot;1645517760385-0&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">消费者组mygroup中的消费者consumer1从mystream读取一条消息，&gt;表示读取一条该消费者组从未读取过的消息</span></span><br><span class="line">XREADGROUP GROUP mygroup consumer1 COUNT 1 STREAMS mystream &gt;</span><br><span class="line">1) 1) &quot;mystream&quot;</span><br><span class="line">   2) 1) 1) &quot;1645517760385-0&quot;</span><br><span class="line">         2) 1) &quot;field1&quot;</span><br><span class="line">            2) &quot;value1&quot;</span><br><span class="line">            3) &quot;field2&quot;</span><br><span class="line">            4) &quot;value2&quot;</span><br><span class="line">            </span><br><span class="line"><span class="meta">#</span><span class="bash">消费完成后ack确认消息</span></span><br><span class="line">xack mystream mygroup 1645517760385-0</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果消费者应用在ack前异常宕机，恢复后重新获取未处理的消息id。</span></span><br><span class="line">XPENDING mystream mygroup - + 10 </span><br><span class="line">1) 1) &quot;1645517760385-0&quot;</span><br><span class="line">   2) &quot;consumer1&quot;</span><br><span class="line">   3) (integer) 305356</span><br><span class="line">   4) (integer) 1</span><br><span class="line">   </span><br><span class="line"><span class="meta"> #</span><span class="bash">如果consumer1永远宕机，其他消费者可以把pending状态的消息移动到自己名下后继续消费</span></span><br><span class="line"><span class="meta"> #</span><span class="bash">将消息id 1645517760385-0移动到consumer2下</span></span><br><span class="line"> XCLAIM mystream mygroup consumer2 0 1645517760385-0</span><br><span class="line"> 1) 1) &quot;1645517760385-0&quot;</span><br><span class="line">   2) 1) &quot;field1&quot;</span><br><span class="line">      2) &quot;value1&quot;</span><br><span class="line">      3) &quot;field2&quot;</span><br><span class="line">      4) &quot;value2&quot;</span><br></pre></td></tr></table></figure></details><p>Redis stream保证了消息至少被处理一次，但如果想做到每条消息仅被处理一次还需要应用逻辑的介入。</p><p>消息被重复处理要么是生产者重复投递，要么是消费者重复消费。</p><ul><li><p>对于生产者重复投递问题，Redis stream为每个消息都设置了一个唯一递增的id，通过参数可以让Redis自动生成id或者应用自己指定id，应用可以根据业务逻辑为每个msg生成id，当xadd超时后应用并不能确定消息是否投递成功，可以通过xread查询该id的消息是否存在，存在就说明已经投递成功，不存在则重新投递，而且stream限制了id必须递增，这意味了已经存在的消息重复投递会被拒绝。这套机制保证了每个消息可以仅被投递一次。</p></li><li><p>对于消费者重复消费的问题，考虑一个场景，消费者读取消息后业务处理完毕，但还没来得及ack就发生了异常，应用恢复后对于这条没有ack的消息进行了重复消费。这个问题因为ack和消费消息的业务逻辑发生在2个系统，没法做到事务性，需要业务来改造，保证消息处理的幂等性。</p></li></ul><h3 id="stream的不足"><a href="#stream的不足" class="headerlink" title="stream的不足"></a>stream的不足</h3><p>stream的模型做到了消息的高效分发，而且保证了消息至少被处理一次，通过应用逻辑的改造能做到消息仅被处理一次，它的能力对标kafka，但吞吐高于kafka，在高吞吐场景下成本比kafka低，那它又有哪些不足了。</p><p>首先消息队列很重要的一个功能就是削峰填谷，来匹配生产者和消费者吞吐的差异，生产者和消费者吞吐差异越大，持续时间越长，就意味着steam中需要堆积更多的消息，而Redis作为一个全内存的产品，<strong>数据堆积的成本比磁盘高</strong>。</p><p>其次stream通过ack机制保证了消息至少被消费一次，但这有个<strong>前提</strong>就是存储在Redis中的消息本身不会丢失。</p><ul><li>Redis数据的持久化依赖aof和rdb文件，aof落盘方式有几种，通过配置appendfsync决定，通常我们不会配置为always来让每条命令执行完后都做一次fsync，线上配置一般为everysec，每秒做一次fsync，而rdb是全量备份时生成，这意味了宕机恢复可能会丢掉最近一秒的数据。</li><li>另一方面线上生产环境的Redis都是高可用架构，当主节点宕机后通常不会走恢复逻辑，而是直接切换到备节点继续提供服务，而Redis的同步方式是异步同步，这意味着主节点上新写入的数据可能还没同步到备节点，在切换后这部分数据就丢失了。所以在<strong>故障恢复中Redis中的数据可能会丢失一部分</strong>，在这样的背景下无论stream的接口设计的多么完善，都不能保证消息至少被消费一次。</li></ul><h3 id="stream总结"><a href="#stream总结" class="headerlink" title="stream总结"></a>stream总结</h3><h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><ul><li>在成本、功能上做了很多改进，支持了紧凑的存储小消息、具备广播能力、消费者能水平扩容、具备背压机制</li><li>通过ack机制保证了Redis服务端<strong>正常情况下</strong>消息至少被处理一次的能力</li></ul><h4 id="不足-2"><a href="#不足-2" class="headerlink" title="不足"></a>不足</h4><ul><li>内存型消息队列，数据堆积成本高</li><li>Redis本身rpo&gt;0，故障恢复可能会丢数据，所以stream在Redis发生故障恢复后也<strong>不能保证</strong>消息至少被消费一次。</li></ul><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>消息队列主要是为了解决3类问题，应用模块的解耦、消息的异步化、削峰填谷。</p><p>目前主流的消息队列都能满足这些需求，所以在实际选型时还会考虑一些特殊的功能是否满足，产品的性能如何，具体业务场景下的成本怎么样，开发的复杂度等。</p><p>Redis的消息队列功能并不是最全面的，它不希望做成一个大而全的产品，而是做一个小而美的产品，服务好一部分用户在某些场景下的需求。</p><p>目前用户选型Redis作为消息队列服务的原因，主要有Redis在相同成本下吞吐更高、Redis的延时更低、应用需要一个消息服务但又不想额外引入一堆依赖等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文档说明： 转自&lt;a href=&quot;https://mp.weixin.qq.com/s/gCUT5TcCQRAxYkTJfTRjJw&quot;&gt;阿里开发者-阿里巴巴官方技术号&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="MQ" scheme="http://example.com/tags/MQ/"/>
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>AOP实现机制详解与字节码编排技术</title>
    <link href="http://example.com/2022/04/07/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E6%8E%92%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2022/04/07/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E6%8E%92%E6%8A%80%E6%9C%AF/</id>
    <published>2022-04-07T11:20:11.000Z</published>
    <updated>2022-04-18T01:58:00.451Z</updated>
    
    <content type="html"><![CDATA[<img src="/2022/04/07/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E6%8E%92%E6%8A%80%E6%9C%AF/04/07/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E6%8E%92%E6%8A%80%E6%9C%AF/%E5%AD%97%E8%8A%82%E7%A0%81%E5%A2%9E%E5%BC%BA.jpg" class><p>文章说明： 转载自<a href="https://blog.csdn.net/qq_32115439/article/details/78361596">Java-AOP(Hook)实现机制(JDK/cglib动态代理/ASM/Javassist/AspectJ)</a></p><h2 id="AOP的各种实现"><a href="#AOP的各种实现" class="headerlink" title="AOP的各种实现"></a>AOP的各种实现</h2><p>AOP就是面向切面编程，我们可以从几个层面来实现AOP。 </p><p>AOP实现时有三种方式：</p><ul><li>生成子类字节码</li><li>生成代理类字节码</li><li>直接修改原类的字节码。</li></ul><p><img src="/2022/04/07/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E6%8E%92%E6%8A%80%E6%9C%AF/img.png"></p><p>在编译器修改源代码，在运行期字节码加载前修改字节码或字节码加载后动态创建代理类的字节码，以下是各种实现机制的比较。 </p><table><thead><tr><th>类别</th><th>机制</th><th>原理</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>静态AOP</td><td>静态织入</td><td>在编译期，切面直接以字节码的形式编译到目标字节码文件中。</td><td>对系统无性能影响。</td><td>灵活性不够。</td></tr><tr><td>动态AOP</td><td>动态代理</td><td>在运行期，目标类加载后，为接口动态生成代理类，将切面植入到代理类中。</td><td>相对于静态AOP更加灵活。</td><td>切入的关注点需要实现接口。对系统有一点性能影响。</td></tr><tr><td>动态字节码生成</td><td>在运行期，目标类加载后，动态构建字节码文件生成目标类的子类，将切面逻辑加入到子类中。</td><td>没有接口也可以织入。</td><td>扩展类的实例方法为final时，则无法进行织入。</td><td></td></tr><tr><td>自定义类加载器</td><td>在运行期，目标加载前，将切面逻辑加到目标字节码里。</td><td>可以对绝大部分类进行织入。</td><td>代码中如果使用了其他类加载器，则这些类将不会被织入。</td><td></td></tr><tr><td>字节码转换</td><td>在运行期，所有类加载器加载字节码前，前进行拦截。</td><td>可以对所有类进行织入。</td><td></td><td></td></tr></tbody></table><h2 id="AOP中的公民"><a href="#AOP中的公民" class="headerlink" title="AOP中的公民"></a>AOP中的公民</h2><ul><li>Joinpoint：拦截点，如某个业务方法。</li><li>Pointcut：Joinpoint的表达式，表示拦截哪些方法。一个Pointcut对应多个Joinpoint。</li><li>Advice:  要切入的逻辑。</li><li>Before Advice 在方法前切入。</li><li>After Advice 在方法后切入，抛出异常时也会切入。</li><li>After Returning Advice 在方法返回后切入，抛出异常则不会切入。</li><li>After Throwing Advice 在方法抛出异常时切入。</li><li>Around Advice 在方法执行前后切入，可以中断或忽略原有流程的执行。</li></ul><h3 id="公民之间的关系"><a href="#公民之间的关系" class="headerlink" title="公民之间的关系"></a>公民之间的关系</h3><p><img src="/2022/04/07/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E6%8E%92%E6%8A%80%E6%9C%AF/img_1.png"></p><p>织入器通过在切面中定义pointcut来搜索目标（被代理类）的JoinPoint(切入点)，然后把要切入的逻辑（Advice）织入到目标对象里，生成代理类。</p><h2 id="AOP的实现机制"><a href="#AOP的实现机制" class="headerlink" title="AOP的实现机制"></a>AOP的实现机制</h2><h3 id="动态代理-JavaAgent"><a href="#动态代理-JavaAgent" class="headerlink" title="动态代理-JavaAgent"></a>动态代理-JavaAgent</h3><h3 id="动态字节码生成-Cglib"><a href="#动态字节码生成-Cglib" class="headerlink" title="动态字节码生成-Cglib"></a>动态字节码生成-Cglib</h3><p>使用动态字节码生成技术实现AOP原理是在运行期间目标字节码加载后，生成目标类的子类，将切面逻辑加入到子类中，所以<strong>使用Cglib实现AOP不需要基于接口</strong>。</p><p><img src="/2022/04/07/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E6%8E%92%E6%8A%80%E6%9C%AF/img_2.png"></p><p>Cglib是一个强大的,高性能的Code生成类库，它可以在运行期间扩展Java类和实现Java接口，它封装了<strong>Asm</strong>，所以使用Cglib前需要引入Asm的jar。</p><details><summary>使用CGLib实现AOP</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;   </span><br><span class="line">    byteCodeGe();   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void byteCodeGe() &#123; </span><br><span class="line">//创建一个织入器 </span><br><span class="line">Enhancer enhancer = new Enhancer(); </span><br><span class="line">//设置父类 </span><br><span class="line">enhancer.setSuperclass(Business.class); </span><br><span class="line">//设置需要织入的逻辑 </span><br><span class="line">enhancer.setCallback(new LogIntercept()); </span><br><span class="line">//使用织入器创建子类 </span><br><span class="line">IBusiness2 newBusiness = (IBusiness2) enhancer.create(); </span><br><span class="line">newBusiness.doSomeThing2(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**  </span><br><span class="line"> * 记录日志  </span><br><span class="line"> */   </span><br><span class="line">public static class LogIntercept implements MethodInterceptor &#123;   </span><br><span class="line">    @Override   </span><br><span class="line">    public Object intercept(Object target, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123;   </span><br><span class="line">        //执行原有逻辑，注意这里是invokeSuper   </span><br><span class="line">        Object rev = proxy.invokeSuper(target, args);   </span><br><span class="line">        //执行织入的日志   </span><br><span class="line">        if (method.getName().equals(&quot;doSomeThing2&quot;)) &#123;   </span><br><span class="line">            System.out.println(&quot;记录日志&quot;);   </span><br><span class="line">        &#125;   </span><br><span class="line">        return rev;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></details><h2 id="自定义类加载器-Javassist"><a href="#自定义类加载器-Javassist" class="headerlink" title="自定义类加载器-Javassist"></a>自定义类加载器-Javassist</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2022/04/07/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/AOP%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AD</summary>
      
    
    
    
    <category term="JAVA基础" scheme="http://example.com/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="动态代理" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
    <category term="字节码编排" scheme="http://example.com/tags/%E5%AD%97%E8%8A%82%E7%A0%81%E7%BC%96%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>JavaAgent动态代理实现及原理详细分析</title>
    <link href="http://example.com/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</id>
    <published>2022-04-02T08:35:54.000Z</published>
    <updated>2022-04-07T07:22:23.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。</p><p>代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。</p><p>简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。</p><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img.png"></p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口，被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。</p><h3 id="静态代理简单实现"><a href="#静态代理简单实现" class="headerlink" title="静态代理简单实现"></a>静态代理简单实现</h3><p>假设现在项目经理有一个需求：在项目现有所有类的方法前后打印日志。</p><p>你如何在不修改已有代码的前提下，完成这个需求？</p><ol><li>为现有的每一个类都编写一个对应的代理类，并且让它实现和目标类相同的接口（假设都有）</li></ol><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_1.png"></p><ol start="2"><li>在创建代理对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后打印日志。也就是说，<strong>代理对象 = 增强代码 + 目标对象（原对象）</strong>。有了代理对象后，就不用原对象了</li></ol><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_2.png"></p><h3 id="静态代理的缺陷"><a href="#静态代理的缺陷" class="headerlink" title="静态代理的缺陷"></a>静态代理的缺陷</h3><p>程序员要手动为每一个目标类编写对应的代理类。</p><p>如果当前系统已经有成百上千个类，工作量太大了。</p><p>所以，现在我们的努力方向是：如何少写或者不写代理类，却能完成代理功能？</p><h2 id="复习对象创建"><a href="#复习对象创建" class="headerlink" title="复习对象创建"></a>复习对象创建</h2><p>对于很多初学JAVA的朋友而言，创建对象的过程大概如下图： </p><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_3.png"></p><p>实际上，我们也可以换个角度来说</p><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_4.png"></p><p>所谓的Class对象，是Class类的实例，而Class类是描述所有类的，比如Person类，Student类<img src="https://pic1.zhimg.com/50/v2-c9bf695b1b9d2a0ae01cf92501492159_720w.jpg?source=1940ef5c" data-caption data-size="normal" data-rawwidth="563" data-rawheight="454" data-default-watermark-src="https://pic3.zhimg.com/50/v2-cbd87cbe037bde814221c7584cd60f4e_720w.jpg?source=1940ef5c" class="origin_image zh-lightbox-thumb" width="563" data-original="https://pica.zhimg.com/v2-c9bf695b1b9d2a0ae01cf92501492159_r.jpg?source=1940ef5c"></p><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_5.png"></p><p>可以看出，要创建一个实例，最关键的就是<strong>得到对应的Class对象</strong>。</p><p>分析到这里，貌似有了思路：</p><p><strong>能否不写代理类，而直接得到代理Class对象，然后根据它创建代理实例（反射）。</strong></p><p>Class对象包含了一个类的所有信息，比如构造器、方法、字段等。如果我们不写代理类，这些信息从哪获取呢？</p><p>代理类和目标类理应<strong>实现同一组接口</strong>。</p><ul><li>之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写。</li></ul><p>还是上面这幅图：</p><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_6.png"></p><p>所以，可以这样说：接口拥有代理对象和目标对象共同的类信息。</p><p>所以，我们可以从接口那得到理应由代理类提供的信息。但是别忘了，接口是无法创建对象的，怎么办？</p><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>代理类在程序运行时创建的代理方式被成为动态代理。 </p><p>在静态代理的例子中，代理类是自己定义好的，在程序运行之前就已经编译完成。</p><p>然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。</p><p>相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。</p><h3 id="JDK动态代理的简单实现"><a href="#JDK动态代理的简单实现" class="headerlink" title="JDK动态代理的简单实现"></a>JDK动态代理的简单实现</h3><p>JDK提供了java.lang.reflect.InvocationHandler接口和 java.lang.reflect.Proxy类，这两个类相互配合，入口是Proxy，所以我们先聊它。</p><p>Proxy有个静态方法：getProxyClass(ClassLoader, interfaces)，只要你给它传入类加载器和一组接口，它就给你返回代理Class对象。</p><p>用通俗的话说，getProxyClass()这个方法，会从你传入的接口Class中，“拷贝”类结构信息到一个新的Class对象中，但新的Class对象带有构造器，是可以创建对象的。</p><p>打个比方，一个大内太监（接口Class），空有一身武艺（类信息），但是无法传给后人。现在江湖上有个妙手神医（Proxy类），发明了克隆大法（getProxyClass），不仅能克隆太监的一身武艺，还保留了小DD（构造器）…</p><p>所以，一旦我们明确接口，完全可以通过接口的Class对象，创建一个代理Class，通过代理Class即可创建代理对象。</p><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_7.png"></p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_8.png" class title="静态代理"><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_9.png" class title="动态代理"><p>所以，按我理解，Proxy.getProxyClass()这个方法的本质就是：以Class造Class。</p><p>有了Class对象，就很好办了，具体看代码：</p><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_10.png"></p><p>完美。</p><p>根据代理Class的构造器创建对象时，需要传入InvocationHandler。每次调用代理对象的方法，最终都会调用InvocationHandler的invoke()方法：</p><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_11.png"></p><p>怎么做到的呢？</p><p>根据代理Class的构造器创建对象时，需要传入InvocationHandler。通过构造器传入一个引用，那么必然有个成员变量去接收。没错，代理对象的内部确实有个成员变量invocationHandler，而且代理对象的每个方法内部都会调用handler.invoke()！InvocationHandler对象成了代理对象和目标对象的桥梁，不像静态代理这么直接。</p><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_12.png"></p><p>大家仔细看上图右侧的动态代理，我在invocationHandler的invoke()方法中并没有写目标对象。因为一开始invocationHandler的invoke()里确实没有目标对象，需要我们手动new。</p><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_13.png"></p><p>但这种写法不够优雅，属于硬编码。我这次代理A对象，下次想代理B对象还要进来改invoke()方法，太差劲了。改进一下，让调用者把目标对象作为参数传进来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">CalculatorImpl target = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line">                <span class="comment">//传入目标对象</span></span><br><span class="line">                <span class="comment">//目的：1.根据它实现的接口生成代理对象 2.代理对象调用目标对象方法</span></span><br><span class="line">Calculator calculatorProxy = (Calculator) getProxy(target);</span><br><span class="line">calculatorProxy.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">calculatorProxy.subtract(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(<span class="keyword">final</span> Object target)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//参数1：随便找个类加载器给它， 参数2：目标对象实现的接口，让代理对象实现相同接口</span></span><br><span class="line">Class proxyClazz = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces());</span><br><span class="line">Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class);</span><br><span class="line">Object proxy = constructor.newInstance(<span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">System.out.println(method.getName() + <span class="string">&quot;方法开始执行...&quot;</span>);</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">System.out.println(result);</span><br><span class="line">System.out.println(method.getName() + <span class="string">&quot;方法执行结束...&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就非常灵活，非常优雅了。无论现在系统有多少类，只要你把实例传进来，getProxy()都能给你返回对应的代理对象。就这样，我们完美地跳过了代理类，直接创建了代理对象！</p><p>不过实际编程中，一般不用getProxyClass()，而是使用Proxy类的另一个静态方法：Proxy.newProxyInstance()，直接返回代理实例，连中间得到代理Class对象的过程都帮你隐藏：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">CalculatorImpl target = <span class="keyword">new</span> CalculatorImpl();</span><br><span class="line">Calculator calculatorProxy = (Calculator) getProxy(target);</span><br><span class="line">calculatorProxy.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">calculatorProxy.subtract(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(<span class="keyword">final</span> Object target)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Object proxy = Proxy.newProxyInstance(</span><br><span class="line">target.getClass().getClassLoader(),<span class="comment">/*类加载器*/</span></span><br><span class="line">target.getClass().getInterfaces(),<span class="comment">/*让代理对象和目标对象实现相同接口*/</span></span><br><span class="line"><span class="keyword">new</span> InvocationHandler()&#123;<span class="comment">/*代理对象的方法最终都会被JVM导向它的invoke方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">System.out.println(method.getName() + <span class="string">&quot;方法开始执行...&quot;</span>);</span><br><span class="line">Object result = method.invoke(target, args);</span><br><span class="line">System.out.println(result);</span><br><span class="line">System.out.println(method.getName() + <span class="string">&quot;方法执行结束...&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我想应该能看懂动态代理了。</p><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_14.png"></p><p>最后讨论一下代理对象是什么类型。</p><p>首先，请区分两个概念：代理Class对象和代理对象。</p><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_15.png"></p><p>单从名字看，代理Class和Calculator的接口确实相去甚远，但是我们却能将代理对象赋值给接口类型：</p><p><img src="/2022/04/02/JAVA%E5%9F%BA%E7%A1%80/JAVA%E4%BB%A3%E7%90%86/JavaAgent%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%8E%9F%E7%90%86%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/img_16.png"></p><p>千万别觉得名字奇怪，就怀疑它不能用接口接收，只要实现该接口就是该类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代理对象的本质就是：和目标对象实现相同接口的实例。代理Class可以叫任何名字，whatever，只要它实现某个接口，就能成为该接口类型。</span><br></pre></td></tr></table></figure><p>我写了一个MyProxy类，那么它的Class名字必然叫MyProxy。但这和能否赋值给接口没有任何关系。由于它实现了Serializable和Collection，所以myProxy（代理实例）同时是这两个接口的类型。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>j动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。是因为所有被代理执行的方法，都是通过在InvocationHandler中的invoke方法调用的，所以我们只要在invoke方法中统一处理，就可以对所有被代理的方法进行相同的操作了。例如，这里的方法计时，所有的被代理对象执行的方法都会被计时，然而我只做了很少的代码量。</p><p>动态代理的过程，代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。因为动态代理的过程中，我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象是通过InvocationHandler来完成的代理过程的，其中具体是怎样操作的，为什么代理对象执行的方法都会通过InvocationHandler中的invoke方法来执行。</p><h3 id="JDK动态代理Proxy类源码分析"><a href="#JDK动态代理Proxy类源码分析" class="headerlink" title="JDK动态代理Proxy类源码分析"></a>JDK动态代理Proxy类源码分析</h3><h4 id="JDK动态代理创建出来的动态代理类"><a href="#JDK动态代理创建出来的动态代理类" class="headerlink" title="JDK动态代理创建出来的动态代理类"></a>JDK动态代理创建出来的动态代理类</h4><p>上面我们利用Proxy类的newProxyInstance方法创建了一个动态代理对象，查看该方法的源码，发现它只是封装了创建动态代理类的步骤：</p><details><summary>newProxyInstance</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static Object newProxyInstance(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;[] interfaces,</span><br><span class="line">                                          InvocationHandler h)</span><br><span class="line">        throws IllegalArgumentException</span><br><span class="line">    &#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        final Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        final SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        if (sm != null) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Look up or generate the designated proxy class.</span><br><span class="line">         */</span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">         * Invoke its constructor with the designated invocation handler.</span><br><span class="line">         */</span><br><span class="line">        try &#123;</span><br><span class="line">            if (sm != null) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            final InvocationHandler ih = h;</span><br><span class="line">            if (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    public Void run() &#123;</span><br><span class="line">                        cons.setAccessible(true);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            return cons.newInstance(new Object[]&#123;h&#125;);</span><br><span class="line">        &#125; catch (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            if (t instanceof RuntimeException) &#123;</span><br><span class="line">                throw (RuntimeException) t;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">            throw new InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></details><p>其实，我们最应该关注的是 <strong>Class&lt;?&gt; cl = getProxyClass0(loader, intfs)</strong>; 这句，这里产生了代理类，后面代码中的构造器也是通过这里产生的类来获得，可以看出，这个类的产生就是整个动态代理的关键，由于是动态生成的类文件，我这里不具体进入分析如何产生的这个类文件，只需要知道这个类文件时缓存在java虚拟机中的，我们可以</p><details><summary>通过方法将其打印到文件里面，一睹真容</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">byte[] classFile = ProxyGenerator.generateProxyClass(&quot;$Proxy0&quot;, Student.class.getInterfaces());</span><br><span class="line">String path = &quot;G:/javacode/javase/Test/bin/proxy/StuProxy.class&quot;;</span><br><span class="line">try(FileOutputStream fos = new FileOutputStream(path)) &#123;</span><br><span class="line">    fos.write(classFile);</span><br><span class="line">    fos.flush();</span><br><span class="line">    System.out.println(&quot;代理类class文件写入成功&quot;);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">   System.out.println(&quot;写文件错误&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary>对这个class文件进行反编译，我们看看jdk为我们生成了什么样的内容</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"><span class="keyword">import</span> proxy.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *注意这里是生成代理类的构造方法，方法参数为InvocationHandler类型，看到这，是不是就有点明白</span></span><br><span class="line"><span class="comment">  *为何代理对象调用方法都是执行InvocationHandler中的invoke方法，而InvocationHandler又持有一个</span></span><br><span class="line"><span class="comment">  *被代理对象的实例，不禁会想难道是....？ 没错，就是你想的那样。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *super(paramInvocationHandler)，是调用父类Proxy的构造方法。</span></span><br><span class="line"><span class="comment">  *父类持有：protected InvocationHandler h;</span></span><br><span class="line"><span class="comment">  *Proxy构造方法：</span></span><br><span class="line"><span class="comment">  *    protected Proxy(InvocationHandler h) &#123;</span></span><br><span class="line"><span class="comment">  *         Objects.requireNonNull(h);</span></span><br><span class="line"><span class="comment">  *         this.h = h;</span></span><br><span class="line"><span class="comment">  *     &#125;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler)</span><br><span class="line">    <span class="keyword">throws</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">super</span>(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这个静态块本来是在最后的，我把它拿到前面来，方便描述</span></span><br><span class="line">   <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//看看这儿静态块儿里面有什么，是不是找到了giveMoney方法。请记住giveMoney通过反射得到的名字m3，其他的先不管</span></span><br><span class="line">      m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, <span class="keyword">new</span> Class[] &#123; Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>) &#125;);</span><br><span class="line">      m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      m3 = Class.forName(<span class="string">&quot;proxy.Person&quot;</span>).getMethod(<span class="string">&quot;giveMoney&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  *这里调用代理对象的giveMoney方法，直接就调用了InvocationHandler中的invoke方法，并把m3传了进去。</span></span><br><span class="line"><span class="comment">  *this.h.invoke(this, m3, null);这里简单，明了。</span></span><br><span class="line"><span class="comment">  *来，再想想，代理对象持有一个InvocationHandler对象，InvocationHandler对象持有一个被代理的对象，</span></span><br><span class="line"><span class="comment">  *再联系到InvacationHandler中的invoke方法。嗯，就是这样。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">giveMoney</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Error|RuntimeException localError)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> localError;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable localThrowable)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意，这里为了节省篇幅，省去了toString，hashCode、equals方法的内容。原理和giveMoney方法一毛一样。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>jdk为我们的生成了一个叫$Proxy0（这个名字后面的0是编号，有多个代理类会一次递增）的代理类，这个类文件时放在内存中的，我们在创建代理对象时，就是通过反射获得这个类的构造方法，然后创建的代理实例。通过对这个生成的代理类源码的查看，我们很容易能看出，动态代理实现的具体过程。</p><p>我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。</p><p>代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>生成的代理类：$Proxy0 extends Proxy implements Person，我们看到代理类继承了Proxy类，所以也就决定了java动态代理只能对接口进行代理，Java的继承机制注定了这些动态代理类们无法实现对class的动态代理。</p><p>上面的动态代理的例子，其实就是AOP的一个简单实现了。</p><p>Spring的AOP实现其实也是用了Proxy和InvocationHandler这两个东西的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代理模式&quot;&gt;&lt;a href=&quot;#代理模式&quot; class=&quot;headerlink&quot; title=&quot;代理模式&quot;&gt;&lt;/a&gt;代理模式&lt;/h2&gt;&lt;p&gt;代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转</summary>
      
    
    
    
    <category term="JAVA基础" scheme="http://example.com/categories/JAVA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="动态代理" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>数据库MySQL系列之分区分片分库分表</title>
    <link href="http://example.com/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://example.com/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</id>
    <published>2022-03-22T09:20:40.000Z</published>
    <updated>2022-03-24T09:39:43.427Z</updated>
    
    <content type="html"><![CDATA[<p>数据库的数据量达到一定程度之后，为避免带来系统性能上的瓶颈， 往往需要进行数据的处理，最常采用的手段总结起来：</p><ul><li>分区</li><li>分片</li><li>分库</li><li>分表</li></ul><h2 id="表分区"><a href="#表分区" class="headerlink" title="表分区"></a>表分区</h2><h3 id="什么是表分区"><a href="#什么是表分区" class="headerlink" title="什么是表分区"></a>什么是表分区</h3><p>MySQL 数据库中的数据是以文件的形势存在磁盘上的，默认放在 /var/lib/mysql/ 目录下面，</p><p>我们可以通过 show variables like ‘%datadir%’; 命令来查看：</p><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img.png"></p><p>我们进入到这个目录下，就可以看到我们定义的所有数据库了，一个数据库就是一个文件夹，一个库中，有其对应的表的信息，如下：</p><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_1.png"></p><p>在 MySQL 中，如果存储引擎是 MyISAM，那么在 data 目录下会看到 3 类文件：.frm、.myi、.myd，作用如下：</p><ol><li><code>*.frm</code>：这个是表定义，是描述表结构的文件。</li><li><code>*.myd</code>：这个是数据信息文件，是表的数据文件。</li><li><code>*.myi</code>：这个是索引信息文件。</li></ol><p>如果存储引擎是 InnoDB, 那么在 data 目录下会看到两类文件：.frm、.ibd，作用分别如下：</p><ol><li><code>*.frm</code>：表结构文件。</li><li><code>*.ibd</code>：表数据和索引的文件。 </li></ol><p>无论是哪种存储引擎，只要一张表的数据量过大，就会导致 <em>.myd、</em>.myi 以及 *.ibd 文件过大，数据的查找就会变的很慢。</p><p>为了解决这个问题，我们可以利用 MySQL 的分区功能，在物理上将这一张表对应的文件，分割成许多小块，如此，当我们查找一条数据时，就不用在某一个文件中进行整个遍历了，我们只需要知道这条数据位于哪一个数据块，然后在那一个数据块上查找就行了；另一方面，如果一张表的数据量太大，可能一个磁盘放不下，这个时候，通过表分区我们就可以把数据分配到不同的磁盘里面去。</p><p>MySQL 从 5.1 开始添加了对分区的支持，分区的过程是将一个表或索引分解为多个更小、更可管理的部分。对于开发者而言，分区后的表使用方式和不分区基本上还是一模一样，只不过在物理存储上，原本该表只有一个数据文件，现在变成了多个，每个分区都是独立的对象，可以独自处理，也可以作为一个更大对象的一部分进行处理。</p><p>需要注意的是，分区功能<strong>并不是在存储引擎层完成</strong>的，常见的存储引擎如 InnoDB、MyISAM、NDB 等都支持分区。但并不是所有的存储引擎都支持，如 CSV、FEDORATED、MERGE 等就不支持分区，因此在使用此分区功能前，应该对选择的存储引擎对分区的支持有所了解。</p><h3 id="表分区两种方式"><a href="#表分区两种方式" class="headerlink" title="表分区两种方式"></a>表分区两种方式</h3><p>不同于 MyCat 中既可以垂直切分又可以水平切分，MySQL 数据库支持的分区类型为水平分区，它<strong>不支持垂直分区</strong>。</p><h4 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h4><p>将同一个表的数据进行分块保存到不同的数据库中，来解决单表中数据量增长出现的压力。这些数据库中的表结构完全相同。</p><p>先来一张简单的示意图，大家感受一下什么是水平切分：</p><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_2.png"></p><p>假设我的 DB 中有 table-1、table-2 以及 table-3 三张表，水平切分就是拿着我 40 米大刀，对准黑色的线条，砍一剑或者砍 N 剑！</p><p>砍完之后，将砍掉的部分放到另外一个数据库实例中，变成下面这样：</p><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_3.png"></p><p>这样，原本放在一个 DB 中的 table 现在放在两个 DB 中了，观察之后我们发现：</p><ul><li>两个 DB 中表的个数都是完整的，就是原来 DB 中有几张表，现在还是几张。 </li><li>每张表中的数据是不完整的，数据被拆分到了不同的 DB 中去了。</li></ul><p>这就是数据库的水平切分，也可以理解为<strong>按照数据行进行切分</strong>，即按照表中某个字段的某种规则来将表数据分散到多个库之中，每个表中包含一部分数据，即<strong>水平切分不改变表结构</strong>。</p><p>表结构设计水平切分，常见的一些场景包括：</p><ul><li>比如在线电子商务网站，订单表数据量过大，按照年度、月度水平切分</li><li>Web 2.0网站注册用户、在线活跃用户过多，按照用户ID范围等方式，将相关用户以及该用户紧密关联的表做水平切分</li><li>例如论坛的置顶帖子，因为涉及到分页问题，每页都需要显示置顶贴，这种情况可以把置顶贴水平切分开来，避免取置顶帖子时从所有帖子的表中读取</li></ul><h4 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h4><p>是指按功能模块拆分，以解决表与表之间的io竞争。比如分为订单库、商品库、用户库…这种方式多个数据库之间的表结构不同。</p><p>先来一张简单的示意图，大家感受一下垂直切分：</p><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_4.png"></p><p>所谓的垂直切分就是拿着我 40 米大刀，对准了黑色的线条砍。</p><p>砍完之后，将不同的表放到不同的数据库实例中去，变成下面这个样子：</p><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_5.png"><br><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_6.png"><br><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_7.png"></p><p>这个时候我们发现如下几个特点：</p><ul><li>每一个数据库实例中的表的数量都是不完整的。</li><li>每一个数据库实例中表的数据是完整的。</li></ul><p>这就是垂直切分。</p><p>一般来说，垂直切分我们可以按照业务来划分，不同业务的表放到不同的数据库实例中。</p><p>表结构设计垂直切分，常见的一些场景包括：</p><ul><li><strong>大字段的垂直切分</strong>。单独将大字段建在另外的表中，提高基础表的访问性能，原则上在性能关键的应用中应当避免数据库的大字段</li><li><strong>按照使用用途垂直切分</strong>。例如企业物料属性，可以按照基本属性、销售属性、采购属性、生产制造属性、财务会计属性等用途垂直切分</li><li><strong>按照访问频率垂直切分</strong>。例如电子商务、Web 2.0系统中，如果用户属性设置非常多，可以将基本、使用频繁的属性和不常用的属性垂直切分开</li></ul><h4 id="MySQL-数据库支持的分区类型为水平分区。"><a href="#MySQL-数据库支持的分区类型为水平分区。" class="headerlink" title="MySQL 数据库支持的分区类型为水平分区。"></a>MySQL 数据库支持的分区类型为水平分区。</h4><p>MySQL 数据库的分区是<strong>局部分区索引</strong>，即一个分区中既存放了数据又存放了索引。</p><p>目前，MySQL数据库还不支持全局分区（数据存放在各个分区中，但是所有数据的索引放在一个对象中）。</p><h3 id="为什么需要表分区"><a href="#为什么需要表分区" class="headerlink" title="为什么需要表分区"></a>为什么需要表分区</h3><ul><li>可以让单表存储更多的数据。</li><li>分区表的数据更容易维护，可以通过清除整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。<br>另外，还可以对一个独立分区进行优化、检查、修复等操作。</li><li>部分查询能够从查询条件确定只落在少数分区上，查询速度会很快。</li><li>分区表的数据还可以分布在不同的物理设备上，从而高效利用多个硬件设备。</li><li>可以使用分区表来避免某些特殊瓶颈，例如 InnoDB 单个索引的互斥访问、ext3 文件系统的 inode 锁竞争。</li><li>可以备份和恢复单个分区。</li></ul><h4 id="分区的限制和缺点"><a href="#分区的限制和缺点" class="headerlink" title="分区的限制和缺点"></a>分区的限制和缺点</h4><ul><li>一个表最多只能有 1024 个分区。</li><li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。</li><li>分区表无法使用外键约束。</li><li>NULL 值会使分区过滤无效。</li><li>所有分区必须使用相同的存储引擎。</li></ul><h3 id="分区实践"><a href="#分区实践" class="headerlink" title="分区实践"></a>分区实践</h3><p>说了这么多，来个例子看一下。</p><p>首先我们先来查看一下当前的 MySQL 是否支持分区。</p><p>在 MySQL5.6.1 之前可以通过命令 <code>show variables like &#39;%have_partitioning%&#39;</code> 来查看 MySQL 是否支持分区。如果 <code>have_partitioning</code> 的值为 <code>YES</code>，则表示支持分区。</p><p>从 MySQL5.6.1 开始，<code>have_partitioning</code> 参数已经被去掉了，而是用 <code>SHOW PLUGINS</code> 来代替。若有 <code>partition</code> 行且 <code>STATUS</code> 列的值为 <code>ACTIVE</code>，则表示支持分区，如下所示：</p><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_8.png"></p><p>确认我们的 MySQL 支持分区后，我们就可以开始分区啦！</p><h4 id="RANGE-分区"><a href="#RANGE-分区" class="headerlink" title="RANGE 分区"></a>RANGE 分区</h4><p>RANGE 分区比较简单，就是根据某一个字段的值进行分区。 </p><p>不过这个字段有一个要求，就是<strong>必须是主键或者是联合主键中的某个字段</strong>。</p><p>例如根据 user 表的 id 进行分区：</p><ul><li>当 id 小于 100，数据插入 p0 分区；</li><li>当 id 大于等于 100 小于 200 的时候，插入 p1 分区；</li><li>如果 id 大于等于 200 则插入 p2 分区。</li></ul><p>上面的规则涉及到了 id 的所有范围了，如果没有第三条规则，那么插入一个 id 为 300 的记录时，就会报错。</p><p>建表 SQL 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create  table  user(</span><br><span class="line">  id int primary key,</span><br><span class="line">  username varchar(255)</span><br><span class="line">)engine=innodb</span><br><span class="line">  partition by range(id)(</span><br><span class="line">     partition  p0  values  less  than(100),</span><br><span class="line">     partition  p1  values  less  than(200),</span><br><span class="line">     partition  p2  values  less  than maxvalue  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>表创建成功后，我们进入到 <code>/var/lib/mysql/test08</code> 文件夹中，来看刚刚创建的表文件：</p><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_9.png"></p><p>可以看到，此时的数据文件分为好几个了。</p><p>在 <code>information_schema.partitions</code> 表中，我们可以查看分区的详细信息：</p><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_10.png"></p><p>也可以自己写个 SQL 去查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.partitions where table_schema=&#x27;test08&#x27; and table_name=&#x27;user&#x27;</span><br></pre></td></tr></table></figure><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_11.png"></p><p>每一行展示一个分区的信息，包括分区的方式、该区的范围、分区的字段、该区目前有几条记录等等。</p><p>RANGE 分区有一个比较典型的使用场景，就是按照日期对表进行分区，例如同一年注册的用户放在一个分区中，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create  table  user(</span><br><span class="line">  id int,</span><br><span class="line">  username varchar(255),</span><br><span class="line">  password varchar(255),</span><br><span class="line">  createDate date,</span><br><span class="line">  primary key (id,createDate)</span><br><span class="line">)engine=innodb</span><br><span class="line">  partition by range(year(createDate))(</span><br><span class="line">     partition  p2022  values  less  than(2023),</span><br><span class="line">     partition  p2023  values  less  than(2024),</span><br><span class="line">     partition  p2024  values  less  than(2025)  </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意，<code>createDate</code> 是联合主键的一员。如果 <code>createDate</code> 不是主键，只是一个普通字段，那么创建时就会抛出如下错误：</p><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_12.png"></p><p>现在，如果我们要查询 2022 年注册的用户，系统就只会去搜索 p2022 这个分区，通过 explain 执行计划可以证实我们的想法：</p><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_13.png"></p><p>如果想要删除 2022 年注册的用户，则只需要删除该分区即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user drop partition p2022;</span><br></pre></td></tr></table></figure><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_14.png"></p><p>由上图可以看到，删除之后，数据就没了。</p><h4 id="LIST-分区"><a href="#LIST-分区" class="headerlink" title="LIST 分区"></a>LIST 分区</h4><p>LIST 分区和 RANGE 分区类似，区别在于 LIST 分区是基于列值匹配一个离散值集合中的某个值来进行选择，而非连续的。举个例子大家看下就明白了：</p><p>假设我有一个用户表，用户有性别，现在想按照性别将用户分开存储，男性存储在一个分区中，女性存储在一个分区中，SQL 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create  table  user(</span><br><span class="line">  id int,</span><br><span class="line">  username varchar(255),</span><br><span class="line">  password varchar(255),</span><br><span class="line">  gender int,</span><br><span class="line">  primary key(id, gender)</span><br><span class="line">)engine=innodb</span><br><span class="line">  partition by list(gender)(</span><br><span class="line">     partition  man  values  in  (1),</span><br><span class="line">     partition  woman  values  in  (0));</span><br></pre></td></tr></table></figure><p>这个表将来就两个分区，分别存储男性和女性，gender 的取值为 1 或者 0，gender 如果取其他值，执行就会出错，最终执行结果如下：</p><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_15.png"></p><p>这样分区之后，将来查询男性或者查询女性效率都会比较高，删除某一性别的用户时删除效率也高。</p><h4 id="HASH-分区"><a href="#HASH-分区" class="headerlink" title="HASH 分区"></a>HASH 分区</h4><p>HASH 分区的目的是将数据均匀地分布到预先定义的各个分区中，保证各分区的数据量大致都是一样的。</p><p>在 RANGE 和 LIST 分区中，必须明确指定一个给定的列值或列值集合应该保存在哪个分区中；而在 HASH 分区中，MySQL 自动完成这些工作，用户所要做的只是基于将要进行哈希分区的列指定一个表达式，并且分区的数量。</p><ul><li>使用 HASH 分区来分割一个表，要在 CREATE TABLE 语句上添加 PARTITION BY HASH (expr)，其中 expr 是一个<strong>字段或者是一个返回整数的表达式</strong>；</li><li>通过 PARTITIONS 属性指定分区的数量，如果没有指定，那么<strong>分区的数量默认为 1</strong>，</li><li>HASH 分区不能删除分区，所以<strong>不能使用 DROP PARTITION 操作进行分区删除</strong>操作。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create  table  user(</span><br><span class="line">  id int,</span><br><span class="line">  username varchar(255),</span><br><span class="line">  password varchar(255),</span><br><span class="line">  gender int,</span><br><span class="line">  primary key(id, gender)</span><br><span class="line">)engine=innodb partition by hash(id) partitions 4;</span><br></pre></td></tr></table></figure><h4 id="KEY-分区"><a href="#KEY-分区" class="headerlink" title="KEY 分区"></a>KEY 分区</h4><p>KEY 分区和 HASH 分区相似，但是 KEY 分区支持除 text 和 BLOB 之外的所有数据类型的分区，而 HASH 分区只支持数字分区。</p><p>KEY 分区不允许使用用户自定义的表达式进行分区，KEY 分区使用系统提供的 HASH 函数进行分区。</p><p>当表中存在主键或者唯一索引时，如果创建 KEY 分区时没有指定字段系统默认会<strong>首选主键列作为分区字段</strong>,如果不存在主键列会选择<strong>非空唯一索引列</strong>作为分区字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create  table  user(</span><br><span class="line">  id int,</span><br><span class="line">  username varchar(255),</span><br><span class="line">  password varchar(255),</span><br><span class="line">  gender int,</span><br><span class="line">  primary key(id, gender)</span><br><span class="line">)engine=innodb partition by key(id) partitions 4;</span><br></pre></td></tr></table></figure><h4 id="COLUMNS-分区"><a href="#COLUMNS-分区" class="headerlink" title="COLUMNS 分区"></a>COLUMNS 分区</h4><p>COLUMN 分区是 5.5 开始引入的分区功能，只有 RANGE COLUMN 和 LIST COLUMN 这两种分区；支持整形、日期、字符串；这种分区方式和 RANGE、LIST 的分区方式非常的相似。</p><p>COLUMNS Vs RANGE Vs LIST 分区：</p><ul><li>针对日期字段的分区不需要再使用函数进行转换了。</li><li>COLUMN 分区支持多个字段作为分区键但是不支持表达式作为分区键。</li></ul><p>COLUMNS 支持的类型</p><ul><li>整形支持：tinyint、smallint、mediumint、int、bigint；不支持 decimal 和 float。</li><li>时间类型支持：date、datetime。</li><li>字符类型支持：char、varchar、binary、varbinary；不支持text、blob。</li></ul><p>举个例子看下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create  table  user(</span><br><span class="line">  id int,</span><br><span class="line">  username varchar(255),</span><br><span class="line">  password varchar(255),</span><br><span class="line">  gender int,</span><br><span class="line">  createDate date,</span><br><span class="line">  primary key(id, createDate)</span><br><span class="line">)engine=innodb PARTITION BY RANGE COLUMNS(createDate) (</span><br><span class="line">    PARTITION p0 VALUES LESS THAN (&#x27;1990-01-01&#x27;),</span><br><span class="line">    PARTITION p1 VALUES LESS THAN (&#x27;2000-01-01&#x27;),</span><br><span class="line">    PARTITION p2 VALUES LESS THAN (&#x27;2010-01-01&#x27;),</span><br><span class="line">    PARTITION p3 VALUES LESS THAN (&#x27;2020-01-01&#x27;),</span><br><span class="line">    PARTITION p4 VALUES LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这是 RANGE COLUMNS，分区值是连续的。</p><p>再来看 LIST COLUMNS 分区，这个就类似于枚举了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create  table  user(</span><br><span class="line">  id int,</span><br><span class="line">  username varchar(255),</span><br><span class="line">  password varchar(255),</span><br><span class="line">  gender int,</span><br><span class="line">  createDate date,</span><br><span class="line">  primary key(id, createDate)</span><br><span class="line">)engine=innodb PARTITION BY LIST COLUMNS(createDate) (</span><br><span class="line">    PARTITION p0 VALUES IN (&#x27;1990-01-01&#x27;),</span><br><span class="line">    PARTITION p1 VALUES IN (&#x27;2000-01-01&#x27;),</span><br><span class="line">    PARTITION p2 VALUES IN (&#x27;2010-01-01&#x27;),</span><br><span class="line">    PARTITION p3 VALUES IN (&#x27;2020-01-01&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="常见分区命令"><a href="#常见分区命令" class="headerlink" title="常见分区命令"></a>常见分区命令</h3><h4 id="添加分区"><a href="#添加分区" class="headerlink" title="添加分区"></a>添加分区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table user add partition (partition p3 values less than (4000)); -- range 分区</span><br><span class="line">alter table user add partition (partition p3 values in (40));  -- lists分区</span><br></pre></td></tr></table></figure><h4 id="删除表分区（会删除数据）"><a href="#删除表分区（会删除数据）" class="headerlink" title="删除表分区（会删除数据）"></a>删除表分区（会删除数据）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user drop partition p30;</span><br></pre></td></tr></table></figure><h4 id="除表的所有分区（不会丢失数据）："><a href="#除表的所有分区（不会丢失数据）：" class="headerlink" title="除表的所有分区（不会丢失数据）："></a>除表的所有分区（不会丢失数据）：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user remove partitioning; </span><br></pre></td></tr></table></figure><h4 id="重新定义-range-分区表（不会丢失数据）："><a href="#重新定义-range-分区表（不会丢失数据）：" class="headerlink" title="重新定义 range 分区表（不会丢失数据）："></a>重新定义 range 分区表（不会丢失数据）：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table user partition by range(salary)(</span><br><span class="line">partition p1 values less than (2000),</span><br><span class="line">partition p2 values less than (4000)); </span><br></pre></td></tr></table></figure><h4 id="重新定义-hash-分区表（不会丢失数据）："><a href="#重新定义-hash-分区表（不会丢失数据）：" class="headerlink" title="重新定义 hash 分区表（不会丢失数据）："></a>重新定义 hash 分区表（不会丢失数据）：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user partition by hash(salary) partitions 7; </span><br></pre></td></tr></table></figure><h4 id="合并分区：把-2-个分区合并为一个，不会丢失数据："><a href="#合并分区：把-2-个分区合并为一个，不会丢失数据：" class="headerlink" title="合并分区：把 2 个分区合并为一个，不会丢失数据："></a>合并分区：把 2 个分区合并为一个，不会丢失数据：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user  reorganize partition p1,p2 into (partition p1 values less than (1000));</span><br></pre></td></tr></table></figure><h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>分片是把数据库横向扩展（Scale Out）到多个物理节点上的一种有效的方式，其主要目的是为突破单节点数据库服务器的 I/O 能力限制，解决数据库扩展性问题。</p><p>Shard这个词的意思是“碎片”。</p><p>如果将一个数据库当作一块大玻璃，将这块玻璃打碎，那么每一小块都称为数据库的碎片（DatabaseShard）。</p><p>将整个数据库打碎的过程就叫做分片，可以翻译为分片。</p><p>形式上，分片可以简单定义为将大数据库分布到多个物理节点上的一个分区方案。</p><p>每一个分区包含数据库的某一部分，称为一个片，分区方式可以是任意的，并不局限于传统的水平分区和垂直分区。</p><p>一个分片可以包含多个表的内容甚至可以包含多个数据库实例中的内容。</p><p>每个分片被放置在一个数据库服务器上，一个数据库服务器可以处理一个或多个分片的数据。</p><p>系统中需要有服务器进行查询路由转发，负责将查询转发到包含该查询所访问数据的分片或分片集合节点上去执行。</p><h2 id="分表和分区"><a href="#分表和分区" class="headerlink" title="分表和分区"></a>分表和分区</h2><p>分表从表面意思说就是把一张表分成多个小表，分区则是把一张表的数据分成N多个区块，这些区块可以在同一个磁盘上，也可以在不同的磁盘上。</p><p>分表和分区的区别</p><ol><li>实现方式上</li></ol><p>  mysql的分表是真正的分表，一张表分成很多表后，每一个小表都是完正的一张表，都对应三个文件（MyISAM引擎：一个.MYD数据文件，.MYI索引文件，.frm表结构文件）。</p><ol start="2"><li>数据处理上</li></ol><p>  分表后数据都是存放在分表里，总表只是一个外壳，存取数据发生在一个一个的分表里面。分区则不存在分表的概念，分区只不过把存放数据的文件分成了许多小块，分区后的表还是一张表，数据处理还是由自己来完成。</p><ol start="3"><li>提高性能上</li></ol><p>  分表后，单表的并发能力提高了，磁盘I/O性能也提高了。分区突破了磁盘I/O瓶颈，想提高磁盘的读写能力，来增加mysql性能。</p><p>  在这一点上，分区和分表的测重点不同，分表重点是存取数据时，如何提高mysql并发能力上；而分区呢，如何突破磁盘的读写能力，从而达到提高mysql性能的目的。</p><ol start="4"><li>实现的难易度上</li></ol><p>  分表的方法有很多，用merge来分表，是最简单的一种方式。这种方式和分区难易度差不多，并且对程序代码来说可以做到透明的。如果是用其他分表方式就比分区麻烦了。分区实现是比较简单的，建立分区表，跟建平常的表没什么区别，并且对代码端来说是透明的。</p><p>分区的适用场景: </p><ol><li>一张表的查询速度已经慢到影响使用的时候。</li><li>表中的数据是分段的</li><li>对数据的操作往往只涉及一部分数据，而不是所有的数据</li></ol><p>分表的适用场景:</p><ol><li>一张表的查询速度已经慢到影响使用的时候。</li><li>当频繁插入或者联合查询时，速度变慢。</li><li>分表的实现需要业务结合实现和迁移，较为复杂。</li></ol><h2 id="分表与分库"><a href="#分表与分库" class="headerlink" title="分表与分库"></a>分表与分库</h2><p>分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。</p><p>面对高并发的读写访问，当数据库master服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义了。</p><p>因此，我们必须换一种思路，对数据库进行拆分，从而提高数据库写入能力，这就是所谓的分库。</p><p>与分表策略相似，分库可以采用通过一个关键字取模的方式，来对数据访问进行路由，如下图所示</p><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_16.png"></p><h2 id="分区与分片"><a href="#分区与分片" class="headerlink" title="分区与分片"></a>分区与分片</h2><p><img src="/2022/03/22/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%86%E5%8C%BA%E5%88%86%E7%89%87%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/img_17.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据库的数据量达到一定程度之后，为避免带来系统性能上的瓶颈， 往往需要进行数据的处理，最常采用的手段总结起来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分区&lt;/li&gt;
&lt;li&gt;分片&lt;/li&gt;
&lt;li&gt;分库&lt;/li&gt;
&lt;li&gt;分表&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;表分区&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="InnoDB" scheme="http://example.com/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>Redis初探之常见问题汇总</title>
    <link href="http://example.com/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2022-03-09T14:38:15.000Z</published>
    <updated>2022-03-10T08:45:58.811Z</updated>
    
    <content type="html"><![CDATA[<p>拓展阅读: <a href="/2020/10/09/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F02%E4%B9%8B%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%89%E5%A4%A7%E5%88%A9%E5%99%A8%E4%B9%8B%E7%BC%93%E5%AD%98/" title="高并发系统02之高并发三大利器之缓存">高并发系统02之高并发三大利器之缓存</a></p><h2 id="Redis-缓存使用优缺点总结"><a href="#Redis-缓存使用优缺点总结" class="headerlink" title="Redis 缓存使用优缺点总结"></a>Redis 缓存使用优缺点总结</h2><p>Redis 是完全开源免费的，是一个高性能的key-value类型的内存数据库。</p><p>整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p><p>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><p>速度快，因为数据存在内存中，读的速度是 110000 次 /s, 写的速度是 81000 次 /s；</p><ul><li>值得注意的是，该测试结果还是早些年旧机器上的测试结果。如果与今天的机器设备相比，预估可能是以下结果的两倍。</li></ul></li><li><p>支持丰富数据类型，支持string，list，set，sorted set，hash；</p></li><li><p>支持事务，操作都是原子性，对数据的更改要么全部执行，要么全部不执行，事务中任意命令执行失败，其余命令依然被执行。也就是说 Redis 事务不保证原子性，也不支持回滚；事务中的多条命令被一次性发送给服务器，服务器在执行命令期间，不会去执行其他客户端的命令请求。</p></li><li><p>丰富的特性：可用于缓存，消息（支持 publish/subscribe 通知），按key设置过期时间，过期后将会自动删除。</p><p> 具体<strong>淘汰策略</strong>有：</p><ul><li>volatile-lru：从已经设置过期时间的数据集中，挑选最近最少使用的数据淘汰 </li><li>volatile-ttl：从已经设置过期时间的数据集中，挑选即将要过期的数据淘汰 </li><li>volatile-random：从已经设置过期时间的数据集中，随机挑选数据淘汰</li><li>allkeys-lru：从所有的数据集中，挑选最近最少使用的数据淘汰 </li><li>allkeys-random：从所有的数据集中，随机挑选数据淘汰</li><li>no-enviction：禁止淘汰数据</li></ul><p> 具体<strong>过期键的策略</strong>有：</p><ul><li>定时删除（缓存过期时间到就删除，创建timer耗CPU）</li><li>惰性删除（获取的时候检查，不获取一直留在内存，对内存不友好）</li><li>定期删除（CPU和内存的折中方案）</li></ul></li><li><p>支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用；</p></li><li><p>支持数据的备份，即 master - slave 模式的数据备份。</p></li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在<strong>较小数据量的高性能操作和运算</strong>上。</p><h2 id="Redis-支持的数据类型"><a href="#Redis-支持的数据类型" class="headerlink" title="Redis 支持的数据类型"></a>Redis 支持的数据类型</h2><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><p>Redis 支持 5 中数据类型：string（字符串），hash（哈希），list（列表），set（集合），zset（sorted set：有序集合）。</p><ul><li><p><strong>String</strong> key-value, 最基本的数据类型，二进制安全的字符串，最大存储数据512M</p></li><li><p><strong>List</strong> 简单的字符串列表，按插入顺序排序，可以左添加/右添加，最大存储数据量2^32-1。list 内的元素是可重复的。可以做消息队列或最新消息排行等功能。</p></li><li><p><strong>Hash</strong> String类型key-value集合映射表，适合存储对象，并且可以像数据库中一样只对某一项属性值进行存储、读取、修改等操作。最大存储数据量2^32-1。</p></li><li><p><strong>Set</strong> hash表实现，无序的字符串集合，不存在重复的元素，添加、删除、查找复杂度O（1），最大存储数据量2^32-1</p></li><li><p><strong>SortedSet</strong> 每个元素关联一个double类型分数，redis 通过分数来为集合中的成员进行从小到大的排序。zset 的元素是唯一的，但是分数（score）却可以重复，可用作排行榜等场景。</p></li></ul><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><h4 id="布隆过滤器解决什么问题"><a href="#布隆过滤器解决什么问题" class="headerlink" title="布隆过滤器解决什么问题"></a>布隆过滤器解决什么问题</h4><p>大数据量集合，如何准确快速的判断某个数据是否在大数据量集合中，并且不占用内存？</p><h4 id="布隆过滤器怎么解决该问题"><a href="#布隆过滤器怎么解决该问题" class="headerlink" title="布隆过滤器怎么解决该问题"></a>布隆过滤器怎么解决该问题</h4><p>一种数据结构，是由一串很长的二进制向量组成，可以将其看成一个二进制数组。既然是二进制，那么里面存放的不是0，就是1，但是初始默认值都是0。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_2.png"></p><p>添加数据：自定义几个Hash函数，分别算出Key对应的各个值，将值的位置都置为1。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_1.png"></p><p>判断存在性：如果通过哈希函数算出来的值，对应的地方有0，则数据一定不存在；无法判断数据一定存在。</p><h4 id="布隆过滤器有什么优缺点"><a href="#布隆过滤器有什么优缺点" class="headerlink" title="布隆过滤器有什么优缺点"></a>布隆过滤器有什么优缺点</h4><ul><li>优点：内存占用极小，插入&amp;查询极快</li><li>缺点：无法判断数据一定存在；随着数据量增大，误判率增加；无法删除数据。</li></ul><h4 id="Redis如何实现布隆过滤器"><a href="#Redis如何实现布隆过滤器" class="headerlink" title="Redis如何实现布隆过滤器"></a>Redis如何实现布隆过滤器</h4><p>Redis本身支持bitmap数据结构，通过setbit和getbit即可实现一个Bloom Filter，具体实现参考文章：</p><p><a href="https://segmentfault.com/a/1190000017370384">基于Redis的BloomFilter实现</a></p><p><a href="https://blog.csdn.net/zwx900102/article/details/110307834?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&spm=1001.2101.3001.4242">如何利用一个支持元素删除的布隆过滤器来解决缓存穿透问题</a></p><h2 id="Redis-线程模型"><a href="#Redis-线程模型" class="headerlink" title="Redis 线程模型"></a>Redis 线程模型</h2><h3 id="为什么说Redis是单线程模型"><a href="#为什么说Redis是单线程模型" class="headerlink" title="为什么说Redis是单线程模型"></a>为什么说Redis是单线程模型</h3><p>Redis的单线程，其实是指执行Redis命令的<strong>核心模块是单线程</strong>的，也就是文件事件处理器，主要由四个部分组成：</p><ul><li>套接字</li><li>IO多路复用</li><li>文件事件分派器</li><li>事件处理器。</li></ul><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img.png"></p><h3 id="Redis为什么一开始要使用单线程"><a href="#Redis为什么一开始要使用单线程" class="headerlink" title="Redis为什么一开始要使用单线程"></a>Redis为什么一开始要使用单线程</h3><ul><li>使用非阻塞IO和多路复用IO<ul><li>使用IO多路复用机制同时监听多个文件描述符的可读和可写状态</li><li>绝大部分操作纯内存，在单线程模式下，处理的网络请求得到忽略</li></ul></li><li>可维护性高<ul><li>单线程不存在并发读写问题</li><li>无上下文切换，可以避免线程切换带来的开销</li></ul></li><li>Redis本身是基于内存的，数据都存放在内存中，单线程效率依旧高</li><li>普通 KV 存储<strong>瓶颈压根不在 CPU，而往往可能受到内存和网络I/O的制约</strong></li><li>可以通过开启多个Redis实例来利用多核</li></ul><p>Redis6.0其实已经支持多线程来提高性能了。</p><h3 id="Redis为什么要引入多线程"><a href="#Redis为什么要引入多线程" class="headerlink" title="Redis为什么要引入多线程"></a>Redis为什么要引入多线程</h3><p>Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。</p><p>对网络事件进行监听，分发给work thread进行处理，处理完以后将主动权交还给主线程，进行执行操作，当然后续还会有，执行后依然交由 work thread 进行响应数据的 socket write 操作。</p><p>大元素异步删除支持。</p><h2 id="Redis-高可用架构"><a href="#Redis-高可用架构" class="headerlink" title="Redis 高可用架构"></a>Redis 高可用架构</h2><h3 id="首先，保证数据不丢失-数据持久化"><a href="#首先，保证数据不丢失-数据持久化" class="headerlink" title="首先，保证数据不丢失-数据持久化"></a>首先，保证数据不丢失-数据持久化</h3><p>Redis 数据是存储在内存中的，为了保证 Redis 数据不丢失，那就要把数据从内存存储到磁盘上，以便在服务器重启后还能够从磁盘中恢复原有数据，这就是 Redis 的数据持久化。</p><p>Redis 数据持久化有三种方式： 1）AOF 日志（Append Only File，文件追加方式）：记录所有的操作命令，并以文本的形式追加到文件中。 2）RDB 快照（Redis<br>DataBase）：将某一个时刻的内存数据，以二进制的方式写入磁盘。 3）混合持久化方式：Redis 4.0 新增了混合持久化的方式，集成了 RDB 和 AOF 的优点。</p><p><a href="https://baijiahao.baidu.com/s?id=1662843885312435398">详解Redis持久化（RDB和AOF）</a></p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>Redis DataBase：采用的是内存快照的方式，它记录的是某一时刻的数据，而不是操作。</p><p>故障恢复时只需要直接把 RDB 文件读入内存即可实现快速恢复。</p><h5 id="快照的过程"><a href="#快照的过程" class="headerlink" title="快照的过程"></a>快照的过程</h5><ul><li> Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；</li><li> 父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；</li><li> 当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成。</li><li> 在执行fork的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令 ），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。</li></ul><p>Redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说<strong>任何时候RDB文件都是完整的</strong>。</p><p>这使得我们可以通过定时备份RDB文件来实现Redis数据库备份。</p><p>RDB文件是经过压缩（可以配置rdbcompression参数以禁用压缩节省CPU占用）的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。</p><p>除了自动快照，还可以手动发送SAVE或BGSAVE命令让Redis执行快照。</p><ul><li>SAVE: 是由主进程进行快照操作，会阻塞住其他请求</li><li>BGSAVE: 会通过fork子进程进行快照操作。</li></ul><p>redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。 </p><p>通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。<strong>如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化</strong>。</p><h5 id="快照配置"><a href="#快照配置" class="headerlink" title="快照配置"></a>快照配置</h5><p>RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的所有数据进行快照并存储在硬盘上。</p><p>进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：时间和改动的键的个数。</p><p>当在指定的时间内被更改的键的个数大于指定的数值时就会进行快照。</p><p>RDB是redis默认采用的持久化方式，在配置文件中已经预置了3个条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1      #900秒内有至少1个键被更改则进行快照</span><br><span class="line">save 300 10     #300秒内有至少10个键被更改则进行快照</span><br><span class="line">save 60 10000   #60秒内有至少10000个键被更改则进行快照</span><br></pre></td></tr></table></figure><p>可以存在多个条件，条件之间是”或”的关系，只要满足其中一个条件，就会进行快照。</p><p>如果想要禁用自动快照，只需要将所有的save参数删除即可。</p><p>Redis默认会将快照文件存储在当前目录(可CONFIG GET dir来查看)的dump.rdb文件中，可以通过配置dir和dbfilename两个参数分别指定快照文件的存储路径和文件名。</p><h5 id="快照优势与劣势"><a href="#快照优势与劣势" class="headerlink" title="快照优势与劣势"></a>快照优势与劣势</h5><p>优势：</p><ul><li>全量备份，适合做冷备；</li><li>fork子进程，让子进程执行磁盘 IO 操作，性能影响小；</li><li>相对于 AOF 持久化机制来说，恢复更快；</li><li>fork子进程生成快照时可以会暂停服务。</li></ul><p>劣势：</p><ul><li>如果想要在 Redis 故障时，尽可能少的丢失数据，那么 RDB 没有 AOF 好；</li><li>RDB 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li></ul><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>Append Only File：采用的是“<strong>写后日志</strong>”的方式，Redis 先执行命令把数据写入内存，然后再记录日志到文件中。</p><p>AOF 日志记录的是操作命令，不是实际的数据，如果采用 AOF 方法做故障恢复时需要将全量日志都执行一遍。</p><h5 id="AOF-重写机制"><a href="#AOF-重写机制" class="headerlink" title="AOF 重写机制"></a>AOF 重写机制</h5><ul><li>解决AOF文件体积膨胀的问题，使用更小的体积来保存数据库状态</li><li>Redis增加了一个AOF重写缓存，这个缓存在fork出子进程之后开始启用，Redis服务器主进程在执行完写命令之后，会同时将这个写命令追加到AOF缓冲区和AOF重写缓冲区</li><li>AOF缓冲区的内容会定期被写入和同步到AOF文件中，对现有的AOF文件的处理工作会正常进行，从创建子进程开始，服务器执行的所有写操作都会被记录到AOF重写缓冲区中；</li><li>当子进程完成对AOF文件重写之后，它会向父进程发送一个完成信号，父进程接到该完成信号之后，会调用一个信号处理函数，该函数完成以下工作：</li><li>将AOF重写缓存中的内容全部写入到新的AOF文件中；这个时候新的AOF文件所保存的数据库状态和服务器当前的数据库状态一致；</li><li>新的AOF文件进行改名，原子的覆盖原有的AOF文件；完成新旧两个AOF文件的替换。</li><li>在整个AOF后台重写过程中，只有最后的“主进程写入命令到AOF缓存”和“对新的AOF文件进行改名，覆盖原有的AOF文件。”<ul><li>这<strong>两个步骤（信号处理函数执行期间）会造成主进程阻塞</strong>，在其他时候，AOF后台重写都不会对主进程造成阻塞，这将AOF重写对性能造成的影响降到最低。</li></ul></li></ul><h5 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h5><p>默认情况下Redis没有开启AOF(append only file)方式的持久化，可以在redis.conf中通过appendonly参数开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>在启动时Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入的速度相较RDB会慢一些</p><p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfilename appendonly.aof</span><br></pre></td></tr></table></figure><p>配置redis自动重写AOF文件的条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100  # 当目前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据</span><br><span class="line"> </span><br><span class="line">auto-aof-rewrite-min-size 64mb   # 允许重写的最小AOF文件大小</span><br><span class="line">配置写入AOF文件后，要求系统刷新硬盘缓存的机制</span><br><span class="line"> </span><br><span class="line"># appendfsync always   # 每次执行写入都会执行同步，最安全也最慢</span><br><span class="line">appendfsync everysec   # 每秒执行一次同步操作</span><br><span class="line"></span><br><span class="line"># appendfsync no       # 不主动进行同步操作，而是完全交由操作系统来做（即每30秒一次），最快也最不安全</span><br></pre></td></tr></table></figure><h5 id="“写后日志”"><a href="#“写后日志”" class="headerlink" title="“写后日志”"></a>“写后日志”</h5><h6 id="为什么使用写后日志"><a href="#为什么使用写后日志" class="headerlink" title="为什么使用写后日志"></a>为什么使用写后日志</h6><p>Redis 在写入日志之前，不对命令进行语法检查，所以只记录执行成功的命令，避免出现记录错误命令的情况，而且在命令执行后再写日志不会阻塞当前的写操作。</p><h6 id="写后日志有什么风险"><a href="#写后日志有什么风险" class="headerlink" title="写后日志有什么风险"></a>写后日志有什么风险</h6><ul><li>数据可能会丢失：如果 Redis 刚执行完命令，此时发生故障宕机，会导致这条命令存在丢失的风险。</li><li>可能阻塞其他操作：AOF 日志其实也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。</li></ul><h5 id="AOF优势"><a href="#AOF优势" class="headerlink" title="AOF优势"></a>AOF优势</h5><ul><li>数据安全，aof持久化，可以配置appendfsync属性，有always，每进行一次命令操作就记录到aof文件中一次。</li><li>通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题。</li><li>适合误删除紧急恢复-AOF机制的rewrite模式。AOF文件没被rewrite之前（文件过大时，会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）)</li><li>写QPS性能降低(每秒一次性能影响不高)</li></ul><h4 id="持久化机制如何选择"><a href="#持久化机制如何选择" class="headerlink" title="持久化机制如何选择"></a>持久化机制如何选择</h4><p>redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制。</p><p>用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</p><h3 id="其次，解决单点故障-复制副本"><a href="#其次，解决单点故障-复制副本" class="headerlink" title="其次，解决单点故障-复制副本"></a>其次，解决单点故障-复制副本</h3><p>为解决单点数据库问题，Redis会把数据复制多个副本部署到其他节点上。</p><p>通过复制，实现Redis的高可用性，实现对数据的冗余备份，保证数据和服务的高度可靠性。</p><p>Redis的主从结构可以采用一主多从或者级联结构，Redis主从复制可以根据是否是全量分为全量同步和增量同步。下图为级联结构。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_3.png"></p><h4 id="全量同步"><a href="#全量同步" class="headerlink" title="全量同步"></a>全量同步</h4><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_4.png"></p><p>具体步骤如下：</p><ul><li> 从服务器连接主服务器，发送SYNC命令；</li><li> 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；</li><li> 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li><li> 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li><li> 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li><li> 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；</li></ul><p>完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。</p><h4 id="增量同步"><a href="#增量同步" class="headerlink" title="增量同步"></a>增量同步</h4><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。</p><p>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p><p>增量同步功能组成部分</p><ol><li>主服务器的复制偏移量和从服务器的复制偏移量；<ul><li>主服务器每次向从服务器传播N个字节的数据时，就将自己的复制偏移量的值加N；</li><li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N。</li></ul></li><li>主服务器的复制积压缓冲区；<ul><li>由主服务器维护的一个固定长度队列，默认为1M，当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面。</li></ul></li><li>服务器的运行ID。<ul><li>每个服务器在启动时随机生成运行ID（runid）。</li></ul></li></ol><p>Redis增量同步功能实现：</p><ol><li>从服务器向主服务器发送PSYNC命令，携带主服务器的runid和复制偏移量；</li><li>主服务器验证runid和自身runid是否一致，如不一致，则进行全量复制；</li><li>主服务器验证复制偏移量是否在积压缓冲区内，如不在，则进行全量复制；</li><li>如都验证通过，则主服务器将保持在积压区内的偏移量后的所有数据发送给从服务器，主从服务器再次回到一致状态。</li></ol><p>总结： </p><ol><li>只有当从服务器的携带的主服务器runid和offset都符合，Redis才会采用增量同步的策略，存在着很大的局限性；</li><li>因此从服务器重启、更换主服务器、以及断连时间过长，redis都会采用全量同步的策略。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机</span><br></pre></td></tr></table></figure><h4 id="主从同步注意事项"><a href="#主从同步注意事项" class="headerlink" title="主从同步注意事项"></a>主从同步注意事项</h4><ol><li>Redis使用异步复制。但从Redis 2.8开始，从服务器会周期性的应答从复制流中处理的数据量。<ul><li>主从服务器之间会定期进行通话，但是如果master上设置了密码，那么如果不给slave设置密码就会导致slave不能跟master进行任何操作，所以如果你的master服务器<br>上有密码，那么也需要给slave相应的设置一下密码（通过设置配置文件中的masterauth）</li></ul></li><li>一个主服务器可以有多个从服务器。<ul><li>一般slave服务器不能进行写操作，但是这不是死的，之所以这样是为了更容易的保证主和各个从之间数据的一致性，如果slave服务器上数据进行了修改， 那么要保证所有主从服务器都能一致，可能在结构上和处理逻辑上更为负责。不过你也可以通过配置文件让从服务器支持写操作。（所带来的影响还得自己承担）   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">从服务器默认只读模式，这个行为是由Redis.conf文件中的slave-read-only 参数控制的，可以在运行中通过CONFIG SET来启用或者禁用。</span><br><span class="line"></span><br><span class="line">只读的从服务器会拒绝所有写命令，所以对从服务器不会有误写操作。但这不表示可以把从服务器实例暴露在危险的网络环境下。</span><br><span class="line">因为像DEBUG或者CONFIG这样的管理命令还是可以运行的。不过你可以通过使用rename-command命令来为这些命令改名来增加安全性。</span><br><span class="line"></span><br><span class="line">你可能想知道为什么只读限制还可以被还原，使得从服务器还可以进行写操作。虽然当主从服务器进行重新同步或者从服务器重启后，</span><br><span class="line">这些写操作都会失效，还是有一些使用场景会想从服务器中写入临时数据的，但将来这个特性可能会被去掉。</span><br></pre></td></tr></table></figure></li><li>可以配置主服务器连接N个以上从服务器才允许对主服务器进行写操作。   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">因为Redis使用的是异步主从复制，</span><br><span class="line">没办法确保从服务器确实收到了要写入的数据，所以还是有一定的数据丢失的可能性。</span><br><span class="line"></span><br><span class="line">这一特性的工作原理如下：</span><br><span class="line">1）从服务器每秒钟ping一次主服务器，确认处理的复制流数量。</span><br><span class="line">2）主服务器记住每个从服务器最近一次ping的时间。</span><br><span class="line">3）用户可以配置最少要有N个服务器有小于M秒的确认延迟。</span><br><span class="line">4）如果有N个以上从服务器，并且确认延迟小于M秒，主服务器接受写操作。</span><br><span class="line"></span><br><span class="line">还可以把这看做是CAP原则（一致性，可用性，分区容错性）不严格的一致性实现，虽然不能百分百确保一致性，但至少保证了丢失的数据不会超过M秒内的数据量。</span><br><span class="line"></span><br><span class="line">如果条件不满足，主服务器会拒绝写操作并返回一个错误。</span><br><span class="line">1）min-slaves-to-write（最小从服务器数）</span><br><span class="line">2）min-slaves-max-lag（从服务器最大确认延迟）</span><br></pre></td></tr></table></figure></li></ul></li><li>从服务器也可以接受其他从服务器的连接。<ul><li>除了多个从服务器连接到一个主服务器之外，多个从服务器也可以连接到一个从服务器上，形成一个<br>图状结构。</li></ul></li><li>Redis主从复制不阻塞主服务器端。也就是说当若干个从服务器在进行初始同步时，主服务器仍然可以处理请求。</li><li>主从复制也不阻塞从服务器端。<ul><li>当从服务器进行初始同步时，它使用旧版本的数据来应对查询请求，假设你在redis.conf配置文件是这么配置的。</li><li>否则的话，你可以配置当复制流关闭时让从服务器给客户端返回一个错误。但是，当初始同步完成后，需要删除旧的数据集和加载新的数据集，在这个短暂的时间内，从服务器会阻塞连接进来的请求。</li></ul></li><li>主从复制可以用来增强扩展性，使用多个从服务器来处理只读的请求（比如，繁重的排序操作可以放到从服务器去做），也可以简单的用来做数据冗余。</li><li>使用主从复制可以为主服务器免除把数据写入磁盘的消耗：在主服务器的redis.conf文件中配置“避免保存”（注释掉所有“保存“命令），然后连接一个配置为“进行保存”的从服务器即可。<ul><li>这个配置要确保主服务器不会自动重启，主redis服务器一旦重启，因为主redis服务器数据为空，这时候通过主从同步可能导致从redis服务器上的数据也被清空。</li><li>全量同步过程中，master会将数据保存在rdb文件中然后发送给slave服务器，但是如果master上的磁盘空间有效怎么办呢？那么此时全部同步对于master来说将是一份十分有压力的操作了。此时可以通过<strong>无盘复制</strong>来达到目的，由master直接开启一个socket将rdb文件发送给slave服务器。（无盘复制一般应用在磁盘空间有限但是网络状态良好的情况下）</li><li>强烈建议在主服务器上开启持久化，当不能这么做时，比如考虑到延迟的问题，应该将实例配置为避免自动重启。   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">设置节点A为主服务器，关闭持久化，节点B和C从节点A复制数据。</span><br><span class="line">这时出现了一个崩溃，但Redis具有自动重启系统，重启了进程，因为关闭了持久化，节点重启后只有一个空的数据集。</span><br><span class="line">节点B和C从节点A进行复制，现在节点A是空的，所以节点B和C上的复制数据也会被删除。</span><br><span class="line">当在高可用系统中使用Redis Sentinel，关闭了主服务器的持久化，并且允许自动重启，这种情况是很危险的。</span><br><span class="line">比如主服务器可能在很短的时间就完成了重启，以至于Sentinel都无法检测到这次失败，那么上面说的这种失败的情况就发生了。</span><br><span class="line">    </span><br><span class="line">如果数据比较重要，并且在使用主从复制时关闭了主服务器持久化功能的场景中，都应该禁止实例自动重启。</span><br></pre></td></tr></table></figure></li></ul></li><li>关于slave服务器上过期键的处理，由master服务器负责键的过期删除处理，然后将相关删除命令已数据同步的方式同步给slave服务器，slave服务器根据删除命令删除<br>本地的key。</li></ol><h3 id="最后，满足不同架构需求-多种架构模式"><a href="#最后，满足不同架构需求-多种架构模式" class="headerlink" title="最后，满足不同架构需求-多种架构模式"></a>最后，满足不同架构需求-多种架构模式</h3><p>为了满足开发市场需求，Redis 支持<strong>单机、主从、哨兵、集群</strong>多种架构模式。</p><h4 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h4><p>单机模式顾名思义就是安装一个 Redis，启动起来，业务调用即可。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_5.png"></p><p>一些简单的应用，并非必须保证高可用的情况下可以使用该模式。</p><p>优点：</p><ul><li>部署简单；</li><li>成本低，无备用节点；</li><li>高性能，单机不需要同步数据，数据天然一致性。</li></ul><p>缺点:</p><ul><li>可靠性保证不是很好，单节点有宕机的风险。</li><li>单机高性能受限于 CPU 的处理能力，Redis 是单线程的。</li></ul><p>单机 Redis 能够承载的 QPS（每秒查询速率）大概在几万左右。 取决于业务操作的复杂性，Lua 脚本复杂性就极高。假如是简单的 key value 查询那性能就会很高。</p><p>假设上千万、上亿用户同时访问 Redis，QPS 达到 10 万+。这些请求过来，单机 Redis 直接就挂了。系统的瓶颈就出现在 Redis 单机问题上，此时我们可以通过<strong>主从复制</strong>解决该问题，实现系统的高并发</p><h4 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h4><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_6.png"></p><p>Redis 的复制（Replication）功能允许用户根据一个 Redis 服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器（Master），而通过复制创建出来的复制品则为从服务器（Slave）。 只要主从服务器之间的网络连接正常，主服务器就会将写入自己的数据同步更新给从服务器，从而保证主从服务器的数据相同。</p><p>数据的复制是单向的，只能由主节点到从节点，简单理解就是从节点只支持读操作，不允许写操作。主要是读高并发的场景下用主从架构。</p><p>主从模式需要考虑的问题是：当 Master 节点宕机，需要选举产生一个新的 Master 节点，从而保证服务的高可用性。</p><p>优点：</p><ul><li>Master/Slave 角色方便水平扩展，QPS 增加，增加 Slave 即可；</li><li>降低 Master 读压力，转交给 Slave 节点；</li><li>主节点宕机，从节点作为主节点的备份可以随时顶上继续提供服务；</li></ul><p>缺点： </p><ul><li>可靠性保证不是很好，主节点故障便无法提供写入服务；</li><li>没有解决主节点写的压力；</li><li>数据冗余（为了高并发、高可用和高性能，一般是允许有冗余存在的）；</li><li>一旦主节点宕机，从节点晋升成主节点，需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预；</li><li>主节点的写能力受到单机的限制；</li><li>主节点的存储能力受到单机的限制。</li></ul><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>主从模式中，当主节点宕机之后，从节点是可以作为主节点顶上来继续提供服务，但是需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。</p><p>于是，在 Redis 2.8 版本开始，引入了哨兵（Sentinel）这个概念，在主从复制的基础上，哨兵实现了自动化故障恢复。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_7.png"></p><p>如图所示，哨兵模式由两部分组成，哨兵节点和数据节点：</p><ul><li>哨兵节点：哨兵节点是特殊的 Redis 节点，不存储数据；</li><li>数据节点：主节点和从节点都是数据节点。</li></ul><p>Redis Sentinel 是分布式系统中监控 Redis 主从服务器，并提供主服务器下线时自动故障转移功能的模式。</p><p>其中三个特性为：</p><ul><li>监控(Monitoring)：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常；</li><li>提醒(Notification)：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知；</li><li>自动故障迁移(Automatic failover)：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</li></ul><h5 id="Sentinel关键名词"><a href="#Sentinel关键名词" class="headerlink" title="Sentinel关键名词"></a>Sentinel关键名词</h5><p>####### 定时任务<br>Sentinel 内部有 3 个定时任务，分别是：</p><ul><li>每 1 秒每个 Sentinel 对其他 Sentinel 和 Redis 节点执行 PING 操作（监控），这是一个心跳检测，是失败判定的依据。</li><li>每 2 秒每个 Sentinel 通过 Master 节点的 channel 交换信息（Publish/Subscribe）；</li><li>每 10 秒每个 Sentinel 会对 Master 和 Slave 执行 INFO 命令，这个任务主要达到两个目的：<ul><li>发现 Slave 节点；</li><li>确认主从关系。</li></ul></li></ul><p>####### 主观下线<br>所谓主观下线（Subjectively Down， 简称 SDOWN）指的是单个 Sentinel 实例对服务器做出的下线判断，即单个 Sentinel 认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。</p><p>主观下线就是说如果服务器在给定的毫秒数之内，没有返回 Sentinel 发送的 PING 命令的回复，或者返回一个错误，那么 Sentinel 会将这个服务器标记为主观下线（SDOWN）。</p><p>####### 客观下线<br>客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断，并且通过命令互相交流之后，得出的服务器下线判断，然后开启 failover。</p><p>只有在足够数量的 Sentinel 都将一个服务器标记为主观下线之后， 服务器才会被标记为客观下线（ODOWN）。</p><p>只有当 Master 被认定为客观下线时，才会发生故障迁移。</p><p>####### 仲裁<br>仲裁指的是配置文件中的 <code>quorum</code> 选项。</p><p>某个 Sentinel 先将 Master 节点标记为主观下线，然后会将这个判定通过 sentinel is-master-down-by-addr 命令询问其他 Sentinel 节点是否也同样认为该 addr 的 Master 节点要做主观下线。</p><p>最后当达成这一共识的 Sentinel 个数达到前面说的 <code>quorum</code> 设置的值时，该 Master 节点会被认定为客观下线并进行故障转移。</p><p><code>quorum</code> 的值一般设置为 Sentinel 个数的二分之一加 1，例如 3 个 Sentinel 就设置为 2。</p><h5 id="Sentinel工作原理"><a href="#Sentinel工作原理" class="headerlink" title="Sentinel工作原理"></a>Sentinel工作原理</h5><ol><li>每个 Sentinel 以每秒一次的频率向它所知的 Master，Slave 以及其他 Sentinel 节点发送一个 PING 命令；</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过配置文件 own-after-milliseconds 选项所指定的值，则这个实例会被 Sentinel 标记为主观下线；</li><li>如果一个 Master 被标记为主观下线，那么正在监视这个 Master 的所有 Sentinel 要以每秒一次的频率确认 Master 是否真的进入主观下线状态；</li><li>当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认 Master 的确进入了主观下线状态，则 Master 会被标记为客观下线；</li><li>如果 Master 处于 ODOWN 状态，则投票自动选出新的主节点。将剩余的从节点指向新的主节点继续进行数据复制；</li><li>在正常情况下，每个 Sentinel 会以每 10 秒一次的频率向它已知的所有 Master，Slave 发送 INFO 命令；当 Master 被 Sentinel 标记为客观下线时，Sentinel 向已下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次；</li><li>若没有足够数量的 Sentinel 同意 Master 已经下线，Master 的客观下线状态就会被移除。若 Master 重新向 Sentinel 的 PING 命令返回有效回复，Master 的主观下线状态就会被移除。</li></ol><h5 id="哨兵模式的优缺点"><a href="#哨兵模式的优缺点" class="headerlink" title="哨兵模式的优缺点"></a>哨兵模式的优缺点</h5><h6 id="哨兵模式的优点"><a href="#哨兵模式的优点" class="headerlink" title="哨兵模式的优点"></a>哨兵模式的优点</h6><ul><li>哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都有；</li><li>主从可以自动切换，系统更健壮，可用性更高；</li><li>Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li></ul><h6 id="哨兵模式的缺点"><a href="#哨兵模式的缺点" class="headerlink" title="哨兵模式的缺点"></a>哨兵模式的缺点</h6><ul><li>主从切换需要时间，会丢失数据；</li><li>还是没有解决主节点写的压力；</li><li>主节点的写能力，存储能力受到单机的限制；</li><li>动态扩容困难复杂，对于集群，容量达到上限时在线扩容会变得很复杂。</li></ul><h4 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h4><p>假设上千万、上亿用户同时访问 Redis，QPS 达到 10 万+。这些请求过来，<strong>单机</strong> Redis 直接就挂了。系统的瓶颈就出现在 Redis 单机问题上，此时我们可以通过<strong>主从复制</strong>解决该问题，实现系统的高并发。</p><p>主从模式中，当主节点宕机之后，从节点是可以作为主节点顶上来继续提供服务，但是需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。于是，在 Redis 2.8 版本开始，引入了<strong>哨兵</strong>（Sentinel）这个概念，在<strong>主从复制</strong>的基础上，哨兵实现了<strong>自动化故障恢复</strong>。</p><p>哨兵模式中，单个节点的写能力，存储能力受到单机的限制，动态扩容困难复杂。于是，Redis 3.0 版本正式推出 <strong>Redis Cluster 集群</strong>模式，有效地解决了 Redis 分布式方面的需求。Redis Cluster 集群模式具有<strong>高可用、可扩展性、分布式、容错</strong>等特性。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_8.png"></p><p>Redis Cluster 采用无中心结构，<strong>每个节点都可以保存数据和整个集群状态</strong>，每个节点都和其他所有节点连接。</p><p>Cluster 一般由多个节点组成，节点数量至少为 6 个才能保证组成完整高可用的集群，其中三个为主节点，三个为从节点。</p><p>三个主节点会分配<strong>槽</strong>，处理客户端的命令请求，而从节点可用在主节点故障后，顶替主节点。</p><p>如上图所示，该集群中包含 6 个 Redis 节点，3 主 3 从，分别为 M1，M2，M3，S1，S2，S3。</p><p>除了主从 Redis 节点之间进行数据复制外，所有 Redis 节点之间采用 <strong>Gossip 协议</strong>进行通信，交换维护节点元数据信息。</p><p>总结下来就是：读请求分配给 Slave 节点，写请求分配给 Master，数据同步从 Master 到 Slave 节点。</p><h5 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h5><p>单机、主从、哨兵的模式数据都是存储在一个节点上，其他节点进行数据的复制。</p><p>而单个节点存储是存在上限的，集群模式就是把数据进行<strong>分片存储</strong>，当一个分片数据达到上限的时候，还可以分成多个分片。</p><p>Redis Cluster 采用<strong>虚拟哈希槽分区</strong>，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：HASH_SLOT = CRC16(key) % 16384。</p><p>每一个节点负责维护一部分槽以及槽所映射的键值数据。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/img_9.png"></p><p>Redis Cluster 提供了灵活的节点扩容和缩容方案。在不影响集群对外服务的情况下，可以为集群添加节点进行扩容也可以下线部分节点进行缩容。</p><p>可以说，槽是 Redis Cluster 管理数据的基本单位，集群伸缩就是槽和数据在节点之间的移动。</p><p>简单的理解就是：扩容或缩容以后，槽需要重新分配，数据也需要重新迁移，但是服务不需要下线。</p><p>假如，这里有 3 个节点的集群环境如下：</p><ul><li>节点 A 哈希槽范围为 0 ~ 5500；</li><li>节点 B 哈希槽范围为 5501 ~ 11000；</li><li>节点 C 哈希槽范围为 11001 ~ 16383。</li></ul><p>此时，我们如果要存储数据，按照 Redis Cluster 哈希槽的算法，假设结果是： CRC16(key) % 16384 = 6782。 那么就会把这个 key 的存储分配到 B 节点。此时连接 A、B、C 任何一个节点获取 key，都会这样计算，最终通过 B 节点获取数据。</p><p>假如这时我们新增一个节点 D，Redis Cluster 会从各个节点中拿取一部分 Slot 到 D 上，比如会变成这样：</p><ul><li>节点 A 哈希槽范围为 1266 ~ 5500；</li><li>节点 B 哈希槽范围为 6827 ~ 11000；</li><li>节点 C 哈希槽范围为 12288 ~ 16383；</li><li>节点 D 哈希槽范围为 0 ~ 1265，5501 ~ 6826，11001 ~ 12287</li></ul><p>这种特性允许在集群中轻松地添加和删除节点。</p><p>同样的如果我想删除节点 D，只需要将节点 D 的哈希槽移动到其他节点，当节点是空时，便可完全将它从集群中移除。</p><h5 id="主从"><a href="#主从" class="headerlink" title="主从"></a>主从</h5><p>Redis Cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点复制主节点数据备份，当这个主节点挂掉后，就会通过这个主节点的从节点选取一个来充当主节点，从而保证集群的高可用。</p><p>回到刚才的例子中，集群有 A、B、C 三个主节点，如果这 3 个节点都没有对应的从节点，如果 B 挂掉了，则集群将无法继续，因为我们不再有办法为 5501 ~ 11000 范围内的哈希槽提供服务。</p><p>所以我们在创建集群的时候，一定要为每个主节点都添加对应的从节点。比如，集群包含主节点 A、B、C，以及从节点 A1、B1、C1，那么即使 B 挂掉系统也可以继续正确工作。</p><p>因为 B1 节点属于 B 节点的子节点，所以 Redis 集群将会选择 B1 节点作为新的主节点，集群将会继续正确地提供服务。当 B 重新开启后，它就会变成 B1 的从节点。但是请注意，如果节点 B 和 B1 同时挂掉，Redis Cluster 就无法继续正确地提供服务了。</p><h5 id="Redis-Cluster优缺点"><a href="#Redis-Cluster优缺点" class="headerlink" title="Redis Cluster优缺点"></a>Redis Cluster优缺点</h5><h6 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h6><ul><li>无中心架构；</li><li>可扩展性，数据按照 Slot 存储分布在多个节点，节点间数据共享，节点可动态添加或删除，可动态调整数据分布；</li><li>高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本。</li><li>实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升。</li></ul><h6 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h6><ul><li>数据通过异步复制，<strong>无法保证数据强一致性</strong>；</li><li>集群环境搭建复杂，不过基于 Docker 的搭建方案会相对简单。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;拓展阅读: &lt;a href=&quot;/2020/10/09/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E7%90%86%</summary>
      
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis底层存储结构之用户数据结构存储模式详解</title>
    <link href="http://example.com/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-03-09T14:38:15.000Z</published>
    <updated>2022-03-21T09:45:11.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis作为目前已知速度最快的Key-Value数据库，本质上是一个数据结构服务器（data structures server），以高效的方式实现了多种现成的数据结构，研究它的数据结构和基于其上的算法，对于我们自己提升局部算法的编程水平有很重要的参考意义。</p><p>当我们提到Redis的“数据结构”，可能是在两个不同的层面来讨论它。</p><p>第一个层面，是从使用者的角度。比如：</p><ul><li>string</li><li>list</li><li>hash</li><li>set</li><li>sorted set</li></ul><p>这一层面也是Redis暴露给外部的调用接口。</p><p>第二个层面，是从内部实现的角度，属于更底层的实现。 比如：</p><ul><li>dict</li><li>sds</li><li>ziplist</li><li>quicklist</li><li>skiplist</li></ul><p>对于第一个层面的”数据结构“，<a href="http://redis.io/topics/data-types-intro">Redis官方文档</a>有详细介绍，我们在 <a href="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%88%9D%E6%8E%A2%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" title="Redis初探之常见问题汇总">Redis初探之常见问题汇总</a> 也有简单的总结。</p><p>本文的重点在于讨论第二个层面：</p><ul><li>Redis数据结构的内部实现</li><li>以及这两个层面的数据结构之间的关系： Redis如何通过组合第二个层面的各种基础数据结构来实现第一个层面的更高层的数据结构。</li></ul><p>在讨论任何一个系统的内部实现的时候，我们都要先明确它的设计原则，这样我们才能更深刻地理解它为什么会进行如此设计的真正意图。</p><p>在本文接下来的讨论中，我们主要关注以下几点：</p><ul><li>存储效率（memory efficiency）。<ul><li>Redis是专用于存储数据的，它对于计算机资源的主要消耗就在于内存，因此节省内存是它非常非常重要的一个方面。</li><li>这意味着Redis一定是非常精细地考虑了<strong>压缩数据、减少内存碎片</strong>等问题。</li></ul></li><li>快速响应时间（fast response time）。<ul><li>与快速响应时间相对的，是高吞吐量（high throughput）。</li><li>Redis是用于提供在线访问的，对于单个请求的响应时间要求很高，因此，<strong>快速响应时间是比高吞吐量更重要的目标</strong>。</li><li>有时候，这两个目标是矛盾的。</li></ul></li><li>单线程（single-threaded）。<ul><li>Redis的性能瓶颈不在于CPU资源，而在于内存访问和网络IO。</li><li>而采用单线程的设计带来的好处是，极大简化了数据结构和算法的实现。</li><li>相反，Redis通过异步IO和pipelining等机制来实现高速的并发访问。</li><li>显然，单线程的设计，对于单个请求的快速响应时间也提出了更高的要求。</li></ul></li></ul><h2 id="Redis-Dict结构"><a href="#Redis-Dict结构" class="headerlink" title="Redis Dict结构"></a>Redis Dict结构</h2><p>dict是一个用于维护key和value映射关系的数据结构，与很多语言中的Map或dictionary类似。</p><ul><li>Redis的一个database中所有key到value的映射，就是使用一个dict来维护的。</li></ul><p>不过，这只是它在Redis中的一个用途而已，它在Redis中被使用的地方还有很多。</p><ul><li>比如，一个Redis hash结构，当它的field较多时，便会采用dict来存储。</li><li>再比如，Redis配合使用dict和skiplist来共同维护一个sorted set。</li></ul><p>这些细节我们后面再讨论，我们先集中精力讨论dict本身的实现。</p><h3 id="为什么要使用Dict"><a href="#为什么要使用Dict" class="headerlink" title="为什么要使用Dict"></a>为什么要使用Dict</h3><p>dict本质上是为了解决算法中的查找问题（Searching）。</p><p>一般查找问题的解法分为两个大类：</p><ul><li>一个是基于各种平衡树，</li><li>一个是基于哈希表。</li></ul><p>我们平常使用的各种Map或dictionary，大都是基于哈希表实现的。</p><p>在不要求数据有序存储，且能保持较低的哈希值冲突概率的前提下，基于哈希表的查找性能能做到非常高效，接近O(1)，而且实现简单。</p><p>在Redis中，dict也是一个<strong>基于哈希表</strong>的算法。</p><p>和传统的哈希算法类似，它采用某个<strong>哈希函数</strong>从key计算得到在哈希表中的位置，采用<strong>拉链法</strong>解决冲突，并在装载因子（load factor）超过预定值时自动扩展内存，引发<strong>重哈希</strong>（rehashing）。</p><p>Redis的dict实现最显著的一个特点，就在于它的重哈希。</p><p>它采用了一种称为<strong>增量式重哈希</strong>（incremental rehashing）的方法，在需要扩展内存时避免一次性对所有key进行重哈希，而是将重哈希操作分散到对于dict的各个增删改查的操作中去。</p><p>这种方法能做到<strong>每次只对一小部分key进行重哈希</strong>，而每次重哈希之间不影响dict的操作。</p><p>dict之所以这样设计，是为了<strong>避免重哈希期间单个请求的响应时间剧烈增加</strong>，这与前面提到的“快速响应时间”的设计原则是相符的。</p><h3 id="Dict的数据结构定义"><a href="#Dict的数据结构定义" class="headerlink" title="Dict的数据结构定义"></a>Dict的数据结构定义</h3><p>为了实现增量式重哈希（incremental rehashing），dict的数据结构里包含两个哈希表。</p><p>在重哈希期间，数据从第一个哈希表向第二个哈希表迁移。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_6.png"></p><p>其C代码定义如下(出自Redis源码dict.h)：</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_7.png"></p><p>结合上面的代码和结构图，可以很清楚地看出dict的结构。</p><h4 id="一个指向dictType结构的指针（type）。"><a href="#一个指向dictType结构的指针（type）。" class="headerlink" title="一个指向dictType结构的指针（type）。"></a>一个指向dictType结构的指针（type）。</h4><ul><li>它通过自定义的方式使得dict的key和value能够存储任何类型的数据。</li><li>dictType结构包含若干函数指针，用于dict的调用者对涉及key和value的各种操作进行自定义。<ul><li>hashFunction，对key进行哈希值计算的哈希算法。</li><li>keyDup和valDup，分别定义key和value的拷贝函数，用于在需要的时候对key和value进行深拷贝，而不仅仅是传递对象指针。</li><li>keyCompare，定义两个key的比较操作，在根据key进行查找时会用到。 </li><li>keyDestructor和valDestructor，分别定义对key和value的析构函数。<h4 id="privdata。"><a href="#privdata。" class="headerlink" title="privdata。"></a>privdata。</h4>一个私有数据指针，由调用者在创建dict的时候传进来，在dictType的某些操作被调用时会传回给调用者。</li></ul></li></ul><h4 id="两个哈希表（ht-2-）。"><a href="#两个哈希表（ht-2-）。" class="headerlink" title="两个哈希表（ht[2]）。"></a>两个哈希表（ht[2]）。</h4><p>它定义一个哈希表的结构，由如下若干项组成:</p><ul><li>一个dictEntry指针数组（table）。<ul><li>key的哈希值最终映射到这个数组的某个位置上（对应一个bucket）。</li><li>如果多个key映射到同一个位置，就发生了冲突，那么就拉出一个dictEntry链表。</li><li>dictEntry结构中包含k, v和指向链表下一项的next指针。<ul><li>k是void指针，这意味着它可以指向任何类型。</li><li>v是个union，当它的值是uint64_t、int64_t或double类型时，就不再需要额外的存储，这有利于减少内存碎片。</li><li>当然，v也可以是void指针，以便能存储任何类型的数据。</li></ul></li></ul></li><li>size：标识dictEntry指针数组的长度。<ul><li>它总是2的指数。</li></ul></li><li>sizemask：用于将哈希值映射到table的位置索引。<ul><li>它的值等于(size-1)，比如7, 15, 31, 63，等等，也就是用二进制表示的各个bit全1的数字。每个key先经过hashFunction计算得到一个哈希值，然后计算(哈希值 &amp; sizemask)得到在table上的位置。相当于计算取余(哈希值 % size)。 </li></ul></li></ul><h4 id="used"><a href="#used" class="headerlink" title="used"></a>used</h4><p>记录dict中现有的数据个数，它与size的比值就是装载因子（load factor）。</p><p>这个比值越大，哈希值冲突概率越高。</p><ul><li><p>只有在重哈希的过程中，ht[0]和ht[1]才都有效。 而在平常情况下，只有ht[0]有效，ht[1]里面没有任何数据。</p></li><li><p>上图表示的就是重哈希进行到中间某一步时的情况。</p></li><li><p>当前重哈希索引（rehashidx）。</p><ul><li>如果rehashidx = -1，表示当前没有在重哈希过程中；</li><li>否则，表示当前正在进行重哈希，且它的值记录了当前重哈希进行到哪一步了。</li></ul></li><li><p>当前正在进行遍历的iterator的个数。这不是我们现在讨论的重点，暂时忽略。</p></li></ul><h3 id="Dict的CURD"><a href="#Dict的CURD" class="headerlink" title="Dict的CURD"></a>Dict的CURD</h3><h4 id="dictCreate"><a href="#dictCreate" class="headerlink" title="dictCreate"></a>dictCreate</h4><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_8.png"></p><p>dictCreate为dict的数据结构分配空间并为各个变量赋初值。</p><p>其中两个哈希表ht[0]和ht[1]起始都没有分配空间，table指针都赋为NULL。</p><p>这意味着要等第一个数据插入时才会真正分配空间。</p><h4 id="dictFind"><a href="#dictFind" class="headerlink" title="dictFind"></a>dictFind</h4><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_9.png"></p><p>上述dictFind的源码，根据dict当前是否正在重哈希，依次做了这么几件事：</p><ul><li>如果当前正在进行重哈希，那么将重哈希过程向前推进一步（即调用_dictRehashStep）。实际上，除了查找，插入和删除也都会触发这一动作。这就将重哈希过程分散到各个查找、插入和删除操作中去了，而不是集中在某一个操作中一次性做完。</li><li>计算key的哈希值（调用dictHashKey，里面的实现会调用前面提到的hashFunction）。</li><li>先在第一个哈希表ht[0]上进行查找。在table数组上定位到哈希值对应的位置（如前所述，通过哈希值与sizemask进行按位与），然后在对应的dictEntry链表上进行查找。查找的时候需要对key进行比较，这时候调用dictCompareKeys，它里面的实现会调用到前面提到的keyCompare。如果找到就返回该项。否则，进行下一步。</li><li>判断当前是否在重哈希，如果没有，那么在ht[0]上的查找结果就是最终结果（没找到，返回NULL）。否则，在ht[1]上进行查找（过程与上一步相同）。</li></ul><p>下面我们有必要看一下增量式重哈希的_dictRehashStep的实现。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_10.png"></p><p>dictRehash每次将重哈希至少向前推进n步（除非不到n步整个重哈希就结束了），每一步都将ht[0]上某一个bucket（即一个dictEntry链表）上的每一个dictEntry移动到ht[1]上，它在ht[1]上的新位置根据ht[1]的sizemask进行重新计算。rehashidx记录了当前尚未迁移（有待迁移）的ht[0]的bucket位置。</p><p>如果dictRehash被调用的时候，rehashidx指向的bucket里一个dictEntry也没有，那么它就没有可迁移的数据。这时它尝试在ht[0].table数组中不断向后遍历，直到找到下一个存有数据的bucket位置。如果一直找不到，则最多走n*10步，本次重哈希暂告结束。</p><p>最后，如果ht[0]上的数据都迁移到ht[1]上了（即d-&gt;ht[0].used == 0），那么整个重哈希结束，ht[0]变成ht[1]的内容，而ht[1]重置为空。</p><p>根据以上对于重哈希过程的分析，我们容易看出，本文前面的dict结构图中所展示的正是rehashidx=2时的情况，前面两个bucket（ht[0].table[0]和ht[0].table[1]）都已经迁移到ht[1]上去了。</p><h4 id="dictAdd-amp-dictReplace"><a href="#dictAdd-amp-dictReplace" class="headerlink" title="dictAdd &amp; dictReplace"></a>dictAdd &amp; dictReplace</h4><p>dictAdd插入新的一对key和value，如果key已经存在，则插入失败。</p><p>dictReplace也是插入一对key和value，不过在key存在的时候，它会更新value。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_11.png"></p><p>以上是dictAdd的关键实现代码。我们主要需要注意以下几点：</p><ul><li>它也会触发推进一步重哈希（_dictRehashStep）。</li><li>如果正在重哈希中，它会把数据插入到ht[1]；否则插入到ht[0]。</li><li>在对应的bucket中插入数据的时候，总是插入到dictEntry的头部。因为新数据接下来被访问的概率可能比较高，这样再次查找它时就比较次数较少。</li><li>_dictKeyIndex在dict中寻找插入位置。如果不在重哈希过程中，它只查找ht[0]；否则查找ht[0]和ht[1]。</li><li>_dictKeyIndex可能触发dict内存扩展（_dictExpandIfNeeded，它将哈希表长度扩展为原来两倍，具体请参考dict.c中源码）。</li></ul><p>dictReplace在dictAdd基础上实现，如下：</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_12.png"></p><p>在key已经存在的情况下，dictReplace会同时调用dictAdd和dictFind，这其实相当于两次查找过程。这里Redis的代码不够优化。</p><h4 id="dictDelete"><a href="#dictDelete" class="headerlink" title="dictDelete"></a>dictDelete</h4><p>dictDelete的源码这里忽略，具体请参考dict.c。需要稍加注意的是：</p><p>dictDelete也会触发推进一步重哈希（_dictRehashStep）</p><p>如果当前不在重哈希过程中，它只在ht[0]中查找要删除的key；否则ht[0]和ht[1]它都要查找。</p><p>删除成功后会调用key和value的析构函数（keyDestructor和valDestructor）。</p><h2 id="Redis-SDS"><a href="#Redis-SDS" class="headerlink" title="Redis SDS"></a>Redis SDS</h2><p>不管在哪门编程语言当中，字符串都几乎是使用最多的数据结构。 sds正是在Redis中被广泛使用的字符串结构，它的全称是Simple Dynamic String。</p><p>与其它语言环境中出现的字符串相比，它具有如下显著的特点：</p><ul><li>可动态扩展内存。sds表示的字符串其内容可以修改，也可以追加。在很多语言中字符串会分为mutable和immutable两种，显然sds属于mutable类型的。</li><li>二进制安全（Binary Safe）。sds能存储任意二进制数据，而不仅仅是可打印字符。</li><li>与传统的C语言字符串类型兼容。</li></ul><p>看到这里，很多对Redis有所了解的同学可能已经产生了一个疑问：Redis已经对外暴露了一个字符串结构，叫做string，那这里所说的<strong>sds到底和string是什么关系呢</strong>？可能有人会猜：string是基于sds实现的。这个猜想已经非常接近事实，但在描述上还不太准确。有关string和sds之间关系的详细分析，我们放在后面再讲。现在为了方便讨论，让我们先暂时简单地认为，string的底层实现就是sds。</p><p>在讨论sds的具体实现之前，我们先站在Redis使用者的角度，来观察一下string所支持的一些主要操作。下面是一个操作示例：</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_13.png"></p><p>以上这些操作都比较简单，我们简单解释一下：</p><ul><li>初始的字符串的值设为”tielei”。</li><li>第3步通过append命令对字符串进行了追加，变成了”tielei zhang”。</li><li>然后通过setbit命令将第53个bit设置成了1。bit的偏移量从左边开始算，从0开始。其中第48～55bit是中间的空格那个字符，它的ASCII码是0x20。将第53个bit设置成1之后，它的ASCII码变成了0x24，打印出来就是’$’。因此，现在字符串的值变成了”tielei$zhang”。</li><li>最后通过getrange取从倒数第5个字节到倒数第1个字节的内容，得到”zhang”。</li></ul><p>这些命令的实现，有一部分是和sds的实现有关的。下面我们开始详细讨论。</p><h3 id="SDS的数据结构定义"><a href="#SDS的数据结构定义" class="headerlink" title="SDS的数据结构定义"></a>SDS的数据结构定义</h3><p>我们知道，在C语言中，字符串是以’\0’字符结尾（NULL结束符）的字符数组来存储的，通常表达为字符指针的形式（char *）。它不允许字节0出现在字符串中间，因此，它不能用来存储任意的二进制数据。</p><p>我们可以在sds.h中找到sds的类型定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef char *sds;</span><br></pre></td></tr></table></figure><p>肯定有人感到困惑了，竟然sds就等同于char *？我们前面提到过，sds和传统的C语言字符串保持类型兼容，因此它们的类型定义是一样的，都是char *。在有些情况下，需要传入一个C语言字符串的地方，也确实可以传入一个sds。</p><p>但是，sds和char *并不等同。sds是Binary Safe的，它可以存储任意二进制数据，不能像C语言字符串那样以字符’\0’来标识字符串的结束，因此它必然有个长度字段。但这个长度字段在哪里呢？</p><p>实际上sds还包含一个header结构：</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_14.png"></p><p>sds一共有5种类型的header。之所以有5种，是为了能让不同长度的字符串可以使用不同大小的header。这样，短字符串就能使用较小的header，从而节省内存。</p><p>一个sds字符串的完整结构，由在<strong>内存地址上前后相邻</strong>的两部分组成：</p><ul><li>一个header。通常包含字符串的长度(len)、最大容量(alloc)和flags。sdshdr5有所不同。</li><li>一个字符数组。这个字符数组的长度等于最大容量+1。真正有效的字符串数据，其长度通常小于最大容量。在真正的字符串数据之后，是空余未用的字节（一般以字节0填充），允许在不重新分配内存的前提下让字符串数据向后做有限的扩展。在真正的字符串数据之后，还有一个NULL结束符，即ASCII码为0的’\0’字符。这是为了和传统C字符串兼容。之所以字符数组的长度比最大容量多1个字节，就是为了在字符串长度达到最大容量时仍然有1个字节存放NULL结束符。</li></ul><p>header的类型共有5种，在sds.h中有常量定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define SDS_TYPE_5  0</span><br><span class="line">#define SDS_TYPE_8  1</span><br><span class="line">#define SDS_TYPE_16 2</span><br><span class="line">#define SDS_TYPE_32 3</span><br><span class="line">#define SDS_TYPE_64 4</span><br></pre></td></tr></table></figure><p>除了sdshdr5之外，其它4个header的结构都包含3个字段：</p><ul><li>len: 表示字符串的真正长度（不包含NULL结束符在内）。</li><li>alloc: 表示字符串的最大容量（不包含最后多余的那个字节）。</li><li>flags: 总是占用一个字节。其中的最低3个bit用来表示header的类型。</li></ul><p>sds的数据结构，我们有必要非常仔细地去解析它。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_15.png"></p><p>上图是sds的一个内部结构的例子。图中展示了两个sds字符串s1和s2的内存结构，一个使用sdshdr8类型的header，另一个使用sdshdr16类型的header。但它们都表达了同样的一个长度为6的字符串的值：”tielei”。下面我们结合代码，来解释每一部分的组成。</p><p>sds的字符指针（s1和s2）就是指向真正的数据（字符数组）开始的位置，而header位于内存地址较低的方向。</p><p>在sds.h中有一些跟解析header有关的宏定义：</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_16.png"></p><p>其中SDS_HDR用来从sds字符串获得header起始位置的指针，比如SDS_HDR(8, s1)表示s1的header指针，SDS_HDR(16, s2)表示s2的header指针。</p><p>当然，使用SDS_HDR之前我们必须先知道到底是哪一种header，这样我们才知道SDS_HDR第1个参数应该传什么。由sds字符指针获得header类型的方法是，先向低地址方向偏移1个字节的位置，得到flags字段。比如，s1[-1]和s2[-1]分别获得了s1和s2的flags的值。然后取flags的最低3个bit得到header的类型。</p><ul><li>由于s1[-1] == 0x01 == SDS_TYPE_8，因此s1的header类型是sdshdr8。</li><li>由于s2[-1] == 0x02 == SDS_TYPE_16，因此s2的header类型是sdshdr16。</li></ul><p>有了header指针，就能很快定位到它的len和alloc字段：</p><ul><li>s1的header中，len的值为0x06，表示字符串数据长度为6；alloc的值为0x80，表示字符数组最大容量为128。</li><li>s2的header中，len的值为0x0006，表示字符串数据长度为6；alloc的值为0x03E8，表示字符数组最大容量为1000。（注意：图中是按小端地址构成）</li></ul><p>在各个header的类型定义中，还有几个需要我们注意的地方：</p><ul><li>在各个header的定义中使用了__attribute__ ((packed))，是为了让编译器以紧凑模式来分配内存。如果没有这个属性，编译器可能会为struct的字段做优化对齐，在其中填充空字节。那样的话，就不能保证header和sds的数据部分紧紧前后相邻，也不能按照固定向低地址方向偏移1个字节的方式来获取flags字段了。</li><li>在各个header的定义中最后有一个char buf[]。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组。而程序在为header分配的内存的时候，它并不占用内存空间。如果计算sizeof(struct sdshdr16)的值，那么结果是5个字节，其中没有buf字段。</li><li>sdshdr5与其它几个header结构不同，它不包含alloc字段，而长度使用flags的高5位来存储。因此，它不能为字符串分配空余空间。如果字符串需要动态增长，那么它就必然要重新分配内存才行。所以说，这种类型的sds字符串更适合存储静态的短字符串（长度小于32）。</li></ul><p>至此，我们非常清楚地看到了：sds字符串的header，其实隐藏在真正的字符串数据的前面（低地址方向）。这样的一个定义，有如下几个好处：</p><ul><li>header和数据相邻，而不用分成两块内存空间来单独分配。这有利于减少内存碎片，提高存储效率（memory efficiency）。</li><li>虽然header有多个类型，但sds可以用统一的char *来表达。且它与传统的C语言字符串保持类型兼容。如果一个sds里面存储的是可打印字符串，那么我们可以直接把它传给C函数，比如使用strcmp比较字符串大小，或者使用printf进行打印。</li></ul><p>弄清了sds的数据结构，它的具体操作函数就比较好理解了。</p><h3 id="sds的一些基础函数"><a href="#sds的一些基础函数" class="headerlink" title="sds的一些基础函数"></a>sds的一些基础函数</h3><ul><li>sdslen(const sds s): 获取sds字符串长度。</li><li>sdssetlen(sds s, size_t newlen): 设置sds字符串长度。</li><li>sdsinclen(sds s, size_t inc): 增加sds字符串长度。</li><li>sdsalloc(const sds s): 获取sds字符串容量。</li><li>sdssetalloc(sds s, size_t newlen): 设置sds字符串容量。</li><li>sdsavail(const sds s): 获取sds字符串空余空间（即alloc - len）。</li><li>sdsHdrSize(char type): 根据header类型得到header大小。</li><li>sdsReqType(size_t string_size): 根据字符串数据长度计算所需要的header类型。</li></ul><p>这里我们挑选sdslen和sdsReqType的代码，察看一下。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_17.png"></p><p>sdslen先用s跟前面的分析类似:</p><ul><li>先用s[-1]向低地址方向偏移1个字节，得到flags；</li><li>然后与SDS_TYPE_MASK进行按位与，得到header类型；</li><li>然后根据不同的header类型，调用SDS_HDR得到header起始指针，进而获得len字段。</li></ul><p>通过sdsReqType的代码，很容易看到：</p><ul><li>长度在0和2^5-1之间，选用SDS_TYPE_5类型的header。</li><li>长度在2^5和2^8-1之间，选用SDS_TYPE_8类型的header。</li><li>长度在2^8和2^16-1之间，选用SDS_TYPE_16类型的header。</li><li>长度在2^16和2^32-1之间，选用SDS_TYPE_32类型的header。</li><li>长度大于2^32的，选用SDS_TYPE_64类型的header。能表示的最大长度为2^64-1。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：sdsReqType的实现代码，直到3.2.0，它在长度边界值上都一直存在问题，直到3.2 branch上的commit 6032340才修复。</span><br></pre></td></tr></table></figure><h3 id="sds的CURD"><a href="#sds的CURD" class="headerlink" title="sds的CURD"></a>sds的CURD</h3><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_18.png"></p><h4 id="sdsnewlen-创建sds字符串"><a href="#sdsnewlen-创建sds字符串" class="headerlink" title="sdsnewlen 创建sds字符串"></a>sdsnewlen 创建sds字符串</h4><p>创建一个长度为initlen的sds字符串，并使用init指向的字符数组（任意二进制数据）来初始化数据。如果init为NULL，那么使用全0来初始化数据。</p><p>它的实现中，我们需要注意的是：</p><ul><li>如果要创建一个长度为0的空字符串，那么不使用SDS_TYPE_5类型的header，而是转而使用SDS_TYPE_8类型的header。这是因为创建的空字符串一般接下来的操作很可能是追加数据，但SDS_TYPE_5类型的sds字符串不适合追加数据（会引发内存重新分配）。</li><li>需要的内存空间一次性进行分配，其中包含三部分：header、数据、最后的多余字节（hdrlen+initlen+1）。</li><li>初始化的sds字符串数据最后会追加一个NULL结束符（s[initlen] = ‘\0’）。</li></ul><h4 id="sdsfree-释放内存"><a href="#sdsfree-释放内存" class="headerlink" title="sdsfree 释放内存"></a>sdsfree 释放内存</h4><p>需要注意的是：内存要整体释放，所以要先计算出header起始指针，把它传给s_free函数。</p><p>这个指针也正是在sdsnewlen中调用s_malloc返回的那个地址。</p><h4 id="sdscatlen-追加操作"><a href="#sdscatlen-追加操作" class="headerlink" title="sdscatlen 追加操作"></a>sdscatlen 追加操作</h4><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_19.png"></p><p>sdscatlen将t指向的长度为len的任意二进制数据追加到sds字符串s的后面。本文开头演示的string的append命令，内部就是调用sdscatlen来实现的。</p><p>在sdscatlen的实现中，先调用sdsMakeRoomFor来保证字符串s有足够的空间来追加长度为len的数据。sdsMakeRoomFor可能会分配新的内存，也可能不会。</p><p>sdsMakeRoomFor是sds实现中很重要的一个函数。关于它的实现代码，我们需要注意的是：</p><ul><li>如果原来字符串中的空余空间够用（avail &gt;= addlen），那么它什么也不做，直接返回。</li><li>如果需要分配空间，它会比实际请求的要多分配一些，以防备接下来继续追加。它在字符串已经比较长的情况下要至少多分配SDS_MAX_PREALLOC个字节，这个常量在sds.h中定义为(1024*1024)=1MB。</li><li>按分配后的空间大小，可能需要更换header类型（原来header的alloc字段太短，表达不了增加后的容量）。</li><li>如果需要更换header，那么整个字符串空间（包括header）都需要重新分配（s_malloc），并拷贝原来的数据到新的位置。</li><li>如果不需要更换header（原来的header够用），那么调用一个比较特殊的s_realloc，试图在原来的地址上重新分配空间。s_realloc的具体实现得看Redis编译的时候选用了哪个allocator（在Linux上默认使用jemalloc）。但不管是哪个realloc的实现，它所表达的含义基本是相同的：它尽量在原来分配好的地址位置重新分配，如果原来的地址位置有足够的空余空间完成重新分配，那么它返回的新地址与传入的旧地址相同；否则，它分配新的地址块，并进行数据搬迁。参见<a href="http://man.cx/realloc%E3%80%82">http://man.cx/realloc。</a></li></ul><p>从sdscatlen的函数接口，我们可以看到一种使用模式：<strong>调用它的时候，传入一个旧的sds变量，然后它返回一个新的sds变量</strong>。由于它的内部实现可能会造成地址变化，因此调用者在调用完之后，原来旧的变量就失效了，而都应该用新返回的变量来替换。不仅仅是sdscatlen函数，sds中的其它函数（比如sdscpy、sdstrim、sdsjoin等），还有Redis中其它一些能自动扩展内存的数据结构（如ziplist），也都是同样的使用模式。</p><h3 id="浅谈sds与string的关系"><a href="#浅谈sds与string的关系" class="headerlink" title="浅谈sds与string的关系"></a>浅谈sds与string的关系</h3><p>现在我们回过头来看看本文开头给出的string操作的例子：</p><ul><li>append操作使用sds的sdscatlen来实现。</li><li>setbit和getrange都是先根据key取到整个sds字符串，然后再从字符串选取或修改指定的部分。由于sds就是一个字符数组，所以对它的某一部分进行操作似乎都比较简单。</li></ul><p>但是，string除了支持这些操作之外，当它存储的值是个数字的时候，它还支持incr、decr等操作。 当string存储数字值的时候，它的内部存储就不是sds了。而且，这种情况下，setbit和getrange的实现也会有所不同。这些细节，我们放在后续robj的时候再进行系统地讨论。</p><h2 id="Redis-robj"><a href="#Redis-robj" class="headerlink" title="Redis robj"></a>Redis robj</h2><p>从Redis的使用者的角度来看，一个Redis节点包含多个database（非cluster模式下默认是16个，cluster模式下只能是1个），而一个database维护了从key space到object space的映射关系。这个映射关系的key是string类型，而value可以是多种数据类型，比如：string, list, hash等。我们可以看到，key的类型固定是string，而value可能的类型是多个。</p><p>而从Redis内部实现的角度来看，一个database内的这个映射关系是用一个dict来维护的。dict的key固定用一种数据结构来表达就够了，这就是动态字符串sds。而value则比较复杂，为了在同一个dict内能够存储不同类型的value，这就需要一个通用的数据结构，这个通用的数据结构就是robj（全名是redisObject）。</p><p>举个例子：</p><ul><li>如果value是一个list，那么它的内部存储结构是一个quicklist（quicklist的具体实现我们放在后面的文章讨论）；</li><li>如果value是一个string，那么它的内部存储结构一般情况下是一个sds。</li><li>当然实际情况更复杂一点，比如一个string类型的value，如果它的值是一个数字，那么Redis内部还会把它转成long型来存储，从而减小内存使用。</li></ul><p>一个robj既能表示一个sds，也能表示一个quicklist，甚至还能表示一个long型。</p><h3 id="robj的数据结构定义"><a href="#robj的数据结构定义" class="headerlink" title="robj的数据结构定义"></a>robj的数据结构定义</h3><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_20.png"></p><p>一个robj包含如下5个字段：</p><ul><li>type: 对象的数据类型。<ul><li>占4个bit。</li><li>可能的取值有5种：OBJ_STRING, OBJ_LIST, OBJ_SET, OBJ_ZSET, OBJ_HASH，分别对应Redis对外暴露的5种数据结构（即我们在第一篇文章中提到的第一个层面的5种数据结构）。</li></ul></li><li>encoding: 对象的内部表示方式（也可以称为编码）。<ul><li>占4个bit。</li><li>可能的取值有10种，即前面代码中的10个OBJ_ENCODING_XXX常量。</li></ul></li><li>lru: 做LRU替换算法用<ul><li>占24个bit。 </li><li>这个不是我们这里讨论的重点，暂时忽略。</li></ul></li><li>refcount: 引用计数。<ul><li>它允许robj对象在某些情况下被共享。</li></ul></li><li>ptr: 数据指针。 <ul><li>指向真正的数据。</li><li>比如，一个代表string的robj，它的ptr可能指向一个sds结构；一个代表list的robj，它的ptr可能指向一个quicklist。</li></ul></li></ul><p>对于同一个type，还可能对应不同的encoding，这说明同样的一个数据类型，可能存在不同的内部表示方式。而不同的内部表示，在内存占用和查找性能上会有所不同。</p><p>这里特别需要仔细察看的是encoding字段。对于同一个type，还可能对应不同的encoding，这说明同样的一个数据类型，可能存在不同的内部表示方式。而不同的内部表示，在内存占用和查找性能上会有所不同。</p><p>比如，当type = OBJ_STRING的时候，表示这个robj存储的是一个string，这时encoding可以是下面3种中的一种：</p><ul><li>OBJ_ENCODING_RAW: string采用原生的表示方式，即用sds来表示。</li><li>OBJ_ENCODING_INT: string采用数字的表示方式，实际上是一个long型。</li><li>OBJ_ENCODING_EMBSTR: string采用一种特殊的嵌入式的sds来表示。接下来我们会讨论到这个细节。</li></ul><p>再举一个例子：当type = OBJ_HASH的时候，表示这个robj存储的是一个hash，这时encoding可以是下面2种中的一种：</p><ul><li>OBJ_ENCODING_HT: hash采用一个dict来表示。</li><li>OBJ_ENCODING_ZIPLIST: hash采用一个ziplist来表示。</li></ul><p>前面代码段中出现的所有10种encoding，在这里我们先简单解释一下：</p><ul><li>OBJ_ENCODING_RAW: 最原生的表示方式。其实只有string类型才会用这个encoding值（表示成sds）。</li><li>OBJ_ENCODING_INT: 表示成数字。实际用long表示。</li><li>OBJ_ENCODING_HT: 表示成dict。</li><li>OBJ_ENCODING_ZIPMAP: 是个旧的表示方式，已不再用。在小于Redis 2.6的版本中才有。</li><li>OBJ_ENCODING_LINKEDLIST: 也是个旧的表示方式，已不再用。</li><li>OBJ_ENCODING_ZIPLIST: 表示成ziplist。</li><li>OBJ_ENCODING_INTSET: 表示成intset。用于set数据结构。</li><li>OBJ_ENCODING_SKIPLIST: 表示成skiplist。用于sorted set数据结构。</li><li>OBJ_ENCODING_EMBSTR: 表示成一种特殊的嵌入式的sds。</li><li>OBJ_ENCODING_QUICKLIST: 表示成quicklist。用于list数据结构。</li></ul><p>我们来总结一下robj的作用：</p><ul><li>为多种数据类型提供一种统一的表示方式。</li><li>允许同一类型的数据采用不同的内部表示，从而在某些情况下尽量节省内存。</li><li>支持对象共享和引用计数。当对象被共享的时候，只占用一份内存拷贝，进一步节省内存。</li></ul><h3 id="string-robj的编码过程"><a href="#string-robj的编码过程" class="headerlink" title="string robj的编码过程"></a>string robj的编码过程</h3><p>当我们执行Redis的set命令的时候，Redis首先将接收到的value值（string类型）表示成一个type = OBJ_STRING并且encoding = OBJ_ENCODING_RAW的robj对象，然后在存入内部存储之前先执行一个编码过程，试图将它表示成另一种更节省内存的encoding方式。这一过程的核心代码，是object.c中的tryObjectEncoding函数。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_21.png"></p><p>这段代码执行的操作比较复杂，我们有必要仔细看一下每一步的操作：</p><ul><li>第1步检查，检查type。确保只对string类型的对象进行操作。</li><li>第2步检查，检查encoding。sdsEncodedObject是定义在server.h中的一个宏，确保只对OBJ_ENCODING_RAW和OBJ_ENCODING_EMBSTR编码的string对象进行操作。这两种编码的string都采用sds来存储，可以尝试进一步编码处理。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define sdsEncodedObject(objptr) (objptr-&gt;encoding == OBJ_ENCODING_RAW </span><br></pre></td></tr></table></figure></li><li>第3步检查，检查refcount。引用计数大于1的共享对象，在多处被引用。由于编码过程结束后robj的对象指针可能会变化（我们在介绍sdscatlen函数的时候提到过类似这种接口使用模式），这样对于引用计数大于1的对象，就需要更新所有地方的引用，这不容易做到。因此，对于计数大于1的对象不做编码处理。</li><li>试图将字符串转成64位的long。64位的long所能表达的数据范围是-2^63到2^63-1，用十进制表达出来最长是20位数（包括负号）。这里判断小于等于21，似乎是写多了，实际判断小于等于20就够了（如果我算错了请一定告诉我哦）。string2l如果将字符串转成long转成功了，那么会返回1并且将转好的long存到value变量里。<ul><li>如果Redis的配置不要求运行LRU替换算法，且转成的long型数字的值又比较小（小于OBJ_SHARED_INTEGERS，在目前的实现中这个值是10000），那么会使用共享数字对象来表示。之所以这里的判断跟LRU有关，是因为LRU算法要求每个robj有不同的lru字段值，所以用了LRU就不能共享robj。shared.integers是一个长度为10000的数组，里面预存了10000个小的数字对象。这些小数字对象都是encoding = OBJ_ENCODING_INT的string robj对象。</li><li>如果前一步不能使用共享小对象来表示，那么将原来的robj编码成encoding = OBJ_ENCODING_INT，这时ptr字段直接存成这个long型的值。注意ptr字段本来是一个void *指针（即存储的是内存地址），因此在64位机器上有64位宽度，正好能存储一个64位的long型值。这样，除了robj本身之外，它就不再需要额外的内存空间来存储字符串值。</li></ul></li><li>接下来是对于那些不能转成64位long的字符串进行处理。最后再做两步处理：<ul><li>如果字符串长度足够小（小于等于OBJ_ENCODING_EMBSTR_SIZE_LIMIT，定义为44），那么调用createEmbeddedStringObject编码成encoding = OBJ_ENCODING_EMBSTR；<br><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_22.png"><br>createEmbeddedStringObject对sds重新分配内存，将robj和sds放在一个连续的内存块中分配，这样对于短字符串的存储有利于减少内存碎片。这个连续的内存块包含如下几部分：<ul><li>16个字节的robj结构。</li><li>3个字节的sdshdr8头。</li><li>最多44个字节的sds字符数组。 </li><li>1个NULL结束符。</li></ul>加起来一共不超过64字节（16+3+44+1），因此这样的一个短字符串可以完全分配在一个64字节长度的内存块中。</li><li>如果前面所有的编码尝试都没有成功（仍然是OBJ_ENCODING_RAW），且sds里空余字节过多，那么做最后一次努力，调用sds的sdsRemoveFreeSpace接口来释放空余字节。</li></ul></li></ul><h3 id="string-robj的解码过程"><a href="#string-robj的解码过程" class="headerlink" title="string robj的解码过程"></a>string robj的解码过程</h3><p>当我们需要获取字符串的值，比如执行get命令的时候，我们需要执行与前面讲的编码过程相反的操作——解码。</p><p>这一解码过程的核心代码，是object.c中的getDecodedObject函数。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_23.png"></p><p>这个过程比较简单，需要我们注意的点有：</p><ul><li><p>编码为OBJ_ENCODING_RAW和OBJ_ENCODING_EMBSTR的字符串robj对象，不做变化，原封不动返回。站在使用者的角度，这两种编码没有什么区别，内部都是封装的sds。</p></li><li><p>编码为数字的字符串robj对象，将long重新转为十进制字符串的形式，然后调用createStringObject转为sds的表示。注意：这里由long转成的sds字符串长度肯定不超过20，而根据createStringObject的实现，它们肯定会被编码成OBJ_ENCODING_EMBSTR的对象。createStringObject的代码如下：<br><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_24.png"></p></li></ul><h3 id="再谈sds与string的关系"><a href="#再谈sds与string的关系" class="headerlink" title="再谈sds与string的关系"></a>再谈sds与string的关系</h3><p>在SDS章节中，我们简单地提到了sds与string的关系；在本节介绍了robj的概念之后，我们重新总结一下sds与string的关系。</p><ul><li>确切地说，string在Redis中是用一个robj来表示的。</li><li>用来表示string的robj可能编码成3种内部表示：OBJ_ENCODING_RAW, OBJ_ENCODING_EMBSTR, OBJ_ENCODING_INT。其中前两种编码使用的是sds来存储，最后一种OBJ_ENCODING_INT编码直接把string存成了long型。</li><li>在对string进行incr, decr等操作的时候，如果它内部是OBJ_ENCODING_INT编码，那么可以直接进行加减操作；如果它内部是OBJ_ENCODING_RAW或OBJ_ENCODING_EMBSTR编码，那么Redis会先试图把sds存储的字符串转成long型，如果能转成功，再进行加减操作。</li><li>对一个内部表示成long型的string执行append, setbit, getrange这些命令，针对的仍然是string的值（即十进制表示的字符串），而不是针对内部表示的long型进行操作。比如字符串”32”，如果按照字符数组来解释，它包含两个字符，它们的ASCII码分别是0x33和0x32。当我们执行命令setbit key 7 0的时候，相当于把字符0x33变成了0x32，这样字符串的值就变成了”22”。而如果将字符串”32”按照内部的64位long型来解释，那么它是0x0000000000000020，在这个基础上执行setbit位操作，结果就完全不对了。因此，在这些命令的实现中，会把long型先转成字符串再进行相应的操作。由于篇幅原因，这三个命令的实现代码这里就不详细介绍了，有兴趣的读者可以参考Redis源码：<ul><li>t_string.c中的appendCommand函数；</li><li>biops.c中的setbitCommand函数；</li><li>t_string.c中的getrangeCommand函数。</li></ul></li></ul><p>值得一提的是，append和setbit命令的实现中，都会最终调用到db.c中的dbUnshareStringValue函数，将string对象的内部编码转成OBJ_ENCODING_RAW的（只有这种编码的robj对象，其内部的sds 才能在后面自由追加新的内容），并解除可能存在的对象共享状态。这里面调用了前面提到的getDecodedObject。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_25.png"></p><h3 id="robj的引用计数操作"><a href="#robj的引用计数操作" class="headerlink" title="robj的引用计数操作"></a>robj的引用计数操作</h3><p>将robj的引用计数加1和减1的操作，定义在object.c中：</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_26.png"></p><p>我们特别关注一下将引用计数减1的操作decrRefCount。如果只剩下最后一个引用了（refcount已经是1了），那么在decrRefCount被调用后，整个robj将被释放。</p><p>注意：<strong>Redis的del命令就依赖decrRefCount操作将value释放掉</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们很容易看出，robj所表示的就是Redis对外暴露的第一层面的数据结构：string, list, hash, set, sorted set，而每一种数据结构的底层实现所对应的是哪个（或哪些）第二层面的数据结构（dict, sds, ziplist, quicklist, skiplist, 等），则通过不同的encoding来区分。</p><p>可以说，robj是联结两个层面的数据结构的桥梁。</p><h2 id="Redis-ziplist"><a href="#Redis-ziplist" class="headerlink" title="Redis ziplist"></a>Redis ziplist</h2><p>我们首先介绍一个新的Redis内部数据结构——ziplist，然后在后半部分我们会讨论一下在robj, dict和ziplist的基础上，Redis对外暴露的hash结构是怎样构建起来的。</p><p>我们在讨论中还会涉及到两个Redis配置（在redis.conf中的ADVANCED CONFIG部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br></pre></td></tr></table></figure><p>后续会对这两个配置做详细的解释。</p><h3 id="什么是ziplist"><a href="#什么是ziplist" class="headerlink" title="什么是ziplist"></a>什么是ziplist</h3><p>Redis官方对于ziplist的定义是（出自ziplist.c的文件头部注释）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The ziplist is a specially encoded dually linked list that is designed to be very memory efficient. It stores both strings and integer values, where integers are encoded as actual integers instead of a series of characters. It allows push and pop operations on either side of the list in O(1) time.</span><br></pre></td></tr></table></figure><p>翻译一下就是说：ziplist是一个经过特殊编码的双向链表，它的设计目标就是为了提高存储效率。ziplist可以用于存储字符串或整数，其中整数是按真正的二进制表示进行编码的，而不是编码成字符串序列。它能以O(1)的时间复杂度在表的两端提供push和pop操作。</p><p>实际上，ziplist充分体现了Redis对于存储效率的追求。一个普通的双向链表，链表中每一项都占用独立的一块内存，各项之间用地址指针（或引用）连接起来。这种方式会带来大量的内存碎片，而且地址指针也会占用额外的内存。而ziplist却是将表中每一项存放在前后连续的地址空间内，一个ziplist整体占用一大块内存。它是一个表（list），但其实不是一个链表（linked list）。</p><p>另外，ziplist为了在细节上节省内存，对于值的存储采用了变长的编码方式，大概意思是说，对于大的整数，就多用一些字节来存储，而对于小的整数，就少用一些字节来存储。我们接下来很快就会讨论到这些实现细节。</p><h3 id="ziplist的数据结构定义"><a href="#ziplist的数据结构定义" class="headerlink" title="ziplist的数据结构定义"></a>ziplist的数据结构定义</h3><p>ziplist的数据结构组成是ziplist要讨论的重点。实际上，ziplist还是稍微有点复杂的，它复杂的地方就在于它的数据结构定义。一旦理解了数据结构，它的一些操作也就比较容易理解了。</p><p>从宏观上看，ziplist的内存结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry&gt;...&lt;entry&gt;&lt;zlend&gt;</span><br></pre></td></tr></table></figure><p>各个部分在内存上是前后相邻的，它们分别的含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt;: 32bit，表示ziplist占用的字节总数（也包括&lt;zlbytes&gt;本身占用的4个字节）。</span><br><span class="line"></span><br><span class="line">&lt;zltail&gt;: 32bit，表示ziplist表中最后一项（entry）在ziplist中的偏移字节数。&lt;zltail&gt;的存在，使得我们可以很方便地找到最后一项（不用遍历整个ziplist），从而可以在ziplist尾端快速地执行push或pop操作。</span><br><span class="line"></span><br><span class="line">&lt;zllen&gt;: 16bit， 表示ziplist中数据项（entry）的个数。zllen字段因为只有16bit，所以可以表达的最大值为2^16-1。这里需要特别注意的是，如果ziplist中数据项个数超过了16bit能表达的最大值，ziplist仍然可以来表示。那怎么表示呢？这里做了这样的规定：如果&lt;zllen&gt;小于等于2^16-2（也就是不等于2^16-1），那么&lt;zllen&gt;就表示ziplist中数据项的个数；否则，也就是&lt;zllen&gt;等于16bit全为1的情况，那么&lt;zllen&gt;就不表示数据项个数了，这时候要想知道ziplist中数据项总数，那么必须对ziplist从头到尾遍历各个数据项，才能计数出来。</span><br><span class="line"></span><br><span class="line">&lt;entry&gt;: 表示真正存放数据的数据项，长度不定。一个数据项（entry）也有它自己的内部结构，这个稍后再解释。</span><br><span class="line"></span><br><span class="line">&lt;zlend&gt;: ziplist最后1个字节，是一个结束标记，值固定等于255。</span><br></pre></td></tr></table></figure><p>上面的定义中还值得注意的一点是：<code>&lt;zlbytes&gt;, &lt;zltail&gt;,&lt;zllen&gt;</code>既然占据多个字节，那么在存储的时候就有大端（big endian）和小端（little endian）的区别。</p><p>ziplist采取的是<strong>小端模式</strong>来存储，这在下面我们介绍具体例子的时候还会再详细解释。</p><p>我们再来看一下每一个数据项<code>&lt;entry&gt;</code>的构成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;prevrawlen&gt;&lt;len&gt;&lt;data&gt;</span><br></pre></td></tr></table></figure><p>我们看到在真正的数据（<data>）前面，还有两个字段：</data></p><ul><li><code>&lt;prevrawlen&gt;</code>: 表示前一个数据项占用的总字节数。这个字段的用处是为了让ziplist能够从后向前遍历（从后一项的位置，只需向前偏移prevrawlen个字节，就找到了前一项）。这个字段采用变长编码。</li><li><code>&lt;len&gt;</code>: 表示当前数据项的数据长度（即<data>部分的长度）。也采用变长编码。</data></li></ul><p>那么<code>&lt;prevrawlen&gt;</code>和<code>&lt;len&gt;</code>是怎么进行变长编码的呢？各位读者打起精神了，我们终于讲到了ziplist的定义中最繁琐的地方了。</p><p>先说<code>&lt;prevrawlen&gt;</code>。它有两种可能，或者是1个字节，或者是5个字节：</p><ul><li>如果前一个数据项占用字节数小于254，那么<code>&lt;prevrawlen&gt;</code>就只用一个字节来表示，这个字节的值就是前一个数据项的占用字节数。</li><li>如果前一个数据项占用字节数大于等于254，那么<code>&lt;prevrawlen&gt;</code>就用5个字节来表示，其中第1个字节的值是254（作为这种情况的一个标记），而后面4个字节组成一个整型值，来真正存储前一个数据项的占用字节数。</li></ul><p>为什么没有255的情况呢？这是因为：255已经定义为ziplist结束标记<code>&lt;zlend&gt;</code>的值了。</p><p>在ziplist的很多操作的实现中，都会根据数据项的第1个字节是不是255来判断当前是不是到达ziplist的结尾了，因此一个正常的数据的第1个字节（也就是<code>&lt;prevrawlen&gt;</code>的第1个字节）是不能够取255这个值的，否则就冲突了。</p><p>而<code>&lt;len&gt;</code>字段就更加复杂了，它根据第1个字节的不同，总共分为9种情况（下面的表示法是按二进制表示）：</p><ol><li>|00pppppp| - 1 byte。第1个字节最高两个bit是00，那么<code>&lt;len&gt;</code>字段只有1个字节，剩余的6个bit用来表示长度值，最高可以表示63 (2^6-1)。</li><li>|01pppppp|qqqqqqqq| - 2 bytes。第1个字节最高两个bit是01，那么<code>&lt;len&gt;</code>字段占2个字节，总共有14个bit用来表示长度值，最高可以表示16383 (2^14-1)。</li><li>|10__|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt| - 5 bytes。第1个字节最高两个bit是10，那么len字段占5个字节，总共使用32个bit来表示长度值（6个bit舍弃不用），最高可以表示2^32-1。</li></ol><p>需要注意的是：在前三种情况下，<code>&lt;data&gt;</code>都是按字符串来存储的；从下面第4种情况开始，<code>&lt;data&gt;</code>开始变为按整数来存储了。</p><ol start="4"><li>|11000000| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xC0，后面的数据<code>&lt;data&gt;</code>存储为2个字节的int16_t类型。</li><li>|11010000| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xD0，后面的数据<code>&lt;data&gt;</code>存储为4个字节的int32_t类型。</li><li>|11100000| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xE0，后面的数据<code>&lt;data&gt;</code>存储为8个字节的int64_t类型。</li><li>|11110000| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xF0，后面的数据<code>&lt;data&gt;</code>存储为3个字节长的整数。</li><li>|11111110| - 1 byte。<code>&lt;len&gt;</code>字段占用1个字节，值为0xFE，后面的数据<code>&lt;data&gt;</code>存储为1个字节的整数。</li><li>|1111xxxx| – (xxxx的值在0001和1101之间)。这是一种特殊情况，xxxx从1到13一共13个值，这时就用这13个值来表示真正的数据。注意，这里是表示真正的数据，而不是数据长度了。也就是说，在这种情况下，后面不再需要一个单独的<code>&lt;data&gt;</code>字段来表示真正的数据了，而是<code>&lt;len&gt;</code>和<code>&lt;data&gt;</code>合二为一了。另外，由于xxxx只能取0001和1101这13个值了（其它可能的值和其它情况冲突了，比如0000和1110分别同前面第7种第8种情况冲突，1111跟结束标记冲突），而小数值应该从0开始，因此这13个值分别表示0到12，即xxxx的值减去1才是它所要表示的那个整数数据的值。</li></ol><p>好了，ziplist的数据结构定义，我们介绍了完了，现在我们看一个具体的例子。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_27.png"></p><p>上图是一份真实的ziplist数据。我们逐项解读一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 这个ziplist一共包含33个字节。字节编号从byte[0]到byte[32]。图中每个字节的值使用16进制表示。</span><br><span class="line">* 头4个字节（0x21000000）是按小端（little endian）模式存储的&lt;zlbytes&gt;字段。什么是小端呢？就是指数据的低字节保存在内存的低地址中（参见维基百科词条Endianness）。因此，这里&lt;zlbytes&gt;的值应该解析成0x00000021，用十进制表示正好就是33。</span><br><span class="line">* 接下来4个字节（byte[4..7]）是&lt;zltail&gt;，用小端存储模式来解释，它的值是0x0000001D（值为29），表示最后一个数据项在byte[29]的位置（那个数据项为0x05FE14）。</span><br><span class="line">* 再接下来2个字节（byte[8..9]），值为0x0004，表示这个ziplist里一共存有4项数据。</span><br><span class="line">* 接下来6个字节（byte[10..15]）是第1个数据项。其中，prevrawlen=0，因为它前面没有数据项；len=4，相当于前面定义的9种情况中的第1种，表示后面4个字节按字符串存储数据，数据的值为&quot;name&quot;。</span><br><span class="line">* 接下来8个字节（byte[16..23]）是第2个数据项，与前面数据项存储格式类似，存储1个字符串&quot;tielei&quot;。</span><br><span class="line">* 接下来5个字节（byte[24..28]）是第3个数据项，与前面数据项存储格式类似，存储1个字符串&quot;age&quot;。</span><br><span class="line">* 接下来3个字节（byte[29..31]）是最后一个数据项，它的格式与前面的数据项存储格式不太一样。其中，第1个字节prevrawlen=5，表示前一个数据项占用5个字节；第2个字节=FE，相当于前面定义的9种情况中的第8种，所以后面还有1个字节用来表示真正的数据，并且以整数表示。它的值是20（0x14）。</span><br><span class="line">* 最后1个字节（byte[32]）表示&lt;zlend&gt;，是固定的值255（0xFF）。</span><br></pre></td></tr></table></figure><p>总结一下，这个ziplist里存了4个数据项，分别为：</p><ul><li>字符串: “name”</li><li>字符串: “tielei”</li><li>字符串: “age”</li><li>整数: 20</li></ul><p>实际上，这个ziplist是通过两个hset命令创建出来的。这个我们后边会再提到。</p><h3 id="ziplist的接口"><a href="#ziplist的接口" class="headerlink" title="ziplist的接口"></a>ziplist的接口</h3><p>我们先不着急看实现，先来挑几个ziplist的重要的接口，看看它们长什么样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned char *ziplistNew(void);</span><br><span class="line">unsigned char *ziplistMerge(unsigned char **first, unsigned char **second);</span><br><span class="line">unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where);</span><br><span class="line">unsigned char *ziplistIndex(unsigned char *zl, int index);</span><br><span class="line">unsigned char *ziplistNext(unsigned char *zl, unsigned char *p);</span><br><span class="line">unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p);</span><br><span class="line">unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen);</span><br><span class="line">unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p);</span><br><span class="line">unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip);</span><br><span class="line">unsigned int ziplistLen(unsigned char *zl);</span><br></pre></td></tr></table></figure><p>我们从这些接口的名字就可以粗略猜出它们的功能，下面简单解释一下：</p><ul><li>ziplist的数据类型，没有用自定义的struct之类的来表达，而就是简单的unsigned char *。这是因为ziplist本质上就是一块连续内存，内部组成结构又是一个高度动态的设计（变长编码），也没法用一个固定的数据结构来表达。</li><li>ziplistNew: 创建一个空的ziplist（只包含<code>&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;zlend&gt;</code>）。</li><li>ziplistMerge: 将两个ziplist合并成一个新的ziplist。</li><li>ziplistPush: 在ziplist的头部或尾端插入一段数据（产生一个新的数据项）。注意一下这个接口的返回值，是一个新的ziplist。调用方必须用这里返回的新的ziplist，替换之前传进来的旧的ziplist变量，而经过这个函数处理之后，原来旧的ziplist变量就失效了。为什么一个简单的插入操作会导致产生一个新的ziplist呢？这是因为ziplist是一块连续空间，对它的追加操作，会引发内存的realloc，因此ziplist的内存位置可能会发生变化。实际上，我们在之前介绍sds的文章中提到过类似这种接口使用模式（参见sdscatlen函数的说明）。</li><li>ziplistIndex: 返回index参数指定的数据项的内存位置。index可以是负数，表示从尾端向前进行索引。</li><li>ziplistNext和ziplistPrev分别返回一个ziplist中指定数据项p的后一项和前一项。</li><li>ziplistInsert: 在ziplist的任意数据项前面插入一个新的数据项。</li><li>ziplistDelete: 删除指定的数据项。</li><li>ziplistFind: 查找给定的数据（由vstr和vlen指定）。注意它有一个skip参数，表示查找的时候每次比较之间要跳过几个数据项。为什么会有这么一个参数呢？其实这个参数的主要用途是当用ziplist表示hash结构的时候，是按照一个field，一个value来依次存入ziplist的。也就是说，偶数索引的数据项存field，奇数索引的数据项存value。当按照field的值进行查找的时候，就需要把奇数项跳过去。</li><li>ziplistLen: 计算ziplist的长度（即包含数据项的个数）。</li></ul><h4 id="ziplist的插入逻辑解析"><a href="#ziplist的插入逻辑解析" class="headerlink" title="ziplist的插入逻辑解析"></a>ziplist的插入逻辑解析</h4><p>ziplist的相关接口的具体实现，还是有些复杂的，限于篇幅的原因，我们这里只结合代码来讲解插入的逻辑。插入是很有代表性的操作，通过这部分来一窥ziplist内部的实现，其它部分的实现我们也就会很容易理解了。</p><p>ziplistPush和ziplistInsert都是插入，只是对于插入位置的限定不同。</p><p>它们在内部实现都依赖一个名为__ziplistInsert的内部函数:</p><details><summary>__ziplistInsert源码（出自ziplist.c）</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">static unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) &#123;</span><br><span class="line">    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class="line">    unsigned int prevlensize, prevlen = 0;</span><br><span class="line">    size_t offset;</span><br><span class="line">    int nextdiff = 0;</span><br><span class="line">    unsigned char encoding = 0;</span><br><span class="line">    long long value = 123456789; </span><br><span class="line">    zlentry tail;</span><br><span class="line"></span><br><span class="line">    /* Find out prevlen for the </span><br><span class="line">     * entry that is inserted. */</span><br><span class="line">    if (p[0] != ZIP_END) &#123;</span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line">        if (ptail[0] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    /* See if the entry can be encoded */</span><br><span class="line">    if (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;        </span><br><span class="line">        /* &#x27;encoding&#x27; is set to the </span><br><span class="line">         * appropriate integer encoding */</span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; else &#123;        </span><br><span class="line">        /* &#x27;encoding&#x27; is untouched, </span><br><span class="line">         * however zipEncodeLength will use </span><br><span class="line">         * the string length to figure out </span><br><span class="line">         * how to encode it. */</span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    /* We need space for both the length </span><br><span class="line">     * of the previous entry and</span><br><span class="line">     * the length of the payload. */</span><br><span class="line">    reqlen += zipPrevEncodeLength(NULL,prevlen);</span><br><span class="line">    reqlen += zipEncodeLength(NULL,encoding,slen);</span><br><span class="line"></span><br><span class="line">    /* When the insert position is not </span><br><span class="line">     * equal to the tail, we need to</span><br><span class="line">     * make sure that the next entry can </span><br><span class="line">     * hold this entry&#x27;s length in</span><br><span class="line">     * its prevlen field. */</span><br><span class="line">    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : 0;</span><br><span class="line"></span><br><span class="line">    /* Store offset because a realloc</span><br><span class="line">     * may change the address of zl. */</span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    /* Apply memory move when necessary </span><br><span class="line">     * and update tail offset. */</span><br><span class="line">    if (p[0] != ZIP_END) &#123;       </span><br><span class="line">        /* Subtract one because of </span><br><span class="line">         * the ZIP_END bytes */</span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset-1+nextdiff);</span><br><span class="line"></span><br><span class="line">        /* Encode this entry&#x27;s raw </span><br><span class="line">         * length in the next entry. */</span><br><span class="line">        zipPrevEncodeLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        /* Update offset for tail */</span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line"></span><br><span class="line">        /* When the tail contains more </span><br><span class="line">         * than one entry, we need to take</span><br><span class="line">         * &quot;nextdiff&quot; in account as well. </span><br><span class="line">         * Otherwise, a change in the</span><br><span class="line">         * size of prevlen doesn&#x27;t have an </span><br><span class="line">         * effect on the *tail* offset. */</span><br><span class="line">        zipEntry(p+reqlen, &amp;tail);</span><br><span class="line">        if (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;        </span><br><span class="line">        /* This element will be the new tail. */</span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;    </span><br><span class="line">    /* When nextdiff != 0, the raw </span><br><span class="line">     *length of the next entry has changed, so</span><br><span class="line">     * we need to cascade the update </span><br><span class="line">     * throughout the ziplist */</span><br><span class="line">    if (nextdiff != 0) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    /* Write the entry */</span><br><span class="line">    p += zipPrevEncodeLength(p,prevlen);</span><br><span class="line">    p += zipEncodeLength(p,encoding,slen);</span><br><span class="line">    if (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        memcpy(p,s,slen);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,1);</span><br><span class="line">    return zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>我们来简单解析一下这段代码：</p><ul><li>这个函数是在指定的位置p插入一段新的数据，待插入数据的地址指针是s，长度为slen。<br>插入后形成一个新的数据项，占据原来p的配置，原来位于p位置的数据项以及后面的所有数据项，需要统一向后移动，给新插入的数据项留出空间。<br>参数p指向的是ziplist中某一个数据项的起始位置，或者在向尾端插入的时候，它指向ziplist的结束标记<code>&lt;zlend&gt;</code>。</li><li>函数开始先计算出待插入位置前一个数据项的长度<code>prevlen</code>。这个长度要存入新插入的数据项的<code>&lt;prevrawlen&gt;</code>字段。</li><li>然后计算当前数据项占用的总字节数reqlen，它包含三部分：<code>&lt;prevrawlen&gt;, &lt;len&gt;, 真正的数据</code>。<br>其中的数据部分会通过调用<code>zipTryEncoding</code>先来尝试转成整数。</li><li>由于插入导致的ziplist对于内存的新增需求，除了待插入数据项占用的reqlen之外，还要考虑原来p位置的数据项（现在要排在待插入数据项之后）的<code>&lt;prevrawlen&gt;</code>字段的变化。<br>本来它保存的是前一项的总长度，现在变成了保存当前插入的数据项的总长度。<br>这样它的<code>&lt;prevrawlen&gt;</code>字段本身需要的存储空间也可能发生变化，这个变化可能是变大也可能是变小。<br>这个变化了多少的值nextdiff，是调用zipPrevLenByteDiff计算出来的。<br>如果变大了，nextdiff是正值，否则是负值。</li><li>现在很容易算出来插入后新的ziplist需要多少字节了，然后调用ziplistResize来重新调整大小。<br>ziplistResize的实现里会调用allocator的zrealloc，它有可能会造成数据拷贝。</li><li>现在额外的空间有了，接下来就是将原来p位置的数据项以及后面的所有数据都向后挪动，并为它设置新的<code>&lt;prevrawlen&gt;</code>字段。此外，还可能需要调整ziplist的<code>&lt;zltail&gt;</code>字段。</li><li>最后，组装新的待插入数据项，放在位置p。</li></ul><h3 id="hash与ziplist"><a href="#hash与ziplist" class="headerlink" title="hash与ziplist"></a>hash与ziplist</h3><p>hash是Redis中可以用来存储一个对象结构的比较理想的数据类型。一个对象的各个属性，正好对应一个hash结构的各个field。</p><p>我们在网上很容易找到这样一些技术文章，它们会说存储一个对象，使用hash比string要节省内存。<br>实际上这么说是有前提的，具体取决于对象怎么来存储：</p><ul><li>如果你把对象的多个属性存储到多个key上（各个属性值存成string），当然占的内存要多。</li><li>但如果你采用一些序列化方法，比如Protocol Buffers，或者Apache Thrift，先把对象序列化为字节数组，然后再存入到Redis的string中，那么跟hash相比，哪一种更省内存，就不一定了。</li></ul><p>当然，hash比序列化后再存入string的方式，在支持的操作命令上，还是有优势的：</p><ul><li>它既支持多个field同时存取（hmset/hmget），</li><li>也支持按照某个特定的field单独存取（hset/hget）。</li></ul><p>实际上，hash随着数据的增大，其底层数据结构的实现是会发生变化的，当然存储效率也就不同。</p><ul><li>在field比较少，各个value值也比较小的时候，hash采用ziplist来实现；</li><li>而随着field增多和value值增大，hash可能会变成dict来实现。</li></ul><p>当hash底层变成dict来实现的时候，它的存储效率就没法跟那些序列化方式相比了。</p><p>当我们为某个key第一次执行 hset key field value 命令的时候，Redis会创建一个hash结构，这个新创建的hash底层就是一个ziplist。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">robj *createHashObject(void) &#123;</span><br><span class="line">    unsigned char *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(OBJ_HASH, zl);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的createHashObject函数，出自object.c，它负责的任务就是创建一个新的hash结构。可以看出，它创建了一个type = OBJ_HASH但encoding = OBJ_ENCODING_ZIPLIST的robj对象。</p><p>实际上，本文前面给出的那个ziplist实例，就是由如下两个命令构建出来的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hset user:100 name tielei</span><br><span class="line">hset user:100 age 20</span><br></pre></td></tr></table></figure><p>每执行一次hset命令，插入的field和value分别作为一个新的数据项插入到ziplist中（即每次hset产生两个数据项）。</p><p>当随着数据的插入，hash底层的这个ziplist就可能会转成dict。那么到底插入多少才会转呢？</p><p>还记得本文开头提到的两个Redis配置吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br></pre></td></tr></table></figure><p>这个配置的意思是说，在如下两个条件之一满足的时候，ziplist会转成dict：</p><ul><li>当hash中的数据项（即field-value对）的数目超过512的时候，也就是ziplist数据项超过1024的时候（请参考t_hash.c中的hashTypeSet函数）。</li><li>当hash中插入的任意一个value的长度超过了64的时候（请参考t_hash.c中的hashTypeTryConversion函数）。</li></ul><p>Redis的hash之所以这样设计，是因为当ziplist变得很大的时候，它有如下几个缺点：</p><ul><li>每次插入或修改引发的realloc操作会有更大的概率造成内存拷贝，从而降低性能。</li><li>一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据。</li><li>当ziplist数据项过多的时候，在它上面查找指定的数据项就会性能变得很低，因为ziplist上的查找需要进行遍历。</li></ul><p>总之，ziplist本来就设计为各个数据项挨在一起组成连续的内存空间，这种结构<strong>并不擅长做修改操作</strong>。一旦数据发生改动，就会引发内存realloc，可能导致内存拷贝。</p><h2 id="Redis-quicklist"><a href="#Redis-quicklist" class="headerlink" title="Redis quicklist"></a>Redis quicklist</h2><h3 id="quickList概述"><a href="#quickList概述" class="headerlink" title="quickList概述"></a>quickList概述</h3><p>Redis对外暴露的上层list数据类型，经常被用作队列使用。比如它支持的如下一些操作：</p><ul><li>lpush: 在左侧（即列表头部）插入数据。</li><li>rpop: 在右侧（即列表尾部）删除数据。</li><li>rpush: 在右侧（即列表尾部）插入数据。</li><li>lpop: 在左侧（即列表头部）删除数据。</li></ul><p>这些操作都是O(1)时间复杂度的。</p><p>当然，list也支持在任意中间位置的存取操作，比如lindex和linsert，但它们都需要对list进行遍历，所以时间复杂度较高。</p><p>概况起来，list具有这样的一些特点：</p><ul><li>它是一个有序列表，便于在表的两端追加和删除数据，而对于中间位置的存取具有O(N)的时间复杂度。 </li></ul><p>这不正是一个双向链表所具有的特点吗？ list的内部实现quicklist正是一个双向链表。</p><p>在quicklist.c的文件头部注释中，是这样描述quicklist的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A doubly linked list of ziplists</span><br></pre></td></tr></table></figure><p>它确实是一个双向链表，而且是一个ziplist的双向链表。</p><p>ziplist本身也是一个有序列表，而且是一个内存紧缩的列表（各个数据项在内存上前后相邻）。</p><p>比如，一个包含3个节点的quicklist，如果每个节点的ziplist又包含4个数据项，那么对外表现上，这个list就总共包含12个数据项。</p><p>quicklist的结构为什么这样设计呢？总结起来，大概又是一个空间和时间的折中：</p><ul><li>双向链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</li><li>ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</li></ul><p>于是，结合了双向链表和ziplist的优点，quicklist就应运而生了。</p><p>不过，这也带来了一个新问题：到底一个quicklist节点包含多长的ziplist合适呢？比如，同样是存储12个数据项，既可以是一个quicklist包含3个节点，而每个节点的ziplist又包含4个数据项，也可以是一个quicklist包含6个节点，而每个节点的ziplist又包含2个数据项。</p><p>这又是一个需要找平衡点的难题。我们只从存储效率上分析一下：</p><ul><li>每个quicklist节点上的ziplist越短，则内存碎片越多。内存碎片多了，有可能在内存中产生很多无法被利用的小碎片，从而降低存储效率。这种情况的极端是每个quicklist节点上的ziplist只包含一个数据项，这就蜕化成一个普通的双向链表了。</li><li>每个quicklist节点上的ziplist越长，则为ziplist分配大块连续内存空间的难度就越大。有可能出现内存里有很多小块的空闲空间（它们加起来很多），但却找不到一块足够大的空闲空间分配给ziplist的情况。这同样会降低存储效率。这种情况的极端是整个quicklist只有一个节点，所有的数据项都分配在这仅有的一个节点的ziplist里面。这其实蜕化成一个ziplist了。</li></ul><p>可见，一个quicklist节点上的ziplist要保持一个合理的长度。那到底多长合理呢？这可能取决于具体应用场景。实际上，Redis提供了一个配置参数list-max-ziplist-size，就是为了让使用者可以来根据自己的情况进行调整。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list-max-ziplist-size -2</span><br></pre></td></tr></table></figure><p>我们来详细解释一下这个参数的含义。它可以取正值，也可以取负值。</p><p>当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。</p><p>当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5这五个值，每个值含义如下：</p><ul><li>-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb =&gt; 1024 bytes）</li><li>-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。</li><li>-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。 </li><li>-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）</li><li>-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。</li></ul><p>另外，list的设计目标是能够用来<strong>存储很长的数据列表</strong>的。</p><p>当列表很长的时候，最容易被访问的很可能是两端的数据，中间的数据被访问的频率比较低（访问起来性能也很低）。如果应用场景符合这个特点，那么list还提供了一个选项，能够把中间的数据节点进行压缩，从而进一步节省内存空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list-compress-depth 0</span><br></pre></td></tr></table></figure><p>这个参数表示一个quicklist两端不被压缩的节点个数。注：这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。实际上，一个quicklist节点上的ziplist，如果被压缩，就是整体被压缩的。</p><p>参数list-compress-depth的取值含义如下：</p><ul><li>0: 是个特殊值，表示都不压缩。这是Redis的默认值。</li><li>1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。</li><li>2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。</li><li>3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。</li><li>依此类推…</li></ul><p>由于0是个特殊值，很容易看出quicklist的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。</p><p>Redis对于quicklist内部节点的压缩算法，采用的<a href="http://oldhome.schmorp.de/marc/liblzf.html">LZF</a>——一种无损压缩算法。</p><h3 id="quicklist的数据结构定义"><a href="#quicklist的数据结构定义" class="headerlink" title="quicklist的数据结构定义"></a>quicklist的数据结构定义</h3><details><summary>quicklist相关的数据结构定义</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">typedef struct quicklistNode &#123;</span><br><span class="line">    struct quicklistNode *prev;</span><br><span class="line">    struct quicklistNode *next;</span><br><span class="line">    unsigned char *zl;</span><br><span class="line">    unsigned int sz;             /* ziplist size in bytes */</span><br><span class="line">    unsigned int count : 16;     /* count of items in ziplist */</span><br><span class="line">    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */</span><br><span class="line">    unsigned int container : 2;  /* NONE==1 or ZIPLIST==2 */</span><br><span class="line">    unsigned int recompress : 1; /* was this node previous compressed? */</span><br><span class="line">    unsigned int attempted_compress : 1; /* node can&#x27;t compress; too small */</span><br><span class="line">    unsigned int extra : 10; /* more bits to steal for future usage */</span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line">typedef struct quicklistLZF &#123;</span><br><span class="line">    unsigned int sz; /* LZF size in bytes*/</span><br><span class="line">    char compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br><span class="line"></span><br><span class="line">typedef struct quicklist &#123;</span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    unsigned long count; /* total count of all entries in all ziplists */</span><br><span class="line">    unsigned int len; /* number of quicklistNodes */</span><br><span class="line">    int fill : 16; /* fill factor for individual nodes */</span><br><span class="line">    unsigned int compress : 16; /* depth of end nodes not to compress;0=off */</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure></details><p>quicklistNode结构代表quicklist的一个节点，其中各个字段的含义如下：</p><ul><li>prev: 指向链表前一个节点的指针。</li><li>next: 指向链表后一个节点的指针。</li><li>zl: 数据指针。如果当前节点的数据没有压缩，那么它指向一个ziplist结构；否则，它指向一个quicklistLZF结构。</li><li>sz: 表示zl指向的ziplist的总大小（包括zlbytes, zltail,zllen, zlend和各个数据项）。需要注意的是：如果ziplist被压缩了，那么这个sz的值仍然是压缩前的ziplist大小。</li><li>count: 表示ziplist里面包含的数据项个数。这个字段只有16bit。稍后我们会一起计算一下这16bit是否够用。</li><li>encoding: 表示ziplist是否压缩了（以及用了哪个压缩算法）。目前只有两种取值：2表示被压缩了（而且用的是LZF压缩算法），1表示没有压缩。</li><li>container: 是一个预留字段。本来设计是用来表明一个quicklist节点下面是直接存数据，还是使用ziplist存数据，或者用其它的结构来存数据（用作一个数据容器，所以叫container）。但是，在目前的实现中，这个值是一个固定的值2，表示使用ziplist作为数据容器。</li><li>recompress: 当我们使用类似lindex这样的命令查看了某一项本来压缩的数据时，需要把数据暂时解压，这时就设置recompress=1做一个标记，等有机会再把数据重新压缩。</li><li>attempted_compress: 这个值只对Redis的自动化测试程序有用。我们不用管它。</li><li>extra: 其它扩展字段。目前Redis的实现里也没用上。</li></ul><p>quicklistLZF结构表示一个被压缩过的ziplist。其中：</p><ul><li>sz: 表示压缩后的ziplist大小。</li><li>compressed: 是个柔性数组（flexible array member），存放压缩后的ziplist字节数组。</li></ul><p>真正表示quicklist的数据结构是同名的quicklist这个struct：</p><ul><li>head: 指向头节点（左侧第一个节点）的指针。</li><li>tail: 指向尾节点（右侧第一个节点）的指针。</li><li>count: 所有ziplist数据项的个数总和。</li><li>len: quicklist节点的个数。</li><li>fill: 16bit，ziplist大小设置，存放list-max-ziplist-size参数的值。</li><li>compress: 16bit，节点压缩深度设置，存放list-compress-depth参数的值。</li></ul><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_32.png"><br>上图是一个quicklist的结构图举例（点击可以看大图）。图中例子对应的ziplist大小配置和节点压缩深度配置，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list-max-ziplist-size 3</span><br><span class="line">list-compress-depth 2</span><br></pre></td></tr></table></figure><p>这个例子中我们需要注意的几点是：</p><ul><li>两端各有2个橙黄色的节点，是没有被压缩的。它们的数据指针zl指向真正的ziplist。中间的其它节点是被压缩过的，它们的数据指针zl指向被压缩后的ziplist结构，即一个quicklistLZF结构。</li><li>左侧头节点上的ziplist里有2项数据，右侧尾节点上的ziplist里有1项数据，中间其它节点上的ziplist里都有3项数据（包括压缩的节点内部）。这表示在表的两端执行过多次push和pop操作后的一个状态。</li></ul><p>现在我们来大概计算一下quicklistNode结构中的count字段这16bit是否够用。</p><p>我们已经知道，ziplist大小受到list-max-ziplist-size参数的限制。按照正值和负值有两种情况：</p><ul><li>当这个参数取正值的时候，就是恰好表示一个quicklistNode结构中zl所指向的ziplist所包含的数据项的最大值。list-max-ziplist-size参数是由quicklist结构的fill字段来存储的，而fill字段是16bit，所以它所能表达的值能够用16bit来表示。</li><li>当这个参数取负值的时候，能够表示的ziplist最大长度是64 Kb。而ziplist中每一个数据项，最少需要2个字节来表示：1个字节的prevrawlen，1个字节的data（len字段和data合二为一；详见上一篇）。所以，ziplist中数据项的个数不会超过32 K，用16bit来表达足够了。</li></ul><p>实际上，在目前的quicklist的实现中，ziplist的大小还会受到另外的限制，根本不会达到这里所分析的最大值。</p><h3 id="quicklist执行过程源码"><a href="#quicklist执行过程源码" class="headerlink" title="quicklist执行过程源码"></a>quicklist执行过程源码</h3><h4 id="quicklist的创建"><a href="#quicklist的创建" class="headerlink" title="quicklist的创建"></a>quicklist的创建</h4><p>当我们使用lpush或rpush命令第一次向一个不存在的list里面插入数据的时候，Redis会首先调用</p><details><summary>quicklistCreate</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">quicklist *quicklistCreate(void) &#123;</span><br><span class="line">    struct quicklist *quicklist;</span><br><span class="line"></span><br><span class="line">    quicklist = zmalloc(sizeof(*quicklist));</span><br><span class="line">    quicklist-&gt;head = quicklist-&gt;tail = NULL;</span><br><span class="line">    quicklist-&gt;len = 0;</span><br><span class="line">    quicklist-&gt;count = 0;</span><br><span class="line">    quicklist-&gt;compress = 0;</span><br><span class="line">    quicklist-&gt;fill = -2;    </span><br><span class="line">    return quicklist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details> <p>接口创建一个空的quicklist。</p><p>在很多介绍数据结构的书上，实现双向链表的时候经常会多增加一个空余的头节点，主要是为了插入和删除操作的方便。从上面quicklistCreate的代码可以看出，quicklist是一个不包含空余头节点的双向链表（head和tail都初始化为NULL）。</p><h4 id="quicklist的push操作"><a href="#quicklist的push操作" class="headerlink" title="quicklist的push操作"></a>quicklist的push操作</h4><p>quicklist的push操作是调用</p><details><summary>quicklistPush</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">void quicklistPush(quicklist *quicklist, void *value, const size_t sz,                   int where) &#123;    </span><br><span class="line">    if (where == QUICKLIST_HEAD) &#123;</span><br><span class="line">        quicklistPushHead(quicklist, value, sz);</span><br><span class="line">    &#125; else if (where == QUICKLIST_TAIL) &#123;</span><br><span class="line">        quicklistPushTail(quicklist, value, sz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Add new entry to head node of quicklist.</span><br><span class="line"> *</span><br><span class="line"> * Returns 0 if used existing head.</span><br><span class="line"> * Returns 1 if new head created. */</span><br><span class="line">int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) &#123;</span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line">    if (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;head-&gt;count++;    </span><br><span class="line">    return (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Add new entry to tail node of quicklist.</span><br><span class="line"> *</span><br><span class="line"> * Returns 0 if used existing tail.</span><br><span class="line"> * Returns 1 if new tail created. */</span><br><span class="line">int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) &#123;</span><br><span class="line">    quicklistNode *orig_tail = quicklist-&gt;tail;</span><br><span class="line">    if (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;tail, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        quicklist-&gt;tail-&gt;zl =</span><br><span class="line">            ziplistPush(quicklist-&gt;tail-&gt;zl, value, sz, ZIPLIST_TAIL);</span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;tail);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);</span><br><span class="line"></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);</span><br><span class="line">    &#125;</span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    quicklist-&gt;tail-&gt;count++;    </span><br><span class="line">    return (orig_tail != quicklist-&gt;tail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>来实现的。</p><p>不管是在头部还是尾部插入数据，都包含两种情况：</p><ul><li>如果头节点（或尾节点）上ziplist大小没有超过限制（即_quicklistNodeAllowInsert返回1），那么新数据被直接插入到ziplist中（调用ziplistPush）。</li><li>如果头节点（或尾节点）上ziplist太大了，那么新创建一个quicklistNode节点（对应地也会新创建一个ziplist），然后把这个新创建的节点插入到quicklist双向链表中（调用_quicklistInsertNodeAfter）。</li></ul><p>在_quicklistInsertNodeAfter的实现中，还会根据list-compress-depth的配置将里面的节点进行压缩。它的实现比较繁琐，我们这里就不展开讨论了。</p><h4 id="quicklist的其它操作"><a href="#quicklist的其它操作" class="headerlink" title="quicklist的其它操作"></a>quicklist的其它操作</h4><p>quicklist的操作较多，且实现细节都比较繁杂，这里就不一一分析源码了，我们简单介绍一些比较重要的操作。</p><p>quicklist的pop操作是调用quicklistPopCustom来实现的。<br>quicklistPopCustom的实现过程基本上跟quicklistPush相反，先从头部或尾部节点的ziplist中把对应的数据项删除，如果在删除后ziplist为空了，那么对应的头部或尾部节点也要删除。<br>删除后还可能涉及到里面节点的解压缩问题。</p><p>quicklist不仅实现了从头部或尾部插入，也实现了从任意指定的位置插入。quicklistInsertAfter和quicklistInsertBefore就是分别在指定位置后面和前面插入数据项。这种在任意指定位置插入数据的操作，情况比较复杂，有众多的逻辑分支。</p><ul><li>当插入位置所在的ziplist大小没有超过限制时，直接插入到ziplist中就好了；</li><li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小没有超过限制，那么就转而插入到相邻的那个quicklist链表节点的ziplist中；</li><li>当插入位置所在的ziplist大小超过了限制，但插入的位置位于ziplist两端，并且相邻的quicklist链表节点的ziplist大小也超过限制，这时需要新创建一个quicklist链表节点插入。</li><li>对于插入位置所在的ziplist大小超过了限制的其它情况（主要对应于在ziplist中间插入数据的情况），则需要把当前ziplist分裂为两个节点，然后再其中一个节点上插入数据。</li></ul><p>quicklistSetOptions用于设置ziplist大小配置参数（list-max-ziplist-size）和节点压缩深度配置参数（list-compress-depth）。代码比较简单，就是将相应的值分别设置给quicklist结构的fill字段和compress字段。</p><h2 id="Redis-SkipList"><a href="#Redis-SkipList" class="headerlink" title="Redis SkipList"></a>Redis SkipList</h2><h3 id="什么是跳跃表"><a href="#什么是跳跃表" class="headerlink" title="什么是跳跃表"></a>什么是跳跃表</h3><p>skiplist本质上也是一种<strong>查找结构</strong>，用于解决算法中的查找问题（Searching），即根据给定的key，快速查到它所在的位置（或者对应的value）。</p><p>介绍dict的时候，曾经讨论过：一般查找问题的解法分为两个大类：</p><ul><li>一个是基于各种平衡树，</li><li>一个是基于哈希表。</li></ul><p>但skiplist却比较特殊，它没法归属到这两大类里面。</p><h4 id="skiplist数据结构简介"><a href="#skiplist数据结构简介" class="headerlink" title="skiplist数据结构简介"></a>skiplist数据结构简介</h4><p>跳跃表是一种<strong>有序的</strong>数据结构，它通过在<strong>每个节点中维持多个指向其他节点的指针</strong>，从而达到快速访问节点的目的。</p><p>这么说，我们可能很难理解，我们可以先回忆一下链表。</p><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img.png"></p><p>如果我们想要提高其查找效率，可以考虑在链表上建索引的方式。每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_1.png"></p><p>这个时候，我们假设要查找节点8，我们可以先在索引层遍历，当遍历到索引层中值为 7 的结点时，发现下一个节点是9，那么要查找的节点8肯定就在这两个节点之间。</p><p>我们下降到链表层继续遍历就找到了8这个节点。</p><p>原先我们在单链表中找到8这个节点要遍历8个节点，而现在有了一级索引后只需要遍历五个节点。</p><p>从这个例子里，我们看出，加来一层索引之后，查找一个结点需要遍的结点个数减少了，也就是说查找效率提高了。</p><p>同理再加一级索引：</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_2.png"></p><p>从图中我们可以看出，查找效率又有提升。在例子中我们的数据很少，当有大量的数据时，我们可以增加多级索引，其查找效率可以得到明显提升。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_3.png"></p><p>skiplist正是受这种多层链表的想法的启发而设计出来的。</p><p>实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。</p><p>但是，这种方法在插入数据的时候有很大的问题。</p><p>新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。<br>如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。<br>删除数据也有同样的问题。</p><p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是**为每个节点随机出一个层数(level)**。</p><p>比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。</p><p>为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程（点击看大图）：</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_28.png"></p><p>从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。</p><p>实际上，这是skiplist的一个很重要的特性，这让它在<strong>插入性能上明显优于平衡树</strong>的方案。这在后面我们还会提到。</p><p>根据上图中的skiplist结构，我们很容易理解这种数据结构的名字的由来。</p><p>skiplist，翻译成中文，可以翻译成“跳表”或“跳跃表”，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。</p><p>这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。</p><p>在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。</p><p>刚刚创建的这个skiplist总共包含4层链表，现在假设我们在它里面依然查找23，下图给出了查找路径：</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_29.png"></p><p>需要注意的是，前面演示的各个节点的插入过程，实际上在插入之前也要先经历一个类似的查找过程，在确定插入位置后，再完成插入操作。</p><p>至此，skiplist的查找和插入操作，我们已经很清楚了。而删除操作与插入操作类似，我们也很容易想象出来。这些操作我们也应该能很容易地用代码实现出来。</p><p>当然，实际应用中的skiplist每个节点应该包含key和value两部分。前面的描述中我们没有具体区分key和value，但实际上列表中是按照key进行排序的，查找过程也是根据key在比较。</p><h4 id="skiplist算法性能"><a href="#skiplist算法性能" class="headerlink" title="skiplist算法性能"></a>skiplist算法性能</h4><p>节点插入时随机出一个层数，仅仅依靠这样一个简单的随机数操作而构建出来的多层链表结构，能保证它有一个良好的查找性能吗？</p><p>在分析之前，我们还需要着重指出的是，执行插入操作时计算随机数的过程，是一个很关键的过程，它对skiplist的统计特性有着很重要的影响。</p><p>这并不是一个普通的服从均匀分布的随机数，它的计算过程如下：</p><ul><li>首先，每个节点肯定都有第1层指针（每个节点都在第1层链表里）。</li><li>如果一个节点有第i层(i&gt;=1)指针（即节点已经在第1层到第i层链表中），那么它有第(i+1)层指针的概率为p。</li><li>节点最大的层数不允许超过一个最大值，记为MaxLevel。</li></ul><p>这个计算随机层数的伪码如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">randomLevel()</span><br><span class="line">    level := 1</span><br><span class="line">    // random()返回一个[0...1)的随机数</span><br><span class="line">    while random() &lt; p and level &lt; MaxLevel do</span><br><span class="line">        level := level + 1</span><br><span class="line">    return level</span><br></pre></td></tr></table></figure><p>randomLevel()的伪码中包含两个参数，一个是p，一个是MaxLevel。在Redis的skiplist实现中，这两个参数的取值为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = 1/4</span><br><span class="line">MaxLevel = 32</span><br></pre></td></tr></table></figure><p>我们先来计算一下每个节点所包含的平均指针数目（概率期望）。节点包含的指针数目，相当于这个算法在空间上的额外开销(overhead)，可以用来度量空间复杂度。</p><p>根据前面randomLevel()的伪码，我们很容易看出，产生越高的节点层数，概率越低。定量的分析如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">节点层数至少为1。而大于1的节点层数，满足一个概率分布。</span><br><span class="line">节点层数恰好等于1的概率为1-p。</span><br><span class="line">节点层数大于等于2的概率为p，而节点层数恰好等于2的概率为p(1-p)。</span><br><span class="line">节点层数大于等于3的概率为p2，而节点层数恰好等于3的概率为p2(1-p)。</span><br><span class="line">节点层数大于等于4的概率为p3，而节点层数恰好等于4的概率为p3(1-p)。</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>因此，一个节点的平均层数（也即包含的平均指针数目），计算如下：</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_30.png"></p><p>现在很容易计算出：</p><ul><li>当p=1/2时，每个节点所包含的平均指针数目为2；</li><li>当p=1/4时，每个节点所包含的平均指针数目为1.33。这也是Redis里的skiplist实现在空间上的开销。</li></ul><p>接下来，为了分析时间复杂度，我们计算一下skiplist的平均查找长度。查找长度指的是查找路径上跨越的跳数，而查找过程中的比较次数就等于查找长度加1。<br>以前面图中标出的查找23的查找路径为例，从左上角的头结点开始，一直到结点22，查找长度为6。</p><p>为了计算查找长度，这里我们需要利用一点小技巧。我们注意到，每个节点插入的时候，它的层数是由随机函数randomLevel()计算出来的，而且随机的计算不依赖于其它节点，每次插入过程都是完全独立的。所以，从统计上来说，一个skiplist结构的形成与节点的插入顺序无关。</p><p>这样的话，为了计算查找长度，我们可以将查找过程倒过来看，从右下方第1层上最后到达的那个节点开始，沿着查找路径向左向上回溯，类似于爬楼梯的过程。我们假设当回溯到某个节点的时候，它才被插入，这虽然相当于改变了节点的插入顺序，但从统计上不影响整个skiplist的形成结构。</p><p>现在假设我们从一个层数为i的节点x出发，需要向左向上攀爬k层。这时我们有两种可能：</p><ul><li>如果节点x有第(i+1)层指针，那么我们需要向上走。这种情况概率为p。</li><li>如果节点x没有第(i+1)层指针，那么我们需要向左走。这种情况概率为(1-p)。</li></ul><p>用C(k)表示向上攀爬k个层级所需要走过的平均查找路径长度（概率期望）,得到一个差分方程并化简：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C(k)=(1-p)(C(k)+1) + p(C(k-1)+1)</span><br><span class="line">C(k)=1/p+C(k-1)</span><br><span class="line">C(k)=k/p</span><br></pre></td></tr></table></figure><p>这个结果的意思是，我们每爬升1个层级，需要在查找路径上走1/p步。而我们总共需要攀爬的层级数等于整个skiplist的总层数-1。</p><p>那么接下来我们需要分析一下当skiplist中有n个节点的时候，它的总层数的概率均值是多少。这个问题直观上比较好理解。根据节点的层数随机算法，容易得出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第1层链表固定有n个节点；</span><br><span class="line">第2层链表平均有n*p个节点；</span><br><span class="line">第3层链表平均有n*p2个节点；</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>所以，从第1层到最高层，各层链表的平均节点数是一个指数递减的等比数列。容易推算出，总层数的均值为log1/pn，而最高层的平均节点数为1/p。</p><p>综上，粗略来计算的话，平均查找长度约等于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C(log1/pn-1)=(log1/pn-1)/p</span><br></pre></td></tr></table></figure><p>即，**平均时间复杂度为O(log n)**。</p><p>当然，这里的时间复杂度分析还是比较粗略的：</p><ul><li>比如，沿着查找路径向左向上回溯的时候，可能先到达左侧头结点，然后沿头结点一路向上；</li><li>还可能先到达最高层的节点，然后沿着最高层链表一路向左。</li></ul><p>但这些细节不影响平均时间复杂度的最后结果。</p><p>另外，这里给出的时间复杂度只是一个概率平均值，但实际上计算一个精细的概率分布也是有可能的。</p><h4 id="skiplist与平衡树、哈希表的比较"><a href="#skiplist与平衡树、哈希表的比较" class="headerlink" title="skiplist与平衡树、哈希表的比较"></a>skiplist与平衡树、哈希表的比较</h4><ul><li>skiplist和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。所谓范围查找，指的是查找那些大小在指定的两个值之间的所有节点。</li><li>在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</li><li>平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</li><li>从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</li><li>查找单个key，skiplist和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。</li><li>从算法实现难度上来比较，skiplist比平衡树要简单得多。</li></ul><h3 id="Redis中SkipList使用"><a href="#Redis中SkipList使用" class="headerlink" title="Redis中SkipList使用"></a>Redis中SkipList使用</h3><p>Redis使用跳跃表作为有序集合键(sorted set)的底层实现之一(sorted set底层不仅仅使用了skiplist，还使用了ziplist和dict),</p><ul><li>如果一个有序集合包含的<strong>元素数量比较多</strong></li><li>又或者有序集合中元素的成员是<strong>比较长的字符串</strong>时,<br>Redis就会使用跳跃表来作为有序集合健的底层实现。</li></ul><p>这里我们需要思考一个问题——为什么元素数量比较多或者成员是比较长的字符串的时候Redis要使用跳跃表来实现？</p><p>从上面我们可以知道，跳跃表在链表的基础上增加了多级索引以提升查找的效率，但其是一个空间换时间的方案，必然会带来一个问题——<strong>索引是占内存的</strong>。</p><p>原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值值和几个指针，并不需要存储对象，因此当<strong>节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略</strong>。</p><h3 id="Redis中SkipList的实现"><a href="#Redis中SkipList的实现" class="headerlink" title="Redis中SkipList的实现"></a>Redis中SkipList的实现</h3><h4 id="Redis中SkipList实现的特殊性"><a href="#Redis中SkipList实现的特殊性" class="headerlink" title="Redis中SkipList实现的特殊性"></a>Redis中SkipList实现的特殊性</h4><p>我们简单分析一下几个查询命令：</p><ul><li>zrevrank由数据查询它对应的排名，这在前面介绍的skiplist中并不支持。</li><li>zscore由数据查询它对应的分数，这也不是skiplist所支持的。</li><li>zrevrange根据一个排名范围，查询排名在这个范围内的数据。这在前面介绍的skiplist中也不支持。</li><li>zrevrangebyscore根据分数区间查询数据集合，是一个skiplist所支持的典型的范围查找（score相当于key）。</li></ul><p>实际上，Redis中sorted set的实现是这样的：</p><ul><li>当数据较少时，sorted set是由一个ziplist来实现的。</li><li>当数据多的时候，sorted set是由一个dict + 一个skiplist来实现的。<ul><li>dict用来查询数据到分数的对应关系</li><li>而skiplist用来根据分数查询数据（可能是范围查找）。</li></ul></li></ul><p>现在我们集中精力来看一下sorted set与skiplist的关系，：</p><ul><li>zscore(由数据查分数)的查询，不是由skiplist来提供的，而是由那个dict来提供的。 </li><li>为了支持排名(rank)，Redis里对skiplist做了扩展，使得根据排名能够快速查到数据，或者根据分数查到数据之后，也同时很容易获得排名。<ul><li>根据排名的查找，时间复杂度也为O(log n)。</li></ul></li><li>zrevrange的查询，是根据排名查数据，由扩展后的skiplist来提供。</li><li>zrevrank是先在dict中由数据查到分数，再拿分数到skiplist中去查找，查到后也同时获得了排名。</li></ul><p>前述的查询过程，也暗示了各个操作的时间复杂度：</p><ul><li>zscore只用查询一个dict，所以时间复杂度为O(1)</li><li>zrevrank, zrevrange, zrevrangebyscore由于要查询skiplist，所以<ul><li>zrevrank的时间复杂度为O(log n)，</li><li>而zrevrange, zrevrangebyscore的时间复杂度为O(log(n)+M)，其中M是当前查询返回的元素个数。</li></ul></li></ul><p>总结起来，Redis中的skiplist跟前面介绍的经典的skiplist相比，有如下不同：</p><ul><li>分数(score)允许重复，即skiplist的key允许重复。这在最开始介绍的经典skiplist中是不允许的。</li><li>在比较时，不仅比较分数（相当于skiplist的key），还比较数据本身。在Redis的skiplist实现中，数据本身的内容唯一标识这份数据，而不是由key来唯一标识。另外，当多个元素分数相同的时候，还需要根据数据内容来进字典排序。</li><li>第1层链表不是一个单向链表，而是一个双向链表。这是为了方便以倒序方式获取一个范围内的元素。</li><li>在skiplist中可以很方便地计算出每个元素的排名(rank)。</li></ul><h4 id="SkipList的数据结构定义"><a href="#SkipList的数据结构定义" class="headerlink" title="SkipList的数据结构定义"></a>SkipList的数据结构定义</h4><p>Redis的跳跃表由zskiplistNode和skiplist两个结构定义,其中 </p><ul><li>zskiplistNode结构用于表示跳跃表节点,</li><li>而zskiplist结构则用于保存跳跃表节点的相关信息,比如节点的数量,以及指向表头节点和表尾节点的指针等等。</li></ul><details><summary>zskiplistNode & zskiplist 源码 (出自server.h)</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define ZSKIPLIST_MAXLEVEL 32</span><br><span class="line">#define ZSKIPLIST_P 0.25</span><br><span class="line"></span><br><span class="line">typedef struct zskiplistNode &#123;</span><br><span class="line">    robj *obj;</span><br><span class="line">    double score;</span><br><span class="line">    struct zskiplistNode *backward;</span><br><span class="line">    struct zskiplistLevel &#123;</span><br><span class="line">        struct zskiplistNode *forward;</span><br><span class="line">        unsigned int span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line">typedef struct zskiplist &#123;</span><br><span class="line">    struct zskiplistNode *header, *tail;</span><br><span class="line">    unsigned long length;</span><br><span class="line">    int level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><ul><li>开头定义了两个常量，ZSKIPLIST_MAXLEVEL和ZSKIPLIST_P，分别对应我们前面讲到的skiplist的两个参数：一个是MaxLevel，一个是p。</li><li>zskiplistNode定义了skiplist的节点结构。</li><li>zskiplist定义了真正的skiplist结构。</li></ul></details><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_4.png"></p><p>上图展示了一个跳跃表示例,其中最左边的是 <strong>skiplist</strong> 结构,该结构包含以下属性:</p><p><strong>头指针header、 尾指针tail</strong>: 通过这个指针程序定位表头、表尾节点的时间复杂度就为O(1)</p><p><strong>总层数level</strong>: 当前所有节点层数的最大值(表头节点的层数不计算在内)，通过这个属性可以再O(1)的时间复杂度内获取层高最好的节点的层数。</p><p><strong>链表长度length</strong>: 记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(新创建的skiplist包含一个空的头指针，这个头指针不计算在内)，通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度。</p><p>结构右方的是四个 <strong>zskiplistNode</strong> 结构,该结构包含以下属性。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_5.png"></p><p><strong>level[]</strong>: 指向各层链表后一个节点的指针（后向指针）</p><ul><li>每层对应1个后向指针，用forward字段表示。 </li><li>每个后向指针还对应了一个span值，它表示当前的指针跨越了多少个节点<ul><li>span用于计算元素排名(rank)，这正是前面我们提到的Redis对于skiplist所做的一个扩展。</li><li>注意的是，level[]是一个柔性数组（flexible array member），因此它占用的内存不在zskiplistNode结构里面，而需要插入节点的时候单独为它分配。</li><li>也正因为如此，skiplist的每个节点所包含的指针数目才是不固定的，我们前面分析过的结论——skiplist每个节点包含的指针数目平均为1/(1-p)——才能有意义。</li></ul></li><li>每次创建一个新跳跃表节点的时候,程序都根据幂次定律(powerlaw,越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小,这个大小就是层的“高度”。</li></ul><p><strong>backward指针</strong>：指向链表前一个节点的指针（前向指针）</p><ul><li>节点中用BW字样标记节点的前向指针,它指向位于当前节点的前一个节点。</li><li>前向指针在程序从表尾向表头遍历时使用。</li><li>与后向指针所不同的是每个节点只有一个前向指针，因此每次只能后退一个节点（所以只有第1层链表是一个双向链表。）。</li></ul><p><strong>分值(score)</strong>: 数据对应的分数</p><ul><li>在跳跃表中,节点按各自所保存的分值<strong>从小到大</strong>排列。</li></ul><p><strong>成员对象(oj)</strong>: 一个string robj的节点对象</p><ul><li>本来一个string robj可能存放的不是sds，而是long型，但zadd命令在将数据插入到skiplist里面之前先进行了解码，所以这里的obj字段里存储的一定是一个sds。 </li><li>方便在查找的时候对数据进行字典序的比较（分值相同的节点将按照成员对象在字典序中的大小来进行排序），而且，skiplist里的数据部分是数字的可能性也比较小。</li><li>成员对象较小的节点会排在前面(靠近表头的方向),而成员对象较大的节点则会排在后面(靠近表尾的方向)。</li></ul><p>下图以一个常规的代数课成绩表为例，展示了Redis中一个skiplist的可能结构：</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_31.png"></p><p>注意：图中前向指针上面括号中的数字，表示对应的span的值。即当前指针跨越了多少个节点，这个计数不包括指针的起点节点，但包括指针的终点节点。</p><p>假设我们在这个skiplist中查找score=89.0的元素（即Bob的成绩数据），在查找路径中，我们会跨域图中标红的指针，这些指针上面的span值累加起来，就得到了Bob的排名(2+2+1)-1=4（减1是因为rank值以0起始）。需要注意这里算的是从小到大的排名，而如果要算从大到小的排名，只需要用skiplist长度减去查找路径上的span累加值，即6-(2+2+1)=1。</p><p>可见，在查找skiplist的过程中，通过累加span值的方式，我们就能很容易算出排名。相反，如果指定排名来查找数据（类似zrange和zrevrange那样），也可以不断累加span并时刻保持累加值不超过指定的排名，通过这种方式就能得到一条O(log n)的查找路径。</p><h4 id="Redis中的SortedSet"><a href="#Redis中的SortedSet" class="headerlink" title="Redis中的SortedSet"></a>Redis中的SortedSet</h4><p>我们前面提到过，Redis中的sorted set，是在skiplist, dict和ziplist基础上构建起来的:</p><ul><li>当数据较少时，sorted set是由一个ziplist来实现的。</li><li>当数据多的时候，sorted set是由一个叫zset的数据结构来实现的，这个zset包含一个dict + 一个skiplist。dict用来查询数据到分数(score)的对应关系，而skiplist用来根据分数查询数据（可能是范围查找）。</li></ul><p>在这里我们先来讨论一下前一种情况——基于ziplist实现的sorted set。ziplist是由很多数据项组成的一大块连续内存。</p><p>由于sorted set的每一项元素都由数据和score组成，因此，当使用zadd命令插入一个(数据, score)对的时候，底层在相应的ziplist上就插入两个数据项：数据在前，score在后。</p><p>ziplist的主要优点是节省内存，但它上面的查找操作只能按顺序查找（可以正序也可以倒序）。因此，sorted set的各个查询操作，就是在ziplist上从前向后（或从后向前）一步步查找，每一步前进两个数据项，跨域一个(数据, score)对。</p><p>随着数据的插入，sorted set底层的这个ziplist就可能会转成zset的实现（转换过程详见t_zset.c的zsetConvert）。那么到底插入多少才会转呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br></pre></td></tr></table></figure><p>这个配置的意思是说，在如下两个条件之一满足的时候，ziplist会转成zset（具体的触发条件参见t_zset.c中的zaddGenericCommand相关代码）：</p><ul><li>当sorted set中的元素个数，即(数据, score)对的数目超过128的时候，也就是ziplist数据项超过256的时候。</li><li>当sorted set中插入的任意一个数据的长度超过了64的时候。</li></ul><p>最后，zset结构的代码定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><h3 id="Redis中SkipList常用操作时间复杂度"><a href="#Redis中SkipList常用操作时间复杂度" class="headerlink" title="Redis中SkipList常用操作时间复杂度"></a>Redis中SkipList常用操作时间复杂度</h3><table><thead><tr><th>操作</th><th>时间复杂度</th></tr></thead><tbody><tr><td>创建一个跳跃表</td><td>O(1)</td></tr><tr><td>释放给定跳跃表以及其中包含的节点</td><td>O(N)</td></tr><tr><td>添加给定成员和分值的新节点</td><td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td></tr><tr><td>删除除跳跃表中包含给定成员和分值的节点</td><td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td></tr><tr><td>返回给定成员和分值的节点再表中的排位</td><td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td></tr><tr><td>返回在给定排位上的节点</td><td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td></tr><tr><td>给定一个分值范围,返回跳跃表中第一个符合这个范围的节点</td><td>O(1)</td></tr><tr><td>给定一个分值范围,返回跳跃表中最后一个符合这个范围的节点</td><td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td></tr><tr><td>给定一个分值范围,除跳跃表中所有在这个范围之内的节点</td><td>平均O(logN),最坏O(logN)(N为跳跃表的长度)</td></tr><tr><td>给定一个排位范围,鼎除跳跃表中所有在这个范围之内的节点</td><td>O(N),N为被除节点数量</td></tr><tr><td>给定一个分值范固(range),比如0到15,20到28,诸如此类,如果跳氏表中有至少一个节点的分值在这个范間之内,那么返回1,否则返回0</td><td>O(N),N为被除节点数量</td></tr></tbody></table><h2 id="Redis-IntSet"><a href="#Redis-IntSet" class="headerlink" title="Redis IntSet"></a>Redis IntSet</h2><p>Redis里面使用intset是为了实现集合(set)这种对外的数据结构。<br>set结构类似于数学上的集合的概念，它包含的元素无序，且不能重复。<br>Redis里的set结构还实现了基础的集合并、交、差的操作。</p><p>与Redis对外暴露的其它数据结构类似，set的底层实现，随着元素类型是否是整型以及添加的元素的数目多少，而有所变化。<br>概括来讲：</p><ul><li>当set中添加的元素都是整型且元素数目较少时，set使用intset作为底层数据结构，</li><li>否则，set使用dict作为底层数据结构。</li></ul><h3 id="intset数据结构简介"><a href="#intset数据结构简介" class="headerlink" title="intset数据结构简介"></a>intset数据结构简介</h3><p>intset顾名思义，是由整数组成的集合。</p><p>实际上，intset是一个由整数组成的有序集合，从而便于在上面进行二分查找，用于快速地判断一个元素是否属于这个集合。</p><p>它在内存分配上与ziplist有些类似，是连续的一整块内存空间，而且对于大整数和小整数（按绝对值）采取了不同的编码，尽量对内存的使用进行了优化。</p><details><summary>intset的数据结构定义</summary><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    uint32_t length;</span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line"></span><br><span class="line">#define INTSET_ENC_INT16 (sizeof(int16_t))</span><br><span class="line">#define INTSET_ENC_INT32 (sizeof(int32_t))</span><br><span class="line">#define INTSET_ENC_INT64 (sizeof(int64_t))</span><br></pre></td></tr></table></figure></details><p>各个字段含义如下：</p><ul><li><p>encoding: 数据编码，表示intset中的每个数据元素用几个字节来存储。它有三种可能的取值：</p><ul><li>INTSET_ENC_INT16表示每个元素用2个字节存储，</li><li>INTSET_ENC_INT32表示每个元素用4个字节存储，</li><li>INTSET_ENC_INT64表示每个元素用8个字节存储。</li></ul><p>因此，intset中存储的整数最多只能占用64bit。</p></li><li><p>length: 表示intset中的元素个数。encoding和length两个字段构成了intset的头部（header）。</p></li><li><p>contents: 是一个柔性数组（flexible array member），表示intset的header后面紧跟着数据元素。</p><ul><li>这个数组的总长度（即总字节数）等于encoding * length。</li><li>柔性数组在Redis的很多数据结构的定义中都出现过（例如sds,quicklist, skiplist），用于表达一个偏移量。</li><li>contents需要单独为其分配空间，这部分内存不包含在intset结构当中。</li></ul></li></ul><p>其中需要注意的是，intset可能会随着数据的添加而改变它的数据编码：</p><ul><li>最开始，新创建的intset使用占内存最小的INTSET_ENC_INT16（值为2）作为数据编码。</li><li>每添加一个新元素，则根据元素大小决定是否对数据编码进行升级。</li></ul><p>下图给出了一个添加数据的具体例子（点击看大图）。</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_33.png"></p><p>在上图中：</p><ul><li>新创建的intset只有一个header，总共8个字节。其中encoding = 2, length = 0。</li><li>添加13, 5两个元素之后，因为它们是比较小的整数，都能使用2个字节表示，所以encoding不变，值还是2。</li><li>当添加32768的时候，它不再能用2个字节来表示了（2个字节能表达的数据范围是-215~215-1，而32768等于215，超出范围了），因此encoding必须升级到INTSET_ENC_INT32（值为4），即用4个字节表示一个元素。</li><li>在添加每个元素的过程中，intset始终保持从小到大有序。</li><li>与ziplist类似，intset也是按小端（little endian）模式存储的（参见维基百科词条Endianness）。比如，在上图中intset添加完所有数据之后，表示encoding字段的4个字节应该解释成0x00000004，而第5个数据应该解释成0x000186A0 = 100000。</li></ul><p>intset与ziplist相比：</p><ul><li>ziplist可以存储任意二进制串，而intset只能存储整数。</li><li>ziplist是无序的，而intset是从小到大有序的。因此，在ziplist上查找只能遍历，而在intset上可以进行二分查找，性能更高。</li><li>ziplist可以对每个数据项进行不同的变长编码（每个数据项前面都有数据长度字段len），而intset只能整体使用一个统一的编码（encoding）。</li></ul><h3 id="intset的查找和添加操作"><a href="#intset的查找和添加操作" class="headerlink" title="intset的查找和添加操作"></a>intset的查找和添加操作</h3><p>要理解intset的一些实现细节，只需要关注intset的两个关键操作基本就可以了：查找（intsetFind）和添加（intsetAdd）元素。</p><h4 id="intsetFind"><a href="#intsetFind" class="headerlink" title="intsetFind"></a>intsetFind</h4><p>intsetFind的关键代码如下：</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_34.png"></p><p>关于以上代码，我们需要注意的地方包括：</p><ul><li>intsetFind在指定的intset中查找指定的元素value，找到返回1，没找到返回0。</li><li>_intsetValueEncoding函数会根据要查找的value落在哪个范围而计算出相应的数据编码（即它应该用几个字节来存储）。</li><li>如果value所需的数据编码比当前intset的编码要大，则它肯定在当前intset所能存储的数据范围之外（特别大或特别小），所以这时会直接返回0；否则调用intsetSearch执行一个二分查找算法。</li><li>intsetSearch在指定的intset中查找指定的元素value，如果找到，则返回1并且将参数pos指向找到的元素位置；如果没找到，则返回0并且将参数pos指向能插入该元素的位置。</li><li>intsetSearch是对于二分查找算法的一个实现，它大致分为三个部分：<ul><li>特殊处理intset为空的情况。</li><li>特殊处理两个边界情况：当要查找的value比最后一个元素还要大或者比第一个元素还要小的时候。实际上，这两部分的特殊处理，在二分查找中并不是必须的，但它们在这里提供了特殊情况下快速失败的可能。</li><li>真正执行二分查找过程。注意：如果最后没找到，插入位置在min指定的位置。</li></ul></li><li>代码中出现的intrev32ifbe是为了在需要的时候做大小端转换的。<br>前面我们提到过，intset里的数据是按小端（little endian）模式存储的，因此在大端（big endian）机器上运行时，这里的intrev32ifbe会做相应的转换。</li></ul><p>这个查找算法的总的时间复杂度为O(log n)。</p><h4 id="intsetAdd"><a href="#intsetAdd" class="headerlink" title="intsetAdd"></a>intsetAdd</h4><p>intsetAdd的关键代码如下（出自intset.c）</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_35.png"></p><p>关于以上代码，我们需要注意的地方包括：</p><ul><li>intsetAdd在intset中添加新元素value。<ul><li>如果value在添加前已经存在，则不会重复添加， 这时参数success被置为0；</li><li>如果value在原来intset中不存在，则将value插入到适当位置，这时参数success被置为0。</li></ul></li><li>如果要添加的元素value所需的数据编码比当前intset的编码要大，那么则调用intsetUpgradeAndAdd将intset的编码进行升级后再插入value。</li><li>调用intsetSearch，如果能查到，则不会重复添加。</li><li>如果没查到，则调用intsetResize对intset进行内存扩充，使得它能够容纳新添加的元素。<ul><li><a href="http://man.cx/realloc">因为intset是一块连续空间，因此这个操作会引发内存的realloc, 这有可能带来一次数据拷贝</a></li><li>同时调用intsetMoveTail将待插入位置后面的元素统一向后移动1个位置，这也涉及到一次数据拷贝。<ul><li>值得注意的是，在intsetMoveTail中是调用memmove完成这次数据拷贝的。</li><li><a href="http://man.cx/memmove">memmove保证了在拷贝过程中不会造成数据重叠或覆盖</a></li></ul></li></ul></li><li>intsetUpgradeAndAdd的实现中也会调用intsetResize来完成内存扩充。<ul><li>在进行编码升级时，intsetUpgradeAndAdd的实现会把原来intset中的每个元素取出来，再用新的编码重新写入新的位置。</li></ul></li><li>注意一下intsetAdd的返回值，它返回一个新的intset指针。<ul><li>它可能与传入的intset指针is相同，也可能不同。调用方必须用这里返回的新的intset，替换之前传进来的旧的intset变量。类似这种接口使用模式，在Redis的实现代码中是很常见的，比如我们之前在介绍sds和ziplist的时候都碰到过类似的情况。</li></ul></li></ul><p>显然，这个intsetAdd算法总的时间复杂度为O(n)。</p><h3 id="Redis-Set结构"><a href="#Redis-Set结构" class="headerlink" title="Redis Set结构"></a>Redis Set结构</h3><p>为了更好地理解Redis对外暴露的set数据结构，我们先看一下set的一些关键的命令。下面是一些命令举例：</p><p><img src="/2022/03/09/%E4%B8%AD%E9%97%B4%E4%BB%B6/Cache/Redis/Redis%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B9%8B%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/img_36.png"></p><p>上面这些命令的含义：</p><ul><li>sadd用于分别向集合s1和s2中添加元素。添加的元素既有数字，也有非数字（”a”和”b”）。</li><li>sismember用于判断指定的元素是否在集合内存在。</li><li>sinter, sunion和sdiff分别用于计算集合的交集、并集和差集。</li></ul><p>我们前面提到过，set的底层实现，随着元素类型是否是整型以及添加的元素的数目多少，而有所变化。<br>例如，具体到上述命令的执行过程中，集合s1的底层数据结构会发生如下变化：</p><ul><li>在开始执行完sadd s1 13 5之后，由于添加的都是比较小的整数，所以s1底层是一个intset，其数据编码encoding= 2。</li><li>在执行完sadd s1 32768 10 100000之后，s1底层仍然是一个intset，但其数据编码encoding从2升级到了4。</li><li>在执行完sadd s1 a b之后，由于添加的元素不再是数字，s1底层的实现会转成一个dict。</li></ul><p>我们知道，dict是一个用于维护key和value映射关系的数据结构，那么当set底层用dict表示的时候，它的key和value分别是什么呢？</p><p>实际上，key就是要添加的集合元素，而value是NULL。</p><p>除了前面提到的由于添加非数字元素造成集合底层由intset转成dict之外，还有两种情况可能造成这种转换：</p><ul><li>添加了一个数字，但它无法用64bit的有符号数来表达。intset能够表达的最大的整数范围为-264~264-1，因此，如果添加的数字超出了这个范围，这也会导致intset转成dict。</li><li>添加的集合元素个数超过了set-max-intset-entries配置的值的时候，也会导致intset转成dict（具体的触发条件参见t_set.c中的setTypeAdd相关代码）。</li></ul><p>对于小集合使用intset来存储，主要的原因是节省内存。特别是当存储的元素个数较少的时候，dict所带来的内存开销要大得多（包含两个哈希表、链表指针以及大量的其它元数据）。所以，当存储大量的小集合而且集合元素都是数字的时候，用intset能节省下一笔可观的内存空间。</p><p>实际上，从时间复杂度上比较，intset的平均情况是没有dict性能高的。以查找为例，intset是O(log n)的，而dict可以认为是O(1)的。但是，由于使用intset的时候集合元素个数比较少，所以这个影响不大。</p><h3 id="RedisSet的并、交、叉算法"><a href="#RedisSet的并、交、叉算法" class="headerlink" title="RedisSet的并、交、叉算法"></a>RedisSet的并、交、叉算法</h3><p>Redis set的并、交、差算法的实现代码，在t_set.c中。</p><p>其中计算交集调用的是sinterGenericCommand，计算并集和差集调用的是sunionDiffGenericCommand。</p><p>它们都能同时对多个（可以多于2个）集合进行运算。</p><p>当对多个集合进行差集运算时，它表达的含义是：用第一个集合与第二个集合做差集，所得结果再与第三个集合做差集，依次向后类推。</p><h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h4><p>计算交集的过程大概可以分为三部分：</p><ol><li>检查各个集合，对于不存在的集合当做空集来处理。一旦出现空集，则不用继续计算了，最终的交集就是空集。</li><li>对各个集合按照元素个数由少到多进行排序。这个排序有利于后面计算的时候从最小的集合开始，需要处理的元素个数较少。</li><li>对排序后第一个集合（也就是最小集合）进行遍历，对于它的每一个元素，依次在后面的所有集合中进行查找。只有在所有集合中都能找到的元素，才加入到最后的结果集合中。</li></ol><p>需要注意的是，上述第3步在集合中进行查找，对于intset和dict的存储来说时间复杂度分别是O(log n)和O(1)。</p><p>但由于只有小集合才使用intset，所以可以粗略地认为intset的查找也是常数时间复杂度的。</p><p>因此,<br><a href="http://redis.io/commands/sinter">如Redis官方文档上所说</a><br>sinter命令的时间复杂度为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets.</span><br></pre></td></tr></table></figure><h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h4><p>计算并集最简单，只需要遍历所有集合，将每一个元素都添加到最后的结果集合中。 向集合中添加元素会自动去重。</p><p>由于要遍历所有集合的每个元素，所以<br><a href="http://redis.io/commands/sunion">Redis官方文档</a><br>给出的sunion命令的时间复杂度为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(N) where N is the total number of elements in all given sets.</span><br></pre></td></tr></table></figure><p>注意，这里同前面讨论交集计算一样，将元素插入到结果集合的过程，忽略intset的情况，认为时间复杂度为O(1)。</p><h4 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h4><p>计算差集有两种可能的算法，它们的时间复杂度有所区别。</p><p>第一种算法：</p><ul><li>对第一个集合进行遍历，对于它的每一个元素，依次在后面的所有集合中进行查找。只有在所有集合中都找不到的元素，才加入到最后的结果集合中。</li></ul><p>这种算法的时间复杂度为O(N*M)，其中N是第一个集合的元素个数，M是集合数目。</p><p>第二种算法：</p><ul><li>将第一个集合的所有元素都加入到一个中间集合中。</li><li>遍历后面所有的集合，对于碰到的每一个元素，从中间集合中删掉它。</li><li>最后中间集合剩下的元素就构成了差集。</li></ul><p>这种算法的时间复杂度为O(N)，其中N是所有集合的元素个数总和。</p><p>在计算差集的开始部分，会先分别估算一下两种算法预期的时间复杂度，然后选择复杂度低的算法来进行运算。</p><p>还有两点需要注意：</p><ul><li>在一定程度上优先选择第一种算法，因为它涉及到的操作比较少，只用添加，而第二种算法要先添加再删除。</li><li>如果选择了第一种算法，那么在执行该算法之前，Redis的实现中对于第二个集合之后的所有集合，按照元素个数由多到少进行了排序。这个排序有利于以更大的概率查找到元素，从而更快地结束查找。</li></ul><p>对于sdiff的时间复杂度，<br><a href="http://redis.io/commands/sdiff">Redis官方文档</a><br>只给出了第二种算法的结果，是不准确的。</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p><a href="https://www.jianshu.com/p/c2841d65df4c">死磕Redis5.0之跳跃表</a></p><p><a href="https://mp.weixin.qq.com/s/3TU9qxHJyxHJgVDaYXoluA">Redis内部数据结构详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Redis作为目前已知速度最快的Key-Value数据库，本质上是一个数据结构服务器（data structures server），以高效</summary>
      
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
    <category term="跳跃表" scheme="http://example.com/tags/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    
    <category term="索引" scheme="http://example.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>从主流中间件看分布式系统主从同步策略</title>
    <link href="http://example.com/2022/03/08/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E4%BB%8E%E4%B8%BB%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9C%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/"/>
    <id>http://example.com/2022/03/08/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E4%BB%8E%E4%B8%BB%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9C%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/</id>
    <published>2022-03-08T10:51:24.000Z</published>
    <updated>2022-03-08T08:02:25.416Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h3><h4 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h4><p><img src="/2022/03/08/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E4%BB%8E%E4%B8%BB%E6%B5%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9C%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.png" alt="mysql主从同步"></p><ul><li>主服务器（master）将数据更改的操作记录写到二进制redo日志（binlog）中</li><li>从服务器（slave）将主服务器中的二进制日志复制到自己的中继日志（relay log）中<ul><li>首先slave开始一个工作线程——I/O线程，I/O线程在master上打开一个普通的连接，然后开始Binlog dump process（Binlog转储过程），Binlog dump process从master的二进制日志中读取事件。</li><li>如果已经跟上master，它会睡眠并等待master产生新的事件。</li></ul></li><li>从服务器重做中继日志中的日志，把更改应用到自己的数据库中，保证数据的最终一致性<ul><li>中继日志通常存在系统的缓存中，所以中继日志的开销很小。</li></ul></li></ul><p>复制过程有一个很重要的限制，就是在slave上的复制是串行化的，master上是并行化的。</p><h4 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h4><ul><li>异步复制<ul><li>MySQL主从模式默认的复制，并不关心从库是否已经接收并处理</li><li>可能导致数据不完整</li></ul></li><li>同步复制<ul><li>MySQL Cluster为同步复制，所有客户端确认执行事务后才返回。</li><li>事务时间拉长、性能降低。</li></ul></li><li>半同步复制<ul><li>插件形式支持，至少一个从库接收并写ready log。</li><li>至少延迟一个TCP/IP时间，最好在低延迟网络使用。</li></ul></li></ul><h4 id="Mysql读写分离"><a href="#Mysql读写分离" class="headerlink" title="Mysql读写分离"></a>Mysql读写分离</h4><p>本身未实现读写分离：</p><ul><li>基于项目代码内部实现</li><li>基于中间代理实现<ul><li>MySQL-Proxy</li><li>amoeba(变形虫)</li></ul></li></ul><h3 id="Kafka的主从同步"><a href="#Kafka的主从同步" class="headerlink" title="Kafka的主从同步"></a>Kafka的主从同步</h3><p>kafka的主从同步，主要是针对它的broker来说。</p><p>在kafka的broker中，同一个topic可以被分配成多个Partition，每个Partition的可以有一个或者多个replicas（备份），即会有一个leader以及0到多个Follower。  </p><p>在consumer读取数据的时候，只会从Leader上读取数据，Follower只是在Leader宕机的时候来替代Leader（不支持读写分离）。  </p><p>主从同步有两种方式：同步复制和异步复制，Kafka采用的是中间策略ISR（In Sync Replicas）。</p><h4 id="Kafka的ISR策略"><a href="#Kafka的ISR策略" class="headerlink" title="Kafka的ISR策略"></a>Kafka的ISR策略</h4><p>在有数据写上Leader的时候，Leader会查看Follower组成的ISR列表，并且符合以下两点才算是属于ISR列表：</p><ul><li>broker可以维护和zookeeper的连接，zookeeper通过心跳机制检查每个节点的连接</li><li>如果节点是个follower它必须能及时同步Leader的写操作，不能延时太久。</li></ul><p>当某个主题的分区初始化创建时，每个副本都在ISR集合中。当新消息发布后，leader提交消息前会一直等待直到所有ISR副本收到消息。如果某个follower副本故障，它将会被从ISR中移除。leader会继续提交新的消息，只不过ISR数量与分区创建时的副本数量相比变少了。</p><p><a href="https://baijiahao.baidu.com/s?id=1649059417410404542&wfr=spider&for=pc">kafka如何保证数据一致性剖析？剖析ISR机制</a></p><h4 id="Kafka不支持读写分离"><a href="#Kafka不支持读写分离" class="headerlink" title="Kafka不支持读写分离"></a>Kafka不支持读写分离</h4><p><a href="https://blog.csdn.net/zl1zl2zl3/article/details/87982038">干货|为什么Kafka不支持读写分离</a></p><h3 id="Zookeeper的主从同步ZAB"><a href="#Zookeeper的主从同步ZAB" class="headerlink" title="Zookeeper的主从同步ZAB"></a>Zookeeper的主从同步ZAB</h3><p>Zookeeper的zab策略脱胎于Paxos算法，默认情况下，zk中写数据时，要有一半以上的从节点写入成功，才算是写入成功。</p><h3 id="Redis的主从同步"><a href="#Redis的主从同步" class="headerlink" title="Redis的主从同步"></a>Redis的主从同步</h3><p>redis因为是要提升性能，所以直接采用的异步复制，当在Master上写入数据后直接返回，然后把数据快照广播给Slave，让所有的Slaves去执行操作。</p><p>RBD全量同步 + AOF增量同步</p><p>Redis无磁盘化复制</p><ul><li>master将rbd文件不落地到磁盘，直接在内存中生成（需要配置repl-diskless-sync）</li></ul><p><a href="https://zhuanlan.zhihu.com/p/65712373">调研Redis高可用两种方案</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MySQL主从复制&quot;&gt;&lt;a href=&quot;#MySQL主从复制&quot; class=&quot;headerlink&quot; title=&quot;MySQL主从复制&quot;&gt;&lt;/a&gt;MySQL主从复制&lt;/h3&gt;&lt;h4 id=&quot;复制过程&quot;&gt;&lt;a href=&quot;#复制过程&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="JAVA开发" scheme="http://example.com/categories/JAVA%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="分布式" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="设计理念" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5/"/>
    
    <category term="主从同步" scheme="http://example.com/tags/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Spring三级缓存解决循环依赖</title>
    <link href="http://example.com/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>http://example.com/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2022-03-06T13:50:51.000Z</published>
    <updated>2022-03-08T07:08:33.140Z</updated>
    
    <content type="html"><![CDATA[<p>前置阅读<a href="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" title="初读Spring的Bean生命周期">初读Spring的Bean生命周期</a></p><h3 id="三级缓存具体是什么"><a href="#三级缓存具体是什么" class="headerlink" title="三级缓存具体是什么"></a>三级缓存具体是什么</h3><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/img.png"></p><p>可以看到填充属性的时候，spring会提前将已经实例化的bean通过ObjectFactory半成品暴露出去。</p><p>为什么称为半成品是因为这时候的bean对象实例化，但是未进行属性填充，是一个不完整的bean实例对象。</p><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/img_1.png"></p><p><strong>spring利用singletonObjects, earlySingletonObjects, singletonFactories三级缓存去解决的，所说的缓存其实也就是三个Map</strong></p><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/img_2.png"></p><p>可以看到三级缓存各自保存的对象，这里重点关注二级缓存earlySingletonObjects和三级缓存singletonFactory，一级缓存可以进行忽略。</p><p>前面我们讲过先实例化的bean会通过ObjectFactory半成品提前暴露在三级缓存中</p><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/img_3.png"></p><p>singletonFactory是传入的一个匿名内部类，调用ObjectFactory.getObject()最终会调用getEarlyBeanReference方法。</p><h3 id="循环依赖中是怎么拿其它半成品的实例对象"><a href="#循环依赖中是怎么拿其它半成品的实例对象" class="headerlink" title="循环依赖中是怎么拿其它半成品的实例对象"></a>循环依赖中是怎么拿其它半成品的实例对象</h3><p>我们假设现在有这样的场景AService依赖BService，BService依赖AService</p><ol><li><p>AService首先实例化，实例化通过ObjectFactory半成品暴露在三级缓存中</p></li><li><p>填充属性BService，发现BService还未进行过加载，就会先去加载BService</p></li><li><p>再加载BService的过程中，实例化，也通过ObjectFactory半成品暴露在三级缓存</p></li><li><p>填充属性AService的时候，这时候能够从三级缓存中拿到半成品的ObjectFactory<br> <img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/img_4.png"><br> 三级缓存拿到ObjectFactory对象后，调用ObjectFactory.getObject()方法最终会调用getEarlyBeanReference()方法。</p><p> <strong>getEarlyBeanReference</strong>这个方法主要逻辑大概描述下如果bean被AOP切面代理则返回的是beanProxy对象，如果未被代理则返回的是原bean实例。</p><p>这时我们会发现能够拿到bean实例(属性未填充)，然后从三级缓存移除，放到二级缓存earlySingletonObjects中，而此时B注入的是一个半成品的实例A对象，不过随着B初始化完成后，A会继续进行后续的初始化操作，最终B会注入的是一个完整的A实例，因为在内存中它们是同一个对象。</p></li></ol><h3 id="为什么必须要三级缓存"><a href="#为什么必须要三级缓存" class="headerlink" title="为什么必须要三级缓存"></a>为什么必须要三级缓存</h3><p>我们发现这个二级缓存好像显得有点多余，好像可以去掉，只需要一级和三级缓存也可以做到解决循环依赖的问题？？？</p><p><strong>只要两个缓存确实可以做到解决循环依赖的问题，但是有一个前提这个bean没被AOP进行切面代理</strong></p><p>如果这个bean被AOP进行了切面代理，那么只使用两个缓存是无法解决问题。</p><p>下面来看一下bean被AOP进行了切面代理的场景：</p><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/img_5.png"></p><p>我们发现AService的testAopProxy被AOP代理了，看看传入的匿名内部类的getEarlyBeanReference返回的是什么对象。</p><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/img_6.png"></p><p>发现singletonFactory.getObject()返回的是一个AService的代理对象，还是被CGLIB代理的。</p><p>再看一张再执行一遍singletonFactory.getObject()返回的是否是同一个AService的代理对象</p><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/img_7.png"></p><p>我们会发现再执行一遍singleFactory.getObject()方法又是一个新的代理对象。</p><p>这就会有问题了，因为AService是单例的，每次执行singleFactory.getObject()方法又会产生新的代理对象。</p><p>假设这里只有一级和三级缓存的话，我每次从三级缓存中拿到singleFactory对象，执行getObject()方法又会产生新的代理对象，这是不行的，因为AService是单例的，所有这里我们要借助二级缓存来解决这个问题，将执行了singleFactory.getObject()产生的对象放到二级缓存中去，后面去二级缓存中拿，没必要再执行一遍singletonFactory.getObject()方法再产生一个新的代理对象，保证始终只有一个代理对象。</p><p>还有一个注意的点</p><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/img_8.png"></p><p>既然singleFactory.getObject()返回的是代理对象，那么注入的也应该是代理对象，我们可以看到注入的确实是经过CGLIB代理的AService对象。</p><p>所以<strong>如果没有AOP的话确实可以两级缓存就可以解决循环依赖的问题；如果加上AOP，每次执行singleFactory.getObject()方法会产生一个新的代理对象，所以还要借助另外一个缓存来保存产生的代理对象</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前置阅读&lt;a href=&quot;/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/&quot; ti</summary>
      
    
    
    
    <category term="JAVA开发" scheme="http://example.com/categories/JAVA%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
    <category term="Bean" scheme="http://example.com/tags/Bean/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>初读Spring的Bean生命周期</title>
    <link href="http://example.com/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://example.com/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-03-06T13:50:25.000Z</published>
    <updated>2022-03-08T07:38:21.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>在spring的BeanFactory工厂列举了很多接口，代表着bean的生命周期。</p><details><summary>public interface BeanFactory</summary><ul><li>@author Rod Johnson</li><li>@author Juergen Hoeller</li><li>@author Chris Beams</li><li>@since 13 April 2001</li><li>@see BeanNameAware#setBeanName</li><li>@see BeanClassLoaderAware#setBeanClassLoader</li><li>@see BeanFactoryAware#setBeanFactory</li><li>@see org.springframework.context.ResourceLoaderAware#setResourceLoader</li><li>@see org.springframework.context.ApplicationEventPublisherAware#setApplicationEventPublisher</li><li>@see org.springframework.context.MessageSourceAware#setMessageSource</li><li>@see org.springframework.context.ApplicationContextAware#setApplicationContext</li><li>@see org.springframework.web.context.ServletContextAware#setServletContext</li><li>@see org.springframework.beans.factory.config.BeanPostProcessor#postProcessBeforeInitialization</li><li>@see InitializingBean#afterPropertiesSet</li><li>@see org.springframework.beans.factory.support.RootBeanDefinition#getInitMethodName</li><li>@see org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization</li><li>@see DisposableBean#destroy</li><li>@see org.springframework.beans.factory.support.RootBeanDefinition#getDestroyMethodName</li></ul></details><p>我们结合spring的源码来看这些接口主要是在哪里调用的。</p><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img_1.png"></p><h3 id="第一步：-AbstractAutowireCapableBeanFactory类的doCreateBean方法是创建bean的开始"><a href="#第一步：-AbstractAutowireCapableBeanFactory类的doCreateBean方法是创建bean的开始" class="headerlink" title="第一步： AbstractAutowireCapableBeanFactory类的doCreateBean方法是创建bean的开始"></a>第一步： AbstractAutowireCapableBeanFactory类的doCreateBean方法是创建bean的开始</h3><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img.png"></p><p>我们可以看到首先需要实例化这个bean，也就是在堆中开辟一块内存空间给这个对象，createBeanInstance方法里面逻辑大概就是采用反射生成实例对象， 进行到这里表示对象还并未进行属性的填充，也就是@Autowired注解的属性还未得到注入</p><h3 id="第二步：-填充bean的成员属性"><a href="#第二步：-填充bean的成员属性" class="headerlink" title="第二步： 填充bean的成员属性"></a>第二步： 填充bean的成员属性</h3><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img_2.png"></p><p>populateBean内逻辑大致就是对使用到了注入属性的注解就会进行注入，如果在注入的过程发现注入的对象还没生成，则会跑去生产要注入的对象</p><h3 id="第三步-调用initializeBean方法初始化bean内容"><a href="#第三步-调用initializeBean方法初始化bean内容" class="headerlink" title="第三步: 调用initializeBean方法初始化bean内容"></a>第三步: 调用initializeBean方法初始化bean内容</h3><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img_3.png"></p><p>可以看到initializeBean方法中，首先调用的是使用的Aware接口的方法，我们具体看一下invokeAwareMethods方法中会调用Aware接口的那些方法</p><h4 id="invokeAwareMethods调用实现Aware接口的方法"><a href="#invokeAwareMethods调用实现Aware接口的方法" class="headerlink" title="invokeAwareMethods调用实现Aware接口的方法"></a>invokeAwareMethods调用实现Aware接口的方法</h4><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img_4.png"></p><p>如果我们实现了BeanNameAware，BeanClassLoaderAware，BeanFactoryAware三个Aware接口的话，会依次调用setBeanName(), setBeanClassLoader(), setBeanFactory()方法</p><h4 id="applyBeanPostProcessorsBeforeInitialization"><a href="#applyBeanPostProcessorsBeforeInitialization" class="headerlink" title="applyBeanPostProcessorsBeforeInitialization"></a>applyBeanPostProcessorsBeforeInitialization</h4><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img_5.png"></p><p>如果有类实现了BeanPostProcessor接口，就会执行postProcessBeforeInitialization方法，这里需要注意的是：</p><ul><li><p>如果多个类实现BeanPostProcessor接口，那么多个实现类都会执行postProcessBeforeInitialization方法，可以看到是for循环依次执行的。</p></li><li><p>如果加载A类到spring容器中，A类也重写了BeanPostProcessor接口的postProcessBeforeInitialization方法，这时要注意<strong>A类的postProcessBeforeInitialization方法并不会得到执行</strong>，因为A类还未加载完成，还未完全放到spring的singletonObjects一级缓存中。</p></li><li><p>可以看到ApplicationContextAwareProcessor也实现了BeanPostProcessor接口，重写了postProcessBeforeInitialization方法，方法里面并调用了invokeAwareInterfaces方法，而invokeAwareInterfaces方法也写着如果实现了众多的Aware接口，则会依次执行相应的方法，值得注意的是ApplicationContextAware接口的setApplicationContext方法<br>  <img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img_6.png"><br>  <img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img_7.png"><br>  <img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img_8.png"></p></li></ul><h4 id="invokeInitMethods"><a href="#invokeInitMethods" class="headerlink" title="invokeInitMethods"></a>invokeInitMethods</h4><p>如果实现了InitializingBean接口，重写了afterPropertiesSet方法，则会调用afterPropertiesSet方法。</p><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img_9.png"></p><p>最后还会调用是否指定了init-method，可以通过标签，或者@Bean注解的initMethod指定</p><h4 id="applyBeanPostProcessorsAfterInitialization"><a href="#applyBeanPostProcessorsAfterInitialization" class="headerlink" title="applyBeanPostProcessorsAfterInitialization"></a>applyBeanPostProcessorsAfterInitialization</h4><p><img src="/2022/03/06/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/%E5%88%9D%E8%AF%BBSpring%E7%9A%84Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/img_10.png"></p><p>跟之前的postProcessBeforeInitialization方法类似，也是循环遍历实现了BeanPostProcessor的接口实现类，执行postProcessAfterInitialization方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Bean的生命周期&quot;&gt;&lt;a href=&quot;#Bean的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Bean的生命周期&quot;&gt;&lt;/a&gt;Bean的生命周期&lt;/h2&gt;&lt;p&gt;在spring的BeanFactory工厂列举了很多接口，代表着bean的生命周期。</summary>
      
    
    
    
    <category term="JAVA开发" scheme="http://example.com/categories/JAVA%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
    <category term="Bean" scheme="http://example.com/tags/Bean/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB原理篇之BufferPool缓冲池</title>
    <link href="http://example.com/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8BBufferPool%E7%BC%93%E5%86%B2%E6%B1%A0/"/>
    <id>http://example.com/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8BBufferPool%E7%BC%93%E5%86%B2%E6%B1%A0/</id>
    <published>2022-02-25T15:19:39.000Z</published>
    <updated>2022-03-22T02:35:10.560Z</updated>
    
    <content type="html"><![CDATA[<p>应用系统分层架构，为了加速数据访问，会把最常访问的数据，放在缓存(cache)里，避免每次都去访问数据库。</p><p>操作系统，会有<strong>缓冲池</strong>(buffer pool)机制，避免每次访问磁盘，以加速数据的访问。</p><p>MySQL作为一个存储系统，同样具有缓冲池(buffer pool)机制，以避免每次查询数据都进行磁盘IO。</p><h2 id="什么是InnoDB缓冲池"><a href="#什么是InnoDB缓冲池" class="headerlink" title="什么是InnoDB缓冲池"></a>什么是InnoDB缓冲池</h2><p><strong>缓存表数据与索引数据</strong>，把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘IO，起到加速访问的作用。</p><p>速度快，那为啥不把所有数据都放到缓冲池里？</p><p>凡事都具备两面性，抛开数据易失性不说，访问快速的反面是存储容量小：</p><ol><li>缓存访问快，但容量小，数据库存储了200G数据，缓存容量可能只有64G；</li><li>内存访问快，但容量小，买一台笔记本磁盘有2T，内存可能只有16G；</li></ol><p>因此，只能<strong>把“最热”的数据放到“最近”的地方</strong>，以“最大限度”的降低磁盘访问。</p><h2 id="如何管理与淘汰缓冲池，使得性能最大化呢？"><a href="#如何管理与淘汰缓冲池，使得性能最大化呢？" class="headerlink" title="如何管理与淘汰缓冲池，使得性能最大化呢？"></a>如何管理与淘汰缓冲池，使得性能最大化呢？</h2><p>在介绍具体细节之前，先介绍下“预读”的概念。</p><h3 id="预读"><a href="#预读" class="headerlink" title="预读"></a>预读</h3><h4 id="什么是预读"><a href="#什么是预读" class="headerlink" title="什么是预读"></a>什么是预读</h4><p>磁盘读写，并不是按需读取，而是按页读取，<strong>一次至少读一页数据</strong>（一般是4K），如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率。</p><h4 id="预读为什么有效"><a href="#预读为什么有效" class="headerlink" title="预读为什么有效"></a>预读为什么有效</h4><p>数据访问，通常都遵循“集中读写”的原则，使用一些数据，大概率会使用附近的数据，这就是所谓的“<strong>局部性原理</strong>”，它表明提前加载是有效的，确实能够减少磁盘IO。</p><h4 id="按页读取，和InnoDB缓冲池设计有啥关系"><a href="#按页读取，和InnoDB缓冲池设计有啥关系" class="headerlink" title="按页读取，和InnoDB缓冲池设计有啥关系"></a>按页读取，和InnoDB缓冲池设计有啥关系</h4><ol><li>磁盘访问按页读取能够提高性能，所以缓冲池一般也是按页缓存数据；</li><li>预读机制启示了我们，能把一些“可能要访问”的页提前加入缓冲池，避免未来的磁盘IO操作；</li></ol><h3 id="InnoDB是以什么算法，来管理这些缓冲页呢？"><a href="#InnoDB是以什么算法，来管理这些缓冲页呢？" class="headerlink" title="InnoDB是以什么算法，来管理这些缓冲页呢？"></a>InnoDB是以什么算法，来管理这些缓冲页呢？</h3><p>最容易想到的，就是LRU(Least recently used)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：memcache，OS都会用LRU来进行页置换管理，但MySQL的玩法并不一样。</span><br></pre></td></tr></table></figure><h4 id="传统的LRU如何进行缓冲页管理"><a href="#传统的LRU如何进行缓冲页管理" class="headerlink" title="传统的LRU如何进行缓冲页管理"></a>传统的LRU如何进行缓冲页管理</h4><p>最常见的玩法是，把入缓冲池的页放到LRU的头部，作为最近访问的元素，从而最晚被淘汰。</p><p>这里又分两种情况：</p><ol><li>页已经在缓冲池里，那就只做“移至”LRU头部的动作，而没有页被淘汰；</li><li>页不在缓冲池里，除了做“放入”LRU头部的动作，还要做“淘汰”LRU尾部页的动作；</li></ol><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8BBufferPool%E7%BC%93%E5%86%B2%E6%B1%A0/img.png"></p><p>如上图，假如管理缓冲池的LRU长度为10，缓冲了页号为1，3，5…，40，7的页。</p><p>假如，接下来要访问的数据在页号为4的页中：</p><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8BBufferPool%E7%BC%93%E5%86%B2%E6%B1%A0/img_1.png"></p><ol><li>页号为4的页，本来就在缓冲池里；</li><li>把页号为4的页，放到LRU的头部即可，没有页被淘汰；</li></ol><p>假如，再接下来要访问的数据在页号为50的页中：</p><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8BBufferPool%E7%BC%93%E5%86%B2%E6%B1%A0/img_2.png"></p><ol><li>页号为50的页，原来不在缓冲池里；</li><li>把页号为50的页，放到LRU头部，同时淘汰尾部页号为7的页；</li></ol><p>传统的LRU缓冲池算法十分直观，OS，memcache等很多软件都在用，MySQL为啥这么矫情，不能直接用呢？</p><p>这里有两个问题：</p><ol><li>预读失效；</li><li>缓冲池污染。</li></ol><h4 id="预读失效"><a href="#预读失效" class="headerlink" title="预读失效"></a>预读失效</h4><p>由于预读(Read-Ahead)，提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据，称为预读失效。</p><p><strong>如何对预读失效进行优化？</strong></p><p>要优化预读失效，思路是：</p><ol><li>让预读失败的页，停留在缓冲池LRU里的时间尽可能短；</li><li>让真正被读取的页，才挪到缓冲池LRU的头部；</li></ol><p>以保证，真正被读取的热数据留在缓冲池里的时间尽可能长。</p><p>具体方法是：</p><ol><li>将LRU分为两个部分：<ul><li>新生代(new sublist)</li><li>老生代(old sublist)</li></ul></li><li>新老生代收尾相连，即：新生代的尾(tail)连接着老生代的头(head)；</li><li>新页（例如被预读的页）加入缓冲池时，只加入到老生代头部：<ul><li>如果数据真正被读取（预读成功），才会加入到新生代的头部</li><li>如果数据没有被读取，则会比新生代里的“热数据页”更早被淘汰出缓冲池</li></ul></li></ol><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8BBufferPool%E7%BC%93%E5%86%B2%E6%B1%A0/img_3.png"></p><p>举个例子，整个缓冲池LRU如上图：</p><ol><li>整个LRU长度是10；</li><li>前70%是新生代；</li><li>后30%是老生代；</li><li>新老生代首尾相连</li></ol><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8BBufferPool%E7%BC%93%E5%86%B2%E6%B1%A0/img_4.png"></p><p>假如有一个页号为50的新页被预读加入缓冲池：</p><ol><li>50只会从老生代头部插入，老生代尾部（也是整体尾部）的页会被淘汰掉；</li><li>假设50这一页不会被真正读取，即预读失败，它将比新生代的数据更早淘汰出缓冲池；</li></ol><p>假如50这一页立刻被读取到，例如SQL访问了页内的行row数据：</p><ol><li>它会被立刻加入到新生代的头部；</li><li>新生代的页会被挤到老生代，此时并不会有页面被真正淘汰；</li></ol><p><strong>改进版缓冲池LRU能够很好的解决“预读失败”的问题</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但也不要因噎废食，因为害怕预读失败而取消预读策略，大部分情况下，局部性原理是成立的，预读是有效的。</span><br></pre></td></tr></table></figure><p>新老生代改进版LRU仍然解决不了缓冲池污染的问题。</p><h4 id="缓冲池污染"><a href="#缓冲池污染" class="headerlink" title="缓冲池污染"></a>缓冲池污染</h4><p>当某一个SQL语句，要<strong>批量扫描大量数据</strong>时，可能导致把缓冲池的所有页都替换出去，导致<strong>大量热数据被换出</strong>，MySQL性能急剧下降，这种情况叫缓冲池污染。</p><p>例如，有一个数据量较大的用户表，当执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name like &quot;%shenjian%&quot;;</span><br></pre></td></tr></table></figure><p>虽然结果集可能只有少量数据，但这类like不能命中索引，必须<strong>全表扫描</strong>，就需要访问大量的页：</p><ol><li>把页加到缓冲池（插入老生代头部）；</li><li>从页里读出相关的row（插入新生代头部）；</li><li>row里的name字段和字符串shenjian进行比较，如果符合条件，加入到结果集中；</li><li>…直到扫描完所有页中的所有row…</li></ol><p>如此一来，<strong>所有的数据页都会被加载到新生代的头部，但只会访问一次，真正的热数据被大量换出</strong>。</p><p><strong>怎么解决这类扫码大量数据导致的缓冲池污染问题呢？</strong></p><p>MySQL缓冲池加入了一个“老生代停留时间窗口”的机制：</p><ol><li>假设T=老生代停留时间窗口；</li><li>插入老生代头部的页，即使立刻被访问，并不会立刻放入新生代头部；</li><li>只有满足“被访问”并且“在老生代停留时间”大于T，才会被放入新生代头部；</li></ol><h2 id="上述原理，对应InnoDB里哪些参数？"><a href="#上述原理，对应InnoDB里哪些参数？" class="headerlink" title="上述原理，对应InnoDB里哪些参数？"></a>上述原理，对应InnoDB里哪些参数？</h2><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8BBufferPool%E7%BC%93%E5%86%B2%E6%B1%A0/img_5.png"></p><h3 id="参数：innodb-buffer-pool-size"><a href="#参数：innodb-buffer-pool-size" class="headerlink" title="参数：innodb_buffer_pool_size"></a>参数：innodb_buffer_pool_size</h3><p>介绍：配置缓冲池的大小，在内存允许的情况下，DBA往往会建议调大这个参数，越多数据和索引放到内存里，数据库的性能会越好。</p><h3 id="参数：innodb-old-blocks-pct"><a href="#参数：innodb-old-blocks-pct" class="headerlink" title="参数：innodb_old_blocks_pct"></a>参数：innodb_old_blocks_pct</h3><p>介绍：老生代占整个LRU链长度的比例，默认是37，即整个LRU中新生代与老生代长度比例是63:37。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果把这个参数设为100，就退化为普通LRU了。</span><br></pre></td></tr></table></figure><h3 id="参数：innodb-old-blocks-time"><a href="#参数：innodb-old-blocks-time" class="headerlink" title="参数：innodb_old_blocks_time"></a>参数：innodb_old_blocks_time</h3><p>介绍：老生代停留时间窗口，单位是毫秒，默认是1000，即同时满足“被访问”与“在老生代停留时间超过1秒”两个条件，才会被插入到新生代头部。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>缓冲池(buffer pool)是一种常见的<strong>降低磁盘访问</strong>的机制；</li><li>缓冲池通常<strong>以页(page)为单位缓存数据</strong>；</li><li>缓冲池的<strong>常见管理算法是LRU</strong>，memcache，OS，InnoDB都使用了这种算法；</li><li>InnoDB对普通LRU进行了优化：<ul><li>将缓冲池分为<strong>老生代和新生代</strong>，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，以解决预读失效的问题</li><li>页被访问，且在老生代<strong>停留时间超过配置阈值</strong>的，才进入新生代，以解决批量数据访问，大量热数据淘汰的问题</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;应用系统分层架构，为了加速数据访问，会把最常访问的数据，放在缓存(cache)里，避免每次都去访问数据库。&lt;/p&gt;
&lt;p&gt;操作系统，会有&lt;strong&gt;缓冲池&lt;/strong&gt;(buffer pool)机制，避免每次访问磁盘，以加速数据的访问。&lt;/p&gt;
&lt;p&gt;MySQL作为</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="InnoDB" scheme="http://example.com/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB原理篇之数据页与索引初探</title>
    <link href="http://example.com/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/"/>
    <id>http://example.com/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/</id>
    <published>2022-02-25T14:15:39.000Z</published>
    <updated>2022-03-22T01:47:08.135Z</updated>
    
    <content type="html"><![CDATA[<p>文档说明：转载自<a href="https://mp.weixin.qq.com/s/BVqxg-k8Ro4wAisktLT0Tg">InnoDB原理篇：聊聊数据页变成索引这件事</a></p><p>文档意义：通过数据页到最后的索引，体会数据库查询优化的过程</p><h2 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h2><p>数据库执行<code>CRUD</code>的时候，都会从磁盘上加载数据页到<code>Buffer Pool</code>的缓存页里去，更新缓存页后，由异步线程刷回磁盘的数据页。</p><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/img.png"></p><p>所以MySQL进行数据操作的最小单位是数据页，接下来就分析分析，数据页到底长什么样。</p><p>每个数据页默认16kb的大小，数据页由多个部分组成，如下图所示</p><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/img_1.png"></p><h3 id="空闲空间"><a href="#空闲空间" class="headerlink" title="空闲空间"></a>空闲空间</h3><p>其实数据页还未写入数据时，是没有数据行的，只有空闲空间。</p><p>一旦写入，空闲空间会减少一些，直到空闲空间耗尽，具体过程如下图</p><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/img_2.png"></p><p>数据页满了，自然需要开辟新的数据页出来存储数据。</p><p>但是随着数据页多起来，它们怎么知道上一页与下一页在那呢？</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>其实在数据页文件头中存放了特别多的信息，如当前页号、页类型、所属表空间、上一页号、下一页号等等。</p><p>所以数据页是通过上下页号，组成双向链表，如下图所示</p><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/img_3.png"></p><p>数据页内部会存储一行一行的数据，每一行数据都会按照主键大小进行排序存储，同时每一行数据都有指针指向下一行数据，组成单向链表。</p><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/img_4.png"></p><p>但是这个结构并不高效，假设根据主键ID查询数据，只能进入数据页，挨个挨个的对单向链表遍历查询。</p><p>所以要再加点料，把<strong>二分查找</strong>利用起来</p><h3 id="数据页目录"><a href="#数据页目录" class="headerlink" title="数据页目录"></a>数据页目录</h3><p>这个料就是数据页目录部分，数据页目录存储的内容就是主键ID和行位置。</p><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/img_5.png"></p><p>这样就可以通过数据页目录走二分查找，快速定位到数据页内的数据行。</p><p>如果只有一个数据页，倒没啥问题，哪有成千上万个数据页呢，还是得一个一个进数据页，搜索数据页目录。</p><p>有没有觉得，这似乎是在做全表扫描？</p><p>没错，在没有索引的情况下，数据库就是这样执行的。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>如果没有索引，查询速度可以说是慢到惊人，一般是不能让查询走全表扫描的。</p><p>因此数据库中的查询，必须要运用索引来加速。</p><h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>在说索引之前，先说个前置知识，索引的核心基础要求后一个数据页的主键值都大于前面一个数据页的主键值，如果你的主键是自增的，可以保证这一点。</p><p>但有时候主键并不是自增长的，可能会出现后一个数据页的主键值小于前一个数据页的主键值。</p><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/img_6.png"></p><p>为了保证索引的核心基础，有个交换行数据的过程，这个过程叫页分裂。</p><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/img_7.png"></p><p>过程如下：</p><ul><li>数据页0的id=6行数据挪到数据页1</li><li>数据页1的页目录更新</li><li>数据页1的id=3行数据挪到数据页0</li><li>数据页0的页目录更新</li></ul><h3 id="主键目录"><a href="#主键目录" class="headerlink" title="主键目录"></a>主键目录</h3><p>好了，现在我们以主键为例，创建一个主键索引，这个主键索引就是主键目录，它会维护所有数据页的最小主键值与对应的页号。</p><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/img_8.png"></p><p>有了主键目录的加持，那找数据就非常快了，过程如下：</p><ul><li>二分查找主键目录，找到对应的数据页</li><li>进入数据页，二分查找数据页目录，找到对应的行数据</li></ul><p>可是又来一个新问题，表里的数据可能有几百万，几千万，甚至几亿条数据，会有大量的数据页，意味着主键目录要存储大量的数据页号和最小主键值。</p><p>可能主键目录存储不下，就算能存储，海量的数据仅仅靠二分查找也很吃力。</p><p>所以InnoDB实际上是把主键目录数据存储在多个数据页中，我们把这个数据页称为索引页</p><h3 id="索引页"><a href="#索引页" class="headerlink" title="索引页"></a>索引页</h3><p>索引页，顾名思义，就是存储索引信息的数据页，在数据页的文件头部，有页类型来进行区分。</p><p>索引页会存储两类内容，一类是最小主键值与索引页号，另一类是最小主键值与数据页号。</p><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/img_9.png"></p><p>把大量的索引信息分散在多个索引页中，再将多个索引页组建成B+树结构，方便二分查找，结构如下图</p><p><img src="/2022/02/25/%E6%95%B0%E6%8D%AE%E5%BA%93/InnoDB%E5%8E%9F%E7%90%86%E7%AF%87%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A1%B5%E4%B8%8E%E7%B4%A2%E5%BC%95%E5%88%9D%E6%8E%A2/img_10.png"></p><p>一直说InnoDB的索引是用B+树来组成的，其实就是这个意思，当然真实的B+树不长这样，这样画还是为了帮助大家理解。</p><p>现在整个搜索过程就十分简单了：</p><ul><li>根据主键id二分查找索引页</li><li>找到对应索引页，再二分查找数据页</li><li>进入数据页，二分查找数据页目录，找到对应的行数据</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文档说明：转载自&lt;a href=&quot;https://mp.weixin.qq.com/s/BVqxg-k8Ro4wAisktLT0Tg&quot;&gt;InnoDB原理篇：聊聊数据页变成索引这件事&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档意义：通过数据页到最后的索引，体会数据库查询优化的过程&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="InnoDB" scheme="http://example.com/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>数据库MySQL系列之主从同步与GTID特性</title>
    <link href="http://example.com/2022/02/24/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%B8%8EGTID%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2022/02/24/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%B8%8EGTID%E7%89%B9%E6%80%A7/</id>
    <published>2022-02-24T12:57:00.000Z</published>
    <updated>2022-02-25T07:58:29.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL主从同步原理"><a href="#MySQL主从同步原理" class="headerlink" title="MySQL主从同步原理"></a>MySQL主从同步原理</h2><h3 id="为什么需要主从同步"><a href="#为什么需要主从同步" class="headerlink" title="为什么需要主从同步"></a>为什么需要主从同步</h3><ol><li><p>在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</p></li><li><p>做数据的热备</p></li><li><p>架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</p></li></ol><h3 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h3><h4 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h4><p><img src="/2022/02/24/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%B8%8EGTID%E7%89%B9%E6%80%A7/mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.png" alt="mysql主从同步"></p><ul><li>主服务器（master）将数据更改的操作记录写到二进制redo日志（binlog）中</li><li>从服务器（slave）将主服务器中的二进制日志复制到自己的中继日志（relay log）中<ul><li>首先slave开始一个工作线程——I/O线程，I/O线程在master上打开一个普通的连接，然后开始Binlog dump process（Binlog转储过程），Binlog dump process从master的二进制日志中读取事件。</li><li>如果已经跟上master，它会睡眠并等待master产生新的事件。</li></ul></li><li>从服务器重做中继日志中的日志，把更改应用到自己的数据库中，保证数据的最终一致性<ul><li>中继日志通常存在系统的缓存中，所以中继日志的开销很小。</li></ul></li></ul><p>复制过程有一个很重要的限制，就是在slave上的复制是串行化的，master上是并行化的。</p><h4 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h4><ul><li>异步复制<ul><li>MySQL主从模式默认的复制，并不关心从库是否已经接收并处理</li><li>可能导致数据不完整</li></ul></li><li>同步复制<ul><li>MySQL Cluster为同步复制，所有客户端确认执行事务后才返回。</li><li>事务时间拉长、性能降低。</li></ul></li><li>半同步复制<ul><li>插件形式支持，至少一个从库接收并写ready log。</li><li>至少延迟一个TCP/IP时间，最好在低延迟网络使用。</li></ul></li></ul><h4 id="Mysql读写分离"><a href="#Mysql读写分离" class="headerlink" title="Mysql读写分离"></a>Mysql读写分离</h4><p>本身未实现读写分离：</p><ul><li>基于项目代码内部实现</li><li>基于中间代理实现<ul><li>MySQL-Proxy</li><li>amoeba(变形虫)</li></ul></li></ul><h2 id="MySQL-GTID特性"><a href="#MySQL-GTID特性" class="headerlink" title="MySQL GTID特性"></a>MySQL GTID特性</h2><p>TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL主从同步原理&quot;&gt;&lt;a href=&quot;#MySQL主从同步原理&quot; class=&quot;headerlink&quot; title=&quot;MySQL主从同步原理&quot;&gt;&lt;/a&gt;MySQL主从同步原理&lt;/h2&gt;&lt;h3 id=&quot;为什么需要主从同步&quot;&gt;&lt;a href=&quot;#为什么需要主从同</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="InnoDB" scheme="http://example.com/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>事务数据库特性及隔离级别</title>
    <link href="http://example.com/2022/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%B9%E6%80%A7%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://example.com/2022/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%B9%E6%80%A7%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2022-02-23T03:08:57.000Z</published>
    <updated>2022-02-23T07:38:57.998Z</updated>
    
    <content type="html"><![CDATA[<p>说明： 文章转账自<a href="https://www.cnblogs.com/z-sm/p/7245981.html">数据库事务的特性、隔离级别、传播策略</a></p><h2 id="事务ACID特性"><a href="#事务ACID特性" class="headerlink" title="事务ACID特性"></a>事务ACID特性</h2><p>数据库管理系统中事务(transaction)的四个特性（分析时根据首字母缩写依次解释）：</p><ul><li>原子性（Atomicity）</li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持久性（Durability）</li></ul><p>所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。（执行单个逻辑功能的一组指令或操作称为事务）</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性是指事务是一个<strong>不可再分割的工作单元</strong>，事务中的操作要么都发生，要么都不发生。</p><p>可采用“<strong>A向B转账</strong>”这个例子来说明解释。</p><p>在DBMS中，默认情况下<strong>一条SQL就是一个单独事务，事务是自动提交的</strong>。</p><p>只有显式的使用<strong>start transaction</strong>开启一个事务，才能将一个代码块放在事务中执行。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一致性是指在<strong>事务开始之前和事务结束以后，数据库的完整性约束没有被破坏</strong>。这是说数据库事务不能破坏关系<strong>数据的完整性以及业务逻辑上的一致性</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如A给B转账，不论转账的事务操作是否成功，其两者的存款总额不变（这是业务逻辑的一致性，至于数据库关系约束的完整性就更好理解了）。</span><br></pre></td></tr></table></figure><p>保障机制：</p><ul><li>数据库层面: 在一个事务执行之前和之后，数据符合你设置的约束（唯一约束，外键约束,check约束等)和触发器设置；</li><li>此外: 数据库的内部数据结构（如 B 树索引或双向链表）都必须是正确的。</li></ul><p>业务的一致性一般由开发人员进行保证，亦可转移至数据库层面。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p><strong>多个事务并发访问时，事务之间是隔离的</strong>，一个事务不应该影响其它事务运行效果。</p><p>在并发环境中，当<strong>不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间</strong>。</p><p>由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。</p><p>事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，<strong>事务不会查看到中间状态的数据</strong>。</p><p>事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同一时间只执行一条事务，这样会严重影响性能。</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p><p>完成的事务是系统永久的部分，对系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Write-Ahead Logging：SQL Server中使用了WAL（Write-Ahead Logging）技术来保证事务日志的ACID特性，在数据写入到数据库之前，先写入到日志，再将日志记录变更到存储器中。</span><br></pre></td></tr></table></figure><h2 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h2><p>当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性。</p><h3 id="不用事务隔离带来的问题"><a href="#不用事务隔离带来的问题" class="headerlink" title="不用事务隔离带来的问题"></a>不用事务隔离带来的问题</h3><h4 id="更新丢失"><a href="#更新丢失" class="headerlink" title="更新丢失"></a>更新丢失</h4><p>此写彼写： 两事务同时更新，一个失败回滚覆盖另一个事务的更新。或事务1执行更新操作，在事务1结束前事务2也更新，则事务1的更新结果被事务2的覆盖了。</p><ul><li>两个事务分别写，然后：都回滚则没问题；</li><li>一回滚一提交 或 都提交 则会出现更新丢失问题<ol><li>更新丢失（Lostupdate）: 两个事务都做更新操作，一个事务回滚会覆盖另一个事务更新的数据，导致更新丢失</li><li>两次更新问题（Secondlost updates problem）: 两个事务都做更新操作，后提交事务者会覆盖先提交者的更新。</li></ol></li></ul><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>此写彼读： 事务T2读取到事务T1修改了但是事务1还未提交的数据，之后事务T1又回滚其更新操作，导致事务T2读到的是脏数据。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>此读彼写： 对于数据库中的某个数据，一个事务内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p><p>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p><p>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主；但在另一些情况下就有可能发生问题，例如对于同一个数据被A和B依次查询得到的结果就可能不同，A和B就可能打起来了……</p><h4 id="幻读-虚读"><a href="#幻读-虚读" class="headerlink" title="幻读/虚读"></a>幻读/虚读</h4><p>此读彼写： 幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p><h4 id="各问题区别"><a href="#各问题区别" class="headerlink" title="各问题区别"></a>各问题区别</h4><ul><li><p>脏读和不可重复读的区别：脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p></li><li><p>不可重复读和幻读的异同：都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p></li></ul><h3 id="事务隔离的级别"><a href="#事务隔离的级别" class="headerlink" title="事务隔离的级别"></a>事务隔离的级别</h3><p>为此我们需要通过提供不同类型的“锁”机制针对数据库事务进行不同程度的并发访问控制，由此产生了不同的事务隔离级别：隔离级别（低-&gt;高）。</p><p>SQL、SQL2标准定义了四种隔离级别：</p><h4 id="读未提交（Read-Uncommitted）"><a href="#读未提交（Read-Uncommitted）" class="headerlink" title="读未提交（Read Uncommitted）"></a>读未提交（Read Uncommitted）</h4><p>含义解释：只限制同一数据写事务禁止其他写事务。解决”更新丢失”。（一事务写时禁止其他事务写）</p><p>名称解释：可读取未提交数据</p><p>所需的锁：排他写锁</p><h4 id="读提交（Read-Committed）"><a href="#读提交（Read-Committed）" class="headerlink" title="读提交（Read Committed）"></a>读提交（Read Committed）</h4><p>含义解释：只限制同一数据写事务禁止其它读写事务。解决”脏读”，以及”更新丢失”。（一事务写时禁止其他事务读写）</p><p>名称解释：必须提交以后的数据才能被读取</p><p>所需的锁：排他写锁、瞬间共享读锁</p><h4 id="可重复读（Repeatable-Read）"><a href="#可重复读（Repeatable-Read）" class="headerlink" title="可重复读（Repeatable Read）"></a>可重复读（Repeatable Read）</h4><p>含义解释：限制同一数据写事务禁止其他读写事务，读事务禁止其它写事务(允许读)。解决”不可重复读”，以及”更新丢失”和”脏读”。（一事务写时禁止其他事务读写、一事务读时禁止其他事务写）</p><p>注意没有解决幻读，解决幻读的方法是增加范围锁（range lock）或者表锁。</p><p>名称解释：能够重复读取</p><p>所需的锁：排他写锁、共享读锁</p><h4 id="串行化（Serializable）"><a href="#串行化（Serializable）" class="headerlink" title="串行化（Serializable）"></a>串行化（Serializable）</h4><p>含义解释：限制所有读写事务都必须串行化实行。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。（一事务写时禁止其他事务读写、一事务读时禁止其他事务读写）</p><p>所须的锁：范围锁或表锁</p><h3 id="各隔离级别对各种异常的控制能力"><a href="#各隔离级别对各种异常的控制能力" class="headerlink" title="各隔离级别对各种异常的控制能力"></a>各隔离级别对各种异常的控制能力</h3><table><thead><tr><th></th><th>更新丢失</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>RU(读未提交)</td><td>避免</td><td></td><td></td><td></td></tr><tr><td>RC（读提交）</td><td>避免</td><td>避免</td><td></td><td></td></tr><tr><td>RR（可重复读）</td><td>避免</td><td>避免</td><td>避免</td><td></td></tr><tr><td>S（串行化）</td><td>避免</td><td>避免</td><td>避免</td><td>避免</td></tr></tbody></table><p>四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，数据完整性越好，但执行效率就越低。</p><p>像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。</p><h3 id="常见数据库的默认事务隔离级别"><a href="#常见数据库的默认事务隔离级别" class="headerlink" title="常见数据库的默认事务隔离级别"></a>常见数据库的默认事务隔离级别</h3><table><thead><tr><th>数据库</th><th>默认隔离级别</th><th>备注</th></tr></thead><tbody><tr><td>MySQL</td><td>可重复读（Repeatable Read）</td><td>MySQL的Repeatable Read隔离级别也解决了幻读问题（通过Next-key lock加锁方法即范围锁解决不可重复读和幻读问题，如select * from t where a&gt;10会对key为[10,infinite）范围的行加锁，这样其他事务就不能对此范围内key对应的行更改）达到了SQL、SQL2标准中的Serializable级别。</td></tr><tr><td>Oracle</td><td>读提交（Read Committed）</td><td>只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别</td></tr><tr><td>SQLServer</td><td>读提交（Read Committed）</td><td></td></tr><tr><td>DB2</td><td>读提交（Read Committed）</td><td></td></tr><tr><td>PostgreSQL</td><td>读提交（Read Committed）</td><td></td></tr></tbody></table><p>在MySQL数据库中查看当前事务的隔离级别：</p><pre><code>select @@tx_isolation;</code></pre><p>在MySQL数据库中设置事务的隔离级别：</p><pre><code>set  [glogal | session]  transaction isolation level 隔离级别名称; //设置全部连接或当前连接的事务隔离级别set tx_isolation=’隔离级别名称; //设置当前连接的事务隔离级别</code></pre><p><strong>设置数据库的隔离级别一定要是在开启事务之前！</strong></p><p>如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前链接的隔离级别，至于参数level，可以使用Connection对象的字段：</p><p><img src="/2022/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E5%8A%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%B9%E6%80%A7%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/img.png"></p><p>在JDBC中设置隔离级别的部分代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try (Connection conn = JdbcUtils.getConnection()) &#123;</span><br><span class="line">  conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);</span><br><span class="line">  conn.setAutoCommit(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后记：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。</p><h2 id="事务传播"><a href="#事务传播" class="headerlink" title="事务传播"></a>事务传播</h2><p>事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。</p><p>需要注意的是，传播是指一个线程内的传播，不同线程间是没有传播一说的，即不同线程间无法在一个事务内（不然还要事务隔离干嘛），因为他们通常是不同的数据库连接。因此子异步线程事务回滚与否不会影响父线程的事务回滚与否。</p><p>以Spring Transaction为例，在TransactionDefinition接口定义中包括了如下几个表示传播行为的常量（3+3+1）：</p><ul><li>TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</li><li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则新建事务。</li></ul><p>示例可参阅：<a href="https://blog.csdn.net/f641385712/article/details/98642777">https://blog.csdn.net/f641385712/article/details/98642777</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;说明： 文章转账自&lt;a href=&quot;https://www.cnblogs.com/z-sm/p/7245981.html&quot;&gt;数据库事务的特性、隔离级别、传播策略&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;事务ACID特性&quot;&gt;&lt;a href=&quot;#事务ACID特性&quot; class=&quot;he</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据库MySQL系列之MVCC浅探</title>
    <link href="http://example.com/2022/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8BInnoDB%E4%B8%ADMVCC%E6%B5%85%E6%8E%A2/"/>
    <id>http://example.com/2022/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8BInnoDB%E4%B8%ADMVCC%E6%B5%85%E6%8E%A2/</id>
    <published>2022-02-23T03:08:57.000Z</published>
    <updated>2022-02-23T04:21:57.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVCC简介"><a href="#MVCC简介" class="headerlink" title="MVCC简介"></a>MVCC简介</h1><h2 id="MVCC名词解释"><a href="#MVCC名词解释" class="headerlink" title="MVCC名词解释"></a>MVCC名词解释</h2><p>MVCC (Multiversion Concurrency Control)，即多版本并发控制技术。</p><h2 id="MVCC解决了什么问题"><a href="#MVCC解决了什么问题" class="headerlink" title="MVCC解决了什么问题"></a>MVCC解决了什么问题</h2><p>它使得大部分支持行锁的事务引擎（InnoDB,Falcon以及PBXT等），不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来。<br>只需要很小的开销，就可以实现非锁定读，从而大大提高数据库系统的并发性能。</p><h2 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h2><ul><li><strong>读锁</strong>：也叫共享锁、S锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S 锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li><li><strong>写锁</strong>：又称排他锁、X锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</li><li><strong>表锁</strong>：操作对象是数据表。Mysql大多数锁策略都支持(常见mysql innodb)，是系统开销最低但并发性最低的一个锁策略。事务t对整个表加读锁，则其他事务可读不可写，若加写锁，则其他事务增删改都不行。</li><li><strong>行级锁</strong>：操作对象是数据表中的一行。是MVCC技术用的比较多的，但在MYISAM用不了，行级锁用mysql的储存引擎实现而不是mysql服务器。但行级锁对系统开销较大，处理高并发较好。</li></ul><h1 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h1><p>MVCC是通过保存数据在某个时间点的快照来实现的。不同存储引擎的MVCC实现是不同的，典型的有乐观并发控制和悲观并发控制。</p><h2 id="InnoDB-MVCC具体实现分析"><a href="#InnoDB-MVCC具体实现分析" class="headerlink" title="InnoDB MVCC具体实现分析"></a>InnoDB MVCC具体实现分析</h2><p>innodb MVCC主要是为<strong>Repeatable-Read事务隔离级别</strong>做的。在此隔离级别下，A、B客户端所示的数据相互隔离，互相更新不可见。</p><p>innodb存储的最基本row中包含一些额外的存储信息： DATA_TRX_ID，DATA_ROLL_PTR，DB_ROW_ID，DELETE BIT。</p><ul><li>6字节的DATA_TRX_ID 标记了最新更新这条行记录的transaction id，每处理一个事务，其值自动+1；</li><li>7字节的DATA_ROLL_PTR 指向当前记录项的rollback segment的undo log记录，找之前版本的数据就是通过这个指针；</li><li>6字节的DB_ROW_ID，当由innodb自动产生聚集索引时，聚集索引包括这个DB_ROW_ID的值，否则聚集索引中不包括这个值，这个用于索引当中；</li><li>DELETE BIT位用于标识该记录是否被删除，这里的不是真正的删除数据，而是标志出来的删除，真正意义的删除是在commit的时候。</li></ul><p><img src="/2022/02/23/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93MySQL%E7%B3%BB%E5%88%97%E4%B9%8BInnoDB%E4%B8%ADMVCC%E6%B5%85%E6%8E%A2/img.png" alt="img.png"></p><p>具体的执行过程</p><p>begin-&gt;用排他锁锁定该行-&gt;记录redo log-&gt;记录undo log-&gt;修改当前行的值，写事务编号，回滚指针指向undo log中的修改前的行</p><p>该过程准确说是UPDATE的事务过程，其实undo log分insert和update undo log，因为insert时，原始的数据并不存在，所以回滚时把insert undo log丢弃即可，而update undo log则必须遵守上述过程。</p><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>Innodb检查每行数据，确保他们符合两个标准：</p><ol><li><p>InnoDB只查找版本早于当前事务版本的数据行(也就是数据行的版本必须小于或等于当前事务的版本)，这确保当前事务读取的行要么是事务之前已经存在的，要么是由当前事务创建或修改的；</p></li><li><p>行的删除版本要么未定义,要么大于当前事务版本号,这可以确保事务读取到的行，在事务开始之前未被删除。</p></li></ol><p>只有a,b同时满足的记录，才能返回作为查询结果。</p><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p>InnoDB为新插入的每一行保存当前事务版本号作为版本号。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>InnoDB会为删除的每一行保存当前事务的版本号(事务的ID)作为删除标识。</p><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>InnoDB执行UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要UPDATE的行的删除时间。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>insert操作时 “创建时间”=DB_ROW_ID，这时，“删除时间 ”是未定义的；</p><p>update时，复制新增行的“创建时间”=DB_ROW_ID，删除时间未定义，旧数据行“创建时间”不变，删除时间=该事务的DB_ROW_ID；</p><p>delete操作，相应数据行的“创建时间”不变，删除时间=该事务的DB_ROW_ID；</p><p>select操作对两者都不修改，只读相应的数据</p><h1 id="对于MVCC的总结"><a href="#对于MVCC的总结" class="headerlink" title="对于MVCC的总结"></a>对于MVCC的总结</h1><p>上述更新前建立undo log，根据各种策略读取时非阻塞就是MVCC，undo log中的行就是MVCC中的多版本。</p><p>这个可能与我们所理解的MVCC有较大的出入，一般我们认为MVCC有下面几个特点：</p><ul><li>每行数据都存在一个版本，每次数据更新时都更新该版本</li><li>修改时Copy出当前版本随意修改，各个事务之间无干扰 </li><li>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）</li></ul><p>就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道。</p><p>而Innodb的实现方式是：</p><ul><li>事务以排他锁的形式修改原始数据</li><li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li><li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li></ul><p>二者最本质的区别是，当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？ </p><p>Innodb的实现真算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。</p><p>但理想的MVCC是难以实现的，当事务仅修改一行记录使用理想的MVCC模式是没有问题的，可以通过比较版本号进行回滚；但当事务影响到多行数据时，理想的MVCC据无能为力了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。</span><br></pre></td></tr></table></figure><p>理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。</p><p>修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二提交是目前这种场景保证一致性的唯一手段。</p><p>二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVCC简介&quot;&gt;&lt;a href=&quot;#MVCC简介&quot; class=&quot;headerlink&quot; title=&quot;MVCC简介&quot;&gt;&lt;/a&gt;MVCC简介&lt;/h1&gt;&lt;h2 id=&quot;MVCC名词解释&quot;&gt;&lt;a href=&quot;#MVCC名词解释&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="InnoDB" scheme="http://example.com/tags/InnoDB/"/>
    
    <category term="MVCC" scheme="http://example.com/tags/MVCC/"/>
    
  </entry>
  
</feed>
